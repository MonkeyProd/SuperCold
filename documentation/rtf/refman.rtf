{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;\red0\green128\blue0;\red96\green64\blue32;\rede0\green128\blue0;\red128\green0\blue0;\red128\green96\blue32;\red0\green32\blue128;\red0\green128\blue128;\red255\green0\blue255;\red0\green0\blue0;\red112\green0\blue112;\red255\green0\blue0;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\paperw11900\paperh16840\margl1800\margr1800\margt1440\margb1440\gutter0\ltrsect}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 5;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext50 Code Example 9;}
{\s50\li3600\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext51 Code Example 10;}
{\s51\li3960\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext52 Code Example 11;}
{\s52\li4320\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 12;}
{\s53\li4680\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext53 Code Example 13;}
{\s60\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext61 List Continue 0;}
{\s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext62 List Continue 1;}
{\s62\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext63 List Continue 2;}
{\s63\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext64 List Continue 3;}
{\s64\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext65 List Continue 4;}
{\s65\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext66 List Continue 5;}
{\s66\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext67 List Continue 6;}
{\s67\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext68 List Continue 7;}
{\s68\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext69 List Continue 8;}
{\s69\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext70 List Continue 9;}
{\s70\li3600\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext71 List Continue 10;}
{\s71\li3960\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext72 List Continue 11;}
{\s72\li4320\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 12;}
{\s73\li4680\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext73 List Continue 13;}
{\s80\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext81 DescContinue 0;}
{\s81\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext82 DescContinue 1;}
{\s82\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext83 DescContinue 2;}
{\s83\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext84 DescContinue 3;}
{\s84\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext85 DescContinue 4;}
{\s85\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext86 DescContinue 5;}
{\s86\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext87 DescContinue 6;}
{\s87\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext88 DescContinue 7;}
{\s88\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext89 DescContinue 8;}
{\s89\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext90 DescContinue 9;}
{\s90\li3600\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext91 DescContinue 10;}
{\s91\li3960\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext92 DescContinue 11;}
{\s92\li4320\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 12;}
{\s93\li4680\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext93 DescContinue 13;}
{\s100\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext101 LatexTOC 0;}
{\s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext102 LatexTOC 1;}
{\s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext103 LatexTOC 2;}
{\s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext104 LatexTOC 3;}
{\s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext105 LatexTOC 4;}
{\s105\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext106 LatexTOC 5;}
{\s106\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext107 LatexTOC 6;}
{\s107\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext108 LatexTOC 7;}
{\s108\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext109 LatexTOC 8;}
{\s109\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext110 LatexTOC 9;}
{\s110\li3600\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext111 LatexTOC 10;}
{\s111\li3960\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext112 LatexTOC 11;}
{\s112\li4320\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 12;}
{\s113\li4680\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext113 LatexTOC 13;}
{\s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext121 \sautoupd List Bullet 0;}
{\s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext122 \sautoupd List Bullet 1;}
{\s122\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext123 \sautoupd List Bullet 2;}
{\s123\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext124 \sautoupd List Bullet 3;}
{\s124\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext125 \sautoupd List Bullet 4;}
{\s125\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext126 \sautoupd List Bullet 5;}
{\s126\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext127 \sautoupd List Bullet 6;}
{\s127\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext128 \sautoupd List Bullet 7;}
{\s128\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext129 \sautoupd List Bullet 8;}
{\s129\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext130 \sautoupd List Bullet 9;}
{\s130\fi-360\li3960\widctlpar\jclisttab\tx3960{\*\pn \pnlvlbody\ilvl0\ls11\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext131 \sautoupd List Bullet 10;}
{\s131\fi-360\li4320\widctlpar\jclisttab\tx4320{\*\pn \pnlvlbody\ilvl0\ls12\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext132 \sautoupd List Bullet 11;}
{\s132\fi-360\li4680\widctlpar\jclisttab\tx4680{\*\pn \pnlvlbody\ilvl0\ls13\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 12;}
{\s133\fi-360\li5040\widctlpar\jclisttab\tx5040{\*\pn \pnlvlbody\ilvl0\ls14\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext133 \sautoupd List Bullet 13;}
{\s140\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext141 \sautoupd List Enum 0;}
{\s141\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext142 \sautoupd List Enum 1;}
{\s142\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext143 \sautoupd List Enum 2;}
{\s143\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext144 \sautoupd List Enum 3;}
{\s144\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext145 \sautoupd List Enum 4;}
{\s145\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext146 \sautoupd List Enum 5;}
{\s146\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext147 \sautoupd List Enum 6;}
{\s147\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext148 \sautoupd List Enum 7;}
{\s148\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext149 \sautoupd List Enum 8;}
{\s149\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext150 \sautoupd List Enum 9;}
{\s150\fi-360\li3960\widctlpar\fs20\cgrid \sbasedon0 \snext151 \sautoupd List Enum 10;}
{\s151\fi-360\li4320\widctlpar\fs20\cgrid \sbasedon0 \snext152 \sautoupd List Enum 11;}
{\s152\fi-360\li4680\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 12;}
{\s153\fi-360\li5040\widctlpar\fs20\cgrid \sbasedon0 \snext153 \sautoupd List Enum 13;}
}
{\info 
{\title {\comment SuperCold  {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1.0 \par
}}SuperCold}
{\comment Generated by doxygen 1.9.4.}
{\creatim \yr2022\mo6\dy18\hr6\min57\sec39}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par
\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt SuperCold}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 1.0\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt Sat Jun 18 2022 }}\par
\page\page\vertalt
\pard\plain 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Table of Contents\par
\pard\plain \par
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 
\sect \sbkpage \pgndec \pgnrestart
\sect \sectd \sbknone
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all namespaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b toml} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::color_ansi} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::color_ansi::detail} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::literals} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::literals::toml_literals} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::toml_literals} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::at_least< N >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::basic_value< Comment, Table, Array >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::character< C >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
decltypehas_into_toml_method_impl::check< T >nullptr
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::has_into_toml_method< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
decltypehas_iterator_impl::check< T >nullptr
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::has_iterator< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
decltypehas_key_type_impl::check< T >nullptr
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::has_key_type< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
decltypehas_mapped_type_impl::check< T >nullptr
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::has_mapped_type< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
decltypehas_push_back_method_impl::check< T >nullptr
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::has_push_back_method< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
decltypehas_reserve_method_impl::check< T >nullptr
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::has_reserve_method< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
decltypehas_specialized_from_impl::check< T >nullptr
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::has_specialized_from< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
decltypehas_specialized_into_impl::check< T >nullptr
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::has_specialized_into< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
decltypehas_value_type_impl::check< T >nullptr
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::has_value_type< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
decltypeis_comparable_impl::check< T >nullptr
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::is_comparable< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
decltypehas_from_toml_method_impl::check< T, C, Tb, A >nullptr
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::has_from_toml_method< T, C, Tb, A >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
toml::discard_comments\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
sf::Drawable
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Bullet\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
EyeEnemy\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
GameObject\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Player\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
toml::detail::either< Ts >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::either< Head >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::either< Head, Tail... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::empty_iterator< T, is_const >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::enum_to_type< t, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::enum_to_type< value_t::array, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::enum_to_type< value_t::boolean, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::enum_to_type< value_t::empty, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::enum_to_type< value_t::floating, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::enum_to_type< value_t::integer, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::enum_to_type< value_t::local_date, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::enum_to_type< value_t::local_datetime, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::enum_to_type< value_t::local_time, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::enum_to_type< value_t::offset_datetime, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::enum_to_type< value_t::string, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::enum_to_type< value_t::table, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::exactly< N >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::exception
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::exception\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::internal_error\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::syntax_error\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::type_error\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
toml::detail::exclude< Combinator >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::failure< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::failure< error_type >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::false_type
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::disjunction< std::is_same< T, boolean >, std::is_same< T, integer >, std::is_same< T, floating >, std::is_same< T, string >, std::is_same< T, offset_datetime >, std::is_same< T, local_datetime >, std::is_same< T, local_date >, std::is_same< T, local_time >, std::is_same< T, Value::array_type >, std::is_same< T, Value::table_type > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::is_exact_toml_type< T, V >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBV \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::is_exact_toml_type< T &, V >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_exact_toml_type< T const &, V >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_exact_toml_type< T const volatile &, V >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_exact_toml_type< T volatile &, V >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
toml::detail::is_exact_toml_type< T, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
toml::detail::disjunction< std::is_same< const char *, T >, conjunction< std::is_array< T >, std::is_same< const char, std::remove_extent< T >::type > > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXB \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::is_string_literal< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
toml::detail::disjunction<... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_basic_value< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBE \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::is_basic_value< T & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_basic_value< T const & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_basic_value< T const volatile & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_basic_value< T volatile & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
toml::detail::is_chrono_duration< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_std_forward_list< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_std_pair< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_std_tuple< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
toml::from< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Game\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::has_from_toml_method_impl\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::has_into_toml_method_impl\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::has_iterator_impl\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::has_key_type_impl\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::has_mapped_type_impl\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::has_push_back_method_impl\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::has_reserve_method_impl\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::has_specialized_from_impl\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::has_specialized_into_impl\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::has_value_type_impl\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::in_range< Low, Up >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::index_sequence< Ns >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::index_sequence_maker< N >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::index_sequence_maker< 0 >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
std::integral_constant
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::negation< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
toml::into< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_comparable_impl\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::last_one_in_pack< T, Ts >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::last_one_in_pack< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::local_date\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::local_datetime\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::local_time\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::maybe< Combinator >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::none_t\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::offset_datetime\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::preserve_comments\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
PriorityQueue< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::push_back_index_sequence< IS, N >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::push_back_index_sequence< index_sequence< Ns... >, N >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::region_base\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFS \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::location\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::region\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
toml::detail::remove_cvref< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::repeat< T, N >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::repeat< T, at_least< N > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::repeat< T, exactly< N > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::repeat< T, unlimited >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::result< T, E >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::sequence< Ts >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::sequence< Head >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::sequence< Head, Tail... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::serializer< Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SettingsManager\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SimplexNoise\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::source_location\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
SpriteController\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::storage< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::storage< array_type >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::storage< table_type >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::string\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::success< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::success< value_type >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::switch_cast< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
T
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::conjunction< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::disjunction< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
TileMap\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::time_offset\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
sf::Transformable
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Bullet\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
EyeEnemy\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
GameObject\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Player\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
std::true_type
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::conjunction< negation< is_map< T > >, negation< std::is_same< T, std::string > >, has_iterator< T >, has_value_type< T > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWY \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::is_container< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBQ \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::is_container< T & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_container< T const & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_container< T const volatile & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_container< T volatile & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
toml::detail::conjunction< has_iterator< T >, has_value_type< T >, has_key_type< T >, has_mapped_type< T > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWY \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s103\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::is_map< T >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCA \\*MERGEFORMAT}{\fldrslt pagenum}}
{
\par
\pard\plain \s104\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::is_map< T & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_map< T const & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_map< T const volatile & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_map< T volatile & >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}\par
toml::detail::conjunction<... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_basic_value<::toml::basic_value< C, M, V > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_chrono_duration< std::chrono::duration< Rep, Period > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_std_forward_list< std::forward_list< T > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_std_pair< std::pair< T1, T2 > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::is_std_tuple< std::tuple< Ts... > >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
std::conditional::type
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::conjunction< T, Ts... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
std::conditional::type
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::disjunction< T, Ts... >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
std::conditional::type
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::type_to_enum< T, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
toml::detail::unlimited\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
value_t_constant
{
\par
\pard\plain \s102\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
toml::detail::type_to_enum< boolean, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::type_to_enum< floating, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::type_to_enum< integer, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::type_to_enum< local_date, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::type_to_enum< local_datetime, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::type_to_enum< local_time, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::type_to_enum< offset_datetime, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
toml::detail::type_to_enum< string, Value >\tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Index\par \pard\plain 
{\tc \v Class Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Class List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b toml::detail::at_least< N >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::basic_value< Comment, Table, Array >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAARK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Bullet} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::character< C >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::conjunction<... >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::conjunction< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABWZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::conjunction< T, Ts... >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::discard_comments} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAZF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::disjunction<... >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::disjunction< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::disjunction< T, Ts... >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::either< Ts >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::either< Head >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::either< Head, Tail... >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::empty_iterator< T, is_const >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABXJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::enum_to_type< t, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::enum_to_type< value_t::array, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::enum_to_type< value_t::boolean, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::enum_to_type< value_t::empty, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::enum_to_type< value_t::floating, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::enum_to_type< value_t::integer, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::enum_to_type< value_t::local_date, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::enum_to_type< value_t::local_datetime, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::enum_to_type< value_t::local_time, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::enum_to_type< value_t::offset_datetime, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABYY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::enum_to_type< value_t::string, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::enum_to_type< value_t::table, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::exactly< N >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::exception} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::exclude< Combinator >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EyeEnemy} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::failure< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::from< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Game} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b GameObject} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_from_toml_method< T, C, Tb, A >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_from_toml_method_impl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_into_toml_method< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_into_toml_method_impl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_iterator< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_iterator_impl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_key_type< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_key_type_impl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_mapped_type< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_mapped_type_impl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABZY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_push_back_method< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_push_back_method_impl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_reserve_method< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_reserve_method_impl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_specialized_from< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_specialized_from_impl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_specialized_into< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_specialized_into_impl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_value_type< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::has_value_type_impl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::in_range< Low, Up >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::index_sequence< Ns >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACAZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::index_sequence_maker< N >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::index_sequence_maker< 0 >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::internal_error} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABCY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::into< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_basic_value< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_basic_value< T & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_basic_value< T const & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_basic_value< T const volatile & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_basic_value< T volatile & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_basic_value<::toml::basic_value< C, M, V > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_chrono_duration< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_chrono_duration< std::chrono::duration< Rep, Period > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_comparable< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_comparable_impl} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_container< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_container< T & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_container< T const & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_container< T const volatile & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_container< T volatile & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_exact_toml_type< T, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_exact_toml_type< T &, V >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_exact_toml_type< T const &, V >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_exact_toml_type< T const volatile &, V >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_exact_toml_type< T volatile &, V >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACBZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_map< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_map< T & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_map< T const & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_map< T const volatile & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_map< T volatile & >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_std_forward_list< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_std_forward_list< std::forward_list< T > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_std_pair< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_std_pair< std::pair< T1, T2 > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_std_tuple< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_std_tuple< std::tuple< Ts... > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::is_string_literal< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::last_one_in_pack< T, Ts >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::last_one_in_pack< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::local_date} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::local_datetime} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABDT \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::local_time} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::location} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACCQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::maybe< Combinator >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::negation< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::none_t} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::offset_datetime} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Player} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAGR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::preserve_comments} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABFR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b PriorityQueue< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::push_back_index_sequence< IS, N >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::push_back_index_sequence< index_sequence< Ns... >, N >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::region} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::region_base} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFS \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::remove_cvref< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACFZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::repeat< T, N >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::repeat< T, at_least< N > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::repeat< T, exactly< N > >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::repeat< T, unlimited >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::result< T, E >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABIW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::sequence< Ts >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::sequence< Head >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::sequence< Head, Tail... >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::serializer< Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABLR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SettingsManager} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAHW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SimplexNoise} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Perlin Simplex Noise C++ Implementation (1D, 2D, 3D, 4D) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::source_location} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABMR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SpriteController} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAIP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::storage< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACGO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::string} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABNG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::success< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::switch_cast< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::syntax_error} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOR \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TileMap} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAJE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::time_offset} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABOV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::type_error} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAABPG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::type_to_enum< T, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::type_to_enum< boolean, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::type_to_enum< floating, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::type_to_enum< integer, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::type_to_enum< local_date, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::type_to_enum< local_datetime, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::type_to_enum< local_time, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::type_to_enum< offset_datetime, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::type_to_enum< string, Value >} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b toml::detail::unlimited} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAACHL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:}
{
\par
\pard\plain \s101\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b main.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAES \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Bullet/{\b Bullet.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABJ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Bullet/{\b Bullet.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Enemies/{\b EyeEnemy.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Enemies/{\b EyeEnemy.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/{\b toml.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/PriorityQueue/{\b PriorityQueue.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABN \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/SimplexNoise/{\b SimplexNoise.cpp} ({\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Perlin Simplex Noise C++ Implementation (1D, 2D, 3D) })} \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/SimplexNoise/{\b SimplexNoise.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b color.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b combinator.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b comments.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b datetime.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAABZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b exception.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b from.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b get.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b into.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACD \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b lexer.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b literal.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b macros.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAACG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b parser.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAADZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b region.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b result.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b serializer.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b source_location.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAED \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b storage.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b string.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEF \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b traits.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEG \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b types.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEH \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b utility.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEI \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b value.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEK \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b external/toml/{\b version.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEM \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Game/{\b Game.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEO \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Game/{\b Game.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b GameObject/{\b GameObject.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEQ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b GameObject/{\b GameObject.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAER \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Player/{\b Player.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEU \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Player/{\b Player.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEV \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b SettingsManager/{\b SettingsManager.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEW \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b SettingsManager/{\b SettingsManager.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEX \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b SpriteContoller/{\b SpriteController.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEY \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b SpriteContoller/{\b SpriteController.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAEZ \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b TileMap/{\b TileMap.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFA \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b TileMap/{\b TileMap.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFB \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Utils/{\b debug.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFC \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b Utils/{\b debug.hpp} } \tab {\field\fldedit {\*\fldinst PAGEREF AAAAAAAAFE \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml Namespace Reference\par \pard\plain 
{\tc\tcl2 \v toml}
{\xe \v toml}
{\bkmkstart AAAAAAAAJH}
{\bkmkend AAAAAAAAJH}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b color_ansi}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b detail}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b literals}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml_literals}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b basic_value}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b discard_comments}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b exception}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b failure}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b from}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b internal_error}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b into}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b local_date}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b local_datetime}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b local_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b offset_datetime}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b preserve_comments}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b result}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b serializer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b source_location}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b string}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b success}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b syntax_error}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b time_offset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b type_error}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b character} = char\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b key} = std::string\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b boolean} = bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b integer} = std::int64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b floating} = double\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value} = {\b basic_value}< {\b TOML11_DEFAULT_COMMENT_STRATEGY}, std::unordered_map, std::vector >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b array} = typename {\b value::array_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b table} = typename {\b value::table_type}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b month_t} : std::uint8_t \{ {\b Jan} = 0
, {\b Feb} = 1
, {\b Mar} = 2
, {\b Apr} = 3
, {\b May} = 4
, {\b Jun} = 5
, {\b Jul} = 6
, {\b Aug} = 7
, {\b Sep} = 8
, {\b Oct} = 9
, {\b Nov} = 10
, {\b Dec} = 11
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b string_t} : std::uint8_t \{ {\b basic} = 0
, {\b literal} = 1
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b value_t} : std::uint8_t \{ {\b empty} = 0
, {\b boolean} = 1
, {\b integer} = 2
, {\b floating} = 3
, {\b string} = 4
, {\b offset_datetime} = 5
, {\b local_datetime} = 6
, {\b local_date} = 7
, {\b local_time} = 8
, {\b array} = 9
, {\b table} = 10
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b preserve_comments} &lhs, const {\b preserve_comments} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b preserve_comments} &lhs, const {\b preserve_comments} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b preserve_comments} &lhs, const {\b preserve_comments} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b preserve_comments} &lhs, const {\b preserve_comments} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b preserve_comments} &lhs, const {\b preserve_comments} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b preserve_comments} &lhs, const {\b preserve_comments} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b preserve_comments} &lhs, {\b preserve_comments} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b preserve_comments} &lhs, std::vector< std::string > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} (std::vector< std::string > &lhs, {\b preserve_comments} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b operator<<} (std::basic_ostream< charT, traits > &os, const {\b preserve_comments} &com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b discard_comments} &, const {\b discard_comments} &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b discard_comments} &, const {\b discard_comments} &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b discard_comments} &, const {\b discard_comments} &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b discard_comments} &, const {\b discard_comments} &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b discard_comments} &, const {\b discard_comments} &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b discard_comments} &, const {\b discard_comments} &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} (const {\b discard_comments} &, const {\b discard_comments} &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b operator<<} (std::basic_ostream< charT, traits > &os, const {\b discard_comments} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b local_date} &lhs, const {\b local_date} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b local_date} &lhs, const {\b local_date} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b local_date} &lhs, const {\b local_date} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b local_date} &lhs, const {\b local_date} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b local_date} &lhs, const {\b local_date} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b local_date} &lhs, const {\b local_date} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b operator<<} (std::basic_ostream< charT, traits > &os, const {\b local_date} &date)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b local_time} &lhs, const {\b local_time} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b local_time} &lhs, const {\b local_time} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b local_time} &lhs, const {\b local_time} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b local_time} &lhs, const {\b local_time} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b local_time} &lhs, const {\b local_time} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b local_time} &lhs, const {\b local_time} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b operator<<} (std::basic_ostream< charT, traits > &os, const {\b local_time} &time)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b time_offset} &lhs, const {\b time_offset} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b time_offset} &lhs, const {\b time_offset} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b time_offset} &lhs, const {\b time_offset} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b time_offset} &lhs, const {\b time_offset} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b time_offset} &lhs, const {\b time_offset} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b time_offset} &lhs, const {\b time_offset} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b operator<<} (std::basic_ostream< charT, traits > &os, const {\b time_offset} &offset)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b local_datetime} &lhs, const {\b local_datetime} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b local_datetime} &lhs, const {\b local_datetime} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b local_datetime} &lhs, const {\b local_datetime} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b local_datetime} &lhs, const {\b local_datetime} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b local_datetime} &lhs, const {\b local_datetime} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b local_datetime} &lhs, const {\b local_datetime} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b operator<<} (std::basic_ostream< charT, traits > &os, const {\b local_datetime} &dt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b offset_datetime} &lhs, const {\b offset_datetime} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b offset_datetime} &lhs, const {\b offset_datetime} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b offset_datetime} &lhs, const {\b offset_datetime} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b offset_datetime} &lhs, const {\b offset_datetime} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b offset_datetime} &lhs, const {\b offset_datetime} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b offset_datetime} &lhs, const {\b offset_datetime} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b operator<<} (std::basic_ostream< charT, traits > &os, const {\b offset_datetime} &dt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, T > & {\b get} ({\b basic_value}< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, T > const & {\b get} (const {\b basic_value}< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, T > {\b get} ({\b basic_value}< C, M, V > &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, {\b basic_value}< C, M, V > >{\b ::value}, T > & {\b get} ({\b basic_value}< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, {\b basic_value}< C, M, V > >{\b ::value}, T > const & {\b get} (const {\b basic_value}< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, {\b basic_value}< C, M, V > >{\b ::value}, T > {\b get} ({\b basic_value}< C, M, V > &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::is_basic_value}< T >, {\b detail::negation}< std::is_same< T, {\b basic_value}< C, M, V > > > >{\b ::value}, T > {\b get} (const {\b basic_value}< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< std::is_integral< T >, {\b detail::negation}< std::is_same< T, bool > >, {\b detail::negation}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > > > >{\b ::value}, T > {\b get} (const {\b basic_value}< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< std::is_floating_point< T >, {\b detail::negation}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > > > >{\b ::value}, T > {\b get} (const {\b basic_value}< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, std::string >{\b ::value}, std::string > & {\b get} ({\b basic_value}< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, std::string >{\b ::value}, std::string > const & {\b get} (const {\b basic_value}< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, std::string >{\b ::value}, std::string > {\b get} ({\b basic_value}< C, M, V > &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_chrono_duration}< T >{\b ::value}, T > {\b get} (const {\b basic_value}< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< std::chrono::system_clock::time_point, T >{\b ::value}, T > {\b get} (const {\b basic_value}< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::is_container}< T >, {\b detail::has_push_back_method}< T >, {\b detail::negation}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > > > >{\b ::value}, T > {\b get} (const {\b basic_value}< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::is_container}< T >, {\b detail::negation}< {\b detail::has_push_back_method}< T > >, {\b detail::negation}< {\b detail::has_specialized_from}< T > >, {\b detail::negation}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > > > >{\b ::value}, T > {\b get} (const {\b basic_value}< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_std_pair}< T >{\b ::value}, T > {\b get} (const {\b basic_value}< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_std_tuple}< T >{\b ::value}, T > {\b get} (const {\b basic_value}< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::is_map}< T >, {\b detail::negation}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > > > >{\b ::value}, T > {\b get} (const {\b basic_value}< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::negation}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > > >, {\b detail::has_from_toml_method}< T, C, M, V >, std::is_default_constructible< T > >{\b ::value}, T > {\b get} (const {\b basic_value}< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::has_specialized_from}< T >{\b ::value}, T > {\b get} (const {\b basic_value}< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::negation}< {\b detail::is_basic_value}< T > >, std::is_constructible< T, const {\b basic_value}< C, M, V > & >, {\b detail::negation}< {\b detail::has_from_toml_method}< T, C, M, V > >, {\b detail::negation}< {\b detail::has_specialized_from}< T > > >{\b ::value}, T > {\b get} (const {\b basic_value}< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_std_forward_list}< T >{\b ::value}, T > {\b get} (const {\b basic_value}< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > const & {\b find} (const {\b basic_value}< C, M, V > &v, const {\b key} &ky)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > & {\b find} ({\b basic_value}< C, M, V > &v, const {\b key} &ky)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > {\b find} ({\b basic_value}< C, M, V > &&v, const {\b key} &ky)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > const & {\b find} (const {\b basic_value}< C, M, V > &v, const std::size_t idx)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > & {\b find} ({\b basic_value}< C, M, V > &v, const std::size_t idx)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > {\b find} ({\b basic_value}< C, M, V > &&v, const std::size_t idx)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V, typename Key1 , typename Key2 , typename ... Keys> const {\b basic_value}< C, M, V > & {\b find} (const {\b basic_value}< C, M, V > &v, Key1 &&k1, Key2 &&k2, Keys &&... keys)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V, typename Key1 , typename Key2 , typename ... Keys> {\b basic_value}< C, M, V > & {\b find} ({\b basic_value}< C, M, V > &v, Key1 &&k1, Key2 &&k2, Keys &&... keys)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V, typename Key1 , typename Key2 , typename ... Keys> {\b basic_value}< C, M, V > {\b find} ({\b basic_value}< C, M, V > &&v, Key1 &&k1, Key2 &&k2, Keys &&... keys)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > const & {\b get_or} (const {\b basic_value}< C, M, V > &v, const {\b basic_value}< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > & {\b get_or} ({\b basic_value}< C, M, V > &v, {\b basic_value}< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > {\b get_or} ({\b basic_value}< C, M, V > &&v, {\b basic_value}< C, M, V > &&)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, T > const & {\b get_or} (const {\b basic_value}< C, M, V > &v, const T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, T > & {\b get_or} ({\b basic_value}< C, M, V > &v, T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< {\b detail::remove_cvref_t}< T >, {\b basic_value}< C, M, V > >{\b ::value}, {\b detail::remove_cvref_t}< T > > {\b get_or} ({\b basic_value}< C, M, V > &&v, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< {\b detail::remove_cvref_t}< T >, std::string >{\b ::value}, std::string > const & {\b get_or} (const {\b basic_value}< C, M, V > &v, const T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, std::string >{\b ::value}, std::string > & {\b get_or} ({\b basic_value}< C, M, V > &v, T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< {\b detail::remove_cvref_t}< T >, std::string >{\b ::value}, std::string > {\b get_or} ({\b basic_value}< C, M, V > &&v, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_string_literal}< typename std::remove_reference< T >::type >{\b ::value}, std::string > {\b get_or} (const {\b basic_value}< C, M, V > &v, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::negation}< {\b detail::is_exact_toml_type}< {\b detail::remove_cvref_t}< T >, {\b basic_value}< C, M, V > > >, {\b detail::negation}< std::is_same< std::string, {\b detail::remove_cvref_t}< T > > >, {\b detail::negation}< {\b detail::is_string_literal}< typename std::remove_reference< T >::type > > >{\b ::value}, {\b detail::remove_cvref_t}< T > > {\b get_or} (const {\b basic_value}< C, M, V > &v, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > const & {\b find_or} (const {\b basic_value}< C, M, V > &v, const {\b key} &ky, const {\b basic_value}< C, M, V > &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > & {\b find_or} ({\b basic_value}< C, M, V > &v, const {\b toml::key} &ky, {\b basic_value}< C, M, V > &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > {\b find_or} ({\b basic_value}< C, M, V > &&v, const {\b toml::key} &ky, {\b basic_value}< C, M, V > &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, T > const & {\b find_or} (const {\b basic_value}< C, M, V > &v, const {\b key} &ky, const T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, T > & {\b find_or} ({\b basic_value}< C, M, V > &v, const {\b toml::key} &ky, T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, {\b detail::remove_cvref_t}< T > > {\b find_or} ({\b basic_value}< C, M, V > &&v, const {\b toml::key} &ky, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, std::string >{\b ::value}, std::string > const & {\b find_or} (const {\b basic_value}< C, M, V > &v, const {\b key} &ky, const T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, std::string >{\b ::value}, std::string > & {\b find_or} ({\b basic_value}< C, M, V > &v, const {\b toml::key} &ky, T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, std::string >{\b ::value}, std::string > {\b find_or} ({\b basic_value}< C, M, V > &&v, const {\b toml::key} &ky, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_string_literal}< typename std::remove_reference< T >::type >{\b ::value}, std::string > {\b find_or} (const {\b basic_value}< C, M, V > &v, const {\b toml::key} &ky, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::negation}< {\b detail::is_exact_toml_type}< {\b detail::remove_cvref_t}< T >, {\b basic_value}< C, M, V > > >, {\b detail::negation}< std::is_same< std::string, {\b detail::remove_cvref_t}< T > > >, {\b detail::negation}< {\b detail::is_string_literal}< typename std::remove_reference< T >::type > > >{\b ::value}, {\b detail::remove_cvref_t}< T > > {\b find_or} (const {\b basic_value}< C, M, V > &v, const {\b toml::key} &ky, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value , typename ... Ks, typename {\b detail::enable_if_t}<(sizeof...(Ks) > 1), std::nullptr_t >  = nullptr> auto {\b find_or} (Value &&v, const {\b toml::key} &ky, Ks &&... keys) -> decltype(find_or(std::forward< Value >(v), ky, {\b detail::last_one}(std::forward< Ks >(keys)...)))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Value , typename ... Ks, typename {\b detail::enable_if_t}<(sizeof...(Ks) > 1), std::nullptr_t >  = nullptr> auto {\b find_or} (Value &&v, const {\b toml::key} &ky, Ks &&... keys) -> decltype(find_or< T >(std::forward< Value >(v), ky, {\b detail::last_one}(std::forward< Ks >(keys)...)))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b result}< T, std::string > {\b expect} (const {\b basic_value}< C, M, V > &v) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b result}< T, std::string > {\b expect} (const {\b basic_value}< C, M, V > &v, const {\b toml::key} &k) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
inline {\b ::toml::basic_value}< {\b TOML11_DEFAULT_COMMENT_STRATEGY}, std::unordered_map, std::vector > {\b literal_internal_impl} ({\b ::toml::detail::location} loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
inline {\b ::toml::basic_value}< {\b TOML11_DEFAULT_COMMENT_STRATEGY}, std::unordered_map, std::vector > {\b operator""_toml} (const char *str, std::size_t len)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Comment  = TOML11_DEFAULT_COMMENT_STRATEGY, template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value}< Comment, Table, Array > {\b parse} (std::istream &is, const std::string &fname="unknown file")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Comment  = TOML11_DEFAULT_COMMENT_STRATEGY, template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value}< Comment, Table, Array > {\b parse} (const std::string &fname)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b success}< typename std::remove_cv< typename std::remove_reference< T >::type >::type > {\b ok} (T &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b failure}< typename std::remove_cv< typename std::remove_reference< T >::type >::type > {\b err} (T &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b success}< std::string > {\b ok} (const char *literal)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b failure}< std::string > {\b err} (const char *literal)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename E > void {\b swap} ({\b result}< T, E > &lhs, {\b result}< T, E > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits , typename Alloc > std::basic_string< charT, traits, Alloc > {\b format_key} (const std::basic_string< charT, traits, Alloc > &k)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits , typename Alloc > std::basic_string< charT, traits, Alloc > {\b format_keys} (const std::vector< std::basic_string< charT, traits, Alloc > > &keys)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> std::string {\b format} (const {\b basic_value}< C, M, V > &v, std::size_t w=80u, int fprec=std::numeric_limits< {\b toml::floating} >::max_digits10, bool no_comment=false, bool force_inline=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b nocomment} (std::basic_ostream< charT, traits > &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b showcomment} (std::basic_ostream< charT, traits > &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits , typename C , template< typename ... > class M, template< typename ... > class V> std::basic_ostream< charT, traits > & {\b operator<<} (std::basic_ostream< charT, traits > &os, const {\b basic_value}< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b string} &lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b string} &lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b string} &lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b string} &lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b string} &lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b string} &lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b string} &lhs, const std::string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b string} &lhs, const std::string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b string} &lhs, const std::string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b string} &lhs, const std::string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b string} &lhs, const std::string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b string} &lhs, const std::string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const std::string &lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const std::string &lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const std::string &lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const std::string &lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const std::string &lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const std::string &lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b string} &lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b string} &lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b string} &lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b string} &lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b string} &lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b string} &lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const char *lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const char *lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const char *lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const char *lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const char *lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const char *lhs, const {\b string} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b operator<<} (std::basic_ostream< charT, traits > &os, const {\b string} &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b operator<<} (std::basic_ostream< charT, traits > &os, {\b value_t} t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT  = char, typename traits  = std::char_traits<charT>, typename alloc  = std::allocator<charT>> std::basic_string< charT, traits, alloc > {\b stringize} ({\b value_t} t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename ... Ts> std::unique_ptr< T > {\b make_unique} (Ts &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Container > void {\b try_reserve} (Container &container, std::size_t N)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ts> std::string {\b concat_to_string} (Ts &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > T {\b from_string} (const std::string &str, T opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> bool {\b operator==} (const {\b basic_value}< C, T, A > &lhs, const {\b basic_value}< C, T, A > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> bool {\b operator!=} (const {\b basic_value}< C, T, A > &lhs, const {\b basic_value}< C, T, A > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::enable_if< {\b detail::conjunction}< {\b detail::is_comparable}< typenamebasic_value< C, T, A >::array_type >, {\b detail::is_comparable}< typenamebasic_value< C, T, A >::table_type > >{\b ::value}, bool >::type {\b operator<} (const {\b basic_value}< C, T, A > &lhs, const {\b basic_value}< C, T, A > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::enable_if< {\b detail::conjunction}< {\b detail::is_comparable}< typenamebasic_value< C, T, A >::array_type >, {\b detail::is_comparable}< typenamebasic_value< C, T, A >::table_type > >{\b ::value}, bool >::type {\b operator<=} (const {\b basic_value}< C, T, A > &lhs, const {\b basic_value}< C, T, A > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::enable_if< {\b detail::conjunction}< {\b detail::is_comparable}< typenamebasic_value< C, T, A >::array_type >, {\b detail::is_comparable}< typenamebasic_value< C, T, A >::table_type > >{\b ::value}, bool >::type {\b operator>} (const {\b basic_value}< C, T, A > &lhs, const {\b basic_value}< C, T, A > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::enable_if< {\b detail::conjunction}< {\b detail::is_comparable}< typenamebasic_value< C, T, A >::array_type >, {\b detail::is_comparable}< typenamebasic_value< C, T, A >::table_type > >{\b ::value}, bool >::type {\b operator>=} (const {\b basic_value}< C, T, A > &lhs, const {\b basic_value}< C, T, A > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::string {\b format_error} (const std::string &err_msg, const {\b basic_value}< C, T, A > &v, const std::string &comment, std::vector< std::string > hints=\{\}, const bool colorize={\b TOML11_ERROR_MESSAGE_COLORIZED})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::string {\b format_error} (const std::string &err_msg, const {\b toml::basic_value}< C, T, A > &v1, const std::string &comment1, const {\b toml::basic_value}< C, T, A > &v2, const std::string &comment2, std::vector< std::string > hints=\{\}, const bool colorize={\b TOML11_ERROR_MESSAGE_COLORIZED})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::string {\b format_error} (const std::string &err_msg, const {\b toml::basic_value}< C, T, A > &v1, const std::string &comment1, const {\b toml::basic_value}< C, T, A > &v2, const std::string &comment2, const {\b toml::basic_value}< C, T, A > &v3, const std::string &comment3, std::vector< std::string > hints=\{\}, const bool colorize={\b TOML11_ERROR_MESSAGE_COLORIZED})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Visitor , typename C , template< typename ... > class T, template< typename ... > class A> {\b detail::return_type_of_t}< Visitor, const {\b toml::boolean} & > {\b visit} (Visitor &&visitor, const {\b toml::basic_value}< C, T, A > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Visitor , typename C , template< typename ... > class T, template< typename ... > class A> {\b detail::return_type_of_t}< Visitor, {\b toml::boolean} & > {\b visit} (Visitor &&visitor, {\b toml::basic_value}< C, T, A > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Visitor , typename C , template< typename ... > class T, template< typename ... > class A> {\b detail::return_type_of_t}< Visitor, {\b toml::boolean} && > {\b visit} (Visitor &&visitor, {\b toml::basic_value}< C, T, A > &&v)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> decltype(::toml::get< T >(std::declval< {\b basic_value}< C, M, V > const & >())) {\b find} (const {\b basic_value}< C, M, V > &v, const {\b key} &ky)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v array\:toml}
{\xe \v toml\:array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::array} = typedef typename {\b value::array_type}}}
\par
{\bkmkstart AAAAAAAAJI}
{\bkmkend AAAAAAAAJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v boolean\:toml}
{\xe \v toml\:boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::boolean} = typedef bool}}
\par
{\bkmkstart AAAAAAAAJJ}
{\bkmkend AAAAAAAAJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v character\:toml}
{\xe \v toml\:character}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::character} = typedef char}}
\par
{\bkmkstart AAAAAAAAJK}
{\bkmkend AAAAAAAAJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v floating\:toml}
{\xe \v toml\:floating}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::floating} = typedef double}}
\par
{\bkmkstart AAAAAAAAJL}
{\bkmkend AAAAAAAAJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v integer\:toml}
{\xe \v toml\:integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::integer} = typedef std::int64_t}}
\par
{\bkmkstart AAAAAAAAJM}
{\bkmkend AAAAAAAAJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v key\:toml}
{\xe \v toml\:key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::key} = typedef std::string}}
\par
{\bkmkstart AAAAAAAAJN}
{\bkmkend AAAAAAAAJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v table\:toml}
{\xe \v toml\:table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::table} = typedef typename {\b value::table_type}}}
\par
{\bkmkstart AAAAAAAAJO}
{\bkmkend AAAAAAAAJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value\:toml}
{\xe \v toml\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::value} = typedef {\b basic_value}<{\b TOML11_DEFAULT_COMMENT_STRATEGY}, std::unordered_map, std::vector>}}
\par
{\bkmkstart AAAAAAAAJP}
{\bkmkend AAAAAAAAJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v month_t\:toml}
{\xe \v toml\:month_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b toml::month_t} : std::uint8_t{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAJQ}
{\bkmkend AAAAAAAAJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Jan\:toml}
{\xe \v toml\:Jan}
{\qr Jan{\bkmkstart AAAAAAAAJR}
{\bkmkend AAAAAAAAJR}
\cell }{\cell }{\row }
{\xe \v Feb\:toml}
{\xe \v toml\:Feb}
{\qr Feb{\bkmkstart AAAAAAAAJS}
{\bkmkend AAAAAAAAJS}
\cell }{\cell }{\row }
{\xe \v Mar\:toml}
{\xe \v toml\:Mar}
{\qr Mar{\bkmkstart AAAAAAAAJT}
{\bkmkend AAAAAAAAJT}
\cell }{\cell }{\row }
{\xe \v Apr\:toml}
{\xe \v toml\:Apr}
{\qr Apr{\bkmkstart AAAAAAAAJU}
{\bkmkend AAAAAAAAJU}
\cell }{\cell }{\row }
{\xe \v May\:toml}
{\xe \v toml\:May}
{\qr May{\bkmkstart AAAAAAAAJV}
{\bkmkend AAAAAAAAJV}
\cell }{\cell }{\row }
{\xe \v Jun\:toml}
{\xe \v toml\:Jun}
{\qr Jun{\bkmkstart AAAAAAAAJW}
{\bkmkend AAAAAAAAJW}
\cell }{\cell }{\row }
{\xe \v Jul\:toml}
{\xe \v toml\:Jul}
{\qr Jul{\bkmkstart AAAAAAAAJX}
{\bkmkend AAAAAAAAJX}
\cell }{\cell }{\row }
{\xe \v Aug\:toml}
{\xe \v toml\:Aug}
{\qr Aug{\bkmkstart AAAAAAAAJY}
{\bkmkend AAAAAAAAJY}
\cell }{\cell }{\row }
{\xe \v Sep\:toml}
{\xe \v toml\:Sep}
{\qr Sep{\bkmkstart AAAAAAAAJZ}
{\bkmkend AAAAAAAAJZ}
\cell }{\cell }{\row }
{\xe \v Oct\:toml}
{\xe \v toml\:Oct}
{\qr Oct{\bkmkstart AAAAAAAAKA}
{\bkmkend AAAAAAAAKA}
\cell }{\cell }{\row }
{\xe \v Nov\:toml}
{\xe \v toml\:Nov}
{\qr Nov{\bkmkstart AAAAAAAAKB}
{\bkmkend AAAAAAAAKB}
\cell }{\cell }{\row }
{\xe \v Dec\:toml}
{\xe \v toml\:Dec}
{\qr Dec{\bkmkstart AAAAAAAAKC}
{\bkmkend AAAAAAAAKC}
\cell }{\cell }{\row }
}
}
{\xe \v string_t\:toml}
{\xe \v toml\:string_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b toml::string_t} : std::uint8_t{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAKD}
{\bkmkend AAAAAAAAKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v basic\:toml}
{\xe \v toml\:basic}
{\qr basic{\bkmkstart AAAAAAAAKE}
{\bkmkend AAAAAAAAKE}
\cell }{\cell }{\row }
{\xe \v literal\:toml}
{\xe \v toml\:literal}
{\qr literal{\bkmkstart AAAAAAAAKF}
{\bkmkend AAAAAAAAKF}
\cell }{\cell }{\row }
}
}
{\xe \v value_t\:toml}
{\xe \v toml\:value_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum class {\b toml::value_t} : std::uint8_t{\f2 [strong]}}}
\par
{\bkmkstart AAAAAAAAKG}
{\bkmkend AAAAAAAAKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v empty\:toml}
{\xe \v toml\:empty}
{\qr empty{\bkmkstart AAAAAAAAKH}
{\bkmkend AAAAAAAAKH}
\cell }{\cell }{\row }
{\xe \v boolean\:toml}
{\xe \v toml\:boolean}
{\qr boolean{\bkmkstart AAAAAAAAKI}
{\bkmkend AAAAAAAAKI}
\cell }{\cell }{\row }
{\xe \v integer\:toml}
{\xe \v toml\:integer}
{\qr integer{\bkmkstart AAAAAAAAKJ}
{\bkmkend AAAAAAAAKJ}
\cell }{\cell }{\row }
{\xe \v floating\:toml}
{\xe \v toml\:floating}
{\qr floating{\bkmkstart AAAAAAAAKK}
{\bkmkend AAAAAAAAKK}
\cell }{\cell }{\row }
{\xe \v string\:toml}
{\xe \v toml\:string}
{\qr string{\bkmkstart AAAAAAAAKL}
{\bkmkend AAAAAAAAKL}
\cell }{\cell }{\row }
{\xe \v offset_datetime\:toml}
{\xe \v toml\:offset_datetime}
{\qr offset_datetime{\bkmkstart AAAAAAAAKM}
{\bkmkend AAAAAAAAKM}
\cell }{\cell }{\row }
{\xe \v local_datetime\:toml}
{\xe \v toml\:local_datetime}
{\qr local_datetime{\bkmkstart AAAAAAAAKN}
{\bkmkend AAAAAAAAKN}
\cell }{\cell }{\row }
{\xe \v local_date\:toml}
{\xe \v toml\:local_date}
{\qr local_date{\bkmkstart AAAAAAAAKO}
{\bkmkend AAAAAAAAKO}
\cell }{\cell }{\row }
{\xe \v local_time\:toml}
{\xe \v toml\:local_time}
{\qr local_time{\bkmkstart AAAAAAAAKP}
{\bkmkend AAAAAAAAKP}
\cell }{\cell }{\row }
{\xe \v array\:toml}
{\xe \v toml\:array}
{\qr array{\bkmkstart AAAAAAAAKQ}
{\bkmkend AAAAAAAAKQ}
\cell }{\cell }{\row }
{\xe \v table\:toml}
{\xe \v toml\:table}
{\qr table{\bkmkstart AAAAAAAAKR}
{\bkmkend AAAAAAAAKR}
\cell }{\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v concat_to_string\:toml}
{\xe \v toml\:concat_to_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ... Ts> std::string toml::concat_to_string (Ts &&...  {\i args})}}
\par
{\bkmkstart AAAAAAAAKS}
{\bkmkend AAAAAAAAKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v err\:toml}
{\xe \v toml\:err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b failure}< std::string > toml::err (const char *  {\i literal}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAKT}
{\bkmkend AAAAAAAAKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v err\:toml}
{\xe \v toml\:err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b failure}< typename std::remove_cv< typename std::remove_reference< T >::type >::type > toml::err (T &&  {\i v})}}
\par
{\bkmkstart AAAAAAAAKU}
{\bkmkend AAAAAAAAKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v expect\:toml}
{\xe \v toml\:expect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b result}< T, std::string > toml::expect (const {\b basic_value}< C, M, V > &  {\i v}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAKV}
{\bkmkend AAAAAAAAKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v expect\:toml}
{\xe \v toml\:expect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b result}< T, std::string > toml::expect (const {\b basic_value}< C, M, V > &  {\i v}, const {\b toml::key} &  {\i k}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAKW}
{\bkmkend AAAAAAAAKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find\:toml}
{\xe \v toml\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > toml::find ({\b basic_value}< C, M, V > &&  {\i v}, const {\b key} &  {\i ky})}}
\par
{\bkmkstart AAAAAAAAKX}
{\bkmkend AAAAAAAAKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find\:toml}
{\xe \v toml\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > toml::find ({\b basic_value}< C, M, V > &&  {\i v}, const std::size_t  {\i idx})}}
\par
{\bkmkstart AAAAAAAAKY}
{\bkmkend AAAAAAAAKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find\:toml}
{\xe \v toml\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V, typename Key1 , typename Key2 , typename ... Keys> {\b basic_value}< C, M, V > toml::find ({\b basic_value}< C, M, V > &&  {\i v}, Key1 &&  {\i k1}, Key2 &&  {\i k2}, Keys &&...  {\i keys})}}
\par
{\bkmkstart AAAAAAAAKZ}
{\bkmkend AAAAAAAAKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find\:toml}
{\xe \v toml\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > & toml::find ({\b basic_value}< C, M, V > &  {\i v}, const {\b key} &  {\i ky})}}
\par
{\bkmkstart AAAAAAAALA}
{\bkmkend AAAAAAAALA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find\:toml}
{\xe \v toml\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > & toml::find ({\b basic_value}< C, M, V > &  {\i v}, const std::size_t  {\i idx})}}
\par
{\bkmkstart AAAAAAAALB}
{\bkmkend AAAAAAAALB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find\:toml}
{\xe \v toml\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V, typename Key1 , typename Key2 , typename ... Keys> {\b basic_value}< C, M, V > & toml::find ({\b basic_value}< C, M, V > &  {\i v}, Key1 &&  {\i k1}, Key2 &&  {\i k2}, Keys &&...  {\i keys})}}
\par
{\bkmkstart AAAAAAAALC}
{\bkmkend AAAAAAAALC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find\:toml}
{\xe \v toml\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > const  & toml::find (const {\b basic_value}< C, M, V > &  {\i v}, const {\b key} &  {\i ky})}}
\par
{\bkmkstart AAAAAAAALD}
{\bkmkend AAAAAAAALD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find\:toml}
{\xe \v toml\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > const  & toml::find (const {\b basic_value}< C, M, V > &  {\i v}, const std::size_t  {\i idx})}}
\par
{\bkmkstart AAAAAAAALE}
{\bkmkend AAAAAAAALE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find\:toml}
{\xe \v toml\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V, typename Key1 , typename Key2 , typename ... Keys> const {\b basic_value}< C, M, V > & toml::find (const {\b basic_value}< C, M, V > &  {\i v}, Key1 &&  {\i k1}, Key2 &&  {\i k2}, Keys &&...  {\i keys})}}
\par
{\bkmkstart AAAAAAAALF}
{\bkmkend AAAAAAAALF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find_or\:toml}
{\xe \v toml\:find_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > toml::find_or ({\b basic_value}< C, M, V > &&  {\i v}, const {\b toml::key} &  {\i ky}, {\b basic_value}< C, M, V > &&  {\i opt})}}
\par
{\bkmkstart AAAAAAAALG}
{\bkmkend AAAAAAAALG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find_or\:toml}
{\xe \v toml\:find_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, {\b detail::remove_cvref_t}< T > > toml::find_or ({\b basic_value}< C, M, V > &&  {\i v}, const {\b toml::key} &  {\i ky}, T &&  {\i opt})}}
\par
{\bkmkstart AAAAAAAALH}
{\bkmkend AAAAAAAALH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find_or\:toml}
{\xe \v toml\:find_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, std::string >{\b ::value}, std::string > toml::find_or ({\b basic_value}< C, M, V > &&  {\i v}, const {\b toml::key} &  {\i ky}, T &&  {\i opt})}}
\par
{\bkmkstart AAAAAAAALI}
{\bkmkend AAAAAAAALI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find_or\:toml}
{\xe \v toml\:find_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > & toml::find_or ({\b basic_value}< C, M, V > &  {\i v}, const {\b toml::key} &  {\i ky}, {\b basic_value}< C, M, V > &  {\i opt})}}
\par
{\bkmkstart AAAAAAAALJ}
{\bkmkend AAAAAAAALJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find_or\:toml}
{\xe \v toml\:find_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, T > & toml::find_or ({\b basic_value}< C, M, V > &  {\i v}, const {\b toml::key} &  {\i ky}, T &  {\i opt})}}
\par
{\bkmkstart AAAAAAAALK}
{\bkmkend AAAAAAAALK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find_or\:toml}
{\xe \v toml\:find_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, std::string >{\b ::value}, std::string > & toml::find_or ({\b basic_value}< C, M, V > &  {\i v}, const {\b toml::key} &  {\i ky}, T &  {\i opt})}}
\par
{\bkmkstart AAAAAAAALL}
{\bkmkend AAAAAAAALL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find_or\:toml}
{\xe \v toml\:find_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > const  & toml::find_or (const {\b basic_value}< C, M, V > &  {\i v}, const {\b key} &  {\i ky}, const {\b basic_value}< C, M, V > &  {\i opt})}}
\par
{\bkmkstart AAAAAAAALM}
{\bkmkend AAAAAAAALM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find_or\:toml}
{\xe \v toml\:find_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, T > const  & toml::find_or (const {\b basic_value}< C, M, V > &  {\i v}, const {\b key} &  {\i ky}, const T &  {\i opt})}}
\par
{\bkmkstart AAAAAAAALN}
{\bkmkend AAAAAAAALN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find_or\:toml}
{\xe \v toml\:find_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, std::string >{\b ::value}, std::string > const  & toml::find_or (const {\b basic_value}< C, M, V > &  {\i v}, const {\b key} &  {\i ky}, const T &  {\i opt})}}
\par
{\bkmkstart AAAAAAAALO}
{\bkmkend AAAAAAAALO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find_or\:toml}
{\xe \v toml\:find_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_string_literal}< typename std::remove_reference< T >::type >{\b ::value}, std::string > toml::find_or (const {\b basic_value}< C, M, V > &  {\i v}, const {\b toml::key} &  {\i ky}, T &&  {\i opt})}}
\par
{\bkmkstart AAAAAAAALP}
{\bkmkend AAAAAAAALP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find_or\:toml}
{\xe \v toml\:find_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::negation}< {\b detail::is_exact_toml_type}< {\b detail::remove_cvref_t}< T >, {\b basic_value}< C, M, V > > >, {\b detail::negation}< std::is_same< std::string, {\b detail::remove_cvref_t}< T > > >, {\b detail::negation}< {\b detail::is_string_literal}< typename std::remove_reference< T >::type > > >{\b ::value}, {\b detail::remove_cvref_t}< T > > toml::find_or (const {\b basic_value}< C, M, V > &  {\i v}, const {\b toml::key} &  {\i ky}, T &&  {\i opt})}}
\par
{\bkmkstart AAAAAAAALQ}
{\bkmkend AAAAAAAALQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find_or\:toml}
{\xe \v toml\:find_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value , typename ... Ks, typename {\b detail::enable_if_t}<(sizeof...(Ks) > 1), std::nullptr_t >  = nullptr> auto toml::find_or (Value &&  {\i v}, const {\b toml::key} &  {\i ky}, Ks &&...  {\i keys}) -> decltype(find_or(std::forward<Value>(v), ky, {\b detail::last_one}(std::forward<Ks>(keys)...)))
}}
\par
{\bkmkstart AAAAAAAALR}
{\bkmkend AAAAAAAALR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v find_or\:toml}
{\xe \v toml\:find_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename Value , typename ... Ks, typename {\b detail::enable_if_t}<(sizeof...(Ks) > 1), std::nullptr_t >  = nullptr> auto toml::find_or (Value &&  {\i v}, const {\b toml::key} &  {\i ky}, Ks &&...  {\i keys}) -> decltype(find_or<T>(std::forward<Value>(v), ky, {\b detail::last_one}(std::forward<Ks>(keys)...)))
}}
\par
{\bkmkstart AAAAAAAALS}
{\bkmkend AAAAAAAALS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v format\:toml}
{\xe \v toml\:format}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V> std::string toml::format (const {\b basic_value}< C, M, V > &  {\i v}, std::size_t  {\i w} = {\f2 80u}, int  {\i fprec} = {\f2 std::numeric_limits<{\b toml::floating}>::max_digits10}, bool  {\i no_comment} = {\f2 false}, bool  {\i force_inline} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAALT}
{\bkmkend AAAAAAAALT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v format_error\:toml}
{\xe \v toml\:format_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::string toml::format_error (const std::string &  {\i err_msg}, const {\b basic_value}< C, T, A > &  {\i v}, const std::string &  {\i comment}, std::vector< std::string >  {\i hints} = {\f2 \{\}}, const bool  {\i colorize} = {\f2 {\b TOML11_ERROR_MESSAGE_COLORIZED}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALU}
{\bkmkend AAAAAAAALU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v format_error\:toml}
{\xe \v toml\:format_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::string toml::format_error (const std::string &  {\i err_msg}, const {\b toml::basic_value}< C, T, A > &  {\i v1}, const std::string &  {\i comment1}, const {\b toml::basic_value}< C, T, A > &  {\i v2}, const std::string &  {\i comment2}, const {\b toml::basic_value}< C, T, A > &  {\i v3}, const std::string &  {\i comment3}, std::vector< std::string >  {\i hints} = {\f2 \{\}}, const bool  {\i colorize} = {\f2 {\b TOML11_ERROR_MESSAGE_COLORIZED}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALV}
{\bkmkend AAAAAAAALV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v format_error\:toml}
{\xe \v toml\:format_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::string toml::format_error (const std::string &  {\i err_msg}, const {\b toml::basic_value}< C, T, A > &  {\i v1}, const std::string &  {\i comment1}, const {\b toml::basic_value}< C, T, A > &  {\i v2}, const std::string &  {\i comment2}, std::vector< std::string >  {\i hints} = {\f2 \{\}}, const bool  {\i colorize} = {\f2 {\b TOML11_ERROR_MESSAGE_COLORIZED}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAALW}
{\bkmkend AAAAAAAALW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v format_key\:toml}
{\xe \v toml\:format_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traits , typename Alloc > std::basic_string< charT, traits, Alloc > toml::format_key (const std::basic_string< charT, traits, Alloc > &  {\i k})}}
\par
{\bkmkstart AAAAAAAALX}
{\bkmkend AAAAAAAALX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v format_keys\:toml}
{\xe \v toml\:format_keys}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traits , typename Alloc > std::basic_string< charT, traits, Alloc > toml::format_keys (const std::vector< std::basic_string< charT, traits, Alloc > > &  {\i keys})}}
\par
{\bkmkstart AAAAAAAALY}
{\bkmkend AAAAAAAALY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v from_string\:toml}
{\xe \v toml\:from_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T toml::from_string (const std::string &  {\i str}, T  {\i opt})}}
\par
{\bkmkstart AAAAAAAALZ}
{\bkmkend AAAAAAAALZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, T > toml::get ({\b basic_value}< C, M, V > &&  {\i v})}}
\par
{\bkmkstart AAAAAAAAMA}
{\bkmkend AAAAAAAAMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, {\b basic_value}< C, M, V > >{\b ::value}, T > toml::get ({\b basic_value}< C, M, V > &&  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMB}
{\bkmkend AAAAAAAAMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, std::string >{\b ::value}, std::string > toml::get ({\b basic_value}< C, M, V > &&  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMC}
{\bkmkend AAAAAAAAMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, T > & toml::get ({\b basic_value}< C, M, V > &  {\i v})}}
\par
{\bkmkstart AAAAAAAAMD}
{\bkmkend AAAAAAAAMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, {\b basic_value}< C, M, V > >{\b ::value}, T > & toml::get ({\b basic_value}< C, M, V > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAME}
{\bkmkend AAAAAAAAME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, std::string >{\b ::value}, std::string > & toml::get ({\b basic_value}< C, M, V > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMF}
{\bkmkend AAAAAAAAMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::is_container}< T >, {\b detail::has_push_back_method}< T >, {\b detail::negation}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > > > >{\b ::value}, T > toml::get (const {\b basic_value}< C, M, V > &  {\i v})}}
\par
{\bkmkstart AAAAAAAAMG}
{\bkmkend AAAAAAAAMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::is_container}< T >, {\b detail::negation}< {\b detail::has_push_back_method}< T > >, {\b detail::negation}< {\b detail::has_specialized_from}< T > >, {\b detail::negation}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > > > >{\b ::value}, T > toml::get (const {\b basic_value}< C, M, V > &  {\i v})}}
\par
{\bkmkstart AAAAAAAAMH}
{\bkmkend AAAAAAAAMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_std_pair}< T >{\b ::value}, T > toml::get (const {\b basic_value}< C, M, V > &  {\i v})}}
\par
{\bkmkstart AAAAAAAAMI}
{\bkmkend AAAAAAAAMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_std_tuple}< T >{\b ::value}, T > toml::get (const {\b basic_value}< C, M, V > &  {\i v})}}
\par
{\bkmkstart AAAAAAAAMJ}
{\bkmkend AAAAAAAAMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::is_map}< T >, {\b detail::negation}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > > > >{\b ::value}, T > toml::get (const {\b basic_value}< C, M, V > &  {\i v})}}
\par
{\bkmkstart AAAAAAAAMK}
{\bkmkend AAAAAAAAMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::negation}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > > >, {\b detail::has_from_toml_method}< T, C, M, V >, std::is_default_constructible< T > >{\b ::value}, T > toml::get (const {\b basic_value}< C, M, V > &  {\i v})}}
\par
{\bkmkstart AAAAAAAAML}
{\bkmkend AAAAAAAAML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::has_specialized_from}< T >{\b ::value}, T > toml::get (const {\b basic_value}< C, M, V > &  {\i v})}}
\par
{\bkmkstart AAAAAAAAMM}
{\bkmkend AAAAAAAAMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::negation}< {\b detail::is_basic_value}< T > >, std::is_constructible< T, const {\b basic_value}< C, M, V > & >, {\b detail::negation}< {\b detail::has_from_toml_method}< T, C, M, V > >, {\b detail::negation}< {\b detail::has_specialized_from}< T > > >{\b ::value}, T > toml::get (const {\b basic_value}< C, M, V > &  {\i v})}}
\par
{\bkmkstart AAAAAAAAMN}
{\bkmkend AAAAAAAAMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, T > const  & toml::get (const {\b basic_value}< C, M, V > &  {\i v})}}
\par
{\bkmkstart AAAAAAAAMO}
{\bkmkend AAAAAAAAMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, {\b basic_value}< C, M, V > >{\b ::value}, T > const  & toml::get (const {\b basic_value}< C, M, V > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMP}
{\bkmkend AAAAAAAAMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::is_basic_value}< T >, {\b detail::negation}< std::is_same< T, {\b basic_value}< C, M, V > > > >{\b ::value}, T > toml::get (const {\b basic_value}< C, M, V > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMQ}
{\bkmkend AAAAAAAAMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< std::is_integral< T >, {\b detail::negation}< std::is_same< T, bool > >, {\b detail::negation}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > > > >{\b ::value}, T > toml::get (const {\b basic_value}< C, M, V > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMR}
{\bkmkend AAAAAAAAMR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< std::is_floating_point< T >, {\b detail::negation}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > > > >{\b ::value}, T > toml::get (const {\b basic_value}< C, M, V > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMS}
{\bkmkend AAAAAAAAMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, std::string >{\b ::value}, std::string > const  & toml::get (const {\b basic_value}< C, M, V > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMT}
{\bkmkend AAAAAAAAMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_chrono_duration}< T >{\b ::value}, T > toml::get (const {\b basic_value}< C, M, V > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMU}
{\bkmkend AAAAAAAAMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< std::chrono::system_clock::time_point, T >{\b ::value}, T > toml::get (const {\b basic_value}< C, M, V > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAMV}
{\bkmkend AAAAAAAAMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get\:toml}
{\xe \v toml\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_std_forward_list}< T >{\b ::value}, T > toml::get (const {\b basic_value}< C, M, V > &  {\i v})}}
\par
{\bkmkstart AAAAAAAAMW}
{\bkmkend AAAAAAAAMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_or\:toml}
{\xe \v toml\:get_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > toml::get_or ({\b basic_value}< C, M, V > &&  {\i v}, {\b basic_value}< C, M, V > && )}}
\par
{\bkmkstart AAAAAAAAMX}
{\bkmkend AAAAAAAAMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_or\:toml}
{\xe \v toml\:get_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< {\b detail::remove_cvref_t}< T >, {\b basic_value}< C, M, V > >{\b ::value}, {\b detail::remove_cvref_t}< T > > toml::get_or ({\b basic_value}< C, M, V > &&  {\i v}, T &&  {\i opt})}}
\par
{\bkmkstart AAAAAAAAMY}
{\bkmkend AAAAAAAAMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_or\:toml}
{\xe \v toml\:get_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< {\b detail::remove_cvref_t}< T >, std::string >{\b ::value}, std::string > toml::get_or ({\b basic_value}< C, M, V > &&  {\i v}, T &&  {\i opt})}}
\par
{\bkmkstart AAAAAAAAMZ}
{\bkmkend AAAAAAAAMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_or\:toml}
{\xe \v toml\:get_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > & toml::get_or ({\b basic_value}< C, M, V > &  {\i v}, {\b basic_value}< C, M, V > & )}}
\par
{\bkmkstart AAAAAAAANA}
{\bkmkend AAAAAAAANA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_or\:toml}
{\xe \v toml\:get_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, T > & toml::get_or ({\b basic_value}< C, M, V > &  {\i v}, T &  {\i opt})}}
\par
{\bkmkstart AAAAAAAANB}
{\bkmkend AAAAAAAANB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_or\:toml}
{\xe \v toml\:get_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< T, std::string >{\b ::value}, std::string > & toml::get_or ({\b basic_value}< C, M, V > &  {\i v}, T &  {\i opt})}}
\par
{\bkmkstart AAAAAAAANC}
{\bkmkend AAAAAAAANC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_or\:toml}
{\xe \v toml\:get_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class M, template< typename ... > class V> {\b basic_value}< C, M, V > const  & toml::get_or (const {\b basic_value}< C, M, V > &  {\i v}, const {\b basic_value}< C, M, V > & )}}
\par
{\bkmkstart AAAAAAAAND}
{\bkmkend AAAAAAAAND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_or\:toml}
{\xe \v toml\:get_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_exact_toml_type}< T, {\b basic_value}< C, M, V > >{\b ::value}, T > const  & toml::get_or (const {\b basic_value}< C, M, V > &  {\i v}, const T &  {\i opt})}}
\par
{\bkmkstart AAAAAAAANE}
{\bkmkend AAAAAAAANE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_or\:toml}
{\xe \v toml\:get_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< std::is_same< {\b detail::remove_cvref_t}< T >, std::string >{\b ::value}, std::string > const  & toml::get_or (const {\b basic_value}< C, M, V > &  {\i v}, const T &  {\i opt})}}
\par
{\bkmkstart AAAAAAAANF}
{\bkmkend AAAAAAAANF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_or\:toml}
{\xe \v toml\:get_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::is_string_literal}< typename std::remove_reference< T >::type >{\b ::value}, std::string > toml::get_or (const {\b basic_value}< C, M, V > &  {\i v}, T &&  {\i opt})}}
\par
{\bkmkstart AAAAAAAANG}
{\bkmkend AAAAAAAANG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_or\:toml}
{\xe \v toml\:get_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> {\b detail::enable_if_t}< {\b detail::conjunction}< {\b detail::negation}< {\b detail::is_exact_toml_type}< {\b detail::remove_cvref_t}< T >, {\b basic_value}< C, M, V > > >, {\b detail::negation}< std::is_same< std::string, {\b detail::remove_cvref_t}< T > > >, {\b detail::negation}< {\b detail::is_string_literal}< typename std::remove_reference< T >::type > > >{\b ::value}, {\b detail::remove_cvref_t}< T > > toml::get_or (const {\b basic_value}< C, M, V > &  {\i v}, T &&  {\i opt})}}
\par
{\bkmkstart AAAAAAAANH}
{\bkmkend AAAAAAAANH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v make_unique\:toml}
{\xe \v toml\:make_unique}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename ... Ts> std::unique_ptr< T > toml::make_unique (Ts &&...  {\i args}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANI}
{\bkmkend AAAAAAAANI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v nocomment\:toml}
{\xe \v toml\:nocomment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & toml::nocomment (std::basic_ostream< charT, traits > &  {\i os})}}
\par
{\bkmkstart AAAAAAAANJ}
{\bkmkend AAAAAAAANJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ok\:toml}
{\xe \v toml\:ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b success}< std::string > toml::ok (const char *  {\i literal}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANK}
{\bkmkend AAAAAAAANK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ok\:toml}
{\xe \v toml\:ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b success}< typename std::remove_cv< typename std::remove_reference< T >::type >::type > toml::ok (T &&  {\i v})}}
\par
{\bkmkstart AAAAAAAANL}
{\bkmkend AAAAAAAANL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:toml}
{\xe \v toml\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class T, template< typename ... > class A> bool toml::operator!= (const {\b basic_value}< C, T, A > &  {\i lhs}, const {\b basic_value}< C, T, A > &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANM}
{\bkmkend AAAAAAAANM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:toml}
{\xe \v toml\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator!= (const char *  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANN}
{\bkmkend AAAAAAAANN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:toml}
{\xe \v toml\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator!= (const {\b discard_comments} & , const {\b discard_comments} & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAANO}
{\bkmkend AAAAAAAANO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:toml}
{\xe \v toml\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator!= (const {\b local_date} &  {\i lhs}, const {\b local_date} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANP}
{\bkmkend AAAAAAAANP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:toml}
{\xe \v toml\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator!= (const {\b local_datetime} &  {\i lhs}, const {\b local_datetime} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANQ}
{\bkmkend AAAAAAAANQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:toml}
{\xe \v toml\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator!= (const {\b local_time} &  {\i lhs}, const {\b local_time} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANR}
{\bkmkend AAAAAAAANR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:toml}
{\xe \v toml\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator!= (const {\b offset_datetime} &  {\i lhs}, const {\b offset_datetime} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANS}
{\bkmkend AAAAAAAANS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:toml}
{\xe \v toml\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator!= (const {\b preserve_comments} &  {\i lhs}, const {\b preserve_comments} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANT}
{\bkmkend AAAAAAAANT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:toml}
{\xe \v toml\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator!= (const std::string &  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANU}
{\bkmkend AAAAAAAANU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:toml}
{\xe \v toml\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator!= (const {\b string} &  {\i lhs}, const char *  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANV}
{\bkmkend AAAAAAAANV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:toml}
{\xe \v toml\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator!= (const {\b string} &  {\i lhs}, const std::string &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANW}
{\bkmkend AAAAAAAANW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:toml}
{\xe \v toml\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator!= (const {\b string} &  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANX}
{\bkmkend AAAAAAAANX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:toml}
{\xe \v toml\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator!= (const {\b time_offset} &  {\i lhs}, const {\b time_offset} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAANY}
{\bkmkend AAAAAAAANY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml}
{\xe \v toml\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::enable_if< {\b detail::conjunction}< {\b detail::is_comparable}< typenamebasic_value< C, T, A >::array_type >, {\b detail::is_comparable}< typenamebasic_value< C, T, A >::table_type > >{\b ::value}, bool >::type toml::operator< (const {\b basic_value}< C, T, A > &  {\i lhs}, const {\b basic_value}< C, T, A > &  {\i rhs})}}
\par
{\bkmkstart AAAAAAAANZ}
{\bkmkend AAAAAAAANZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml}
{\xe \v toml\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator< (const char *  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOA}
{\bkmkend AAAAAAAAOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml}
{\xe \v toml\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator< (const {\b discard_comments} & , const {\b discard_comments} & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAOB}
{\bkmkend AAAAAAAAOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml}
{\xe \v toml\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator< (const {\b local_date} &  {\i lhs}, const {\b local_date} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOC}
{\bkmkend AAAAAAAAOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml}
{\xe \v toml\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator< (const {\b local_datetime} &  {\i lhs}, const {\b local_datetime} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOD}
{\bkmkend AAAAAAAAOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml}
{\xe \v toml\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator< (const {\b local_time} &  {\i lhs}, const {\b local_time} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOE}
{\bkmkend AAAAAAAAOE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml}
{\xe \v toml\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator< (const {\b offset_datetime} &  {\i lhs}, const {\b offset_datetime} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOF}
{\bkmkend AAAAAAAAOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml}
{\xe \v toml\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator< (const {\b preserve_comments} &  {\i lhs}, const {\b preserve_comments} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOG}
{\bkmkend AAAAAAAAOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml}
{\xe \v toml\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator< (const std::string &  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOH}
{\bkmkend AAAAAAAAOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml}
{\xe \v toml\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator< (const {\b string} &  {\i lhs}, const char *  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOI}
{\bkmkend AAAAAAAAOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml}
{\xe \v toml\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator< (const {\b string} &  {\i lhs}, const std::string &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOJ}
{\bkmkend AAAAAAAAOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml}
{\xe \v toml\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator< (const {\b string} &  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOK}
{\bkmkend AAAAAAAAOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml}
{\xe \v toml\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator< (const {\b time_offset} &  {\i lhs}, const {\b time_offset} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOL}
{\bkmkend AAAAAAAAOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:toml}
{\xe \v toml\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traits , typename C , template< typename ... > class M, template< typename ... > class V> std::basic_ostream< charT, traits > & toml::operator<< (std::basic_ostream< charT, traits > &  {\i os}, const {\b basic_value}< C, M, V > &  {\i v})}}
\par
{\bkmkstart AAAAAAAAOM}
{\bkmkend AAAAAAAAOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:toml}
{\xe \v toml\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & toml::operator<< (std::basic_ostream< charT, traits > &  {\i os}, const {\b discard_comments} & )}}
\par
{\bkmkstart AAAAAAAAON}
{\bkmkend AAAAAAAAON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:toml}
{\xe \v toml\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & toml::operator<< (std::basic_ostream< charT, traits > &  {\i os}, const {\b local_date} &  {\i date})}}
\par
{\bkmkstart AAAAAAAAOO}
{\bkmkend AAAAAAAAOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:toml}
{\xe \v toml\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & toml::operator<< (std::basic_ostream< charT, traits > &  {\i os}, const {\b local_datetime} &  {\i dt})}}
\par
{\bkmkstart AAAAAAAAOP}
{\bkmkend AAAAAAAAOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:toml}
{\xe \v toml\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & toml::operator<< (std::basic_ostream< charT, traits > &  {\i os}, const {\b local_time} &  {\i time})}}
\par
{\bkmkstart AAAAAAAAOQ}
{\bkmkend AAAAAAAAOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:toml}
{\xe \v toml\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & toml::operator<< (std::basic_ostream< charT, traits > &  {\i os}, const {\b offset_datetime} &  {\i dt})}}
\par
{\bkmkstart AAAAAAAAOR}
{\bkmkend AAAAAAAAOR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:toml}
{\xe \v toml\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & toml::operator<< (std::basic_ostream< charT, traits > &  {\i os}, const {\b preserve_comments} &  {\i com})}}
\par
{\bkmkstart AAAAAAAAOS}
{\bkmkend AAAAAAAAOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:toml}
{\xe \v toml\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & toml::operator<< (std::basic_ostream< charT, traits > &  {\i os}, const {\b string} &  {\i s})}}
\par
{\bkmkstart AAAAAAAAOT}
{\bkmkend AAAAAAAAOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:toml}
{\xe \v toml\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & toml::operator<< (std::basic_ostream< charT, traits > &  {\i os}, const {\b time_offset} &  {\i offset})}}
\par
{\bkmkstart AAAAAAAAOU}
{\bkmkend AAAAAAAAOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:toml}
{\xe \v toml\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & toml::operator<< (std::basic_ostream< charT, traits > &  {\i os}, {\b value_t}  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOV}
{\bkmkend AAAAAAAAOV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml}
{\xe \v toml\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::enable_if< {\b detail::conjunction}< {\b detail::is_comparable}< typenamebasic_value< C, T, A >::array_type >, {\b detail::is_comparable}< typenamebasic_value< C, T, A >::table_type > >{\b ::value}, bool >::type toml::operator<= (const {\b basic_value}< C, T, A > &  {\i lhs}, const {\b basic_value}< C, T, A > &  {\i rhs})}}
\par
{\bkmkstart AAAAAAAAOW}
{\bkmkend AAAAAAAAOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml}
{\xe \v toml\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator<= (const char *  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOX}
{\bkmkend AAAAAAAAOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml}
{\xe \v toml\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator<= (const {\b discard_comments} & , const {\b discard_comments} & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAOY}
{\bkmkend AAAAAAAAOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml}
{\xe \v toml\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator<= (const {\b local_date} &  {\i lhs}, const {\b local_date} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAOZ}
{\bkmkend AAAAAAAAOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml}
{\xe \v toml\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator<= (const {\b local_datetime} &  {\i lhs}, const {\b local_datetime} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPA}
{\bkmkend AAAAAAAAPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml}
{\xe \v toml\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator<= (const {\b local_time} &  {\i lhs}, const {\b local_time} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPB}
{\bkmkend AAAAAAAAPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml}
{\xe \v toml\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator<= (const {\b offset_datetime} &  {\i lhs}, const {\b offset_datetime} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPC}
{\bkmkend AAAAAAAAPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml}
{\xe \v toml\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator<= (const {\b preserve_comments} &  {\i lhs}, const {\b preserve_comments} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPD}
{\bkmkend AAAAAAAAPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml}
{\xe \v toml\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator<= (const std::string &  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPE}
{\bkmkend AAAAAAAAPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml}
{\xe \v toml\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator<= (const {\b string} &  {\i lhs}, const char *  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPF}
{\bkmkend AAAAAAAAPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml}
{\xe \v toml\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator<= (const {\b string} &  {\i lhs}, const std::string &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPG}
{\bkmkend AAAAAAAAPG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml}
{\xe \v toml\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator<= (const {\b string} &  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPH}
{\bkmkend AAAAAAAAPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml}
{\xe \v toml\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator<= (const {\b time_offset} &  {\i lhs}, const {\b time_offset} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPI}
{\bkmkend AAAAAAAAPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml}
{\xe \v toml\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class T, template< typename ... > class A> bool toml::operator== (const {\b basic_value}< C, T, A > &  {\i lhs}, const {\b basic_value}< C, T, A > &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPJ}
{\bkmkend AAAAAAAAPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml}
{\xe \v toml\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator== (const char *  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPK}
{\bkmkend AAAAAAAAPK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml}
{\xe \v toml\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator== (const {\b discard_comments} & , const {\b discard_comments} & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAPL}
{\bkmkend AAAAAAAAPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml}
{\xe \v toml\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator== (const {\b local_date} &  {\i lhs}, const {\b local_date} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPM}
{\bkmkend AAAAAAAAPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml}
{\xe \v toml\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator== (const {\b local_datetime} &  {\i lhs}, const {\b local_datetime} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPN}
{\bkmkend AAAAAAAAPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml}
{\xe \v toml\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator== (const {\b local_time} &  {\i lhs}, const {\b local_time} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPO}
{\bkmkend AAAAAAAAPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml}
{\xe \v toml\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator== (const {\b offset_datetime} &  {\i lhs}, const {\b offset_datetime} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPP}
{\bkmkend AAAAAAAAPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml}
{\xe \v toml\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator== (const {\b preserve_comments} &  {\i lhs}, const {\b preserve_comments} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPQ}
{\bkmkend AAAAAAAAPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml}
{\xe \v toml\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator== (const std::string &  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPR}
{\bkmkend AAAAAAAAPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml}
{\xe \v toml\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator== (const {\b string} &  {\i lhs}, const char *  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPS}
{\bkmkend AAAAAAAAPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml}
{\xe \v toml\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator== (const {\b string} &  {\i lhs}, const std::string &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPT}
{\bkmkend AAAAAAAAPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml}
{\xe \v toml\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator== (const {\b string} &  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPU}
{\bkmkend AAAAAAAAPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml}
{\xe \v toml\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator== (const {\b time_offset} &  {\i lhs}, const {\b time_offset} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPV}
{\bkmkend AAAAAAAAPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml}
{\xe \v toml\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::enable_if< {\b detail::conjunction}< {\b detail::is_comparable}< typenamebasic_value< C, T, A >::array_type >, {\b detail::is_comparable}< typenamebasic_value< C, T, A >::table_type > >{\b ::value}, bool >::type toml::operator> (const {\b basic_value}< C, T, A > &  {\i lhs}, const {\b basic_value}< C, T, A > &  {\i rhs})}}
\par
{\bkmkstart AAAAAAAAPW}
{\bkmkend AAAAAAAAPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml}
{\xe \v toml\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator> (const char *  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPX}
{\bkmkend AAAAAAAAPX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml}
{\xe \v toml\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator> (const {\b discard_comments} & , const {\b discard_comments} & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAPY}
{\bkmkend AAAAAAAAPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml}
{\xe \v toml\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator> (const {\b local_date} &  {\i lhs}, const {\b local_date} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAPZ}
{\bkmkend AAAAAAAAPZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml}
{\xe \v toml\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator> (const {\b local_datetime} &  {\i lhs}, const {\b local_datetime} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQA}
{\bkmkend AAAAAAAAQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml}
{\xe \v toml\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator> (const {\b local_time} &  {\i lhs}, const {\b local_time} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQB}
{\bkmkend AAAAAAAAQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml}
{\xe \v toml\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator> (const {\b offset_datetime} &  {\i lhs}, const {\b offset_datetime} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQC}
{\bkmkend AAAAAAAAQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml}
{\xe \v toml\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator> (const {\b preserve_comments} &  {\i lhs}, const {\b preserve_comments} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQD}
{\bkmkend AAAAAAAAQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml}
{\xe \v toml\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator> (const std::string &  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQE}
{\bkmkend AAAAAAAAQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml}
{\xe \v toml\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator> (const {\b string} &  {\i lhs}, const char *  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQF}
{\bkmkend AAAAAAAAQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml}
{\xe \v toml\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator> (const {\b string} &  {\i lhs}, const std::string &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQG}
{\bkmkend AAAAAAAAQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml}
{\xe \v toml\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator> (const {\b string} &  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQH}
{\bkmkend AAAAAAAAQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml}
{\xe \v toml\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator> (const {\b time_offset} &  {\i lhs}, const {\b time_offset} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQI}
{\bkmkend AAAAAAAAQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml}
{\xe \v toml\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::enable_if< {\b detail::conjunction}< {\b detail::is_comparable}< typenamebasic_value< C, T, A >::array_type >, {\b detail::is_comparable}< typenamebasic_value< C, T, A >::table_type > >{\b ::value}, bool >::type toml::operator>= (const {\b basic_value}< C, T, A > &  {\i lhs}, const {\b basic_value}< C, T, A > &  {\i rhs})}}
\par
{\bkmkstart AAAAAAAAQJ}
{\bkmkend AAAAAAAAQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml}
{\xe \v toml\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator>= (const char *  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQK}
{\bkmkend AAAAAAAAQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml}
{\xe \v toml\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator>= (const {\b discard_comments} & , const {\b discard_comments} & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAQL}
{\bkmkend AAAAAAAAQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml}
{\xe \v toml\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator>= (const {\b local_date} &  {\i lhs}, const {\b local_date} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQM}
{\bkmkend AAAAAAAAQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml}
{\xe \v toml\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator>= (const {\b local_datetime} &  {\i lhs}, const {\b local_datetime} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQN}
{\bkmkend AAAAAAAAQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml}
{\xe \v toml\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator>= (const {\b local_time} &  {\i lhs}, const {\b local_time} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQO}
{\bkmkend AAAAAAAAQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml}
{\xe \v toml\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator>= (const {\b offset_datetime} &  {\i lhs}, const {\b offset_datetime} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQP}
{\bkmkend AAAAAAAAQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml}
{\xe \v toml\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator>= (const {\b preserve_comments} &  {\i lhs}, const {\b preserve_comments} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQQ}
{\bkmkend AAAAAAAAQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml}
{\xe \v toml\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator>= (const std::string &  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQR}
{\bkmkend AAAAAAAAQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml}
{\xe \v toml\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator>= (const {\b string} &  {\i lhs}, const char *  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQS}
{\bkmkend AAAAAAAAQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml}
{\xe \v toml\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator>= (const {\b string} &  {\i lhs}, const std::string &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQT}
{\bkmkend AAAAAAAAQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml}
{\xe \v toml\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator>= (const {\b string} &  {\i lhs}, const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQU}
{\bkmkend AAAAAAAAQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml}
{\xe \v toml\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::operator>= (const {\b time_offset} &  {\i lhs}, const {\b time_offset} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQV}
{\bkmkend AAAAAAAAQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse\:toml}
{\xe \v toml\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment  = TOML11_DEFAULT_COMMENT_STRATEGY, template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value}< Comment, Table, Array > toml::parse (const std::string &  {\i fname})}}
\par
{\bkmkstart AAAAAAAAQW}
{\bkmkend AAAAAAAAQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse\:toml}
{\xe \v toml\:parse}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment  = TOML11_DEFAULT_COMMENT_STRATEGY, template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value}< Comment, Table, Array > toml::parse (std::istream &  {\i is}, const std::string &  {\i fname} = {\f2 "unknown\~ file"})}}
\par
{\bkmkstart AAAAAAAAQX}
{\bkmkend AAAAAAAAQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v showcomment\:toml}
{\xe \v toml\:showcomment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & toml::showcomment (std::basic_ostream< charT, traits > &  {\i os})}}
\par
{\bkmkstart AAAAAAAAQY}
{\bkmkend AAAAAAAAQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v stringize\:toml}
{\xe \v toml\:stringize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT  = char, typename traits  = std::char_traits<charT>, typename alloc  = std::allocator<charT>> std::basic_string< charT, traits, alloc > toml::stringize ({\b value_t}  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAQZ}
{\bkmkend AAAAAAAAQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v swap\:toml}
{\xe \v toml\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::swap (const {\b discard_comments} & , const {\b discard_comments} & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAARA}
{\bkmkend AAAAAAAARA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v swap\:toml}
{\xe \v toml\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::swap ({\b preserve_comments} &  {\i lhs}, {\b preserve_comments} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARB}
{\bkmkend AAAAAAAARB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v swap\:toml}
{\xe \v toml\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::swap ({\b preserve_comments} &  {\i lhs}, std::vector< std::string > &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARC}
{\bkmkend AAAAAAAARC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v swap\:toml}
{\xe \v toml\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > void toml::swap ({\b result}< T, E > &  {\i lhs}, {\b result}< T, E > &  {\i rhs})}}
\par
{\bkmkstart AAAAAAAARD}
{\bkmkend AAAAAAAARD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v swap\:toml}
{\xe \v toml\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::swap (std::vector< std::string > &  {\i lhs}, {\b preserve_comments} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAARE}
{\bkmkend AAAAAAAARE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v try_reserve\:toml}
{\xe \v toml\:try_reserve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Container > void toml::try_reserve (Container &  {\i container}, std::size_t  {\i N})}}
\par
{\bkmkstart AAAAAAAARF}
{\bkmkend AAAAAAAARF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v visit\:toml}
{\xe \v toml\:visit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Visitor , typename C , template< typename ... > class T, template< typename ... > class A> {\b detail::return_type_of_t}< Visitor, const {\b toml::boolean} & > toml::visit (Visitor &&  {\i visitor}, const {\b toml::basic_value}< C, T, A > &  {\i v})}}
\par
{\bkmkstart AAAAAAAARG}
{\bkmkend AAAAAAAARG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v visit\:toml}
{\xe \v toml\:visit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Visitor , typename C , template< typename ... > class T, template< typename ... > class A> {\b detail::return_type_of_t}< Visitor, {\b toml::boolean} && > toml::visit (Visitor &&  {\i visitor}, {\b toml::basic_value}< C, T, A > &&  {\i v})}}
\par
{\bkmkstart AAAAAAAARH}
{\bkmkend AAAAAAAARH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v visit\:toml}
{\xe \v toml\:visit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Visitor , typename C , template< typename ... > class T, template< typename ... > class A> {\b detail::return_type_of_t}< Visitor, {\b toml::boolean} & > toml::visit (Visitor &&  {\i visitor}, {\b toml::basic_value}< C, T, A > &  {\i v})}}
\par
{\bkmkstart AAAAAAAARI}
{\bkmkend AAAAAAAARI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v find\:toml}
{\xe \v toml\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> decltype(::toml::get< T >(std::declval< {\b basic_value}< C, M, V > const & >())) toml::find (const {\b basic_value}< C, M, V > &  {\i v}, const {\b key} &  {\i ky})}}
\par
{\bkmkstart AAAAAAAARJ}
{\bkmkend AAAAAAAARJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::color_ansi Namespace Reference\par \pard\plain 
{\tc\tcl2 \v toml::color_ansi}
{\xe \v toml::color_ansi}
{\bkmkstart AAAAAAABPK}
{\bkmkend AAAAAAABPK}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b colorize} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b nocolorize} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b reset} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b bold} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b grey} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b red} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b green} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b yellow} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b blue} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b magenta} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b cyan} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b white} (std::ostream &os)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v blue\:toml::color_ansi}
{\xe \v toml::color_ansi\:blue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & toml::color_ansi::blue (std::ostream &  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPL}
{\bkmkend AAAAAAABPL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v bold\:toml::color_ansi}
{\xe \v toml::color_ansi\:bold}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & toml::color_ansi::bold (std::ostream &  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPM}
{\bkmkend AAAAAAABPM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v colorize\:toml::color_ansi}
{\xe \v toml::color_ansi\:colorize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & toml::color_ansi::colorize (std::ostream &  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPN}
{\bkmkend AAAAAAABPN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v cyan\:toml::color_ansi}
{\xe \v toml::color_ansi\:cyan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & toml::color_ansi::cyan (std::ostream &  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPO}
{\bkmkend AAAAAAABPO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v green\:toml::color_ansi}
{\xe \v toml::color_ansi\:green}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & toml::color_ansi::green (std::ostream &  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPP}
{\bkmkend AAAAAAABPP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v grey\:toml::color_ansi}
{\xe \v toml::color_ansi\:grey}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & toml::color_ansi::grey (std::ostream &  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPQ}
{\bkmkend AAAAAAABPQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v magenta\:toml::color_ansi}
{\xe \v toml::color_ansi\:magenta}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & toml::color_ansi::magenta (std::ostream &  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPR}
{\bkmkend AAAAAAABPR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v nocolorize\:toml::color_ansi}
{\xe \v toml::color_ansi\:nocolorize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & toml::color_ansi::nocolorize (std::ostream &  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPS}
{\bkmkend AAAAAAABPS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v red\:toml::color_ansi}
{\xe \v toml::color_ansi\:red}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & toml::color_ansi::red (std::ostream &  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPT}
{\bkmkend AAAAAAABPT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reset\:toml::color_ansi}
{\xe \v toml::color_ansi\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & toml::color_ansi::reset (std::ostream &  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPU}
{\bkmkend AAAAAAABPU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v white\:toml::color_ansi}
{\xe \v toml::color_ansi\:white}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & toml::color_ansi::white (std::ostream &  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPV}
{\bkmkend AAAAAAABPV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v yellow\:toml::color_ansi}
{\xe \v toml::color_ansi\:yellow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ostream & toml::color_ansi::yellow (std::ostream &  {\i os}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPW}
{\bkmkend AAAAAAABPW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::color_ansi::detail Namespace Reference\par \pard\plain 
{\tc\tcl2 \v toml::color_ansi::detail}
{\xe \v toml::color_ansi::detail}
{\bkmkstart AAAAAAABPX}
{\bkmkend AAAAAAABPX}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b colorize_index} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v colorize_index\:toml::color_ansi::detail}
{\xe \v toml::color_ansi::detail\:colorize_index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int toml::color_ansi::detail::colorize_index (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPY}
{\bkmkend AAAAAAABPY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail Namespace Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail}
{\xe \v toml::detail}
{\bkmkstart AAAAAAABPZ}
{\bkmkend AAAAAAABPZ}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b at_least}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b character}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b conjunction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b conjunction< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b conjunction< T, Ts... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b disjunction}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b disjunction< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b disjunction< T, Ts... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b either}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b either< Head >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b either< Head, Tail... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b empty_iterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b enum_to_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b enum_to_type< value_t::array, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b enum_to_type< value_t::boolean, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b enum_to_type< value_t::empty, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b enum_to_type< value_t::floating, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b enum_to_type< value_t::integer, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b enum_to_type< value_t::local_date, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b enum_to_type< value_t::local_datetime, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b enum_to_type< value_t::local_time, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b enum_to_type< value_t::offset_datetime, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b enum_to_type< value_t::string, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b enum_to_type< value_t::table, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b exactly}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b exclude}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_from_toml_method}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_from_toml_method_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_into_toml_method}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_into_toml_method_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_iterator}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_iterator_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_key_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_key_type_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_mapped_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_mapped_type_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_push_back_method}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_push_back_method_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_reserve_method}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_reserve_method_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_specialized_from}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_specialized_from_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_specialized_into}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_specialized_into_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_value_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b has_value_type_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b in_range}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b index_sequence}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b index_sequence_maker}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b index_sequence_maker< 0 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_basic_value}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_basic_value< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_basic_value< T const & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_basic_value< T const volatile & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_basic_value< T volatile & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_basic_value<::toml::basic_value< C, M, V > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_chrono_duration}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_chrono_duration< std::chrono::duration< Rep, Period > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_comparable}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_comparable_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_container}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_container< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_container< T const & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_container< T const volatile & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_container< T volatile & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_exact_toml_type}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_exact_toml_type< T &, V >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_exact_toml_type< T const &, V >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_exact_toml_type< T const volatile &, V >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_exact_toml_type< T volatile &, V >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_map}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_map< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_map< T const & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_map< T const volatile & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_map< T volatile & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_std_forward_list}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_std_forward_list< std::forward_list< T > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_std_pair}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_std_pair< std::pair< T1, T2 > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_std_tuple}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_std_tuple< std::tuple< Ts... > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b is_string_literal}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b last_one_in_pack}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b last_one_in_pack< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b location}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b maybe}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b negation}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b none_t}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b push_back_index_sequence}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b push_back_index_sequence< index_sequence< Ns... >, N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b region}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b region_base}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b remove_cvref}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b repeat}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b repeat< T, at_least< N > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b repeat< T, exactly< N > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b repeat< T, unlimited >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sequence}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sequence< Head >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b sequence< Head, Tail... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b storage}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b switch_cast}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b type_to_enum}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b type_to_enum< boolean, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b type_to_enum< floating, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b type_to_enum< integer, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b type_to_enum< local_date, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b type_to_enum< local_datetime, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b type_to_enum< local_time, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b type_to_enum< offset_datetime, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b type_to_enum< string, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b unlimited}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_wschar} = {\b either}< {\b character}<' '>, {\b character}<'\\t'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_ws} = {\b repeat}< {\b lex_wschar}, {\b at_least}< 1 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_newline} = {\b either}< {\b character}<'\\n'>, {\b sequence}< {\b character}<'\\r'>, {\b character}<'\\n'> > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_lower} = {\b in_range}< 'a', 'z'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_upper} = {\b in_range}< 'A', 'Z'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_alpha} = {\b either}< {\b lex_lower}, {\b lex_upper} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_digit} = {\b in_range}< '0', '9'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_nonzero} = {\b in_range}< '1', '9'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_oct_dig} = {\b in_range}< '0', '7'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_bin_dig} = {\b in_range}< '0', '1'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_hex_dig} = {\b either}< {\b lex_digit}, {\b in_range}< 'A', 'F'>, {\b in_range}< 'a', 'f'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_hex_prefix} = {\b sequence}< {\b character}< '0'>, {\b character}< 'x'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_oct_prefix} = {\b sequence}< {\b character}< '0'>, {\b character}< 'o'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_bin_prefix} = {\b sequence}< {\b character}< '0'>, {\b character}< 'b'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_underscore} = {\b character}< '_'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_plus} = {\b character}<'+'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_minus} = {\b character}<'-'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_sign} = {\b either}< {\b lex_plus}, {\b lex_minus} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_unsigned_dec_int} = {\b either}< {\b sequence}< {\b lex_nonzero}, {\b repeat}< {\b either}< {\b lex_digit}, {\b sequence}< {\b lex_underscore}, {\b lex_digit} > >, {\b at_least}< 1 > > >, {\b lex_digit} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_dec_int} = {\b sequence}< {\b maybe}< {\b lex_sign} >, {\b lex_unsigned_dec_int} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_hex_int} = {\b sequence}< {\b lex_hex_prefix}, {\b sequence}< {\b lex_hex_dig}, {\b repeat}< {\b either}< {\b lex_hex_dig}, {\b sequence}< {\b lex_underscore}, {\b lex_hex_dig} > >, {\b unlimited} > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_oct_int} = {\b sequence}< {\b lex_oct_prefix}, {\b sequence}< {\b lex_oct_dig}, {\b repeat}< {\b either}< {\b lex_oct_dig}, {\b sequence}< {\b lex_underscore}, {\b lex_oct_dig} > >, {\b unlimited} > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_bin_int} = {\b sequence}< {\b lex_bin_prefix}, {\b sequence}< {\b lex_bin_dig}, {\b repeat}< {\b either}< {\b lex_bin_dig}, {\b sequence}< {\b lex_underscore}, {\b lex_bin_dig} > >, {\b unlimited} > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_integer} = {\b either}< {\b lex_bin_int}, {\b lex_oct_int}, {\b lex_hex_int}, {\b lex_dec_int} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_inf} = {\b sequence}< {\b character}< 'i'>, {\b character}< 'n'>, {\b character}< 'f'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_nan} = {\b sequence}< {\b character}< 'n'>, {\b character}< 'a'>, {\b character}< 'n'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_special_float} = {\b sequence}< {\b maybe}< {\b lex_sign} >, {\b either}< {\b lex_inf}, {\b lex_nan} > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_zero_prefixable_int} = {\b sequence}< {\b lex_digit}, {\b repeat}< {\b either}< {\b lex_digit}, {\b sequence}< {\b lex_underscore}, {\b lex_digit} > >, {\b unlimited} > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_fractional_part} = {\b sequence}< {\b character}<'.'>, {\b lex_zero_prefixable_int} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_exponent_part} = {\b sequence}< {\b either}< {\b character}< 'e'>, {\b character}< 'E'> >, {\b maybe}< {\b lex_sign} >, {\b lex_zero_prefixable_int} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_float} = {\b either}< {\b lex_special_float}, {\b sequence}< {\b lex_dec_int}, {\b either}< {\b lex_exponent_part}, {\b sequence}< {\b lex_fractional_part}, {\b maybe}< {\b lex_exponent_part} > > > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_true} = {\b sequence}< {\b character}< 't'>, {\b character}< 'r'>, {\b character}< 'u'>, {\b character}< 'e'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_false} = {\b sequence}< {\b character}< 'f'>, {\b character}< 'a'>, {\b character}< 'l'>, {\b character}< 's'>, {\b character}< 'e'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_boolean} = {\b either}< {\b lex_true}, {\b lex_false} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_date_fullyear} = {\b repeat}< {\b lex_digit}, {\b exactly}< 4 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_date_month} = {\b repeat}< {\b lex_digit}, {\b exactly}< 2 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_date_mday} = {\b repeat}< {\b lex_digit}, {\b exactly}< 2 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_time_delim} = {\b either}< {\b character}< 'T'>, {\b character}< 't'>, {\b character}<' '> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_time_hour} = {\b repeat}< {\b lex_digit}, {\b exactly}< 2 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_time_minute} = {\b repeat}< {\b lex_digit}, {\b exactly}< 2 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_time_second} = {\b repeat}< {\b lex_digit}, {\b exactly}< 2 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_time_secfrac} = {\b sequence}< {\b character}<'.'>, {\b repeat}< {\b lex_digit}, {\b at_least}< 1 > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_time_numoffset} = {\b sequence}< {\b either}< {\b character}<'+'>, {\b character}<'-'> >, {\b sequence}< {\b lex_time_hour}, {\b character}<':'>, {\b lex_time_minute} > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_time_offset} = {\b either}< {\b character}< 'Z'>, {\b character}< 'z'>, {\b lex_time_numoffset} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_partial_time} = {\b sequence}< {\b lex_time_hour}, {\b character}<':'>, {\b lex_time_minute}, {\b character}<':'>, {\b lex_time_second}, {\b maybe}< {\b lex_time_secfrac} > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_full_date} = {\b sequence}< {\b lex_date_fullyear}, {\b character}<'-'>, {\b lex_date_month}, {\b character}<'-'>, {\b lex_date_mday} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_full_time} = {\b sequence}< {\b lex_partial_time}, {\b lex_time_offset} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_offset_date_time} = {\b sequence}< {\b lex_full_date}, {\b lex_time_delim}, {\b lex_full_time} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_local_date_time} = {\b sequence}< {\b lex_full_date}, {\b lex_time_delim}, {\b lex_partial_time} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_local_date} = {\b lex_full_date}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_local_time} = {\b lex_partial_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_quotation_mark} = {\b character}<'"'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_basic_unescaped} = {\b exclude}< {\b either}< {\b in_range}< 0x00, 0x08 >, {\b in_range}< 0x0A, 0x1F >, {\b character}< 0x22 >, {\b character}< 0x5C >, {\b character}< 0x7F > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_escape} = {\b character}<'\\\\'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_escape_unicode_short} = {\b sequence}< {\b character}< 'u'>, {\b repeat}< {\b lex_hex_dig}, {\b exactly}< 4 > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_escape_unicode_long} = {\b sequence}< {\b character}< 'U'>, {\b repeat}< {\b lex_hex_dig}, {\b exactly}< 8 > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_escape_seq_char} = {\b either}< {\b character}<'"'>, character<'\\\\'>, {\b character}<'b'>, {\b character}<'f'>, {\b character}<'n'>, {\b character}<'r'>, {\b character}<'t'>, {\b lex_escape_unicode_short}, {\b lex_escape_unicode_long} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_escaped} = {\b sequence}< {\b lex_escape}, {\b lex_escape_seq_char} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_basic_char} = {\b either}< {\b lex_basic_unescaped}, {\b lex_escaped} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_basic_string} = {\b sequence}< {\b lex_quotation_mark}, {\b repeat}< {\b lex_basic_char}, {\b unlimited} >, {\b lex_quotation_mark} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_ml_basic_string_delim} = {\b repeat}< {\b lex_quotation_mark}, {\b exactly}< 3 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_ml_basic_string_open} = {\b lex_ml_basic_string_delim}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_ml_basic_string_close} = {\b sequence}< {\b repeat}< {\b lex_quotation_mark}, {\b exactly}< 3 > >, {\b maybe}< {\b lex_quotation_mark} >, {\b maybe}< {\b lex_quotation_mark} > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_ml_basic_unescaped} = {\b exclude}< {\b either}< {\b in_range}< 0x00, 0x08 >, {\b in_range}< 0x0A, 0x1F >, {\b character}< 0x5C >, {\b character}< 0x7F >, {\b lex_ml_basic_string_delim} > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_ml_basic_escaped_newline} = {\b sequence}< {\b lex_escape}, {\b maybe}< {\b lex_ws} >, {\b lex_newline}, {\b repeat}< {\b either}< {\b lex_ws}, {\b lex_newline} >, {\b unlimited} > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_ml_basic_char} = {\b either}< {\b lex_ml_basic_unescaped}, {\b lex_escaped} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_ml_basic_body} = {\b repeat}< {\b either}< {\b lex_ml_basic_char}, {\b lex_newline}, {\b lex_ml_basic_escaped_newline} >, {\b unlimited} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_ml_basic_string} = {\b sequence}< {\b lex_ml_basic_string_open}, {\b lex_ml_basic_body}, {\b lex_ml_basic_string_close} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_literal_char} = {\b exclude}< {\b either}< {\b in_range}< 0x00, 0x08 >, {\b in_range}< 0x0A, 0x1F >, {\b character}< 0x7F >, {\b character}< 0x27 > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_apostrophe} = {\b character}<'\\''>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_literal_string} = {\b sequence}< {\b lex_apostrophe}, {\b repeat}< {\b lex_literal_char}, {\b unlimited} >, {\b lex_apostrophe} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_ml_literal_string_delim} = {\b repeat}< {\b lex_apostrophe}, {\b exactly}< 3 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_ml_literal_string_open} = {\b lex_ml_literal_string_delim}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_ml_literal_string_close} = {\b sequence}< {\b repeat}< {\b lex_apostrophe}, {\b exactly}< 3 > >, {\b maybe}< {\b lex_apostrophe} >, {\b maybe}< {\b lex_apostrophe} > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_ml_literal_char} = {\b exclude}< {\b either}< {\b in_range}< 0x00, 0x08 >, {\b in_range}< 0x0A, 0x1F >, {\b character}< 0x7F >, {\b lex_ml_literal_string_delim} > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_ml_literal_body} = {\b repeat}< {\b either}< {\b lex_ml_literal_char}, {\b lex_newline} >, {\b unlimited} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_ml_literal_string} = {\b sequence}< {\b lex_ml_literal_string_open}, {\b lex_ml_literal_body}, {\b lex_ml_literal_string_close} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_string} = {\b either}< {\b lex_ml_basic_string}, {\b lex_basic_string}, {\b lex_ml_literal_string}, {\b lex_literal_string} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_dot_sep} = {\b sequence}< {\b maybe}< {\b lex_ws} >, {\b character}<'.'>, {\b maybe}< {\b lex_ws} > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_unquoted_key} = {\b repeat}< {\b either}< {\b lex_alpha}, {\b lex_digit}, {\b character}<'-'>, {\b character}< '_'> >, {\b at_least}< 1 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_quoted_key} = {\b either}< {\b lex_basic_string}, {\b lex_literal_string} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_simple_key} = {\b either}< {\b lex_unquoted_key}, {\b lex_quoted_key} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_dotted_key} = {\b sequence}< {\b lex_simple_key}, {\b repeat}< {\b sequence}< {\b lex_dot_sep}, {\b lex_simple_key} >, {\b at_least}< 1 > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_key} = {\b either}< {\b lex_dotted_key}, {\b lex_simple_key} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_keyval_sep} = {\b sequence}< {\b maybe}< {\b lex_ws} >, {\b character}<'='>, {\b maybe}< {\b lex_ws} > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_std_table_open} = {\b character}<'['>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_std_table_close} = {\b character}<']'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_std_table} = {\b sequence}< {\b lex_std_table_open}, {\b maybe}< {\b lex_ws} >, {\b lex_key}, {\b maybe}< {\b lex_ws} >, {\b lex_std_table_close} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_array_table_open} = {\b sequence}< {\b lex_std_table_open}, {\b lex_std_table_open} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_array_table_close} = {\b sequence}< {\b lex_std_table_close}, {\b lex_std_table_close} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_array_table} = {\b sequence}< {\b lex_array_table_open}, {\b maybe}< {\b lex_ws} >, {\b lex_key}, {\b maybe}< {\b lex_ws} >, {\b lex_array_table_close} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_utf8_1byte} = {\b in_range}< 0x00, 0x7F >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_utf8_2byte} = {\b sequence}< {\b in_range}< static_cast< char >(0xC2), static_cast< char >(0xDF)>, {\b in_range}< static_cast< char >(0x80), static_cast< char >(0xBF)> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_utf8_3byte} = {\b sequence}< {\b either}< {\b sequence}< {\b character}< static_cast< char >(0xE0)>, {\b in_range}< static_cast< char >(0xA0), static_cast< char >(0xBF)> >, {\b sequence}< {\b in_range}< static_cast< char >(0xE1), static_cast< char >(0xEC)>, {\b in_range}< static_cast< char >(0x80), static_cast< char >(0xBF)> >, {\b sequence}< {\b character}< static_cast< char >(0xED)>, {\b in_range}< static_cast< char >(0x80), static_cast< char >(0x9F)> >, {\b sequence}< {\b in_range}< static_cast< char >(0xEE), static_cast< char >(0xEF)>, {\b in_range}< static_cast< char >(0x80), static_cast< char >(0xBF)> > >, {\b in_range}< static_cast< char >(0x80), static_cast< char >(0xBF)> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_utf8_4byte} = {\b sequence}< {\b either}< {\b sequence}< {\b character}< static_cast< char >(0xF0)>, {\b in_range}< static_cast< char >(0x90), static_cast< char >(0xBF)> >, {\b sequence}< {\b in_range}< static_cast< char >(0xF1), static_cast< char >(0xF3)>, {\b in_range}< static_cast< char >(0x80), static_cast< char >(0xBF)> >, {\b sequence}< {\b character}< static_cast< char >(0xF4)>, {\b in_range}< static_cast< char >(0x80), static_cast< char >(0x8F)> > >, {\b in_range}< static_cast< char >(0x80), static_cast< char >(0xBF)>, {\b in_range}< static_cast< char >(0x80), static_cast< char >(0xBF)> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_utf8_code} = {\b either}< {\b lex_utf8_1byte}, {\b lex_utf8_2byte}, {\b lex_utf8_3byte}, {\b lex_utf8_4byte} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_comment_start_symbol} = {\b character}<'#'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_non_eol_ascii} = {\b either}< {\b character}< 0x09 >, {\b in_range}< 0x20, 0x7E > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b lex_comment} = {\b sequence}< {\b lex_comment_start_symbol}, {\b repeat}< {\b either}< {\b lex_non_eol_ascii}, {\b lex_utf8_2byte}, {\b lex_utf8_3byte}, {\b lex_utf8_4byte} >, {\b unlimited} > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t N> using {\b make_index_sequence} = typename {\b index_sequence_maker}< N-1 >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<bool B, typename T > using {\b enable_if_t} = typename std::enable_if< B, T >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F , typename ... Args> using {\b return_type_of_t} = typename std::result_of< F(Args...)>::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b remove_cvref_t} = typename {\b remove_cvref}< T >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b value_t} V> using {\b value_t_constant} = std::integral_constant< {\b value_t}, V >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ts> using {\b last_one_in_pack_t} = typename {\b last_one_in_pack}< Ts... >::type\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b show_char} (const char c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> bool {\b operator==} (const {\b empty_iterator}< T, C > &, const {\b empty_iterator}< T, C > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> bool {\b operator!=} (const {\b empty_iterator}< T, C > &, const {\b empty_iterator}< T, C > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> bool {\b operator<} (const {\b empty_iterator}< T, C > &, const {\b empty_iterator}< T, C > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> bool {\b operator<=} (const {\b empty_iterator}< T, C > &, const {\b empty_iterator}< T, C > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> bool {\b operator>} (const {\b empty_iterator}< T, C > &, const {\b empty_iterator}< T, C > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> bool {\b operator>=} (const {\b empty_iterator}< T, C > &, const {\b empty_iterator}< T, C > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> {\b empty_iterator}< T, C >::difference_type {\b operator-} (const {\b empty_iterator}< T, C > &, const {\b empty_iterator}< T, C > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> {\b empty_iterator}< T, C > {\b operator+} (typename {\b empty_iterator}< T, C >::difference_type, const {\b empty_iterator}< T, C > &rhs) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> {\b empty_iterator}< T, C > {\b operator+} (const {\b empty_iterator}< T, C > &lhs, typename {\b empty_iterator}< T, C >::difference_type) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::tm {\b localtime_s} (const std::time_t *src)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::tm {\b gmtime_s} (const std::time_t *src)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Array , std::size_t ... I> T {\b get_tuple_impl} (const Array &a, {\b index_sequence}< I... >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b enable_if_t}< {\b conjunction}< std::is_integral< {\b remove_cvref_t}< T > >, {\b negation}< std::is_same< {\b remove_cvref_t}< T >, bool > > >{\b ::value}, std::size_t > {\b key_cast} (T &&v) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > {\b enable_if_t}< {\b negation}< {\b conjunction}< std::is_integral< {\b remove_cvref_t}< T > >, {\b negation}< std::is_same< {\b remove_cvref_t}< T >, bool > > > >{\b ::value}, std::string > {\b key_cast} (T &&v) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b boolean}, {\b region} >, std::string > {\b parse_boolean} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b integer}, {\b region} >, std::string > {\b parse_binary_integer} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b integer}, {\b region} >, std::string > {\b parse_octal_integer} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b integer}, {\b region} >, std::string > {\b parse_hexadecimal_integer} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b integer}, {\b region} >, std::string > {\b parse_integer} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b floating}, {\b region} >, std::string > {\b parse_floating} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b read_utf8_codepoint} (const {\b region} &reg, const {\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::string, std::string > {\b parse_escape_sequence} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ptrdiff_t {\b check_utf8_validity} (const std::string &reg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b toml::string}, {\b region} >, std::string > {\b parse_ml_basic_string} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b toml::string}, {\b region} >, std::string > {\b parse_basic_string} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b toml::string}, {\b region} >, std::string > {\b parse_ml_literal_string} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b toml::string}, {\b region} >, std::string > {\b parse_literal_string} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b toml::string}, {\b region} >, std::string > {\b parse_string} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b local_date}, {\b region} >, std::string > {\b parse_local_date} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b local_time}, {\b region} >, std::string > {\b parse_local_time} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b local_datetime}, {\b region} >, std::string > {\b parse_local_datetime} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b offset_datetime}, {\b region} >, std::string > {\b parse_offset_datetime} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< {\b key}, {\b region} >, std::string > {\b parse_simple_key} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< std::vector< {\b key} >, {\b region} >, std::string > {\b parse_key} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > {\b result}< Value, std::string > {\b parse_value} ({\b location} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > {\b result}< std::pair< typename Value::array_type, {\b region} >, std::string > {\b parse_array} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > {\b result}< std::pair< std::pair< std::vector< {\b key} >, {\b region} >, Value >, std::string > {\b parse_key_value_pair} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator > std::string {\b format_dotted_keys} (InputIterator first, const InputIterator last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< std::vector< {\b key} >, {\b region} >, std::string > {\b parse_table_key} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > {\b result}< std::pair< typename Value::table_type, {\b region} >, std::string > {\b parse_inline_table} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value , typename Iterator > bool {\b is_valid_forward_table_definition} (const Value &fwd, const Value &inserting, Iterator key_first, Iterator key_curr, Iterator key_last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value , typename InputIterator > {\b result}< bool, std::string > {\b insert_nested_key} (typename Value::table_type &root, const Value &v, InputIterator iter, const InputIterator last, {\b region} key_reg, const bool is_array_of_table=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< {\b value_t}, std::string > {\b guess_number_type} (const {\b location} &l)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< {\b value_t}, std::string > {\b guess_value_type} (const {\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value , typename T > {\b result}< Value, std::string > {\b parse_value_helper} ({\b result}< std::pair< T, {\b region} >, std::string > rslt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result}< std::pair< std::vector< {\b key} >, {\b region} >, std::string > {\b parse_array_table_key} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > {\b result}< typename Value::table_type, std::string > {\b parse_ml_table} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > {\b result}< Value, std::string > {\b parse_toml_file} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Iterator > std::string {\b make_string} (Iterator first, Iterator last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b make_string} (std::size_t len, char c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b none_t} &, const {\b none_t} &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b none_t} &, const {\b none_t} &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b none_t} &, const {\b none_t} &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b none_t} &, const {\b none_t} &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b none_t} &, const {\b none_t} &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b none_t} &, const {\b none_t} &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traitsT > std::basic_ostream< charT, traitsT > & {\b operator<<} (std::basic_ostream< charT, traitsT > &os, const {\b none_t} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b failure}< {\b none_t} > {\b none} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > int {\b comment_index} (std::basic_ostream< charT, traits > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b format_underline} (const std::string &message, const std::vector< std::pair< {\b source_location}, std::string > > &loc_com, const std::vector< std::string > &helps=\{\}, const bool colorize={\b TOML11_ERROR_MESSAGE_COLORIZED})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Container > void {\b try_reserve_impl} (Container &container, std::size_t N, std::true_type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Container > void {\b try_reserve_impl} (Container &, std::size_t, std::false_type) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b concat_to_string_impl} (std::ostringstream &oss)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename ... Ts> std::string {\b concat_to_string_impl} (std::ostringstream &oss, T &&head, Ts &&... tail)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > T && {\b last_one} (T &&tail) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename ... Ts> {\b enable_if_t}<(sizeof...(Ts) > 0), {\b last_one_in_pack_t}< Ts &&... > > {\b last_one} (T &&, Ts &&... tail)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > {\b region_base} const * {\b get_region} (const Value &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > void {\b change_region} (Value &v, {\b region} reg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b value_t} Expected, typename Value > void {\b throw_bad_cast} (const std::string &funcname, {\b value_t} actual, const Value &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > void {\b throw_key_not_found_error} (const Value &v, const {\b key} &ky)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v enable_if_t\:toml::detail}
{\xe \v toml::detail\:enable_if_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<bool B, typename T > using {\b toml::detail::enable_if_t} = typedef typename std::enable_if<B, T>::type}}
\par
{\bkmkstart AAAAAAABQA}
{\bkmkend AAAAAAABQA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v last_one_in_pack_t\:toml::detail}
{\xe \v toml::detail\:last_one_in_pack_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ... Ts> using {\b toml::detail::last_one_in_pack_t} = typedef typename {\b last_one_in_pack}<Ts...>::type}}
\par
{\bkmkstart AAAAAAABQB}
{\bkmkend AAAAAAABQB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_alpha\:toml::detail}
{\xe \v toml::detail\:lex_alpha}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_alpha} = typedef {\b either}<{\b lex_lower}, {\b lex_upper}>}}
\par
{\bkmkstart AAAAAAABQC}
{\bkmkend AAAAAAABQC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_apostrophe\:toml::detail}
{\xe \v toml::detail\:lex_apostrophe}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_apostrophe} = typedef {\b character}<'\\''>}}
\par
{\bkmkstart AAAAAAABQD}
{\bkmkend AAAAAAABQD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_array_table\:toml::detail}
{\xe \v toml::detail\:lex_array_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_array_table} = typedef {\b sequence}<{\b lex_array_table_open}, {\b maybe}<{\b lex_ws}>, {\b lex_key}, {\b maybe}<{\b lex_ws}>, {\b lex_array_table_close}>}}
\par
{\bkmkstart AAAAAAABQE}
{\bkmkend AAAAAAABQE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_array_table_close\:toml::detail}
{\xe \v toml::detail\:lex_array_table_close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_array_table_close} = typedef {\b sequence}<{\b lex_std_table_close}, {\b lex_std_table_close}>}}
\par
{\bkmkstart AAAAAAABQF}
{\bkmkend AAAAAAABQF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_array_table_open\:toml::detail}
{\xe \v toml::detail\:lex_array_table_open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_array_table_open} = typedef {\b sequence}<{\b lex_std_table_open}, {\b lex_std_table_open}>}}
\par
{\bkmkstart AAAAAAABQG}
{\bkmkend AAAAAAABQG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_basic_char\:toml::detail}
{\xe \v toml::detail\:lex_basic_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_basic_char} = typedef {\b either}<{\b lex_basic_unescaped}, {\b lex_escaped}>}}
\par
{\bkmkstart AAAAAAABQH}
{\bkmkend AAAAAAABQH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_basic_string\:toml::detail}
{\xe \v toml::detail\:lex_basic_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_basic_string} = typedef {\b sequence}<{\b lex_quotation_mark}, {\b repeat}<{\b lex_basic_char}, {\b unlimited}>, {\b lex_quotation_mark}>}}
\par
{\bkmkstart AAAAAAABQI}
{\bkmkend AAAAAAABQI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_basic_unescaped\:toml::detail}
{\xe \v toml::detail\:lex_basic_unescaped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_basic_unescaped} = typedef {\b exclude}<{\b either}<{\b in_range}<0x00, 0x08>, {\b in_range}<0x0A, 0x1F>, {\b character}<0x22>, {\b character}<0x5C>, {\b character}<0x7F> >>}}
\par
{\bkmkstart AAAAAAABQJ}
{\bkmkend AAAAAAABQJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_bin_dig\:toml::detail}
{\xe \v toml::detail\:lex_bin_dig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_bin_dig} = typedef {\b in_range}<'0', '1'>}}
\par
{\bkmkstart AAAAAAABQK}
{\bkmkend AAAAAAABQK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_bin_int\:toml::detail}
{\xe \v toml::detail\:lex_bin_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_bin_int} = typedef {\b sequence}<{\b lex_bin_prefix}, {\b sequence}<{\b lex_bin_dig}, {\b repeat}< {\b either}<{\b lex_bin_dig}, {\b sequence}<{\b lex_underscore}, {\b lex_bin_dig}> >, {\b unlimited}> >>}}
\par
{\bkmkstart AAAAAAABQL}
{\bkmkend AAAAAAABQL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_bin_prefix\:toml::detail}
{\xe \v toml::detail\:lex_bin_prefix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_bin_prefix} = typedef {\b sequence}<{\b character}<'0'>, {\b character}<'b'> >}}
\par
{\bkmkstart AAAAAAABQM}
{\bkmkend AAAAAAABQM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_boolean\:toml::detail}
{\xe \v toml::detail\:lex_boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_boolean} = typedef {\b either}<{\b lex_true}, {\b lex_false}>}}
\par
{\bkmkstart AAAAAAABQN}
{\bkmkend AAAAAAABQN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_comment\:toml::detail}
{\xe \v toml::detail\:lex_comment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_comment} = typedef {\b sequence}<{\b lex_comment_start_symbol}, {\b repeat}<{\b either}< {\b lex_non_eol_ascii}, {\b lex_utf8_2byte}, {\b lex_utf8_3byte}, {\b lex_utf8_4byte}>, {\b unlimited}> >}}
\par
{\bkmkstart AAAAAAABQO}
{\bkmkend AAAAAAABQO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_comment_start_symbol\:toml::detail}
{\xe \v toml::detail\:lex_comment_start_symbol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_comment_start_symbol} = typedef {\b character}<'#'>}}
\par
{\bkmkstart AAAAAAABQP}
{\bkmkend AAAAAAABQP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_date_fullyear\:toml::detail}
{\xe \v toml::detail\:lex_date_fullyear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_date_fullyear} = typedef {\b repeat}<{\b lex_digit}, {\b exactly}<4> >}}
\par
{\bkmkstart AAAAAAABQQ}
{\bkmkend AAAAAAABQQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_date_mday\:toml::detail}
{\xe \v toml::detail\:lex_date_mday}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_date_mday} = typedef {\b repeat}<{\b lex_digit}, {\b exactly}<2> >}}
\par
{\bkmkstart AAAAAAABQR}
{\bkmkend AAAAAAABQR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_date_month\:toml::detail}
{\xe \v toml::detail\:lex_date_month}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_date_month} = typedef {\b repeat}<{\b lex_digit}, {\b exactly}<2> >}}
\par
{\bkmkstart AAAAAAABQS}
{\bkmkend AAAAAAABQS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_dec_int\:toml::detail}
{\xe \v toml::detail\:lex_dec_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_dec_int} = typedef {\b sequence}<{\b maybe}<{\b lex_sign}>, {\b lex_unsigned_dec_int}>}}
\par
{\bkmkstart AAAAAAABQT}
{\bkmkend AAAAAAABQT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_digit\:toml::detail}
{\xe \v toml::detail\:lex_digit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_digit} = typedef {\b in_range}<'0', '9'>}}
\par
{\bkmkstart AAAAAAABQU}
{\bkmkend AAAAAAABQU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_dot_sep\:toml::detail}
{\xe \v toml::detail\:lex_dot_sep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_dot_sep} = typedef {\b sequence}<{\b maybe}<{\b lex_ws}>, {\b character}<'.'>, {\b maybe}<{\b lex_ws}> >}}
\par
{\bkmkstart AAAAAAABQV}
{\bkmkend AAAAAAABQV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_dotted_key\:toml::detail}
{\xe \v toml::detail\:lex_dotted_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_dotted_key} = typedef {\b sequence}<{\b lex_simple_key}, {\b repeat}<{\b sequence}<{\b lex_dot_sep}, {\b lex_simple_key}>, {\b at_least}<1> > >}}
\par
{\bkmkstart AAAAAAABQW}
{\bkmkend AAAAAAABQW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_escape\:toml::detail}
{\xe \v toml::detail\:lex_escape}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_escape} = typedef {\b character}<'\\\\'>}}
\par
{\bkmkstart AAAAAAABQX}
{\bkmkend AAAAAAABQX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_escape_seq_char\:toml::detail}
{\xe \v toml::detail\:lex_escape_seq_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_escape_seq_char} = typedef {\b either}<{\b character}<'"'>, character<'\\\\'>, {\b character}<'b'>, {\b character}<'f'>, {\b character}<'n'>, {\b character}<'r'>, {\b character}<'t'>, {\b lex_escape_unicode_short}, {\b lex_escape_unicode_long} >}}
\par
{\bkmkstart AAAAAAABQY}
{\bkmkend AAAAAAABQY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_escape_unicode_long\:toml::detail}
{\xe \v toml::detail\:lex_escape_unicode_long}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_escape_unicode_long} = typedef {\b sequence}<{\b character}<'U'>, {\b repeat}<{\b lex_hex_dig}, {\b exactly}<8> >>}}
\par
{\bkmkstart AAAAAAABQZ}
{\bkmkend AAAAAAABQZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_escape_unicode_short\:toml::detail}
{\xe \v toml::detail\:lex_escape_unicode_short}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_escape_unicode_short} = typedef {\b sequence}<{\b character}<'u'>, {\b repeat}<{\b lex_hex_dig}, {\b exactly}<4> >>}}
\par
{\bkmkstart AAAAAAABRA}
{\bkmkend AAAAAAABRA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_escaped\:toml::detail}
{\xe \v toml::detail\:lex_escaped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_escaped} = typedef {\b sequence}<{\b lex_escape}, {\b lex_escape_seq_char}>}}
\par
{\bkmkstart AAAAAAABRB}
{\bkmkend AAAAAAABRB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_exponent_part\:toml::detail}
{\xe \v toml::detail\:lex_exponent_part}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_exponent_part} = typedef {\b sequence}<{\b either}<{\b character}<'e'>, {\b character}<'E'> >, {\b maybe}<{\b lex_sign}>, {\b lex_zero_prefixable_int}>}}
\par
{\bkmkstart AAAAAAABRC}
{\bkmkend AAAAAAABRC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_false\:toml::detail}
{\xe \v toml::detail\:lex_false}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_false} = typedef {\b sequence}<{\b character}<'f'>, {\b character}<'a'>, {\b character}<'l'>, {\b character}<'s'>, {\b character}<'e'> >}}
\par
{\bkmkstart AAAAAAABRD}
{\bkmkend AAAAAAABRD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_float\:toml::detail}
{\xe \v toml::detail\:lex_float}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_float} = typedef {\b either}<{\b lex_special_float}, {\b sequence}<{\b lex_dec_int}, {\b either}<{\b lex_exponent_part}, {\b sequence}<{\b lex_fractional_part}, {\b maybe}<{\b lex_exponent_part}> >> >>}}
\par
{\bkmkstart AAAAAAABRE}
{\bkmkend AAAAAAABRE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_fractional_part\:toml::detail}
{\xe \v toml::detail\:lex_fractional_part}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_fractional_part} = typedef {\b sequence}<{\b character}<'.'>, {\b lex_zero_prefixable_int}>}}
\par
{\bkmkstart AAAAAAABRF}
{\bkmkend AAAAAAABRF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_full_date\:toml::detail}
{\xe \v toml::detail\:lex_full_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_full_date} = typedef {\b sequence}<{\b lex_date_fullyear}, {\b character}<'-'>, {\b lex_date_month}, {\b character}<'-'>, {\b lex_date_mday}>}}
\par
{\bkmkstart AAAAAAABRG}
{\bkmkend AAAAAAABRG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_full_time\:toml::detail}
{\xe \v toml::detail\:lex_full_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_full_time} = typedef {\b sequence}<{\b lex_partial_time}, {\b lex_time_offset}>}}
\par
{\bkmkstart AAAAAAABRH}
{\bkmkend AAAAAAABRH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_hex_dig\:toml::detail}
{\xe \v toml::detail\:lex_hex_dig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_hex_dig} = typedef {\b either}<{\b lex_digit}, {\b in_range}<'A', 'F'>, {\b in_range}<'a', 'f'> >}}
\par
{\bkmkstart AAAAAAABRI}
{\bkmkend AAAAAAABRI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_hex_int\:toml::detail}
{\xe \v toml::detail\:lex_hex_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_hex_int} = typedef {\b sequence}<{\b lex_hex_prefix}, {\b sequence}<{\b lex_hex_dig}, {\b repeat}< {\b either}<{\b lex_hex_dig}, {\b sequence}<{\b lex_underscore}, {\b lex_hex_dig}> >, {\b unlimited}> >>}}
\par
{\bkmkstart AAAAAAABRJ}
{\bkmkend AAAAAAABRJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_hex_prefix\:toml::detail}
{\xe \v toml::detail\:lex_hex_prefix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_hex_prefix} = typedef {\b sequence}<{\b character}<'0'>, {\b character}<'x'> >}}
\par
{\bkmkstart AAAAAAABRK}
{\bkmkend AAAAAAABRK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_inf\:toml::detail}
{\xe \v toml::detail\:lex_inf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_inf} = typedef {\b sequence}<{\b character}<'i'>, {\b character}<'n'>, {\b character}<'f'> >}}
\par
{\bkmkstart AAAAAAABRL}
{\bkmkend AAAAAAABRL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_integer\:toml::detail}
{\xe \v toml::detail\:lex_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_integer} = typedef {\b either}<{\b lex_bin_int}, {\b lex_oct_int}, {\b lex_hex_int}, {\b lex_dec_int}>}}
\par
{\bkmkstart AAAAAAABRM}
{\bkmkend AAAAAAABRM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_key\:toml::detail}
{\xe \v toml::detail\:lex_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_key} = typedef {\b either}<{\b lex_dotted_key}, {\b lex_simple_key}>}}
\par
{\bkmkstart AAAAAAABRN}
{\bkmkend AAAAAAABRN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_keyval_sep\:toml::detail}
{\xe \v toml::detail\:lex_keyval_sep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_keyval_sep} = typedef {\b sequence}<{\b maybe}<{\b lex_ws}>, {\b character}<'='>, {\b maybe}<{\b lex_ws}> >}}
\par
{\bkmkstart AAAAAAABRO}
{\bkmkend AAAAAAABRO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_literal_char\:toml::detail}
{\xe \v toml::detail\:lex_literal_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_literal_char} = typedef {\b exclude}<{\b either}<{\b in_range}<0x00, 0x08>, {\b in_range}<0x0A, 0x1F>, {\b character}<0x7F>, {\b character}<0x27> >>}}
\par
{\bkmkstart AAAAAAABRP}
{\bkmkend AAAAAAABRP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_literal_string\:toml::detail}
{\xe \v toml::detail\:lex_literal_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_literal_string} = typedef {\b sequence}<{\b lex_apostrophe}, {\b repeat}<{\b lex_literal_char}, {\b unlimited}>, {\b lex_apostrophe}>}}
\par
{\bkmkstart AAAAAAABRQ}
{\bkmkend AAAAAAABRQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_local_date\:toml::detail}
{\xe \v toml::detail\:lex_local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_local_date} = typedef {\b lex_full_date}}}
\par
{\bkmkstart AAAAAAABRR}
{\bkmkend AAAAAAABRR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_local_date_time\:toml::detail}
{\xe \v toml::detail\:lex_local_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_local_date_time} = typedef {\b sequence}<{\b lex_full_date}, {\b lex_time_delim}, {\b lex_partial_time}>}}
\par
{\bkmkstart AAAAAAABRS}
{\bkmkend AAAAAAABRS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_local_time\:toml::detail}
{\xe \v toml::detail\:lex_local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_local_time} = typedef {\b lex_partial_time}}}
\par
{\bkmkstart AAAAAAABRT}
{\bkmkend AAAAAAABRT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_lower\:toml::detail}
{\xe \v toml::detail\:lex_lower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_lower} = typedef {\b in_range}<'a', 'z'>}}
\par
{\bkmkstart AAAAAAABRU}
{\bkmkend AAAAAAABRU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_minus\:toml::detail}
{\xe \v toml::detail\:lex_minus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_minus} = typedef {\b character}<'-'>}}
\par
{\bkmkstart AAAAAAABRV}
{\bkmkend AAAAAAABRV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_ml_basic_body\:toml::detail}
{\xe \v toml::detail\:lex_ml_basic_body}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_ml_basic_body} = typedef {\b repeat}<{\b either}<{\b lex_ml_basic_char}, {\b lex_newline}, {\b lex_ml_basic_escaped_newline}>, {\b unlimited}>}}
\par
{\bkmkstart AAAAAAABRW}
{\bkmkend AAAAAAABRW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_ml_basic_char\:toml::detail}
{\xe \v toml::detail\:lex_ml_basic_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_ml_basic_char} = typedef {\b either}<{\b lex_ml_basic_unescaped}, {\b lex_escaped}>}}
\par
{\bkmkstart AAAAAAABRX}
{\bkmkend AAAAAAABRX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_ml_basic_escaped_newline\:toml::detail}
{\xe \v toml::detail\:lex_ml_basic_escaped_newline}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_ml_basic_escaped_newline} = typedef {\b sequence}< {\b lex_escape}, {\b maybe}<{\b lex_ws}>, {\b lex_newline}, {\b repeat}<{\b either}<{\b lex_ws}, {\b lex_newline}>, {\b unlimited}> >}}
\par
{\bkmkstart AAAAAAABRY}
{\bkmkend AAAAAAABRY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_ml_basic_string\:toml::detail}
{\xe \v toml::detail\:lex_ml_basic_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_ml_basic_string} = typedef {\b sequence}<{\b lex_ml_basic_string_open}, {\b lex_ml_basic_body}, {\b lex_ml_basic_string_close}>}}
\par
{\bkmkstart AAAAAAABRZ}
{\bkmkend AAAAAAABRZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_ml_basic_string_close\:toml::detail}
{\xe \v toml::detail\:lex_ml_basic_string_close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_ml_basic_string_close} = typedef {\b sequence}< {\b repeat}<{\b lex_quotation_mark}, {\b exactly}<3> >, {\b maybe}<{\b lex_quotation_mark}>, {\b maybe}<{\b lex_quotation_mark}> >}}
\par
{\bkmkstart AAAAAAABSA}
{\bkmkend AAAAAAABSA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_ml_basic_string_delim\:toml::detail}
{\xe \v toml::detail\:lex_ml_basic_string_delim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_ml_basic_string_delim} = typedef {\b repeat}<{\b lex_quotation_mark}, {\b exactly}<3> >}}
\par
{\bkmkstart AAAAAAABSB}
{\bkmkend AAAAAAABSB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_ml_basic_string_open\:toml::detail}
{\xe \v toml::detail\:lex_ml_basic_string_open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_ml_basic_string_open} = typedef {\b lex_ml_basic_string_delim}}}
\par
{\bkmkstart AAAAAAABSC}
{\bkmkend AAAAAAABSC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_ml_basic_unescaped\:toml::detail}
{\xe \v toml::detail\:lex_ml_basic_unescaped}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_ml_basic_unescaped} = typedef {\b exclude}<{\b either}<{\b in_range}<0x00, 0x08>, {\b in_range}<0x0A, 0x1F>, {\b character}<0x5C>, {\b character}<0x7F>, {\b lex_ml_basic_string_delim}> >}}
\par
{\bkmkstart AAAAAAABSD}
{\bkmkend AAAAAAABSD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_ml_literal_body\:toml::detail}
{\xe \v toml::detail\:lex_ml_literal_body}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_ml_literal_body} = typedef {\b repeat}<{\b either}<{\b lex_ml_literal_char}, {\b lex_newline}>, {\b unlimited}>}}
\par
{\bkmkstart AAAAAAABSE}
{\bkmkend AAAAAAABSE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_ml_literal_char\:toml::detail}
{\xe \v toml::detail\:lex_ml_literal_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_ml_literal_char} = typedef {\b exclude}<{\b either}<{\b in_range}<0x00, 0x08>, {\b in_range}<0x0A, 0x1F>, {\b character}<0x7F>, {\b lex_ml_literal_string_delim}> >}}
\par
{\bkmkstart AAAAAAABSF}
{\bkmkend AAAAAAABSF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_ml_literal_string\:toml::detail}
{\xe \v toml::detail\:lex_ml_literal_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_ml_literal_string} = typedef {\b sequence}<{\b lex_ml_literal_string_open}, {\b lex_ml_literal_body}, {\b lex_ml_literal_string_close}>}}
\par
{\bkmkstart AAAAAAABSG}
{\bkmkend AAAAAAABSG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_ml_literal_string_close\:toml::detail}
{\xe \v toml::detail\:lex_ml_literal_string_close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_ml_literal_string_close} = typedef {\b sequence}< {\b repeat}<{\b lex_apostrophe}, {\b exactly}<3> >, {\b maybe}<{\b lex_apostrophe}>, {\b maybe}<{\b lex_apostrophe}> >}}
\par
{\bkmkstart AAAAAAABSH}
{\bkmkend AAAAAAABSH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_ml_literal_string_delim\:toml::detail}
{\xe \v toml::detail\:lex_ml_literal_string_delim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_ml_literal_string_delim} = typedef {\b repeat}<{\b lex_apostrophe}, {\b exactly}<3> >}}
\par
{\bkmkstart AAAAAAABSI}
{\bkmkend AAAAAAABSI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_ml_literal_string_open\:toml::detail}
{\xe \v toml::detail\:lex_ml_literal_string_open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_ml_literal_string_open} = typedef {\b lex_ml_literal_string_delim}}}
\par
{\bkmkstart AAAAAAABSJ}
{\bkmkend AAAAAAABSJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_nan\:toml::detail}
{\xe \v toml::detail\:lex_nan}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_nan} = typedef {\b sequence}<{\b character}<'n'>, {\b character}<'a'>, {\b character}<'n'> >}}
\par
{\bkmkstart AAAAAAABSK}
{\bkmkend AAAAAAABSK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_newline\:toml::detail}
{\xe \v toml::detail\:lex_newline}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_newline} = typedef {\b either}<{\b character}<'\\n'>, {\b sequence}<{\b character}<'\\r'>, {\b character}<'\\n'> >>}}
\par
{\bkmkstart AAAAAAABSL}
{\bkmkend AAAAAAABSL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_non_eol_ascii\:toml::detail}
{\xe \v toml::detail\:lex_non_eol_ascii}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_non_eol_ascii} = typedef {\b either}<{\b character}<0x09>, {\b in_range}<0x20, 0x7E> >}}
\par
{\bkmkstart AAAAAAABSM}
{\bkmkend AAAAAAABSM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_nonzero\:toml::detail}
{\xe \v toml::detail\:lex_nonzero}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_nonzero} = typedef {\b in_range}<'1', '9'>}}
\par
{\bkmkstart AAAAAAABSN}
{\bkmkend AAAAAAABSN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_oct_dig\:toml::detail}
{\xe \v toml::detail\:lex_oct_dig}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_oct_dig} = typedef {\b in_range}<'0', '7'>}}
\par
{\bkmkstart AAAAAAABSO}
{\bkmkend AAAAAAABSO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_oct_int\:toml::detail}
{\xe \v toml::detail\:lex_oct_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_oct_int} = typedef {\b sequence}<{\b lex_oct_prefix}, {\b sequence}<{\b lex_oct_dig}, {\b repeat}< {\b either}<{\b lex_oct_dig}, {\b sequence}<{\b lex_underscore}, {\b lex_oct_dig}> >, {\b unlimited}> >>}}
\par
{\bkmkstart AAAAAAABSP}
{\bkmkend AAAAAAABSP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_oct_prefix\:toml::detail}
{\xe \v toml::detail\:lex_oct_prefix}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_oct_prefix} = typedef {\b sequence}<{\b character}<'0'>, {\b character}<'o'> >}}
\par
{\bkmkstart AAAAAAABSQ}
{\bkmkend AAAAAAABSQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_offset_date_time\:toml::detail}
{\xe \v toml::detail\:lex_offset_date_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_offset_date_time} = typedef {\b sequence}<{\b lex_full_date}, {\b lex_time_delim}, {\b lex_full_time}>}}
\par
{\bkmkstart AAAAAAABSR}
{\bkmkend AAAAAAABSR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_partial_time\:toml::detail}
{\xe \v toml::detail\:lex_partial_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_partial_time} = typedef {\b sequence}<{\b lex_time_hour}, {\b character}<':'>, {\b lex_time_minute}, {\b character}<':'>, {\b lex_time_second}, {\b maybe}<{\b lex_time_secfrac}> >}}
\par
{\bkmkstart AAAAAAABSS}
{\bkmkend AAAAAAABSS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_plus\:toml::detail}
{\xe \v toml::detail\:lex_plus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_plus} = typedef {\b character}<'+'>}}
\par
{\bkmkstart AAAAAAABST}
{\bkmkend AAAAAAABST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_quotation_mark\:toml::detail}
{\xe \v toml::detail\:lex_quotation_mark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_quotation_mark} = typedef {\b character}<'"'>}}
\par
{\bkmkstart AAAAAAABSU}
{\bkmkend AAAAAAABSU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_quoted_key\:toml::detail}
{\xe \v toml::detail\:lex_quoted_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_quoted_key} = typedef {\b either}<{\b lex_basic_string}, {\b lex_literal_string}>}}
\par
{\bkmkstart AAAAAAABSV}
{\bkmkend AAAAAAABSV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_sign\:toml::detail}
{\xe \v toml::detail\:lex_sign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_sign} = typedef {\b either}<{\b lex_plus}, {\b lex_minus}>}}
\par
{\bkmkstart AAAAAAABSW}
{\bkmkend AAAAAAABSW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_simple_key\:toml::detail}
{\xe \v toml::detail\:lex_simple_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_simple_key} = typedef {\b either}<{\b lex_unquoted_key}, {\b lex_quoted_key}>}}
\par
{\bkmkstart AAAAAAABSX}
{\bkmkend AAAAAAABSX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_special_float\:toml::detail}
{\xe \v toml::detail\:lex_special_float}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_special_float} = typedef {\b sequence}<{\b maybe}<{\b lex_sign}>, {\b either}<{\b lex_inf}, {\b lex_nan}> >}}
\par
{\bkmkstart AAAAAAABSY}
{\bkmkend AAAAAAABSY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_std_table\:toml::detail}
{\xe \v toml::detail\:lex_std_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_std_table} = typedef {\b sequence}<{\b lex_std_table_open}, {\b maybe}<{\b lex_ws}>, {\b lex_key}, {\b maybe}<{\b lex_ws}>, {\b lex_std_table_close}>}}
\par
{\bkmkstart AAAAAAABSZ}
{\bkmkend AAAAAAABSZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_std_table_close\:toml::detail}
{\xe \v toml::detail\:lex_std_table_close}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_std_table_close} = typedef {\b character}<']'>}}
\par
{\bkmkstart AAAAAAABTA}
{\bkmkend AAAAAAABTA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_std_table_open\:toml::detail}
{\xe \v toml::detail\:lex_std_table_open}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_std_table_open} = typedef {\b character}<'['>}}
\par
{\bkmkstart AAAAAAABTB}
{\bkmkend AAAAAAABTB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_string\:toml::detail}
{\xe \v toml::detail\:lex_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_string} = typedef {\b either}<{\b lex_ml_basic_string}, {\b lex_basic_string}, {\b lex_ml_literal_string}, {\b lex_literal_string}>}}
\par
{\bkmkstart AAAAAAABTC}
{\bkmkend AAAAAAABTC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_time_delim\:toml::detail}
{\xe \v toml::detail\:lex_time_delim}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_time_delim} = typedef {\b either}<{\b character}<'T'>, {\b character}<'t'>, {\b character}<' '> >}}
\par
{\bkmkstart AAAAAAABTD}
{\bkmkend AAAAAAABTD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_time_hour\:toml::detail}
{\xe \v toml::detail\:lex_time_hour}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_time_hour} = typedef {\b repeat}<{\b lex_digit}, {\b exactly}<2> >}}
\par
{\bkmkstart AAAAAAABTE}
{\bkmkend AAAAAAABTE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_time_minute\:toml::detail}
{\xe \v toml::detail\:lex_time_minute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_time_minute} = typedef {\b repeat}<{\b lex_digit}, {\b exactly}<2> >}}
\par
{\bkmkstart AAAAAAABTF}
{\bkmkend AAAAAAABTF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_time_numoffset\:toml::detail}
{\xe \v toml::detail\:lex_time_numoffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_time_numoffset} = typedef {\b sequence}<{\b either}<{\b character}<'+'>, {\b character}<'-'> >, {\b sequence}<{\b lex_time_hour}, {\b character}<':'>, {\b lex_time_minute}> >}}
\par
{\bkmkstart AAAAAAABTG}
{\bkmkend AAAAAAABTG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_time_offset\:toml::detail}
{\xe \v toml::detail\:lex_time_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_time_offset} = typedef {\b either}<{\b character}<'Z'>, {\b character}<'z'>, {\b lex_time_numoffset}>}}
\par
{\bkmkstart AAAAAAABTH}
{\bkmkend AAAAAAABTH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_time_secfrac\:toml::detail}
{\xe \v toml::detail\:lex_time_secfrac}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_time_secfrac} = typedef {\b sequence}<{\b character}<'.'>, {\b repeat}<{\b lex_digit}, {\b at_least}<1> >>}}
\par
{\bkmkstart AAAAAAABTI}
{\bkmkend AAAAAAABTI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_time_second\:toml::detail}
{\xe \v toml::detail\:lex_time_second}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_time_second} = typedef {\b repeat}<{\b lex_digit}, {\b exactly}<2> >}}
\par
{\bkmkstart AAAAAAABTJ}
{\bkmkend AAAAAAABTJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_true\:toml::detail}
{\xe \v toml::detail\:lex_true}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_true} = typedef {\b sequence}<{\b character}<'t'>, {\b character}<'r'>, {\b character}<'u'>, {\b character}<'e'> >}}
\par
{\bkmkstart AAAAAAABTK}
{\bkmkend AAAAAAABTK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_underscore\:toml::detail}
{\xe \v toml::detail\:lex_underscore}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_underscore} = typedef {\b character}<'_'>}}
\par
{\bkmkstart AAAAAAABTL}
{\bkmkend AAAAAAABTL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_unquoted_key\:toml::detail}
{\xe \v toml::detail\:lex_unquoted_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_unquoted_key} = typedef {\b repeat}<{\b either}<{\b lex_alpha}, {\b lex_digit}, {\b character}<'-'>, {\b character}<'_'> >, {\b at_least}<1> >}}
\par
{\bkmkstart AAAAAAABTM}
{\bkmkend AAAAAAABTM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_unsigned_dec_int\:toml::detail}
{\xe \v toml::detail\:lex_unsigned_dec_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_unsigned_dec_int} = typedef {\b either}<{\b sequence}<{\b lex_nonzero}, {\b repeat}< {\b either}<{\b lex_digit}, {\b sequence}<{\b lex_underscore}, {\b lex_digit}> >, {\b at_least}<1> >>, {\b lex_digit}>}}
\par
{\bkmkstart AAAAAAABTN}
{\bkmkend AAAAAAABTN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_upper\:toml::detail}
{\xe \v toml::detail\:lex_upper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_upper} = typedef {\b in_range}<'A', 'Z'>}}
\par
{\bkmkstart AAAAAAABTO}
{\bkmkend AAAAAAABTO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_utf8_1byte\:toml::detail}
{\xe \v toml::detail\:lex_utf8_1byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_utf8_1byte} = typedef {\b in_range}<0x00, 0x7F>}}
\par
{\bkmkstart AAAAAAABTP}
{\bkmkend AAAAAAABTP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_utf8_2byte\:toml::detail}
{\xe \v toml::detail\:lex_utf8_2byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_utf8_2byte} = typedef {\b sequence}< {\b in_range}<static_cast<char>(0xC2), static_cast<char>(0xDF)>, {\b in_range}<static_cast<char>(0x80), static_cast<char>(0xBF)> >}}
\par
{\bkmkstart AAAAAAABTQ}
{\bkmkend AAAAAAABTQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_utf8_3byte\:toml::detail}
{\xe \v toml::detail\:lex_utf8_3byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_utf8_3byte} = typedef {\b sequence}<{\b either}< {\b sequence}<{\b character}<static_cast<char>(0xE0)>, {\b in_range}<static_cast<char>(0xA0), static_cast<char>(0xBF)> >, {\b sequence}<{\b in_range} <static_cast<char>(0xE1), static_cast<char>(0xEC)>, {\b in_range}<static_cast<char>(0x80), static_cast<char>(0xBF)> >, {\b sequence}<{\b character}<static_cast<char>(0xED)>, {\b in_range}<static_cast<char>(0x80), static_cast<char>(0x9F)> >, {\b sequence}<{\b in_range} <static_cast<char>(0xEE), static_cast<char>(0xEF)>, {\b in_range}<static_cast<char>(0x80), static_cast<char>(0xBF)> > >, {\b in_range}<static_cast<char>(0x80), static_cast<char>(0xBF)> >}}
\par
{\bkmkstart AAAAAAABTR}
{\bkmkend AAAAAAABTR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_utf8_4byte\:toml::detail}
{\xe \v toml::detail\:lex_utf8_4byte}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_utf8_4byte} = typedef {\b sequence}<{\b either}< {\b sequence}<{\b character}<static_cast<char>(0xF0)>, {\b in_range}<static_cast<char>(0x90), static_cast<char>(0xBF)> >, {\b sequence}<{\b in_range} <static_cast<char>(0xF1), static_cast<char>(0xF3)>, {\b in_range}<static_cast<char>(0x80), static_cast<char>(0xBF)> >, {\b sequence}<{\b character}<static_cast<char>(0xF4)>, {\b in_range}<static_cast<char>(0x80), static_cast<char>(0x8F)> > >, {\b in_range}<static_cast<char>(0x80), static_cast<char>(0xBF)>, {\b in_range}<static_cast<char>(0x80), static_cast<char>(0xBF)> >}}
\par
{\bkmkstart AAAAAAABTS}
{\bkmkend AAAAAAABTS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_utf8_code\:toml::detail}
{\xe \v toml::detail\:lex_utf8_code}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_utf8_code} = typedef {\b either}< {\b lex_utf8_1byte}, {\b lex_utf8_2byte}, {\b lex_utf8_3byte}, {\b lex_utf8_4byte} >}}
\par
{\bkmkstart AAAAAAABTT}
{\bkmkend AAAAAAABTT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_ws\:toml::detail}
{\xe \v toml::detail\:lex_ws}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_ws} = typedef {\b repeat}<{\b lex_wschar}, {\b at_least}<1> >}}
\par
{\bkmkstart AAAAAAABTU}
{\bkmkend AAAAAAABTU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_wschar\:toml::detail}
{\xe \v toml::detail\:lex_wschar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_wschar} = typedef {\b either}<{\b character}<' '>, {\b character}<'\\t'> >}}
\par
{\bkmkstart AAAAAAABTV}
{\bkmkend AAAAAAABTV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v lex_zero_prefixable_int\:toml::detail}
{\xe \v toml::detail\:lex_zero_prefixable_int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::lex_zero_prefixable_int} = typedef {\b sequence}<{\b lex_digit}, {\b repeat}<{\b either}<{\b lex_digit}, {\b sequence}<{\b lex_underscore}, {\b lex_digit}> >, {\b unlimited}> >}}
\par
{\bkmkstart AAAAAAABTW}
{\bkmkend AAAAAAABTW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v make_index_sequence\:toml::detail}
{\xe \v toml::detail\:make_index_sequence}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::size_t N> using {\b toml::detail::make_index_sequence} = typedef typename {\b index_sequence_maker}<N-1>::type}}
\par
{\bkmkstart AAAAAAABTX}
{\bkmkend AAAAAAABTX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v remove_cvref_t\:toml::detail}
{\xe \v toml::detail\:remove_cvref_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b toml::detail::remove_cvref_t} = typedef typename {\b remove_cvref}<T>::type}}
\par
{\bkmkstart AAAAAAABTY}
{\bkmkend AAAAAAABTY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v return_type_of_t\:toml::detail}
{\xe \v toml::detail\:return_type_of_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename F , typename ... Args> using {\b toml::detail::return_type_of_t} = typedef typename std::result_of<F(Args...)>::type}}
\par
{\bkmkstart AAAAAAABTZ}
{\bkmkend AAAAAAABTZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value_t_constant\:toml::detail}
{\xe \v toml::detail\:value_t_constant}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b value_t} V> using {\b toml::detail::value_t_constant} = typedef std::integral_constant<{\b value_t}, V>}}
\par
{\bkmkstart AAAAAAABUA}
{\bkmkend AAAAAAABUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v change_region\:toml::detail}
{\xe \v toml::detail\:change_region}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > void toml::detail::change_region (Value &  {\i v}, {\b region}  {\i reg})}}
\par
{\bkmkstart AAAAAAABUB}
{\bkmkend AAAAAAABUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v check_utf8_validity\:toml::detail}
{\xe \v toml::detail\:check_utf8_validity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::ptrdiff_t toml::detail::check_utf8_validity (const std::string &  {\i reg}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUC}
{\bkmkend AAAAAAABUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v comment_index\:toml::detail}
{\xe \v toml::detail\:comment_index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traits > int toml::detail::comment_index (std::basic_ostream< charT, traits > & )}}
\par
{\bkmkstart AAAAAAABUD}
{\bkmkend AAAAAAABUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v concat_to_string_impl\:toml::detail}
{\xe \v toml::detail\:concat_to_string_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::detail::concat_to_string_impl (std::ostringstream &  {\i oss}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUE}
{\bkmkend AAAAAAABUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v concat_to_string_impl\:toml::detail}
{\xe \v toml::detail\:concat_to_string_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename ... Ts> std::string toml::detail::concat_to_string_impl (std::ostringstream &  {\i oss}, T &&  {\i head}, Ts &&...  {\i tail})}}
\par
{\bkmkstart AAAAAAABUF}
{\bkmkend AAAAAAABUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v format_dotted_keys\:toml::detail}
{\xe \v toml::detail\:format_dotted_keys}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename InputIterator > std::string toml::detail::format_dotted_keys (InputIterator  {\i first}, const InputIterator  {\i last})}}
\par
{\bkmkstart AAAAAAABUG}
{\bkmkend AAAAAAABUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v format_underline\:toml::detail}
{\xe \v toml::detail\:format_underline}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::detail::format_underline (const std::string &  {\i message}, const std::vector< std::pair< {\b source_location}, std::string > > &  {\i loc_com}, const std::vector< std::string > &  {\i helps} = {\f2 \{\}}, const bool  {\i colorize} = {\f2 {\b TOML11_ERROR_MESSAGE_COLORIZED}}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUH}
{\bkmkend AAAAAAABUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_region\:toml::detail}
{\xe \v toml::detail\:get_region}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > {\b region_base} const  * toml::detail::get_region (const Value &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUI}
{\bkmkend AAAAAAABUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v get_tuple_impl\:toml::detail}
{\xe \v toml::detail\:get_tuple_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename Array , std::size_t ... I> T toml::detail::get_tuple_impl (const Array &  {\i a}, {\b index_sequence}< I... > )}}
\par
{\bkmkstart AAAAAAABUJ}
{\bkmkend AAAAAAABUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v gmtime_s\:toml::detail}
{\xe \v toml::detail\:gmtime_s}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::tm toml::detail::gmtime_s (const std::time_t *  {\i src}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUK}
{\bkmkend AAAAAAABUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v guess_number_type\:toml::detail}
{\xe \v toml::detail\:guess_number_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< {\b value_t}, std::string > toml::detail::guess_number_type (const {\b location} &  {\i l}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUL}
{\bkmkend AAAAAAABUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v guess_value_type\:toml::detail}
{\xe \v toml::detail\:guess_value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< {\b value_t}, std::string > toml::detail::guess_value_type (const {\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUM}
{\bkmkend AAAAAAABUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v insert_nested_key\:toml::detail}
{\xe \v toml::detail\:insert_nested_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value , typename InputIterator > {\b result}< bool, std::string > toml::detail::insert_nested_key (typename Value::table_type &  {\i root}, const Value &  {\i v}, InputIterator  {\i iter}, const InputIterator  {\i last}, {\b region}  {\i key_reg}, const bool  {\i is_array_of_table} = {\f2 false})}}
\par
{\bkmkstart AAAAAAABUN}
{\bkmkend AAAAAAABUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is_valid_forward_table_definition\:toml::detail}
{\xe \v toml::detail\:is_valid_forward_table_definition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value , typename Iterator > bool toml::detail::is_valid_forward_table_definition (const Value &  {\i fwd}, const Value &  {\i inserting}, Iterator  {\i key_first}, Iterator  {\i key_curr}, Iterator  {\i key_last})}}
\par
{\bkmkstart AAAAAAABUO}
{\bkmkend AAAAAAABUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v key_cast\:toml::detail}
{\xe \v toml::detail\:key_cast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b enable_if_t}< {\b conjunction}< std::is_integral< {\b remove_cvref_t}< T > >, {\b negation}< std::is_same< {\b remove_cvref_t}< T >, bool > > >{\b ::value}, std::size_t > toml::detail::key_cast (T &&  {\i v}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABUP}
{\bkmkend AAAAAAABUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v key_cast\:toml::detail}
{\xe \v toml::detail\:key_cast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b enable_if_t}< {\b negation}< {\b conjunction}< std::is_integral< {\b remove_cvref_t}< T > >, {\b negation}< std::is_same< {\b remove_cvref_t}< T >, bool > > > >{\b ::value}, std::string > toml::detail::key_cast (T &&  {\i v}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABUQ}
{\bkmkend AAAAAAABUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v last_one\:toml::detail}
{\xe \v toml::detail\:last_one}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename ... Ts> {\b enable_if_t}<(sizeof...(Ts) > 0), {\b last_one_in_pack_t}< Ts &&... > > toml::detail::last_one (T && , Ts &&...  {\i tail})}}
\par
{\bkmkstart AAAAAAABUR}
{\bkmkend AAAAAAABUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v last_one\:toml::detail}
{\xe \v toml::detail\:last_one}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T && toml::detail::last_one (T &&  {\i tail}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABUS}
{\bkmkend AAAAAAABUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v localtime_s\:toml::detail}
{\xe \v toml::detail\:localtime_s}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::tm toml::detail::localtime_s (const std::time_t *  {\i src}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUT}
{\bkmkend AAAAAAABUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v make_string\:toml::detail}
{\xe \v toml::detail\:make_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Iterator > std::string toml::detail::make_string (Iterator  {\i first}, Iterator  {\i last})}}
\par
{\bkmkstart AAAAAAABUU}
{\bkmkend AAAAAAABUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v make_string\:toml::detail}
{\xe \v toml::detail\:make_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::detail::make_string (std::size_t  {\i len}, char  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABUV}
{\bkmkend AAAAAAABUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v none\:toml::detail}
{\xe \v toml::detail\:none}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b failure}< {\b none_t} > toml::detail::none (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABUW}
{\bkmkend AAAAAAABUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:toml::detail}
{\xe \v toml::detail\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool C> bool toml::detail::operator!= (const {\b empty_iterator}< T, C > & , const {\b empty_iterator}< T, C > & ){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABUX}
{\bkmkend AAAAAAABUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator!=\:toml::detail}
{\xe \v toml::detail\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::detail::operator!= (const {\b none_t} & , const {\b none_t} & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABUY}
{\bkmkend AAAAAAABUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator+\:toml::detail}
{\xe \v toml::detail\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool C> {\b empty_iterator}< T, C > toml::detail::operator+ (const {\b empty_iterator}< T, C > &  {\i lhs}, typename {\b empty_iterator}< T, C >::difference_type ){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABUZ}
{\bkmkend AAAAAAABUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator+\:toml::detail}
{\xe \v toml::detail\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool C> {\b empty_iterator}< T, C > toml::detail::operator+ (typename {\b empty_iterator}< T, C >::difference_type , const {\b empty_iterator}< T, C > &  {\i rhs}){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVA}
{\bkmkend AAAAAAABVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator-\:toml::detail}
{\xe \v toml::detail\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool C> {\b empty_iterator}< T, C >::difference_type toml::detail::operator- (const {\b empty_iterator}< T, C > & , const {\b empty_iterator}< T, C > & ){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVB}
{\bkmkend AAAAAAABVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml::detail}
{\xe \v toml::detail\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool C> bool toml::detail::operator< (const {\b empty_iterator}< T, C > & , const {\b empty_iterator}< T, C > & ){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVC}
{\bkmkend AAAAAAABVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml::detail}
{\xe \v toml::detail\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::detail::operator< (const {\b none_t} & , const {\b none_t} & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVD}
{\bkmkend AAAAAAABVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<<\:toml::detail}
{\xe \v toml::detail\:operator<<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename charT , typename traitsT > std::basic_ostream< charT, traitsT > & toml::detail::operator<< (std::basic_ostream< charT, traitsT > &  {\i os}, const {\b none_t} & )}}
\par
{\bkmkstart AAAAAAABVE}
{\bkmkend AAAAAAABVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml::detail}
{\xe \v toml::detail\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool C> bool toml::detail::operator<= (const {\b empty_iterator}< T, C > & , const {\b empty_iterator}< T, C > & ){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVF}
{\bkmkend AAAAAAABVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml::detail}
{\xe \v toml::detail\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::detail::operator<= (const {\b none_t} & , const {\b none_t} & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVG}
{\bkmkend AAAAAAABVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml::detail}
{\xe \v toml::detail\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool C> bool toml::detail::operator== (const {\b empty_iterator}< T, C > & , const {\b empty_iterator}< T, C > & ){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVH}
{\bkmkend AAAAAAABVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml::detail}
{\xe \v toml::detail\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::detail::operator== (const {\b none_t} & , const {\b none_t} & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVI}
{\bkmkend AAAAAAABVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml::detail}
{\xe \v toml::detail\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool C> bool toml::detail::operator> (const {\b empty_iterator}< T, C > & , const {\b empty_iterator}< T, C > & ){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVJ}
{\bkmkend AAAAAAABVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml::detail}
{\xe \v toml::detail\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::detail::operator> (const {\b none_t} & , const {\b none_t} & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVK}
{\bkmkend AAAAAAABVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml::detail}
{\xe \v toml::detail\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool C> bool toml::detail::operator>= (const {\b empty_iterator}< T, C > & , const {\b empty_iterator}< T, C > & ){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVL}
{\bkmkend AAAAAAABVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml::detail}
{\xe \v toml::detail\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::detail::operator>= (const {\b none_t} & , const {\b none_t} & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABVM}
{\bkmkend AAAAAAABVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_array\:toml::detail}
{\xe \v toml::detail\:parse_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > {\b result}< std::pair< typename Value::array_type, {\b region} >, std::string > toml::detail::parse_array ({\b location} &  {\i loc})}}
\par
{\bkmkstart AAAAAAABVN}
{\bkmkend AAAAAAABVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_array_table_key\:toml::detail}
{\xe \v toml::detail\:parse_array_table_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< std::vector< {\b key} >, {\b region} >, std::string > toml::detail::parse_array_table_key ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVO}
{\bkmkend AAAAAAABVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_basic_string\:toml::detail}
{\xe \v toml::detail\:parse_basic_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b toml::string}, {\b region} >, std::string > toml::detail::parse_basic_string ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVP}
{\bkmkend AAAAAAABVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_binary_integer\:toml::detail}
{\xe \v toml::detail\:parse_binary_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b integer}, {\b region} >, std::string > toml::detail::parse_binary_integer ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVQ}
{\bkmkend AAAAAAABVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_boolean\:toml::detail}
{\xe \v toml::detail\:parse_boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b boolean}, {\b region} >, std::string > toml::detail::parse_boolean ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVR}
{\bkmkend AAAAAAABVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_escape_sequence\:toml::detail}
{\xe \v toml::detail\:parse_escape_sequence}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::string, std::string > toml::detail::parse_escape_sequence ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVS}
{\bkmkend AAAAAAABVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_floating\:toml::detail}
{\xe \v toml::detail\:parse_floating}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b floating}, {\b region} >, std::string > toml::detail::parse_floating ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVT}
{\bkmkend AAAAAAABVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_hexadecimal_integer\:toml::detail}
{\xe \v toml::detail\:parse_hexadecimal_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b integer}, {\b region} >, std::string > toml::detail::parse_hexadecimal_integer ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVU}
{\bkmkend AAAAAAABVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_inline_table\:toml::detail}
{\xe \v toml::detail\:parse_inline_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > {\b result}< std::pair< typename Value::table_type, {\b region} >, std::string > toml::detail::parse_inline_table ({\b location} &  {\i loc})}}
\par
{\bkmkstart AAAAAAABVV}
{\bkmkend AAAAAAABVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_integer\:toml::detail}
{\xe \v toml::detail\:parse_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b integer}, {\b region} >, std::string > toml::detail::parse_integer ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVW}
{\bkmkend AAAAAAABVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_key\:toml::detail}
{\xe \v toml::detail\:parse_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< std::vector< {\b key} >, {\b region} >, std::string > toml::detail::parse_key ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVX}
{\bkmkend AAAAAAABVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_key_value_pair\:toml::detail}
{\xe \v toml::detail\:parse_key_value_pair}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > {\b result}< std::pair< std::pair< std::vector< {\b key} >, {\b region} >, Value >, std::string > toml::detail::parse_key_value_pair ({\b location} &  {\i loc})}}
\par
{\bkmkstart AAAAAAABVY}
{\bkmkend AAAAAAABVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_literal_string\:toml::detail}
{\xe \v toml::detail\:parse_literal_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b toml::string}, {\b region} >, std::string > toml::detail::parse_literal_string ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABVZ}
{\bkmkend AAAAAAABVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_local_date\:toml::detail}
{\xe \v toml::detail\:parse_local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b local_date}, {\b region} >, std::string > toml::detail::parse_local_date ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWA}
{\bkmkend AAAAAAABWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_local_datetime\:toml::detail}
{\xe \v toml::detail\:parse_local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b local_datetime}, {\b region} >, std::string > toml::detail::parse_local_datetime ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWB}
{\bkmkend AAAAAAABWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_local_time\:toml::detail}
{\xe \v toml::detail\:parse_local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b local_time}, {\b region} >, std::string > toml::detail::parse_local_time ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWC}
{\bkmkend AAAAAAABWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_ml_basic_string\:toml::detail}
{\xe \v toml::detail\:parse_ml_basic_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b toml::string}, {\b region} >, std::string > toml::detail::parse_ml_basic_string ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWD}
{\bkmkend AAAAAAABWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_ml_literal_string\:toml::detail}
{\xe \v toml::detail\:parse_ml_literal_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b toml::string}, {\b region} >, std::string > toml::detail::parse_ml_literal_string ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWE}
{\bkmkend AAAAAAABWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_ml_table\:toml::detail}
{\xe \v toml::detail\:parse_ml_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > {\b result}< typename Value::table_type, std::string > toml::detail::parse_ml_table ({\b location} &  {\i loc})}}
\par
{\bkmkstart AAAAAAABWF}
{\bkmkend AAAAAAABWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_octal_integer\:toml::detail}
{\xe \v toml::detail\:parse_octal_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b integer}, {\b region} >, std::string > toml::detail::parse_octal_integer ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWG}
{\bkmkend AAAAAAABWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_offset_datetime\:toml::detail}
{\xe \v toml::detail\:parse_offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b offset_datetime}, {\b region} >, std::string > toml::detail::parse_offset_datetime ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWH}
{\bkmkend AAAAAAABWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_simple_key\:toml::detail}
{\xe \v toml::detail\:parse_simple_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b key}, {\b region} >, std::string > toml::detail::parse_simple_key ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWI}
{\bkmkend AAAAAAABWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_string\:toml::detail}
{\xe \v toml::detail\:parse_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< {\b toml::string}, {\b region} >, std::string > toml::detail::parse_string ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWJ}
{\bkmkend AAAAAAABWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_table_key\:toml::detail}
{\xe \v toml::detail\:parse_table_key}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b result}< std::pair< std::vector< {\b key} >, {\b region} >, std::string > toml::detail::parse_table_key ({\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWK}
{\bkmkend AAAAAAABWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_toml_file\:toml::detail}
{\xe \v toml::detail\:parse_toml_file}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > {\b result}< Value, std::string > toml::detail::parse_toml_file ({\b location} &  {\i loc})}}
\par
{\bkmkstart AAAAAAABWL}
{\bkmkend AAAAAAABWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_value\:toml::detail}
{\xe \v toml::detail\:parse_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > {\b result}< Value, std::string > toml::detail::parse_value ({\b location} &  {\i loc})}}
\par
{\bkmkstart AAAAAAABWM}
{\bkmkend AAAAAAABWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v parse_value_helper\:toml::detail}
{\xe \v toml::detail\:parse_value_helper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value , typename T > {\b result}< Value, std::string > toml::detail::parse_value_helper ({\b result}< std::pair< T, {\b region} >, std::string >  {\i rslt})}}
\par
{\bkmkstart AAAAAAABWN}
{\bkmkend AAAAAAABWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v read_utf8_codepoint\:toml::detail}
{\xe \v toml::detail\:read_utf8_codepoint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::detail::read_utf8_codepoint (const {\b region} &  {\i reg}, const {\b location} &  {\i loc}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWO}
{\bkmkend AAAAAAABWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v show_char\:toml::detail}
{\xe \v toml::detail\:show_char}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::detail::show_char (const char  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWP}
{\bkmkend AAAAAAABWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v throw_bad_cast\:toml::detail}
{\xe \v toml::detail\:throw_bad_cast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b value_t} Expected, typename Value > void toml::detail::throw_bad_cast (const std::string &  {\i funcname}, {\b value_t}  {\i actual}, const Value &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABWQ}
{\bkmkend AAAAAAABWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v throw_key_not_found_error\:toml::detail}
{\xe \v toml::detail\:throw_key_not_found_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > void toml::detail::throw_key_not_found_error (const Value &  {\i v}, const {\b key} &  {\i ky})}}
\par
{\bkmkstart AAAAAAABWR}
{\bkmkend AAAAAAABWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v try_reserve_impl\:toml::detail}
{\xe \v toml::detail\:try_reserve_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Container > void toml::detail::try_reserve_impl (Container & , std::size_t , std::false_type ){\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABWS}
{\bkmkend AAAAAAABWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v try_reserve_impl\:toml::detail}
{\xe \v toml::detail\:try_reserve_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Container > void toml::detail::try_reserve_impl (Container &  {\i container}, std::size_t  {\i N}, std::true_type )}}
\par
{\bkmkstart AAAAAAABWT}
{\bkmkend AAAAAAABWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::literals Namespace Reference\par \pard\plain 
{\tc\tcl2 \v toml::literals}
{\xe \v toml::literals}
{\bkmkstart AAAAAAACHM}
{\bkmkend AAAAAAACHM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml_literals}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
inline {\b ::toml::basic_value}< {\b TOML11_DEFAULT_COMMENT_STRATEGY}, std::unordered_map, std::vector > {\b literal_internal_impl} ({\b ::toml::detail::location} loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
inline {\b ::toml::basic_value}< {\b TOML11_DEFAULT_COMMENT_STRATEGY}, std::unordered_map, std::vector > {\b operator""_toml} (const char *str, std::size_t len)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::literals::toml_literals Namespace Reference\par \pard\plain 
{\tc\tcl2 \v toml::literals::toml_literals}
{\xe \v toml::literals::toml_literals}
{\bkmkstart AAAAAAACHN}
{\bkmkend AAAAAAACHN}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
inline {\b ::toml::basic_value}< {\b TOML11_DEFAULT_COMMENT_STRATEGY}, std::unordered_map, std::vector > {\b literal_internal_impl} ({\b ::toml::detail::location} loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
inline {\b ::toml::basic_value}< {\b TOML11_DEFAULT_COMMENT_STRATEGY}, std::unordered_map, std::vector > {\b operator""_toml} (const char *str, std::size_t len)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v literal_internal_impl\:toml::literals::toml_literals}
{\xe \v toml::literals::toml_literals\:literal_internal_impl}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
inline {\b ::toml::basic_value}< {\b TOML11_DEFAULT_COMMENT_STRATEGY}, std::unordered_map, std::vector > toml::literals::toml_literals::literal_internal_impl ({\b ::toml::detail::location}  {\i loc})}}
\par
{\bkmkstart AAAAAAACHO}
{\bkmkend AAAAAAACHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator""_toml\:toml::literals::toml_literals}
{\xe \v toml::literals::toml_literals\:operator""_toml}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
inline {\b ::toml::basic_value}< {\b TOML11_DEFAULT_COMMENT_STRATEGY}, std::unordered_map, std::vector > toml::literals::toml_literals::operator""_toml (const char *  {\i str}, std::size_t  {\i len})}}
\par
{\bkmkstart AAAAAAACHP}
{\bkmkend AAAAAAACHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::at_least< N > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::at_least< N >}
{\xe \v toml::detail::at_least< N >}
{\bkmkstart AAAAAAABWU}
{\bkmkend AAAAAAABWU}
\par
{
{\f2 #include <combinator.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::basic_value< Comment, Table, Array > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >}
{\bkmkstart AAAAAAAARK}
{\bkmkend AAAAAAAARK}
\par
{
{\f2 #include <value.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b comment_type} = Comment\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b key_type} = {\b ::toml::key}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = {\b basic_value}< {\b comment_type}, Table, Array >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b boolean_type} = {\b ::toml::boolean}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b integer_type} = {\b ::toml::integer}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b floating_type} = {\b ::toml::floating}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b string_type} = {\b ::toml::string}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b local_time_type} = {\b ::toml::local_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b local_date_type} = {\b ::toml::local_date}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b local_datetime_type} = {\b ::toml::local_datetime}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b offset_datetime_type} = {\b ::toml::offset_datetime}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b array_type} = Array< {\b value_type} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b table_type} = Table< {\b key_type}, {\b value_type} >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~basic_value} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b basic_value} &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} ({\b basic_value} &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} & {\b operator=} (const {\b basic_value} &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} & {\b operator=} ({\b basic_value} &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b basic_value} &v, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} ({\b basic_value} &&v, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> {\b basic_value} (const {\b basic_value}< C, T, A > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> {\b basic_value} (const {\b basic_value}< C, T, A > &v, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> {\b basic_value} & {\b operator=} (const {\b basic_value}< C, T, A > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} ({\b boolean} b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} & {\b operator=} ({\b boolean} b)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} ({\b boolean} b, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< {\b detail::conjunction}< std::is_integral< T >, {\b detail::negation}< std::is_same< T, {\b boolean} > > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} (T i)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< {\b detail::conjunction}< std::is_integral< T >, {\b detail::negation}< std::is_same< T, {\b boolean} > > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} & {\b operator=} (T i)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< {\b detail::conjunction}< std::is_integral< T >, {\b detail::negation}< std::is_same< T, {\b boolean} > > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} (T i, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< std::is_floating_point< T >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} (T f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< std::is_floating_point< T >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} & {\b operator=} (T f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< std::is_floating_point< T >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} (T f, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} ({\b toml::string} s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} & {\b operator=} ({\b toml::string} s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} ({\b toml::string} s, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (std::string s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} & {\b operator=} (std::string s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (std::string s, {\b string_t} kind)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (std::string s, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (std::string s, {\b string_t} kind, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const char *s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} & {\b operator=} (const char *s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const char *s, {\b string_t} kind)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const char *s, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const char *s, {\b string_t} kind, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b local_date} &ld)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} & {\b operator=} (const {\b local_date} &ld)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b local_date} &ld, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b local_time} &lt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b local_time} &lt, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} & {\b operator=} (const {\b local_time} &lt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Rep , typename Period > {\b basic_value} (const std::chrono::duration< Rep, Period > &dur)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Rep , typename Period > {\b basic_value} (const std::chrono::duration< Rep, Period > &dur, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Rep , typename Period > {\b basic_value} & {\b operator=} (const std::chrono::duration< Rep, Period > &dur)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b local_datetime} &ldt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b local_datetime} &ldt, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} & {\b operator=} (const {\b local_datetime} &ldt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b offset_datetime} &odt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b offset_datetime} &odt, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} & {\b operator=} (const {\b offset_datetime} &odt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const std::chrono::system_clock::time_point &tp)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const std::chrono::system_clock::time_point &tp, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} & {\b operator=} (const std::chrono::system_clock::time_point &tp)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b array_type} &ary)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b array_type} &ary, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} & {\b operator=} (const {\b array_type} &ary)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< std::is_convertible< T, {\b value_type} >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} (std::initializer_list< T > list)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< std::is_convertible< T, {\b value_type} >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} (std::initializer_list< T > list, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< std::is_convertible< T, {\b value_type} >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} & {\b operator=} (std::initializer_list< T > list)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< {\b detail::conjunction}< {\b detail::negation}< std::is_same< T, {\b array_type} > >, {\b detail::is_container}< T > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} (const T &list)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< {\b detail::conjunction}< {\b detail::negation}< std::is_same< T, {\b array_type} > >, {\b detail::is_container}< T > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} (const T &list, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< {\b detail::conjunction}< {\b detail::negation}< std::is_same< T, {\b array_type} > >, {\b detail::is_container}< T > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} & {\b operator=} (const T &list)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b table_type} &tab)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b table_type} &tab, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} & {\b operator=} (const {\b table_type} &tab)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (std::initializer_list< std::pair< {\b key}, {\b basic_value} > > list)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (std::initializer_list< std::pair< {\b key}, {\b basic_value} > > list, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} & {\b operator=} (std::initializer_list< std::pair< {\b key}, {\b basic_value} > > list)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Map , typename std::enable_if< {\b detail::conjunction}< {\b detail::negation}< std::is_same< Map, {\b table_type} > >, {\b detail::is_map}< Map > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} (const Map &mp)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Map , typename std::enable_if< {\b detail::conjunction}< {\b detail::negation}< std::is_same< Map, {\b table_type} > >, {\b detail::is_map}< Map > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} (const Map &mp, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Map , typename std::enable_if< {\b detail::conjunction}< {\b detail::negation}< std::is_same< Map, {\b table_type} > >, {\b detail::is_map}< Map > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} & {\b operator=} (const Map &mp)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< {\b detail::has_into_toml_method}< T >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} (const T &ud)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< {\b detail::has_into_toml_method}< T >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} (const T &ud, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< {\b detail::has_into_toml_method}< T >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} & {\b operator=} (const T &ud)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , std::size_t S = sizeof(::toml::into<T>)> {\b basic_value} (const T &ud)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , std::size_t S = sizeof(::toml::into<T>)> {\b basic_value} (const T &ud, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , std::size_t S = sizeof(::toml::into<T>)> {\b basic_value} & {\b operator=} (const T &ud)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} ({\b boolean} b, {\b detail::region} reg, std::vector< std::string > cm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< {\b detail::conjunction}< std::is_integral< T >, {\b detail::negation}< std::is_same< T, {\b boolean} > > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} (T i, {\b detail::region} reg, std::vector< std::string > cm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< std::is_floating_point< T >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} (T f, {\b detail::region} reg, std::vector< std::string > cm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} ({\b toml::string} s, {\b detail::region} reg, std::vector< std::string > cm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b local_date} &ld, {\b detail::region} reg, std::vector< std::string > cm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b local_time} &lt, {\b detail::region} reg, std::vector< std::string > cm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b local_datetime} &ldt, {\b detail::region} reg, std::vector< std::string > cm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b offset_datetime} &odt, {\b detail::region} reg, std::vector< std::string > cm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b array_type} &ary, {\b detail::region} reg, std::vector< std::string > cm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b basic_value} (const {\b table_type} &tab, {\b detail::region} reg, std::vector< std::string > cm)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< {\b detail::is_exact_toml_type}< T, {\b value_type} >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} (std::pair< T, {\b detail::region} > parse_result, std::vector< std::string > com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename std::enable_if< {\b detail::is_exact_toml_type}< T, {\b value_type} >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> bool {\b is} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is} ({\b value_t} t) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_uninitialized} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_boolean} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_integer} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_floating} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_string} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_offset_datetime} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_local_datetime} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_local_date} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_local_time} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_array} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_table} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_t} {\b type} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b value_t} T> {\b detail::enum_to_type}< T, {\b value_type} >{\b ::type} & {\b cast} () &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b value_t} T> {\b detail::enum_to_type}< T, {\b value_type} >{\b ::type} const & {\b cast} () const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<{\b value_t} T> {\b detail::enum_to_type}< T, {\b value_type} >{\b ::type} && {\b cast} () &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} const & {\b as_boolean} (const std::nothrow_t &) const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b integer} const & {\b as_integer} (const std::nothrow_t &) const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b floating} const & {\b as_floating} (const std::nothrow_t &) const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} const & {\b as_string} (const std::nothrow_t &) const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} const & {\b as_offset_datetime} (const std::nothrow_t &) const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_datetime} const & {\b as_local_datetime} (const std::nothrow_t &) const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} const & {\b as_local_date} (const std::nothrow_t &) const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_time} const & {\b as_local_time} (const std::nothrow_t &) const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b array_type} const & {\b as_array} (const std::nothrow_t &) const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b table_type} const & {\b as_table} (const std::nothrow_t &) const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} & {\b as_boolean} (const std::nothrow_t &) &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b integer} & {\b as_integer} (const std::nothrow_t &) &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b floating} & {\b as_floating} (const std::nothrow_t &) &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} & {\b as_string} (const std::nothrow_t &) &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} & {\b as_offset_datetime} (const std::nothrow_t &) &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_datetime} & {\b as_local_datetime} (const std::nothrow_t &) &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} & {\b as_local_date} (const std::nothrow_t &) &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_time} & {\b as_local_time} (const std::nothrow_t &) &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b array_type} & {\b as_array} (const std::nothrow_t &) &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b table_type} & {\b as_table} (const std::nothrow_t &) &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} && {\b as_boolean} (const std::nothrow_t &) &&noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b integer} && {\b as_integer} (const std::nothrow_t &) &&noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b floating} && {\b as_floating} (const std::nothrow_t &) &&noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} && {\b as_string} (const std::nothrow_t &) &&noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} && {\b as_offset_datetime} (const std::nothrow_t &) &&noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_datetime} && {\b as_local_datetime} (const std::nothrow_t &) &&noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} && {\b as_local_date} (const std::nothrow_t &) &&noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_time} && {\b as_local_time} (const std::nothrow_t &) &&noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b array_type} && {\b as_array} (const std::nothrow_t &) &&noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b table_type} && {\b as_table} (const std::nothrow_t &) &&noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} const & {\b as_boolean} () const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b integer} const & {\b as_integer} () const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b floating} const & {\b as_floating} () const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} const & {\b as_string} () const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} const & {\b as_offset_datetime} () const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_datetime} const & {\b as_local_datetime} () const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} const & {\b as_local_date} () const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_time} const & {\b as_local_time} () const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b array_type} const & {\b as_array} () const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b table_type} const & {\b as_table} () const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} & {\b as_boolean} () &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b integer} & {\b as_integer} () &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b floating} & {\b as_floating} () &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} & {\b as_string} () &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} & {\b as_offset_datetime} () &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_datetime} & {\b as_local_datetime} () &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} & {\b as_local_date} () &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_time} & {\b as_local_time} () &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b array_type} & {\b as_array} () &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b table_type} & {\b as_table} () &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b boolean} && {\b as_boolean} () &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b integer} && {\b as_integer} () &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b floating} && {\b as_floating} () &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} && {\b as_string} () &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} && {\b as_offset_datetime} () &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_datetime} && {\b as_local_datetime} () &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} && {\b as_local_date} () &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_time} && {\b as_local_time} () &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b array_type} && {\b as_array} () &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b table_type} && {\b as_table} () &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} & {\b at} (const {\b key} &k)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} const & {\b at} (const {\b key} &k) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} & {\b operator[]} (const {\b key} &k)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} & {\b at} (const std::size_t idx)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} const & {\b at} (const std::size_t idx) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} & {\b operator[]} (const std::size_t idx) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} const & {\b operator[]} (const std::size_t idx) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_back} (const {\b value_type} &x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_back} ({\b value_type} &&x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ts> {\b value_type} & {\b emplace_back} (Ts &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b count} (const {\b key_type} &k) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b contains} (const {\b key_type} &k) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b source_location} {\b location} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b comment_type} const & {\b comments} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b comment_type} & {\b comments} () noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> class {\b basic_value}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > {\b region_base} const * {\b detail::get_region} (const Value &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > void {\b detail::change_region} (Value &v, {\b detail::region} reg)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v array_type\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:array_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> using {\b toml::basic_value}< Comment, Table, Array >::array_type =  Array<{\b value_type}>}}
\par
{\bkmkstart AAAAAAAARL}
{\bkmkend AAAAAAAARL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v boolean_type\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:boolean_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> using {\b toml::basic_value}< Comment, Table, Array >::boolean_type =  {\b ::toml::boolean}}}
\par
{\bkmkstart AAAAAAAARM}
{\bkmkend AAAAAAAARM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v comment_type\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:comment_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> using {\b toml::basic_value}< Comment, Table, Array >::comment_type =  Comment}}
\par
{\bkmkstart AAAAAAAARN}
{\bkmkend AAAAAAAARN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v floating_type\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:floating_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> using {\b toml::basic_value}< Comment, Table, Array >::floating_type =  {\b ::toml::floating}}}
\par
{\bkmkstart AAAAAAAARO}
{\bkmkend AAAAAAAARO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v integer_type\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:integer_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> using {\b toml::basic_value}< Comment, Table, Array >::integer_type =  {\b ::toml::integer}}}
\par
{\bkmkstart AAAAAAAARP}
{\bkmkend AAAAAAAARP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v key_type\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:key_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> using {\b toml::basic_value}< Comment, Table, Array >::key_type =  {\b ::toml::key}}}
\par
{\bkmkstart AAAAAAAARQ}
{\bkmkend AAAAAAAARQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_date_type\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:local_date_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> using {\b toml::basic_value}< Comment, Table, Array >::local_date_type =  {\b ::toml::local_date}}}
\par
{\bkmkstart AAAAAAAARR}
{\bkmkend AAAAAAAARR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_datetime_type\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:local_datetime_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> using {\b toml::basic_value}< Comment, Table, Array >::local_datetime_type =  {\b ::toml::local_datetime}}}
\par
{\bkmkstart AAAAAAAARS}
{\bkmkend AAAAAAAARS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_time_type\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:local_time_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> using {\b toml::basic_value}< Comment, Table, Array >::local_time_type =  {\b ::toml::local_time}}}
\par
{\bkmkstart AAAAAAAART}
{\bkmkend AAAAAAAART}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v offset_datetime_type\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:offset_datetime_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> using {\b toml::basic_value}< Comment, Table, Array >::offset_datetime_type =  {\b ::toml::offset_datetime}}}
\par
{\bkmkstart AAAAAAAARU}
{\bkmkend AAAAAAAARU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v string_type\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:string_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> using {\b toml::basic_value}< Comment, Table, Array >::string_type =  {\b ::toml::string}}}
\par
{\bkmkstart AAAAAAAARV}
{\bkmkend AAAAAAAARV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v table_type\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:table_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> using {\b toml::basic_value}< Comment, Table, Array >::table_type =  Table<{\b key_type}, {\b value_type}>}}
\par
{\bkmkstart AAAAAAAARW}
{\bkmkend AAAAAAAARW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value_type\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> using {\b toml::basic_value}< Comment, Table, Array >::value_type =  {\b basic_value}<{\b comment_type}, Table, Array>}}
\par
{\bkmkstart AAAAAAAARX}
{\bkmkend AAAAAAAARX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAARY}
{\bkmkend AAAAAAAARY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:~basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::~{\b basic_value} (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAARZ}
{\bkmkend AAAAAAAARZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b basic_value}< Comment, Table, Array > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASA}
{\bkmkend AAAAAAAASA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value ({\b basic_value}< Comment, Table, Array > &&  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASB}
{\bkmkend AAAAAAAASB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b basic_value}< Comment, Table, Array > &  {\i v}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASC}
{\bkmkend AAAAAAAASC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value ({\b basic_value}< Comment, Table, Array > &&  {\i v}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASD}
{\bkmkend AAAAAAAASD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename C , template< typename ... > class T, template< typename ... > class A> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b basic_value}< C, T, A > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASE}
{\bkmkend AAAAAAAASE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename C , template< typename ... > class T, template< typename ... > class A> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b basic_value}< C, T, A > &  {\i v}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASF}
{\bkmkend AAAAAAAASF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value ({\b boolean}  {\i b}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASG}
{\bkmkend AAAAAAAASG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value ({\b boolean}  {\i b}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASH}
{\bkmkend AAAAAAAASH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< {\b detail::conjunction}< std::is_integral< T >, {\b detail::negation}< std::is_same< T, {\b boolean} > > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b toml::basic_value}< Comment, Table, Array >::basic_value (T  {\i i}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASI}
{\bkmkend AAAAAAAASI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< {\b detail::conjunction}< std::is_integral< T >, {\b detail::negation}< std::is_same< T, {\b boolean} > > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b toml::basic_value}< Comment, Table, Array >::basic_value (T  {\i i}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASJ}
{\bkmkend AAAAAAAASJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< std::is_floating_point< T >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b toml::basic_value}< Comment, Table, Array >::basic_value (T  {\i f}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASK}
{\bkmkend AAAAAAAASK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< std::is_floating_point< T >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b toml::basic_value}< Comment, Table, Array >::basic_value (T  {\i f}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASL}
{\bkmkend AAAAAAAASL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value ({\b toml::string}  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASM}
{\bkmkend AAAAAAAASM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value ({\b toml::string}  {\i s}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASN}
{\bkmkend AAAAAAAASN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (std::string  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASO}
{\bkmkend AAAAAAAASO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (std::string  {\i s}, {\b string_t}  {\i kind}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASP}
{\bkmkend AAAAAAAASP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (std::string  {\i s}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASQ}
{\bkmkend AAAAAAAASQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (std::string  {\i s}, {\b string_t}  {\i kind}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASR}
{\bkmkend AAAAAAAASR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const char *  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASS}
{\bkmkend AAAAAAAASS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const char *  {\i s}, {\b string_t}  {\i kind}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAST}
{\bkmkend AAAAAAAAST}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const char *  {\i s}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASU}
{\bkmkend AAAAAAAASU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const char *  {\i s}, {\b string_t}  {\i kind}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASV}
{\bkmkend AAAAAAAASV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b local_date} &  {\i ld}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASW}
{\bkmkend AAAAAAAASW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b local_date} &  {\i ld}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASX}
{\bkmkend AAAAAAAASX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b local_time} &  {\i lt}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASY}
{\bkmkend AAAAAAAASY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b local_time} &  {\i lt}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAASZ}
{\bkmkend AAAAAAAASZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename Rep , typename Period > {\b toml::basic_value}< Comment, Table, Array >::basic_value (const std::chrono::duration< Rep, Period > &  {\i dur}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATA}
{\bkmkend AAAAAAAATA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename Rep , typename Period > {\b toml::basic_value}< Comment, Table, Array >::basic_value (const std::chrono::duration< Rep, Period > &  {\i dur}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATB}
{\bkmkend AAAAAAAATB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b local_datetime} &  {\i ldt}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATC}
{\bkmkend AAAAAAAATC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b local_datetime} &  {\i ldt}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATD}
{\bkmkend AAAAAAAATD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b offset_datetime} &  {\i odt}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATE}
{\bkmkend AAAAAAAATE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b offset_datetime} &  {\i odt}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATF}
{\bkmkend AAAAAAAATF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const std::chrono::system_clock::time_point &  {\i tp}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATG}
{\bkmkend AAAAAAAATG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const std::chrono::system_clock::time_point &  {\i tp}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATH}
{\bkmkend AAAAAAAATH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b array_type} &  {\i ary}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATI}
{\bkmkend AAAAAAAATI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b array_type} &  {\i ary}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATJ}
{\bkmkend AAAAAAAATJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< std::is_convertible< T, {\b value_type} >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b toml::basic_value}< Comment, Table, Array >::basic_value (std::initializer_list< T >  {\i list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATK}
{\bkmkend AAAAAAAATK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< std::is_convertible< T, {\b value_type} >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b toml::basic_value}< Comment, Table, Array >::basic_value (std::initializer_list< T >  {\i list}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATL}
{\bkmkend AAAAAAAATL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< {\b detail::conjunction}< {\b detail::negation}< std::is_same< T, {\b array_type} > >, {\b detail::is_container}< T > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const T &  {\i list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATM}
{\bkmkend AAAAAAAATM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< {\b detail::conjunction}< {\b detail::negation}< std::is_same< T, {\b array_type} > >, {\b detail::is_container}< T > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const T &  {\i list}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATN}
{\bkmkend AAAAAAAATN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b table_type} &  {\i tab}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATO}
{\bkmkend AAAAAAAATO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b table_type} &  {\i tab}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATP}
{\bkmkend AAAAAAAATP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (std::initializer_list< std::pair< {\b key}, {\b basic_value}< Comment, Table, Array > > >  {\i list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATQ}
{\bkmkend AAAAAAAATQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (std::initializer_list< std::pair< {\b key}, {\b basic_value}< Comment, Table, Array > > >  {\i list}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATR}
{\bkmkend AAAAAAAATR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename Map , typename std::enable_if< {\b detail::conjunction}< {\b detail::negation}< std::is_same< Map, {\b table_type} > >, {\b detail::is_map}< Map > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const Map &  {\i mp}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATS}
{\bkmkend AAAAAAAATS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename Map , typename std::enable_if< {\b detail::conjunction}< {\b detail::negation}< std::is_same< Map, {\b table_type} > >, {\b detail::is_map}< Map > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const Map &  {\i mp}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATT}
{\bkmkend AAAAAAAATT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< {\b detail::has_into_toml_method}< T >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const T &  {\i ud}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< {\b detail::has_into_toml_method}< T >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const T &  {\i ud}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , std::size_t S = sizeof(::toml::into<T>)> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const T &  {\i ud}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATU}
{\bkmkend AAAAAAAATU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , std::size_t S = sizeof(::toml::into<T>)> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const T &  {\i ud}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATV}
{\bkmkend AAAAAAAATV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value ({\b boolean}  {\i b}, {\b detail::region}  {\i reg}, std::vector< std::string >  {\i cm}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATW}
{\bkmkend AAAAAAAATW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< {\b detail::conjunction}< std::is_integral< T >, {\b detail::negation}< std::is_same< T, {\b boolean} > > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b toml::basic_value}< Comment, Table, Array >::basic_value (T  {\i i}, {\b detail::region}  {\i reg}, std::vector< std::string >  {\i cm}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATX}
{\bkmkend AAAAAAAATX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< std::is_floating_point< T >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b toml::basic_value}< Comment, Table, Array >::basic_value (T  {\i f}, {\b detail::region}  {\i reg}, std::vector< std::string >  {\i cm}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATY}
{\bkmkend AAAAAAAATY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value ({\b toml::string}  {\i s}, {\b detail::region}  {\i reg}, std::vector< std::string >  {\i cm}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAATZ}
{\bkmkend AAAAAAAATZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b local_date} &  {\i ld}, {\b detail::region}  {\i reg}, std::vector< std::string >  {\i cm}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUA}
{\bkmkend AAAAAAAAUA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b local_time} &  {\i lt}, {\b detail::region}  {\i reg}, std::vector< std::string >  {\i cm}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUB}
{\bkmkend AAAAAAAAUB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b local_datetime} &  {\i ldt}, {\b detail::region}  {\i reg}, std::vector< std::string >  {\i cm}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUC}
{\bkmkend AAAAAAAAUC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b offset_datetime} &  {\i odt}, {\b detail::region}  {\i reg}, std::vector< std::string >  {\i cm}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUD}
{\bkmkend AAAAAAAAUD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b array_type} &  {\i ary}, {\b detail::region}  {\i reg}, std::vector< std::string >  {\i cm}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUE}
{\bkmkend AAAAAAAAUE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b toml::basic_value}< Comment, Table, Array >::basic_value (const {\b table_type} &  {\i tab}, {\b detail::region}  {\i reg}, std::vector< std::string >  {\i cm}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUF}
{\bkmkend AAAAAAAAUF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< {\b detail::is_exact_toml_type}< T, {\b value_type} >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b toml::basic_value}< Comment, Table, Array >::basic_value (std::pair< T, {\b detail::region} >  {\i parse_result}, std::vector< std::string >  {\i com}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUG}
{\bkmkend AAAAAAAAUG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v as_array\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b array_type} & {\b toml::basic_value}< Comment, Table, Array >::as_array () &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUH}
{\bkmkend AAAAAAAAUH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_array\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b array_type} && {\b toml::basic_value}< Comment, Table, Array >::as_array () &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUI}
{\bkmkend AAAAAAAAUI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_array\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b array_type} const  & {\b toml::basic_value}< Comment, Table, Array >::as_array () const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUJ}
{\bkmkend AAAAAAAAUJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_array\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b array_type} && {\b toml::basic_value}< Comment, Table, Array >::as_array (const std::nothrow_t & ) &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUK}
{\bkmkend AAAAAAAAUK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_array\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b array_type} & {\b toml::basic_value}< Comment, Table, Array >::as_array (const std::nothrow_t & ) &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUL}
{\bkmkend AAAAAAAAUL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_array\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b array_type} const  & {\b toml::basic_value}< Comment, Table, Array >::as_array (const std::nothrow_t & ) const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUM}
{\bkmkend AAAAAAAAUM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_boolean\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b boolean} & {\b toml::basic_value}< Comment, Table, Array >::as_boolean () &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUN}
{\bkmkend AAAAAAAAUN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_boolean\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b boolean} && {\b toml::basic_value}< Comment, Table, Array >::as_boolean () &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUO}
{\bkmkend AAAAAAAAUO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_boolean\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b boolean} const  & {\b toml::basic_value}< Comment, Table, Array >::as_boolean () const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUP}
{\bkmkend AAAAAAAAUP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_boolean\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b boolean} && {\b toml::basic_value}< Comment, Table, Array >::as_boolean (const std::nothrow_t & ) &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUQ}
{\bkmkend AAAAAAAAUQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_boolean\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b boolean} & {\b toml::basic_value}< Comment, Table, Array >::as_boolean (const std::nothrow_t & ) &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUR}
{\bkmkend AAAAAAAAUR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_boolean\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b boolean} const  & {\b toml::basic_value}< Comment, Table, Array >::as_boolean (const std::nothrow_t & ) const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUS}
{\bkmkend AAAAAAAAUS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_floating\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_floating}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b floating} & {\b toml::basic_value}< Comment, Table, Array >::as_floating () &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUT}
{\bkmkend AAAAAAAAUT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_floating\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_floating}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b floating} && {\b toml::basic_value}< Comment, Table, Array >::as_floating () &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUU}
{\bkmkend AAAAAAAAUU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_floating\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_floating}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b floating} const  & {\b toml::basic_value}< Comment, Table, Array >::as_floating () const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUV}
{\bkmkend AAAAAAAAUV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_floating\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_floating}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b floating} && {\b toml::basic_value}< Comment, Table, Array >::as_floating (const std::nothrow_t & ) &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUW}
{\bkmkend AAAAAAAAUW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_floating\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_floating}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b floating} & {\b toml::basic_value}< Comment, Table, Array >::as_floating (const std::nothrow_t & ) &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUX}
{\bkmkend AAAAAAAAUX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_floating\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_floating}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b floating} const  & {\b toml::basic_value}< Comment, Table, Array >::as_floating (const std::nothrow_t & ) const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAUY}
{\bkmkend AAAAAAAAUY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_integer\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b integer} & {\b toml::basic_value}< Comment, Table, Array >::as_integer () &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAUZ}
{\bkmkend AAAAAAAAUZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_integer\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b integer} && {\b toml::basic_value}< Comment, Table, Array >::as_integer () &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVA}
{\bkmkend AAAAAAAAVA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_integer\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b integer} const  & {\b toml::basic_value}< Comment, Table, Array >::as_integer () const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVB}
{\bkmkend AAAAAAAAVB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_integer\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b integer} && {\b toml::basic_value}< Comment, Table, Array >::as_integer (const std::nothrow_t & ) &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVC}
{\bkmkend AAAAAAAAVC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_integer\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b integer} & {\b toml::basic_value}< Comment, Table, Array >::as_integer (const std::nothrow_t & ) &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVD}
{\bkmkend AAAAAAAAVD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_integer\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b integer} const  & {\b toml::basic_value}< Comment, Table, Array >::as_integer (const std::nothrow_t & ) const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVE}
{\bkmkend AAAAAAAAVE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_date\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_date} & {\b toml::basic_value}< Comment, Table, Array >::as_local_date () &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVF}
{\bkmkend AAAAAAAAVF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_date\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_date} && {\b toml::basic_value}< Comment, Table, Array >::as_local_date () &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVG}
{\bkmkend AAAAAAAAVG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_date\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_date} const  & {\b toml::basic_value}< Comment, Table, Array >::as_local_date () const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVH}
{\bkmkend AAAAAAAAVH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_date\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_date} && {\b toml::basic_value}< Comment, Table, Array >::as_local_date (const std::nothrow_t & ) &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVI}
{\bkmkend AAAAAAAAVI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_date\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_date} & {\b toml::basic_value}< Comment, Table, Array >::as_local_date (const std::nothrow_t & ) &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVJ}
{\bkmkend AAAAAAAAVJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_date\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_date} const  & {\b toml::basic_value}< Comment, Table, Array >::as_local_date (const std::nothrow_t & ) const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVK}
{\bkmkend AAAAAAAAVK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_datetime\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_datetime} & {\b toml::basic_value}< Comment, Table, Array >::as_local_datetime () &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVL}
{\bkmkend AAAAAAAAVL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_datetime\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_datetime} && {\b toml::basic_value}< Comment, Table, Array >::as_local_datetime () &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVM}
{\bkmkend AAAAAAAAVM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_datetime\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_datetime} const  & {\b toml::basic_value}< Comment, Table, Array >::as_local_datetime () const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVN}
{\bkmkend AAAAAAAAVN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_datetime\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_datetime} && {\b toml::basic_value}< Comment, Table, Array >::as_local_datetime (const std::nothrow_t & ) &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVO}
{\bkmkend AAAAAAAAVO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_datetime\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_datetime} & {\b toml::basic_value}< Comment, Table, Array >::as_local_datetime (const std::nothrow_t & ) &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVP}
{\bkmkend AAAAAAAAVP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_datetime\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_datetime} const  & {\b toml::basic_value}< Comment, Table, Array >::as_local_datetime (const std::nothrow_t & ) const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVQ}
{\bkmkend AAAAAAAAVQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_time\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_time} & {\b toml::basic_value}< Comment, Table, Array >::as_local_time () &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVR}
{\bkmkend AAAAAAAAVR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_time\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_time} && {\b toml::basic_value}< Comment, Table, Array >::as_local_time () &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVS}
{\bkmkend AAAAAAAAVS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_time\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_time} const  & {\b toml::basic_value}< Comment, Table, Array >::as_local_time () const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVT}
{\bkmkend AAAAAAAAVT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_time\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_time} && {\b toml::basic_value}< Comment, Table, Array >::as_local_time (const std::nothrow_t & ) &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVU}
{\bkmkend AAAAAAAAVU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_time\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_time} & {\b toml::basic_value}< Comment, Table, Array >::as_local_time (const std::nothrow_t & ) &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVV}
{\bkmkend AAAAAAAAVV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_local_time\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_time} const  & {\b toml::basic_value}< Comment, Table, Array >::as_local_time (const std::nothrow_t & ) const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAVW}
{\bkmkend AAAAAAAAVW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_offset_datetime\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b offset_datetime} & {\b toml::basic_value}< Comment, Table, Array >::as_offset_datetime () &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVX}
{\bkmkend AAAAAAAAVX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_offset_datetime\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b offset_datetime} && {\b toml::basic_value}< Comment, Table, Array >::as_offset_datetime () &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVY}
{\bkmkend AAAAAAAAVY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_offset_datetime\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b offset_datetime} const  & {\b toml::basic_value}< Comment, Table, Array >::as_offset_datetime () const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAVZ}
{\bkmkend AAAAAAAAVZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_offset_datetime\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b offset_datetime} && {\b toml::basic_value}< Comment, Table, Array >::as_offset_datetime (const std::nothrow_t & ) &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWA}
{\bkmkend AAAAAAAAWA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_offset_datetime\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b offset_datetime} & {\b toml::basic_value}< Comment, Table, Array >::as_offset_datetime (const std::nothrow_t & ) &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWB}
{\bkmkend AAAAAAAAWB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_offset_datetime\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b offset_datetime} const  & {\b toml::basic_value}< Comment, Table, Array >::as_offset_datetime (const std::nothrow_t & ) const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWC}
{\bkmkend AAAAAAAAWC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_string\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b string} & {\b toml::basic_value}< Comment, Table, Array >::as_string () &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWD}
{\bkmkend AAAAAAAAWD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_string\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b string} && {\b toml::basic_value}< Comment, Table, Array >::as_string () &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWE}
{\bkmkend AAAAAAAAWE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_string\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b string} const  & {\b toml::basic_value}< Comment, Table, Array >::as_string () const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWF}
{\bkmkend AAAAAAAAWF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_string\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b string} && {\b toml::basic_value}< Comment, Table, Array >::as_string (const std::nothrow_t & ) &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWG}
{\bkmkend AAAAAAAAWG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_string\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b string} & {\b toml::basic_value}< Comment, Table, Array >::as_string (const std::nothrow_t & ) &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWH}
{\bkmkend AAAAAAAAWH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_string\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b string} const  & {\b toml::basic_value}< Comment, Table, Array >::as_string (const std::nothrow_t & ) const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWI}
{\bkmkend AAAAAAAAWI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_table\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b table_type} & {\b toml::basic_value}< Comment, Table, Array >::as_table () &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWJ}
{\bkmkend AAAAAAAAWJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_table\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b table_type} && {\b toml::basic_value}< Comment, Table, Array >::as_table () &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWK}
{\bkmkend AAAAAAAAWK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_table\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b table_type} const  & {\b toml::basic_value}< Comment, Table, Array >::as_table () const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWL}
{\bkmkend AAAAAAAAWL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_table\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b table_type} && {\b toml::basic_value}< Comment, Table, Array >::as_table (const std::nothrow_t & ) &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWM}
{\bkmkend AAAAAAAAWM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_table\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b table_type} & {\b toml::basic_value}< Comment, Table, Array >::as_table (const std::nothrow_t & ) &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWN}
{\bkmkend AAAAAAAAWN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_table\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:as_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b table_type} const  & {\b toml::basic_value}< Comment, Table, Array >::as_table (const std::nothrow_t & ) const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWO}
{\bkmkend AAAAAAAAWO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v at\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b value_type} & {\b toml::basic_value}< Comment, Table, Array >::at (const {\b key} &  {\i k}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWP}
{\bkmkend AAAAAAAAWP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v at\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b value_type} const  & {\b toml::basic_value}< Comment, Table, Array >::at (const {\b key} &  {\i k}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWQ}
{\bkmkend AAAAAAAAWQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v at\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b value_type} & {\b toml::basic_value}< Comment, Table, Array >::at (const std::size_t  {\i idx}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWR}
{\bkmkend AAAAAAAAWR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v at\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b value_type} const  & {\b toml::basic_value}< Comment, Table, Array >::at (const std::size_t  {\i idx}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWS}
{\bkmkend AAAAAAAAWS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v cast\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:cast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<{\b value_t} T> {\b detail::enum_to_type}< T, {\b value_type} >{\b ::type} & {\b toml::basic_value}< Comment, Table, Array >::cast () &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWT}
{\bkmkend AAAAAAAAWT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v cast\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:cast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<{\b value_t} T> {\b detail::enum_to_type}< T, {\b value_type} >{\b ::type} && {\b toml::basic_value}< Comment, Table, Array >::cast () &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWU}
{\bkmkend AAAAAAAAWU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v cast\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:cast}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<{\b value_t} T> {\b detail::enum_to_type}< T, {\b value_type} >{\b ::type} const  & {\b toml::basic_value}< Comment, Table, Array >::cast () const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWV}
{\bkmkend AAAAAAAAWV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v comments\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b comment_type} const  & {\b toml::basic_value}< Comment, Table, Array >::comments () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWW}
{\bkmkend AAAAAAAAWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v comments\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b comment_type} & {\b toml::basic_value}< Comment, Table, Array >::comments (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAWX}
{\bkmkend AAAAAAAAWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v contains\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:contains}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> bool {\b toml::basic_value}< Comment, Table, Array >::contains (const {\b key_type} &  {\i k}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWY}
{\bkmkend AAAAAAAAWY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v count\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> std::size_t {\b toml::basic_value}< Comment, Table, Array >::count (const {\b key_type} &  {\i k}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAWZ}
{\bkmkend AAAAAAAAWZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v emplace_back\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:emplace_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename ... Ts> {\b value_type} & {\b toml::basic_value}< Comment, Table, Array >::emplace_back (Ts &&...  {\i args}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXA}
{\bkmkend AAAAAAAAXA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:is}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< {\b detail::is_exact_toml_type}< T, {\b value_type} >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> bool {\b toml::basic_value}< Comment, Table, Array >::is () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXB}
{\bkmkend AAAAAAAAXB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:is}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> bool {\b toml::basic_value}< Comment, Table, Array >::is ({\b value_t}  {\i t}) const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXC}
{\bkmkend AAAAAAAAXC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is_array\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:is_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> bool {\b toml::basic_value}< Comment, Table, Array >::is_array () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXD}
{\bkmkend AAAAAAAAXD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is_boolean\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:is_boolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> bool {\b toml::basic_value}< Comment, Table, Array >::is_boolean () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXE}
{\bkmkend AAAAAAAAXE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is_floating\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:is_floating}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> bool {\b toml::basic_value}< Comment, Table, Array >::is_floating () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXF}
{\bkmkend AAAAAAAAXF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is_integer\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:is_integer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> bool {\b toml::basic_value}< Comment, Table, Array >::is_integer () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXG}
{\bkmkend AAAAAAAAXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is_local_date\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:is_local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> bool {\b toml::basic_value}< Comment, Table, Array >::is_local_date () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXH}
{\bkmkend AAAAAAAAXH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is_local_datetime\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:is_local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> bool {\b toml::basic_value}< Comment, Table, Array >::is_local_datetime () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXI}
{\bkmkend AAAAAAAAXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is_local_time\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:is_local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> bool {\b toml::basic_value}< Comment, Table, Array >::is_local_time () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXJ}
{\bkmkend AAAAAAAAXJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is_offset_datetime\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:is_offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> bool {\b toml::basic_value}< Comment, Table, Array >::is_offset_datetime () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXK}
{\bkmkend AAAAAAAAXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is_string\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:is_string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> bool {\b toml::basic_value}< Comment, Table, Array >::is_string () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXL}
{\bkmkend AAAAAAAAXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is_table\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:is_table}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> bool {\b toml::basic_value}< Comment, Table, Array >::is_table () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXM}
{\bkmkend AAAAAAAAXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is_uninitialized\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:is_uninitialized}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> bool {\b toml::basic_value}< Comment, Table, Array >::is_uninitialized () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAXN}
{\bkmkend AAAAAAAAXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v location\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b source_location} {\b toml::basic_value}< Comment, Table, Array >::location () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXO}
{\bkmkend AAAAAAAAXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= ({\b basic_value}< Comment, Table, Array > &&  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXP}
{\bkmkend AAAAAAAAXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= ({\b boolean}  {\i b}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXQ}
{\bkmkend AAAAAAAAXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (const {\b array_type} &  {\i ary}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXR}
{\bkmkend AAAAAAAAXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (const {\b basic_value}< Comment, Table, Array > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXS}
{\bkmkend AAAAAAAAXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename C , template< typename ... > class T, template< typename ... > class A> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (const {\b basic_value}< C, T, A > &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXT}
{\bkmkend AAAAAAAAXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (const char *  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXU}
{\bkmkend AAAAAAAAXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (const {\b local_date} &  {\i ld}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXV}
{\bkmkend AAAAAAAAXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (const {\b local_datetime} &  {\i ldt}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXW}
{\bkmkend AAAAAAAAXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (const {\b local_time} &  {\i lt}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXX}
{\bkmkend AAAAAAAAXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename Map , typename std::enable_if< {\b detail::conjunction}< {\b detail::negation}< std::is_same< Map, {\b table_type} > >, {\b detail::is_map}< Map > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (const Map &  {\i mp}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXY}
{\bkmkend AAAAAAAAXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (const {\b offset_datetime} &  {\i odt}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAXZ}
{\bkmkend AAAAAAAAXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename Rep , typename Period > {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (const std::chrono::duration< Rep, Period > &  {\i dur}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYA}
{\bkmkend AAAAAAAAYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (const std::chrono::system_clock::time_point &  {\i tp}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYB}
{\bkmkend AAAAAAAAYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< {\b detail::conjunction}< {\b detail::negation}< std::is_same< T, {\b array_type} > >, {\b detail::is_container}< T > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (const T &  {\i list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYC}
{\bkmkend AAAAAAAAYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< {\b detail::has_into_toml_method}< T >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (const T &  {\i ud}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , std::size_t S = sizeof(::toml::into<T>)> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (const T &  {\i ud}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYD}
{\bkmkend AAAAAAAAYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (const {\b table_type} &  {\i tab}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYE}
{\bkmkend AAAAAAAAYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (std::initializer_list< std::pair< {\b key}, {\b basic_value}< Comment, Table, Array > > >  {\i list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYF}
{\bkmkend AAAAAAAAYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< std::is_convertible< T, {\b value_type} >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (std::initializer_list< T >  {\i list}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYG}
{\bkmkend AAAAAAAAYG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (std::string  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYH}
{\bkmkend AAAAAAAAYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< std::is_floating_point< T >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (T  {\i f}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYI}
{\bkmkend AAAAAAAAYI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename T , typename std::enable_if< {\b detail::conjunction}< std::is_integral< T >, {\b detail::negation}< std::is_same< T, {\b boolean} > > >{\b ::value}, std::nullptr_t >{\b ::type}  = nullptr> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= (T  {\i i}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYJ}
{\bkmkend AAAAAAAAYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b basic_value} & {\b toml::basic_value}< Comment, Table, Array >::operator= ({\b toml::string}  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYK}
{\bkmkend AAAAAAAAYK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator[]\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b value_type} & {\b toml::basic_value}< Comment, Table, Array >::operator[] (const {\b key} &  {\i k}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYL}
{\bkmkend AAAAAAAAYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator[]\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b value_type} const  & {\b toml::basic_value}< Comment, Table, Array >::operator[] (const std::size_t  {\i idx}) const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYM}
{\bkmkend AAAAAAAAYM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator[]\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b value_type} & {\b toml::basic_value}< Comment, Table, Array >::operator[] (const std::size_t  {\i idx}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYN}
{\bkmkend AAAAAAAAYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v push_back\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> void {\b toml::basic_value}< Comment, Table, Array >::push_back (const {\b value_type} &  {\i x}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYO}
{\bkmkend AAAAAAAAYO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v push_back\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> void {\b toml::basic_value}< Comment, Table, Array >::push_back ({\b value_type} &&  {\i x}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYP}
{\bkmkend AAAAAAAAYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> std::size_t {\b toml::basic_value}< Comment, Table, Array >::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAYQ}
{\bkmkend AAAAAAAAYQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v type\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b value_t} {\b toml::basic_value}< Comment, Table, Array >::type () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAYR}
{\bkmkend AAAAAAAAYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v basic_value\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:basic_value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename C , template< typename ... > class T, template< typename ... > class A> friend class {\b basic_value}{\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYS}
{\bkmkend AAAAAAAAYS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v detail::change_region\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:detail::change_region}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename Value > void {\b detail::change_region} (Value &  {\i v}, {\b detail::region}  {\i reg}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYT}
{\bkmkend AAAAAAAAYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v detail::get_region\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:detail::get_region}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> template<typename Value > {\b region_base} const  * {\b detail::get_region} (const Value &  {\i v}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAAAYU}
{\bkmkend AAAAAAAAYU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v array_\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:array_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b array_storage} {\b toml::basic_value}< Comment, Table, Array >::array_}}
\par
{\bkmkstart AAAAAAAAYV}
{\bkmkend AAAAAAAAYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v boolean_\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:boolean_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b boolean} {\b toml::basic_value}< Comment, Table, Array >::boolean_}}
\par
{\bkmkstart AAAAAAAAYW}
{\bkmkend AAAAAAAAYW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v floating_\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:floating_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b floating} {\b toml::basic_value}< Comment, Table, Array >::floating_}}
\par
{\bkmkstart AAAAAAAAYX}
{\bkmkend AAAAAAAAYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v integer_\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:integer_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b integer} {\b toml::basic_value}< Comment, Table, Array >::integer_}}
\par
{\bkmkstart AAAAAAAAYY}
{\bkmkend AAAAAAAAYY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_date_\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:local_date_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_date} {\b toml::basic_value}< Comment, Table, Array >::local_date_}}
\par
{\bkmkstart AAAAAAAAYZ}
{\bkmkend AAAAAAAAYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_datetime_\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:local_datetime_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_datetime} {\b toml::basic_value}< Comment, Table, Array >::local_datetime_}}
\par
{\bkmkstart AAAAAAAAZA}
{\bkmkend AAAAAAAAZA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_time_\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:local_time_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b local_time} {\b toml::basic_value}< Comment, Table, Array >::local_time_}}
\par
{\bkmkstart AAAAAAAAZB}
{\bkmkend AAAAAAAAZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v offset_datetime_\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:offset_datetime_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b offset_datetime} {\b toml::basic_value}< Comment, Table, Array >::offset_datetime_}}
\par
{\bkmkstart AAAAAAAAZC}
{\bkmkend AAAAAAAAZC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v string_\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:string_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b string} {\b toml::basic_value}< Comment, Table, Array >::string_}}
\par
{\bkmkstart AAAAAAAAZD}
{\bkmkend AAAAAAAAZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v table_\:toml::basic_value< Comment, Table, Array >}
{\xe \v toml::basic_value< Comment, Table, Array >\:table_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Comment , template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> {\b table_storage} {\b toml::basic_value}< Comment, Table, Array >::table_}}
\par
{\bkmkstart AAAAAAAAZE}
{\bkmkend AAAAAAAAZE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b value.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Bullet Class Reference\par \pard\plain 
{\tc\tcl2 \v Bullet}
{\xe \v Bullet}
{\bkmkstart AAAAAAAAFG}
{\bkmkend AAAAAAAAFG}
\par
{
{\f2 #include <Bullet.hpp>}}\par
Inheritance diagram for Bullet:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_bullet.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bullet} (sf::Vector2f startPosition, sf::Vector2f velocity, std::vector< sf::Sprite > bulletSprite)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9A\'D0\'BB\'D0\'B0\'D1\'81\'D1\'81, \'D0\'BF\'D1\'83\'D0\'BB\'D0\'B8 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GameObject} & {\b getBulletObject} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 {\b GameObject} \'D0\'BF\'D1\'83\'D0\'BB\'D0\'B8 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b moveBullet} (sf::Time deltaTime)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D0\'B4\'D0\'B2\'D0\'B8\'D0\'B3\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'BF\'D1\'83\'D0\'BB\'D1\'8E }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} (sf::RenderTarget &surface, sf::RenderStates states) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getBulletRect} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 FloatRect \'D0\'BF\'D1\'83\'D0\'BB\'D0\'B8 }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isExist} = true\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Bullet\:Bullet}
{\xe \v Bullet\:Bullet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Bullet::Bullet (sf::Vector2f  {\i startPosition}, sf::Vector2f  {\i velocity}, std::vector< sf::Sprite >  {\i bulletSprite})}}
\par
{\bkmkstart AAAAAAAAFH}
{\bkmkend AAAAAAAAFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9A\'D0\'BB\'D0\'B0\'D1\'81\'D1\'81, \'D0\'BF\'D1\'83\'D0\'BB\'D0\'B8 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i startPosition} \cell }{\'D0\'BD\'D0\'B0\'D1\'87\'D0\'B0\'D0\'BB\'D1\'8C\'D0\'BD\'D0\'BE\'D0\'B5 \'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i velocity} \cell }{\'D0\'B2\'D0\'B5\'D0\'BA\'D1\'82\'D0\'BE\'D1\'80 \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D0\'B8 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i bulletSprite} \cell }{\'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D1\'8B \'D0\'BF\'D1\'83\'D0\'BB\'D0\'B8 \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v draw\:Bullet}
{\xe \v Bullet\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Bullet::draw (sf::RenderTarget &  {\i surface}, sf::RenderStates  {\i states}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFI}
{\bkmkend AAAAAAAAFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getBulletObject\:Bullet}
{\xe \v Bullet\:getBulletObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GameObject} & Bullet::getBulletObject ()}}
\par
{\bkmkstart AAAAAAAAFJ}
{\bkmkend AAAAAAAAFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 {\b GameObject} \'D0\'BF\'D1\'83\'D0\'BB\'D0\'B8 }}\par
}
{\xe \v getBulletRect\:Bullet}
{\xe \v Bullet\:getBulletRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::FloatRect Bullet::getBulletRect ()}}
\par
{\bkmkstart AAAAAAAAFK}
{\bkmkend AAAAAAAAFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 FloatRect \'D0\'BF\'D1\'83\'D0\'BB\'D0\'B8 }}\par
}
{\xe \v moveBullet\:Bullet}
{\xe \v Bullet\:moveBullet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Bullet::moveBullet (sf::Time  {\i deltaTime})}}
\par
{\bkmkstart AAAAAAAAFL}
{\bkmkend AAAAAAAAFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D0\'B4\'D0\'B2\'D0\'B8\'D0\'B3\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'BF\'D1\'83\'D0\'BB\'D1\'8E }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i deltaTime} \cell }{deltaTime \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v isExist\:Bullet}
{\xe \v Bullet\:isExist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Bullet::isExist = true}}
\par
{\bkmkstart AAAAAAAAFM}
{\bkmkend AAAAAAAAFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Bullet/{\b Bullet.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Bullet/{\b Bullet.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::character< C > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::character< C >}
{\xe \v toml::detail::character< C >}
{\bkmkstart AAAAAAABWV}
{\bkmkend AAAAAAABWV}
\par
{
{\f2 #include <combinator.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b result}< {\b region}, {\b none_t} > {\b invoke} ({\b location} &loc)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr char {\b target} = C\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v invoke\:toml::detail::character< C >}
{\xe \v toml::detail::character< C >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<char C> static {\b result}< {\b region}, {\b none_t} > {\b toml::detail::character}< C >::invoke ({\b location} &  {\i loc}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABWW}
{\bkmkend AAAAAAABWW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v target\:toml::detail::character< C >}
{\xe \v toml::detail::character< C >\:target}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<char C> constexpr char {\b toml::detail::character}< C >::target = C{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAABWX}
{\bkmkend AAAAAAABWX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::conjunction<... > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::conjunction<... >}
{\xe \v toml::detail::conjunction<... >}
{\bkmkstart AAAAAAABWY}
{\bkmkend AAAAAAABWY}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::conjunction<... >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1conjunction.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::conjunction< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::conjunction< T >}
{\xe \v toml::detail::conjunction< T >}
{\bkmkstart AAAAAAABWZ}
{\bkmkend AAAAAAABWZ}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::conjunction< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1conjunction_3_01_t_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::conjunction< T, Ts... > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::conjunction< T, Ts... >}
{\xe \v toml::detail::conjunction< T, Ts... >}
{\bkmkstart AAAAAAABXA}
{\bkmkend AAAAAAABXA}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::conjunction< T, Ts... >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1conjunction_3_01_t_00_01_ts_8_8_8_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::discard_comments Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::discard_comments}
{\xe \v toml::discard_comments}
{\bkmkstart AAAAAAAAZF}
{\bkmkend AAAAAAAAZF}
\par
{
{\f2 #include <comments.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b size_type} = std::size_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b difference_type} = std::ptrdiff_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = std::string\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b reference} = std::string &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b const_reference} = std::string const  &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b pointer} = std::string *\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b const_pointer} = std::string const  *\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b iterator} = {\b detail::empty_iterator}< std::string, false >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b const_iterator} = {\b detail::empty_iterator}< std::string, true >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b reverse_iterator} = {\b detail::empty_iterator}< std::string, false >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b const_reverse_iterator} = {\b detail::empty_iterator}< std::string, true >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b discard_comments} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~discard_comments} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b discard_comments} ({\b discard_comments} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b discard_comments} ({\b discard_comments} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b discard_comments} & {\b operator=} ({\b discard_comments} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b discard_comments} & {\b operator=} ({\b discard_comments} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b discard_comments} (const std::vector< std::string > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b discard_comments} (std::vector< std::string > &&) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b discard_comments} & {\b operator=} (const std::vector< std::string > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b discard_comments} & {\b operator=} (std::vector< std::string > &&) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b discard_comments} (const {\b preserve_comments} &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b discard_comments} ({\b size_type}) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b discard_comments} ({\b size_type}, const std::string &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b discard_comments} (std::initializer_list< std::string >) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator > {\b discard_comments} (InputIterator, InputIterator) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator > void {\b assign} (InputIterator, InputIterator) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b assign} (std::initializer_list< std::string >) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b assign} ({\b size_type}, const std::string &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b insert} ({\b const_iterator}, const std::string &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b insert} ({\b const_iterator}, std::string &&)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b insert} ({\b const_iterator}, {\b size_type}, const std::string &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator > {\b iterator} {\b insert} ({\b const_iterator}, InputIterator, InputIterator)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b insert} ({\b const_iterator}, std::initializer_list< std::string >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ts> {\b iterator} {\b emplace} ({\b const_iterator}, Ts &&...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b erase} ({\b const_iterator})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b erase} ({\b const_iterator}, {\b const_iterator})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b discard_comments} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_back} (const std::string &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_back} (std::string &&)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pop_back} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ts> void {\b emplace_back} (Ts &&...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b size_type} {\b size} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b size_type} {\b max_size} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b size_type} {\b capacity} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b empty} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reserve} ({\b size_type})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resize} ({\b size_type})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resize} ({\b size_type}, const std::string &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b shrink_to_fit} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b operator[]} (const {\b size_type}) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b operator[]} (const {\b size_type}) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b at} (const {\b size_type})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b at} (const {\b size_type}) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b front} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b front} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b back} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b back} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pointer} {\b data} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_pointer} {\b data} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b begin} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b end} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b begin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b end} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b cbegin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b cend} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reverse_iterator} {\b rbegin} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reverse_iterator} {\b rend} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reverse_iterator} {\b rbegin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reverse_iterator} {\b rend} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reverse_iterator} {\b crbegin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reverse_iterator} {\b crend} () const noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v const_iterator\:toml::discard_comments}
{\xe \v toml::discard_comments\:const_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::discard_comments::const_iterator} =  {\b detail::empty_iterator}<std::string, true>}}
\par
{\bkmkstart AAAAAAAAZG}
{\bkmkend AAAAAAAAZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v const_pointer\:toml::discard_comments}
{\xe \v toml::discard_comments\:const_pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::discard_comments::const_pointer} =  std::string const*}}
\par
{\bkmkstart AAAAAAAAZH}
{\bkmkend AAAAAAAAZH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v const_reference\:toml::discard_comments}
{\xe \v toml::discard_comments\:const_reference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::discard_comments::const_reference} =  std::string const&}}
\par
{\bkmkstart AAAAAAAAZI}
{\bkmkend AAAAAAAAZI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v const_reverse_iterator\:toml::discard_comments}
{\xe \v toml::discard_comments\:const_reverse_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::discard_comments::const_reverse_iterator} =  {\b detail::empty_iterator}<std::string, true>}}
\par
{\bkmkstart AAAAAAAAZJ}
{\bkmkend AAAAAAAAZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v difference_type\:toml::discard_comments}
{\xe \v toml::discard_comments\:difference_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::discard_comments::difference_type} =  std::ptrdiff_t}}
\par
{\bkmkstart AAAAAAAAZK}
{\bkmkend AAAAAAAAZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v iterator\:toml::discard_comments}
{\xe \v toml::discard_comments\:iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::discard_comments::iterator} =  {\b detail::empty_iterator}<std::string, false>}}
\par
{\bkmkstart AAAAAAAAZL}
{\bkmkend AAAAAAAAZL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pointer\:toml::discard_comments}
{\xe \v toml::discard_comments\:pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::discard_comments::pointer} =  std::string*}}
\par
{\bkmkstart AAAAAAAAZM}
{\bkmkend AAAAAAAAZM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reference\:toml::discard_comments}
{\xe \v toml::discard_comments\:reference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::discard_comments::reference} =  std::string&}}
\par
{\bkmkstart AAAAAAAAZN}
{\bkmkend AAAAAAAAZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reverse_iterator\:toml::discard_comments}
{\xe \v toml::discard_comments\:reverse_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::discard_comments::reverse_iterator} =  {\b detail::empty_iterator}<std::string, false>}}
\par
{\bkmkstart AAAAAAAAZO}
{\bkmkend AAAAAAAAZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size_type\:toml::discard_comments}
{\xe \v toml::discard_comments\:size_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::discard_comments::size_type} =  std::size_t}}
\par
{\bkmkstart AAAAAAAAZP}
{\bkmkend AAAAAAAAZP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value_type\:toml::discard_comments}
{\xe \v toml::discard_comments\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::discard_comments::value_type} =  std::string}}
\par
{\bkmkstart AAAAAAAAZQ}
{\bkmkend AAAAAAAAZQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v discard_comments\:toml::discard_comments}
{\xe \v toml::discard_comments\:discard_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::discard_comments::discard_comments (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAZR}
{\bkmkend AAAAAAAAZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~discard_comments\:toml::discard_comments}
{\xe \v toml::discard_comments\:~discard_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::discard_comments::~discard_comments (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAZS}
{\bkmkend AAAAAAAAZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v discard_comments\:toml::discard_comments}
{\xe \v toml::discard_comments\:discard_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::discard_comments::discard_comments ({\b discard_comments} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAZT}
{\bkmkend AAAAAAAAZT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v discard_comments\:toml::discard_comments}
{\xe \v toml::discard_comments\:discard_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::discard_comments::discard_comments ({\b discard_comments} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAZU}
{\bkmkend AAAAAAAAZU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v discard_comments\:toml::discard_comments}
{\xe \v toml::discard_comments\:discard_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::discard_comments::discard_comments (const std::vector< std::string > & ){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZV}
{\bkmkend AAAAAAAAZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v discard_comments\:toml::discard_comments}
{\xe \v toml::discard_comments\:discard_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::discard_comments::discard_comments (std::vector< std::string > && ){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZW}
{\bkmkend AAAAAAAAZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v discard_comments\:toml::discard_comments}
{\xe \v toml::discard_comments\:discard_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::discard_comments::discard_comments (const {\b preserve_comments} & ){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZX}
{\bkmkend AAAAAAAAZX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v discard_comments\:toml::discard_comments}
{\xe \v toml::discard_comments\:discard_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::discard_comments::discard_comments ({\b size_type} ){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZY}
{\bkmkend AAAAAAAAZY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v discard_comments\:toml::discard_comments}
{\xe \v toml::discard_comments\:discard_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::discard_comments::discard_comments ({\b size_type} , const std::string & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAAAZZ}
{\bkmkend AAAAAAAAZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v discard_comments\:toml::discard_comments}
{\xe \v toml::discard_comments\:discard_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::discard_comments::discard_comments (std::initializer_list< std::string > ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAA}
{\bkmkend AAAAAAABAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v discard_comments\:toml::discard_comments}
{\xe \v toml::discard_comments\:discard_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename InputIterator > toml::discard_comments::discard_comments (InputIterator , InputIterator ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAB}
{\bkmkend AAAAAAABAB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v assign\:toml::discard_comments}
{\xe \v toml::discard_comments\:assign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename InputIterator > void toml::discard_comments::assign (InputIterator , InputIterator ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAC}
{\bkmkend AAAAAAABAC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v assign\:toml::discard_comments}
{\xe \v toml::discard_comments\:assign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::discard_comments::assign ({\b size_type} , const std::string & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAD}
{\bkmkend AAAAAAABAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v assign\:toml::discard_comments}
{\xe \v toml::discard_comments\:assign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::discard_comments::assign (std::initializer_list< std::string > ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAE}
{\bkmkend AAAAAAABAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v at\:toml::discard_comments}
{\xe \v toml::discard_comments\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b reference} toml::discard_comments::at (const  {\i size_type}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAF}
{\bkmkend AAAAAAABAF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v at\:toml::discard_comments}
{\xe \v toml::discard_comments\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reference} toml::discard_comments::at (const  {\i size_type}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAG}
{\bkmkend AAAAAAABAG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v back\:toml::discard_comments}
{\xe \v toml::discard_comments\:back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reference} toml::discard_comments::back () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAH}
{\bkmkend AAAAAAABAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v back\:toml::discard_comments}
{\xe \v toml::discard_comments\:back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b reference} toml::discard_comments::back (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAI}
{\bkmkend AAAAAAABAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v begin\:toml::discard_comments}
{\xe \v toml::discard_comments\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::discard_comments::begin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAJ}
{\bkmkend AAAAAAABAJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v begin\:toml::discard_comments}
{\xe \v toml::discard_comments\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::discard_comments::begin (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAK}
{\bkmkend AAAAAAABAK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v capacity\:toml::discard_comments}
{\xe \v toml::discard_comments\:capacity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b size_type} toml::discard_comments::capacity () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAL}
{\bkmkend AAAAAAABAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v cbegin\:toml::discard_comments}
{\xe \v toml::discard_comments\:cbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::discard_comments::cbegin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAM}
{\bkmkend AAAAAAABAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v cend\:toml::discard_comments}
{\xe \v toml::discard_comments\:cend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::discard_comments::cend () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAN}
{\bkmkend AAAAAAABAN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v clear\:toml::discard_comments}
{\xe \v toml::discard_comments\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::discard_comments::clear (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAO}
{\bkmkend AAAAAAABAO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v crbegin\:toml::discard_comments}
{\xe \v toml::discard_comments\:crbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reverse_iterator} toml::discard_comments::crbegin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAP}
{\bkmkend AAAAAAABAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v crend\:toml::discard_comments}
{\xe \v toml::discard_comments\:crend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reverse_iterator} toml::discard_comments::crend () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAQ}
{\bkmkend AAAAAAABAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v data\:toml::discard_comments}
{\xe \v toml::discard_comments\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_pointer} toml::discard_comments::data () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAR}
{\bkmkend AAAAAAABAR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v data\:toml::discard_comments}
{\xe \v toml::discard_comments\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pointer} toml::discard_comments::data (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAS}
{\bkmkend AAAAAAABAS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v emplace\:toml::discard_comments}
{\xe \v toml::discard_comments\:emplace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ... Ts> {\b iterator} toml::discard_comments::emplace ({\b const_iterator} , Ts &&  {\i ...}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAT}
{\bkmkend AAAAAAABAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v emplace_back\:toml::discard_comments}
{\xe \v toml::discard_comments\:emplace_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ... Ts> void toml::discard_comments::emplace_back (Ts &&  {\i ...}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAU}
{\bkmkend AAAAAAABAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v empty\:toml::discard_comments}
{\xe \v toml::discard_comments\:empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::discard_comments::empty () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAV}
{\bkmkend AAAAAAABAV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v end\:toml::discard_comments}
{\xe \v toml::discard_comments\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::discard_comments::end () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAW}
{\bkmkend AAAAAAABAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v end\:toml::discard_comments}
{\xe \v toml::discard_comments\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::discard_comments::end (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABAX}
{\bkmkend AAAAAAABAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v erase\:toml::discard_comments}
{\xe \v toml::discard_comments\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::discard_comments::erase ({\b const_iterator} ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAY}
{\bkmkend AAAAAAABAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v erase\:toml::discard_comments}
{\xe \v toml::discard_comments\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::discard_comments::erase ({\b const_iterator} , {\b const_iterator} ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABAZ}
{\bkmkend AAAAAAABAZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v front\:toml::discard_comments}
{\xe \v toml::discard_comments\:front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reference} toml::discard_comments::front () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBA}
{\bkmkend AAAAAAABBA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v front\:toml::discard_comments}
{\xe \v toml::discard_comments\:front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b reference} toml::discard_comments::front (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBB}
{\bkmkend AAAAAAABBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v insert\:toml::discard_comments}
{\xe \v toml::discard_comments\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::discard_comments::insert ({\b const_iterator} , const std::string & ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBC}
{\bkmkend AAAAAAABBC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v insert\:toml::discard_comments}
{\xe \v toml::discard_comments\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename InputIterator > {\b iterator} toml::discard_comments::insert ({\b const_iterator} , InputIterator , InputIterator ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBD}
{\bkmkend AAAAAAABBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v insert\:toml::discard_comments}
{\xe \v toml::discard_comments\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::discard_comments::insert ({\b const_iterator} , {\b size_type} , const std::string & ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBE}
{\bkmkend AAAAAAABBE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v insert\:toml::discard_comments}
{\xe \v toml::discard_comments\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::discard_comments::insert ({\b const_iterator} , std::initializer_list< std::string > ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBF}
{\bkmkend AAAAAAABBF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v insert\:toml::discard_comments}
{\xe \v toml::discard_comments\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::discard_comments::insert ({\b const_iterator} , std::string && ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBG}
{\bkmkend AAAAAAABBG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v max_size\:toml::discard_comments}
{\xe \v toml::discard_comments\:max_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b size_type} toml::discard_comments::max_size () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBH}
{\bkmkend AAAAAAABBH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::discard_comments}
{\xe \v toml::discard_comments\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b discard_comments} & toml::discard_comments::operator= (const std::vector< std::string > & ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBI}
{\bkmkend AAAAAAABBI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::discard_comments}
{\xe \v toml::discard_comments\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b discard_comments} & toml::discard_comments::operator= ({\b discard_comments} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABBJ}
{\bkmkend AAAAAAABBJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::discard_comments}
{\xe \v toml::discard_comments\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b discard_comments} & toml::discard_comments::operator= ({\b discard_comments} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABBK}
{\bkmkend AAAAAAABBK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::discard_comments}
{\xe \v toml::discard_comments\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b discard_comments} & toml::discard_comments::operator= (std::vector< std::string > && ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBL}
{\bkmkend AAAAAAABBL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator[]\:toml::discard_comments}
{\xe \v toml::discard_comments\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reference} toml::discard_comments::operator[] (const  {\i size_type}) const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBM}
{\bkmkend AAAAAAABBM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator[]\:toml::discard_comments}
{\xe \v toml::discard_comments\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b reference} toml::discard_comments::operator[] (const  {\i size_type}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBN}
{\bkmkend AAAAAAABBN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pop_back\:toml::discard_comments}
{\xe \v toml::discard_comments\:pop_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::discard_comments::pop_back (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBO}
{\bkmkend AAAAAAABBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v push_back\:toml::discard_comments}
{\xe \v toml::discard_comments\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::discard_comments::push_back (const std::string & ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBP}
{\bkmkend AAAAAAABBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v push_back\:toml::discard_comments}
{\xe \v toml::discard_comments\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::discard_comments::push_back (std::string && ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBQ}
{\bkmkend AAAAAAABBQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rbegin\:toml::discard_comments}
{\xe \v toml::discard_comments\:rbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reverse_iterator} toml::discard_comments::rbegin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBR}
{\bkmkend AAAAAAABBR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rbegin\:toml::discard_comments}
{\xe \v toml::discard_comments\:rbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b reverse_iterator} toml::discard_comments::rbegin (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBS}
{\bkmkend AAAAAAABBS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rend\:toml::discard_comments}
{\xe \v toml::discard_comments\:rend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reverse_iterator} toml::discard_comments::rend () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBT}
{\bkmkend AAAAAAABBT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rend\:toml::discard_comments}
{\xe \v toml::discard_comments\:rend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b reverse_iterator} toml::discard_comments::rend (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBU}
{\bkmkend AAAAAAABBU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reserve\:toml::discard_comments}
{\xe \v toml::discard_comments\:reserve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::discard_comments::reserve ({\b size_type} ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBV}
{\bkmkend AAAAAAABBV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resize\:toml::discard_comments}
{\xe \v toml::discard_comments\:resize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::discard_comments::resize ({\b size_type} ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBW}
{\bkmkend AAAAAAABBW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resize\:toml::discard_comments}
{\xe \v toml::discard_comments\:resize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::discard_comments::resize ({\b size_type} , const std::string & ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBX}
{\bkmkend AAAAAAABBX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shrink_to_fit\:toml::discard_comments}
{\xe \v toml::discard_comments\:shrink_to_fit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::discard_comments::shrink_to_fit (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABBY}
{\bkmkend AAAAAAABBY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size\:toml::discard_comments}
{\xe \v toml::discard_comments\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b size_type} toml::discard_comments::size () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABBZ}
{\bkmkend AAAAAAABBZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v swap\:toml::discard_comments}
{\xe \v toml::discard_comments\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::discard_comments::swap ({\b discard_comments} & ){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABCA}
{\bkmkend AAAAAAABCA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b comments.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::disjunction<... > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::disjunction<... >}
{\xe \v toml::detail::disjunction<... >}
{\bkmkstart AAAAAAABXB}
{\bkmkend AAAAAAABXB}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::disjunction<... >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1disjunction.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::disjunction< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::disjunction< T >}
{\xe \v toml::detail::disjunction< T >}
{\bkmkstart AAAAAAABXC}
{\bkmkend AAAAAAABXC}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::disjunction< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1disjunction_3_01_t_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::disjunction< T, Ts... > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::disjunction< T, Ts... >}
{\xe \v toml::detail::disjunction< T, Ts... >}
{\bkmkstart AAAAAAABXD}
{\bkmkend AAAAAAABXD}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::disjunction< T, Ts... >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1disjunction_3_01_t_00_01_ts_8_8_8_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::either< Ts > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::either< Ts >}
{\xe \v toml::detail::either< Ts >}
{\bkmkstart AAAAAAABXE}
{\bkmkend AAAAAAABXE}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::either< Head > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::either< Head >}
{\xe \v toml::detail::either< Head >}
{\bkmkstart AAAAAAABXF}
{\bkmkend AAAAAAABXF}
\par
{
{\f2 #include <combinator.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b result}< {\b region}, {\b none_t} > {\b invoke} ({\b location} &loc)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v invoke\:toml::detail::either< Head >}
{\xe \v toml::detail::either< Head >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Head > static {\b result}< {\b region}, {\b none_t} > {\b toml::detail::either}< Head >::invoke ({\b location} &  {\i loc}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABXG}
{\bkmkend AAAAAAABXG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::either< Head, Tail... > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::either< Head, Tail... >}
{\xe \v toml::detail::either< Head, Tail... >}
{\bkmkstart AAAAAAABXH}
{\bkmkend AAAAAAABXH}
\par
{
{\f2 #include <combinator.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b result}< {\b region}, {\b none_t} > {\b invoke} ({\b location} &loc)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v invoke\:toml::detail::either< Head, Tail... >}
{\xe \v toml::detail::either< Head, Tail... >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Head , typename ... Tail> static {\b result}< {\b region}, {\b none_t} > {\b toml::detail::either}< Head, Tail... >::invoke ({\b location} &  {\i loc}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABXI}
{\bkmkend AAAAAAABXI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::empty_iterator< T, is_const > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >}
{\bkmkstart AAAAAAABXJ}
{\bkmkend AAAAAAABXJ}
\par
{
{\f2 #include <comments.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = T\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b reference_type} = typename std::conditional< is_const, T const  &, T & >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b pointer_type} = typename std::conditional< is_const, T const  *, T * >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b difference_type} = std::ptrdiff_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b iterator_category} = std::random_access_iterator_tag\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b empty_iterator} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~empty_iterator} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b empty_iterator} ({\b empty_iterator} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b empty_iterator} ({\b empty_iterator} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b empty_iterator} & {\b operator=} ({\b empty_iterator} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b empty_iterator} & {\b operator=} ({\b empty_iterator} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference_type} {\b operator*} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pointer_type} {\b operator->} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference_type} {\b operator[]} ({\b difference_type}) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b empty_iterator} & {\b operator++} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b empty_iterator} {\b operator++} (int) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b empty_iterator} & {\b operator--} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b empty_iterator} {\b operator--} (int) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b empty_iterator} & {\b operator+=} ({\b difference_type}) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b empty_iterator} & {\b operator-=} ({\b difference_type}) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b empty_iterator} {\b operator+} ({\b difference_type}) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b empty_iterator} {\b operator-} ({\b difference_type}) const noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v difference_type\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:difference_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> using {\b toml::detail::empty_iterator}< T, is_const >::difference_type =  std::ptrdiff_t}}
\par
{\bkmkstart AAAAAAABXK}
{\bkmkend AAAAAAABXK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v iterator_category\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:iterator_category}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> using {\b toml::detail::empty_iterator}< T, is_const >::iterator_category =  std::random_access_iterator_tag}}
\par
{\bkmkstart AAAAAAABXL}
{\bkmkend AAAAAAABXL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pointer_type\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:pointer_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> using {\b toml::detail::empty_iterator}< T, is_const >::pointer_type =  typename std::conditional<is_const, T const*, T*>::type}}
\par
{\bkmkstart AAAAAAABXM}
{\bkmkend AAAAAAABXM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reference_type\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:reference_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> using {\b toml::detail::empty_iterator}< T, is_const >::reference_type =  typename std::conditional<is_const, T const&, T&>::type}}
\par
{\bkmkstart AAAAAAABXN}
{\bkmkend AAAAAAABXN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value_type\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> using {\b toml::detail::empty_iterator}< T, is_const >::value_type =  T}}
\par
{\bkmkstart AAAAAAABXO}
{\bkmkend AAAAAAABXO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v empty_iterator\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:empty_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b toml::detail::empty_iterator}< T, is_const >::empty_iterator (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABXP}
{\bkmkend AAAAAAABXP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~empty_iterator\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:~empty_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b toml::detail::empty_iterator}< T, is_const >::~{\b empty_iterator} (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABXQ}
{\bkmkend AAAAAAABXQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v empty_iterator\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:empty_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b toml::detail::empty_iterator}< T, is_const >::empty_iterator ({\b empty_iterator}< T, is_const > const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABXR}
{\bkmkend AAAAAAABXR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v empty_iterator\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:empty_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b toml::detail::empty_iterator}< T, is_const >::empty_iterator ({\b empty_iterator}< T, is_const > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABXS}
{\bkmkend AAAAAAABXS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator*\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:operator*}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b reference_type} {\b toml::detail::empty_iterator}< T, is_const >::operator* () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABXT}
{\bkmkend AAAAAAABXT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator+\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b empty_iterator} {\b toml::detail::empty_iterator}< T, is_const >::operator+ ({\b difference_type} ) const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABXU}
{\bkmkend AAAAAAABXU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator++\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b empty_iterator} & {\b toml::detail::empty_iterator}< T, is_const >::operator++ (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABXV}
{\bkmkend AAAAAAABXV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator++\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b empty_iterator} {\b toml::detail::empty_iterator}< T, is_const >::operator++ (int ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABXW}
{\bkmkend AAAAAAABXW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator+=\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b empty_iterator} & {\b toml::detail::empty_iterator}< T, is_const >::operator+= ({\b difference_type} ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABXX}
{\bkmkend AAAAAAABXX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator-\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:operator-}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b empty_iterator} {\b toml::detail::empty_iterator}< T, is_const >::operator- ({\b difference_type} ) const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABXY}
{\bkmkend AAAAAAABXY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator--\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b empty_iterator} & {\b toml::detail::empty_iterator}< T, is_const >::operator-- (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABXZ}
{\bkmkend AAAAAAABXZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator--\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:operator--}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b empty_iterator} {\b toml::detail::empty_iterator}< T, is_const >::operator-- (int ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABYA}
{\bkmkend AAAAAAABYA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator-=\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:operator-=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b empty_iterator} & {\b toml::detail::empty_iterator}< T, is_const >::operator-= ({\b difference_type} ){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABYB}
{\bkmkend AAAAAAABYB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator->\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:operator->}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b pointer_type} {\b toml::detail::empty_iterator}< T, is_const >::operator-> () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABYC}
{\bkmkend AAAAAAABYC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b empty_iterator} & {\b toml::detail::empty_iterator}< T, is_const >::operator= ({\b empty_iterator}< T, is_const > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABYD}
{\bkmkend AAAAAAABYD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b empty_iterator} & {\b toml::detail::empty_iterator}< T, is_const >::operator= ({\b empty_iterator}< T, is_const > const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABYE}
{\bkmkend AAAAAAABYE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator[]\:toml::detail::empty_iterator< T, is_const >}
{\xe \v toml::detail::empty_iterator< T, is_const >\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , bool is_const> {\b reference_type} {\b toml::detail::empty_iterator}< T, is_const >::operator[] ({\b difference_type} ) const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABYF}
{\bkmkend AAAAAAABYF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b comments.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::enum_to_type< t, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::enum_to_type< t, Value >}
{\xe \v toml::detail::enum_to_type< t, Value >}
{\bkmkstart AAAAAAABYG}
{\bkmkend AAAAAAABYG}
\par
{
{\f2 #include <types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = void\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::enum_to_type< t, Value >}
{\xe \v toml::detail::enum_to_type< t, Value >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<{\b value_t} t, typename Value > using {\b toml::detail::enum_to_type}< t, Value >::type =  void}}
\par
{\bkmkstart AAAAAAABYH}
{\bkmkend AAAAAAABYH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::enum_to_type< value_t::array, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::enum_to_type< value_t::array, Value >}
{\xe \v toml::detail::enum_to_type< value_t::array, Value >}
{\bkmkstart AAAAAAABYI}
{\bkmkend AAAAAAABYI}
\par
{
{\f2 #include <types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = typename Value::array_type\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::enum_to_type< value_t::array, Value >}
{\xe \v toml::detail::enum_to_type< value_t::array, Value >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::detail::enum_to_type}< {\b value_t::array}, Value >::type =  typename Value::array_type}}
\par
{\bkmkstart AAAAAAABYJ}
{\bkmkend AAAAAAABYJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::enum_to_type< value_t::boolean, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::enum_to_type< value_t::boolean, Value >}
{\xe \v toml::detail::enum_to_type< value_t::boolean, Value >}
{\bkmkstart AAAAAAABYK}
{\bkmkend AAAAAAABYK}
\par
{
{\f2 #include <types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b boolean}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::enum_to_type< value_t::boolean, Value >}
{\xe \v toml::detail::enum_to_type< value_t::boolean, Value >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::detail::enum_to_type}< {\b value_t::boolean}, Value >::type =  {\b boolean}}}
\par
{\bkmkstart AAAAAAABYL}
{\bkmkend AAAAAAABYL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::enum_to_type< value_t::empty, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::enum_to_type< value_t::empty, Value >}
{\xe \v toml::detail::enum_to_type< value_t::empty, Value >}
{\bkmkstart AAAAAAABYM}
{\bkmkend AAAAAAABYM}
\par
{
{\f2 #include <types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = void\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::enum_to_type< value_t::empty, Value >}
{\xe \v toml::detail::enum_to_type< value_t::empty, Value >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::detail::enum_to_type}< {\b value_t::empty}, Value >::type =  void}}
\par
{\bkmkstart AAAAAAABYN}
{\bkmkend AAAAAAABYN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::enum_to_type< value_t::floating, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::enum_to_type< value_t::floating, Value >}
{\xe \v toml::detail::enum_to_type< value_t::floating, Value >}
{\bkmkstart AAAAAAABYO}
{\bkmkend AAAAAAABYO}
\par
{
{\f2 #include <types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b floating}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::enum_to_type< value_t::floating, Value >}
{\xe \v toml::detail::enum_to_type< value_t::floating, Value >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::detail::enum_to_type}< {\b value_t::floating}, Value >::type =  {\b floating}}}
\par
{\bkmkstart AAAAAAABYP}
{\bkmkend AAAAAAABYP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::enum_to_type< value_t::integer, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::enum_to_type< value_t::integer, Value >}
{\xe \v toml::detail::enum_to_type< value_t::integer, Value >}
{\bkmkstart AAAAAAABYQ}
{\bkmkend AAAAAAABYQ}
\par
{
{\f2 #include <types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b integer}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::enum_to_type< value_t::integer, Value >}
{\xe \v toml::detail::enum_to_type< value_t::integer, Value >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::detail::enum_to_type}< {\b value_t::integer}, Value >::type =  {\b integer}}}
\par
{\bkmkstart AAAAAAABYR}
{\bkmkend AAAAAAABYR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::enum_to_type< value_t::local_date, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::enum_to_type< value_t::local_date, Value >}
{\xe \v toml::detail::enum_to_type< value_t::local_date, Value >}
{\bkmkstart AAAAAAABYS}
{\bkmkend AAAAAAABYS}
\par
{
{\f2 #include <types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b local_date}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::enum_to_type< value_t::local_date, Value >}
{\xe \v toml::detail::enum_to_type< value_t::local_date, Value >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::detail::enum_to_type}< {\b value_t::local_date}, Value >::type =  {\b local_date}}}
\par
{\bkmkstart AAAAAAABYT}
{\bkmkend AAAAAAABYT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::enum_to_type< value_t::local_datetime, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::enum_to_type< value_t::local_datetime, Value >}
{\xe \v toml::detail::enum_to_type< value_t::local_datetime, Value >}
{\bkmkstart AAAAAAABYU}
{\bkmkend AAAAAAABYU}
\par
{
{\f2 #include <types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b local_datetime}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::enum_to_type< value_t::local_datetime, Value >}
{\xe \v toml::detail::enum_to_type< value_t::local_datetime, Value >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::detail::enum_to_type}< {\b value_t::local_datetime}, Value >::type =  {\b local_datetime}}}
\par
{\bkmkstart AAAAAAABYV}
{\bkmkend AAAAAAABYV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::enum_to_type< value_t::local_time, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::enum_to_type< value_t::local_time, Value >}
{\xe \v toml::detail::enum_to_type< value_t::local_time, Value >}
{\bkmkstart AAAAAAABYW}
{\bkmkend AAAAAAABYW}
\par
{
{\f2 #include <types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b local_time}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::enum_to_type< value_t::local_time, Value >}
{\xe \v toml::detail::enum_to_type< value_t::local_time, Value >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::detail::enum_to_type}< {\b value_t::local_time}, Value >::type =  {\b local_time}}}
\par
{\bkmkstart AAAAAAABYX}
{\bkmkend AAAAAAABYX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::enum_to_type< value_t::offset_datetime, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::enum_to_type< value_t::offset_datetime, Value >}
{\xe \v toml::detail::enum_to_type< value_t::offset_datetime, Value >}
{\bkmkstart AAAAAAABYY}
{\bkmkend AAAAAAABYY}
\par
{
{\f2 #include <types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b offset_datetime}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::enum_to_type< value_t::offset_datetime, Value >}
{\xe \v toml::detail::enum_to_type< value_t::offset_datetime, Value >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::detail::enum_to_type}< {\b value_t::offset_datetime}, Value >::type =  {\b offset_datetime}}}
\par
{\bkmkstart AAAAAAABYZ}
{\bkmkend AAAAAAABYZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::enum_to_type< value_t::string, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::enum_to_type< value_t::string, Value >}
{\xe \v toml::detail::enum_to_type< value_t::string, Value >}
{\bkmkstart AAAAAAABZA}
{\bkmkend AAAAAAABZA}
\par
{
{\f2 #include <types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = {\b string}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::enum_to_type< value_t::string, Value >}
{\xe \v toml::detail::enum_to_type< value_t::string, Value >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::detail::enum_to_type}< {\b value_t::string}, Value >::type =  {\b string}}}
\par
{\bkmkstart AAAAAAABZB}
{\bkmkend AAAAAAABZB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::enum_to_type< value_t::table, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::enum_to_type< value_t::table, Value >}
{\xe \v toml::detail::enum_to_type< value_t::table, Value >}
{\bkmkstart AAAAAAABZC}
{\bkmkend AAAAAAABZC}
\par
{
{\f2 #include <types.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = typename Value::table_type\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::enum_to_type< value_t::table, Value >}
{\xe \v toml::detail::enum_to_type< value_t::table, Value >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::detail::enum_to_type}< {\b value_t::table}, Value >::type =  typename Value::table_type}}
\par
{\bkmkstart AAAAAAABZD}
{\bkmkend AAAAAAABZD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::exactly< N > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::exactly< N >}
{\xe \v toml::detail::exactly< N >}
{\bkmkstart AAAAAAABZE}
{\bkmkend AAAAAAABZE}
\par
{
{\f2 #include <combinator.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::exception Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::exception}
{\xe \v toml::exception}
{\bkmkstart AAAAAAABCB}
{\bkmkend AAAAAAABCB}
\par
{
{\f2 #include <exception.hpp>}}\par
Inheritance diagram for toml::exception:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1exception.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b exception} (const {\b source_location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~exception} () noexcept override=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b what} () const noexcept override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b source_location} const & {\b location} () const noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b source_location} {\b loc_}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v exception\:toml::exception}
{\xe \v toml::exception\:exception}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::exception::exception (const {\b source_location} &  {\i loc}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABCC}
{\bkmkend AAAAAAABCC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~exception\:toml::exception}
{\xe \v toml::exception\:~exception}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual toml::exception::~exception (){\f2 [override]}, {\f2 [virtual]}, {\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCD}
{\bkmkend AAAAAAABCD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v location\:toml::exception}
{\xe \v toml::exception\:location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b source_location} const  & toml::exception::location () const{\f2 [inline]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCE}
{\bkmkend AAAAAAABCE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v what\:toml::exception}
{\xe \v toml::exception\:what}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual const char * toml::exception::what () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCF}
{\bkmkend AAAAAAABCF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b toml::syntax_error} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABCG \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b toml::type_error} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABCH \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b toml::internal_error} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABCI \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v loc_\:toml::exception}
{\xe \v toml::exception\:loc_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b source_location} toml::exception::loc_{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABCJ}
{\bkmkend AAAAAAABCJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b exception.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::exclude< Combinator > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::exclude< Combinator >}
{\xe \v toml::detail::exclude< Combinator >}
{\bkmkstart AAAAAAABZF}
{\bkmkend AAAAAAABZF}
\par
{
{\f2 #include <combinator.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b result}< {\b region}, {\b none_t} > {\b invoke} ({\b location} &loc)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v invoke\:toml::detail::exclude< Combinator >}
{\xe \v toml::detail::exclude< Combinator >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Combinator > static {\b result}< {\b region}, {\b none_t} > {\b toml::detail::exclude}< Combinator >::invoke ({\b location} &  {\i loc}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZG}
{\bkmkend AAAAAAABZG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EyeEnemy Class Reference\par \pard\plain 
{\tc\tcl2 \v EyeEnemy}
{\xe \v EyeEnemy}
{\bkmkstart AAAAAAAAFN}
{\bkmkend AAAAAAAAFN}
\par
{
{\f2 #include <EyeEnemy.hpp>}}\par
Inheritance diagram for EyeEnemy:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_eye_enemy.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b EyeEnemy} (sf::Vector2f startPosition, std::vector< sf::Sprite > moveSprites, std::vector< sf::Sprite > attackSprites, std::vector< sf::Sprite > takeDamageSprites, std::vector< sf::Sprite > deathSprites, float speed, float attack_distance, std::string enemyHitSound, int health=100)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'92\'D1\'80\'D0\'B0\'D0\'B3 - \'D0\'BB\'D0\'B5\'D1\'82\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B3\'D0\'BB\'D0\'B0\'D0\'B7 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b moveTowards} (sf::Vector2f position, sf::Time deltaTime)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D0\'B4\'D0\'B2\'D0\'B8\'D0\'B3\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B2\'D1\'80\'D0\'B0\'D0\'B3\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b hit} (int damage)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D0\'BF\'D0\'BE\'D0\'BB\'D1\'83\'D1\'87\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8F \'D1\'83\'D1\'80\'D0\'BE\'D0\'BD\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b calculateTowardsVector} (sf::Vector2f position) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D1\'80\'D0\'B0\'D1\'81\'D1\'87\'D0\'B5\'D1\'82\'D0\'B0 \'D0\'B2\'D0\'B5\'D0\'BA\'D1\'82\'D0\'BE\'D1\'80\'D0\'B0 \'D1\'82\'D1\'80\'D0\'B0\'D0\'B5\'D0\'BA\'D1\'82\'D0\'BE\'D1\'80\'D0\'B8\'D0\'B8 \'D0\'BA \'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8E }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getNextPosition} (sf::Time deltaTime, sf::Vector2f positionTowards) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D1\'80\'D0\'B0\'D1\'81\'D1\'87\'D0\'B5\'D1\'82\'D0\'B0 \'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8F \'D0\'B2\'D1\'80\'D0\'B0\'D0\'B3\'D0\'B0 \'D0\'B2 \'D1\'81\'D0\'BB\'D0\'B5\'D0\'B4\'D1\'83\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'BC\'D0\'BE\'D0\'BC\'D0\'B5\'D0\'BD\'D1\'82 \'D0\'B2\'D1\'80\'D0\'B5\'D0\'BC\'D0\'B5\'D0\'BD\'D0\'B8 (\'D0\'BD\'D1\'83\'D0\'B6\'D0\'B5\'D0\'BD \'D0\'B4\'D0\'BB\'D1\'8F \'D0\'BA\'D0\'BE\'D0\'BB\'D0\'BB\'D0\'B8\'D0\'B7\'D0\'B8\'D0\'B8) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} (sf::RenderTarget &surface, sf::RenderStates states) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GameObject} & {\b getEnemyObject} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 {\b GameObject} \'D0\'B2\'D1\'80\'D0\'B0\'D0\'B3\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getDead} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D1\'82\'D0\'B0\'D1\'82\'D1\'83\'D1\'81 \'D1\'81\'D0\'BC\'D0\'B5\'D1\'80\'D1\'82\'D0\'B8 \'D0\'B2\'D1\'80\'D0\'B0\'D0\'B3\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b canAttack} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'BF\'D1\'80\'D0\'BE\'D0\'B2\'D0\'B5\'D1\'80\'D0\'BA\'D0\'B0 \'D0\'B2\'D0\'BE\'D0\'B7\'D0\'BC\'D0\'BE\'D0\'B6\'D0\'BD\'D0\'BE\'D1\'81\'D1\'82\'D0\'B8 \'D0\'B0\'D1\'82\'D0\'B0\'D0\'BA\'D0\'BE\'D0\'B2\'D0\'B0\'D1\'82\'D1\'8C }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b attacked} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v EyeEnemy\:EyeEnemy}
{\xe \v EyeEnemy\:EyeEnemy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
EyeEnemy::EyeEnemy (sf::Vector2f  {\i startPosition}, std::vector< sf::Sprite >  {\i moveSprites}, std::vector< sf::Sprite >  {\i attackSprites}, std::vector< sf::Sprite >  {\i takeDamageSprites}, std::vector< sf::Sprite >  {\i deathSprites}, float  {\i speed}, float  {\i attack_distance}, std::string  {\i enemyHitSound}, int  {\i health} = {\f2 100})}}
\par
{\bkmkstart AAAAAAAAFO}
{\bkmkend AAAAAAAAFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'92\'D1\'80\'D0\'B0\'D0\'B3 - \'D0\'BB\'D0\'B5\'D1\'82\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B3\'D0\'BB\'D0\'B0\'D0\'B7 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i startPosition} \cell }{\'D0\'BD\'D0\'B0\'D1\'87\'D0\'B0\'D0\'BB\'D1\'8C\'D0\'BD\'D0\'BE\'D0\'B5 \'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i moveSprites} \cell }{\'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D1\'8B \'D0\'B4\'D0\'B2\'D0\'B8\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8F \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i attackSprites} \cell }{\'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D1\'8B \'D0\'B0\'D1\'82\'D0\'B0\'D0\'BA\'D0\'B8 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i takeDamageSprites} \cell }{\'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D1\'8B \'D0\'BF\'D0\'BE\'D0\'BB\'D1\'83\'D1\'87\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8F \'D1\'83\'D1\'80\'D0\'BE\'D0\'BD\'D0\'B0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i deathSprites} \cell }{\'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D1\'8B \'D1\'81\'D0\'BC\'D0\'B5\'D1\'80\'D1\'82\'D0\'B8 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i speed} \cell }{\'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D1\'8C \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D0\'B4\'D0\'B2\'D0\'B8\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8F \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i attack_distance} \cell }{\'D0\'B4\'D0\'B8\'D1\'81\'D1\'82\'D0\'B0\'D0\'BD\'D1\'86\'D0\'B8\'D1\'8F \'D1\'81 \'D0\'BA\'D0\'BE\'D1\'82\'D0\'BE\'D1\'80\'D0\'BE\'D0\'B9 \'D0\'BD\'D0\'B0\'D1\'87\'D0\'B8\'D0\'BD\'D0\'B0\'D0\'B5\'D1\'82\'D1\'81\'D1\'8F \'D0\'B0\'D1\'82\'D0\'B0\'D0\'BA\'D0\'B0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i enemyHitSound} \cell }{\'D0\'BD\'D0\'B0\'D0\'B7\'D0\'B2\'D0\'B0\'D0\'BD\'D0\'B8\'D0\'B5 \'D0\'B7\'D0\'B2\'D1\'83\'D0\'BA\'D0\'B0 \'D0\'BF\'D0\'BE\'D0\'BB\'D1\'83\'D1\'87\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8F \'D1\'83\'D1\'80\'D0\'BE\'D0\'BD\'D0\'B0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i health} \cell }{\'D0\'BD\'D0\'B0\'D1\'87\'D0\'B0\'D0\'BB\'D1\'8C\'D0\'BD\'D0\'BE\'D0\'B5 \'D0\'B7\'D0\'B4\'D0\'BE\'D1\'80\'D0\'BE\'D0\'B2\'D1\'8C\'D0\'B5 \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v attacked\:EyeEnemy}
{\xe \v EyeEnemy\:attacked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EyeEnemy::attacked ()}}
\par
{\bkmkstart AAAAAAAAFP}
{\bkmkend AAAAAAAAFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v calculateTowardsVector\:EyeEnemy}
{\xe \v EyeEnemy\:calculateTowardsVector}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Vector2f EyeEnemy::calculateTowardsVector (sf::Vector2f  {\i position}) const}}
\par
{\bkmkstart AAAAAAAAFQ}
{\bkmkend AAAAAAAAFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D1\'80\'D0\'B0\'D1\'81\'D1\'87\'D0\'B5\'D1\'82\'D0\'B0 \'D0\'B2\'D0\'B5\'D0\'BA\'D1\'82\'D0\'BE\'D1\'80\'D0\'B0 \'D1\'82\'D1\'80\'D0\'B0\'D0\'B5\'D0\'BA\'D1\'82\'D0\'BE\'D1\'80\'D0\'B8\'D0\'B8 \'D0\'BA \'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8E }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{\'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \'D0\'BA \'D0\'BA\'D0\'BE\'D1\'82\'D0\'BE\'D1\'80\'D0\'BE\'D0\'BC\'D1\'83 \'D1\'80\'D0\'B0\'D1\'81\'D1\'81\'D1\'87\'D0\'B8\'D1\'82\'D1\'8B\'D0\'B2\'D0\'B0\'D0\'B5\'D1\'82\'D1\'81\'D1\'8F \'D1\'82\'D1\'80\'D0\'B0\'D0\'B5\'D0\'BA\'D1\'82\'D0\'BE\'D1\'80\'D0\'B8\'D1\'8F \cell }
{\row }
}
}}
{\xe \v canAttack\:EyeEnemy}
{\xe \v EyeEnemy\:canAttack}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EyeEnemy::canAttack () const}}
\par
{\bkmkstart AAAAAAAAFR}
{\bkmkend AAAAAAAAFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'BF\'D1\'80\'D0\'BE\'D0\'B2\'D0\'B5\'D1\'80\'D0\'BA\'D0\'B0 \'D0\'B2\'D0\'BE\'D0\'B7\'D0\'BC\'D0\'BE\'D0\'B6\'D0\'BD\'D0\'BE\'D1\'81\'D1\'82\'D0\'B8 \'D0\'B0\'D1\'82\'D0\'B0\'D0\'BA\'D0\'BE\'D0\'B2\'D0\'B0\'D1\'82\'D1\'8C }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true \'D0\'B0\'D1\'82\'D0\'B0\'D0\'BA\'D0\'B0 \'D0\'B2\'D0\'BE\'D0\'B7\'D0\'BC\'D0\'BE\'D0\'B6\'D0\'BD\'D0\'B0 \par
false \'D0\'B0\'D1\'82\'D0\'B0\'D0\'BA\'D0\'B0 \'D0\'BD\'D0\'B5\'D0\'B2\'D0\'BE\'D0\'B7\'D0\'BC\'D0\'BE\'D0\'B6\'D0\'BD\'D0\'B0 \par
}}}}
{\xe \v draw\:EyeEnemy}
{\xe \v EyeEnemy\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EyeEnemy::draw (sf::RenderTarget &  {\i surface}, sf::RenderStates  {\i states}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAFS}
{\bkmkend AAAAAAAAFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getDead\:EyeEnemy}
{\xe \v EyeEnemy\:getDead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool EyeEnemy::getDead () const}}
\par
{\bkmkstart AAAAAAAAFT}
{\bkmkend AAAAAAAAFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D1\'82\'D0\'B0\'D1\'82\'D1\'83\'D1\'81 \'D1\'81\'D0\'BC\'D0\'B5\'D1\'80\'D1\'82\'D0\'B8 \'D0\'B2\'D1\'80\'D0\'B0\'D0\'B3\'D0\'B0 }}\par
}
{\xe \v getEnemyObject\:EyeEnemy}
{\xe \v EyeEnemy\:getEnemyObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GameObject} & EyeEnemy::getEnemyObject ()}}
\par
{\bkmkstart AAAAAAAAFU}
{\bkmkend AAAAAAAAFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 {\b GameObject} \'D0\'B2\'D1\'80\'D0\'B0\'D0\'B3\'D0\'B0 }}\par
}
{\xe \v getNextPosition\:EyeEnemy}
{\xe \v EyeEnemy\:getNextPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::FloatRect EyeEnemy::getNextPosition (sf::Time  {\i deltaTime}, sf::Vector2f  {\i positionTowards}) const}}
\par
{\bkmkstart AAAAAAAAFV}
{\bkmkend AAAAAAAAFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D1\'80\'D0\'B0\'D1\'81\'D1\'87\'D0\'B5\'D1\'82\'D0\'B0 \'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8F \'D0\'B2\'D1\'80\'D0\'B0\'D0\'B3\'D0\'B0 \'D0\'B2 \'D1\'81\'D0\'BB\'D0\'B5\'D0\'B4\'D1\'83\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'BC\'D0\'BE\'D0\'BC\'D0\'B5\'D0\'BD\'D1\'82 \'D0\'B2\'D1\'80\'D0\'B5\'D0\'BC\'D0\'B5\'D0\'BD\'D0\'B8 (\'D0\'BD\'D1\'83\'D0\'B6\'D0\'B5\'D0\'BD \'D0\'B4\'D0\'BB\'D1\'8F \'D0\'BA\'D0\'BE\'D0\'BB\'D0\'BB\'D0\'B8\'D0\'B7\'D0\'B8\'D0\'B8) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i deltaTime} \cell }{deltaTime \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i positionTowards} \cell }{\'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \'D0\'BA \'D0\'BA\'D0\'BE\'D1\'82\'D0\'BE\'D1\'80\'D0\'BE\'D0\'BC\'D1\'83 \'D0\'B4\'D0\'B2\'D0\'B8\'D0\'B6\'D0\'B5\'D1\'82\'D1\'81\'D1\'8F \'D0\'B2\'D1\'80\'D0\'B0\'D0\'B3 \cell }
{\row }
}
}}
{\xe \v hit\:EyeEnemy}
{\xe \v EyeEnemy\:hit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EyeEnemy::hit (int  {\i damage})}}
\par
{\bkmkstart AAAAAAAAFW}
{\bkmkend AAAAAAAAFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D0\'BF\'D0\'BE\'D0\'BB\'D1\'83\'D1\'87\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8F \'D1\'83\'D1\'80\'D0\'BE\'D0\'BD\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i damage} \cell }{\'D0\'BA\'D0\'BE\'D0\'BB\'D0\'B8\'D1\'87\'D0\'B5\'D1\'81\'D1\'82\'D0\'B2\'D0\'BE \'D0\'BF\'D0\'BE\'D0\'BB\'D1\'83\'D1\'87\'D0\'B5\'D0\'BD\'D0\'BD\'D0\'BE\'D0\'B3\'D0\'BE \'D1\'83\'D1\'80\'D0\'BE\'D0\'BD\'D0\'B0 \cell }
{\row }
}
}}
{\xe \v moveTowards\:EyeEnemy}
{\xe \v EyeEnemy\:moveTowards}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void EyeEnemy::moveTowards (sf::Vector2f  {\i position}, sf::Time  {\i deltaTime})}}
\par
{\bkmkstart AAAAAAAAFX}
{\bkmkend AAAAAAAAFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D0\'B4\'D0\'B2\'D0\'B8\'D0\'B3\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B2\'D1\'80\'D0\'B0\'D0\'B3\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i position} \cell }{\'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \'D0\'BA\'D1\'83\'D0\'B4\'D0\'B0 \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D0\'B4\'D0\'B2\'D0\'B8\'D0\'B3\'D0\'B0\'D1\'82\'D1\'8C\'D1\'81\'D1\'8F \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i deltaTime} \cell }{deltaTime \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Enemies/{\b EyeEnemy.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Enemies/{\b EyeEnemy.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::failure< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::failure< T >}
{\xe \v toml::failure< T >}
{\bkmkstart AAAAAAABCK}
{\bkmkend AAAAAAABCK}
\par
{
{\f2 #include <result.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = T\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b failure} (const {\b value_type} &v) noexcept(std::is_nothrow_copy_constructible< {\b value_type} >{\b ::value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b failure} ({\b value_type} &&v) noexcept(std::is_nothrow_move_constructible< {\b value_type} >{\b ::value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b failure} (U &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b failure} (const {\b failure}< U > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b failure} ({\b failure}< U > &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~failure} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b failure} (const {\b failure} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b failure} ({\b failure} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b failure} & {\b operator=} (const {\b failure} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b failure} & {\b operator=} ({\b failure} &&)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v value_type\:toml::failure< T >}
{\xe \v toml::failure< T >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b toml::failure}< T >::value_type =  T}}
\par
{\bkmkstart AAAAAAABCL}
{\bkmkend AAAAAAABCL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v failure\:toml::failure< T >}
{\xe \v toml::failure< T >\:failure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b toml::failure}< T >::failure (const {\b value_type} &  {\i v}){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCM}
{\bkmkend AAAAAAABCM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v failure\:toml::failure< T >}
{\xe \v toml::failure< T >\:failure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b toml::failure}< T >::failure ({\b value_type} &&  {\i v}){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCN}
{\bkmkend AAAAAAABCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v failure\:toml::failure< T >}
{\xe \v toml::failure< T >\:failure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename U > {\b toml::failure}< T >::failure (U &&  {\i v}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABCO}
{\bkmkend AAAAAAABCO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v failure\:toml::failure< T >}
{\xe \v toml::failure< T >\:failure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename U > {\b toml::failure}< T >::failure (const {\b failure}< U > &  {\i v}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABCP}
{\bkmkend AAAAAAABCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v failure\:toml::failure< T >}
{\xe \v toml::failure< T >\:failure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename U > {\b toml::failure}< T >::failure ({\b failure}< U > &&  {\i v}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABCQ}
{\bkmkend AAAAAAABCQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~failure\:toml::failure< T >}
{\xe \v toml::failure< T >\:~failure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b toml::failure}< T >::~{\b failure} (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABCR}
{\bkmkend AAAAAAABCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v failure\:toml::failure< T >}
{\xe \v toml::failure< T >\:failure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b toml::failure}< T >::failure (const {\b failure}< T > & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABCS}
{\bkmkend AAAAAAABCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v failure\:toml::failure< T >}
{\xe \v toml::failure< T >\:failure}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b toml::failure}< T >::failure ({\b failure}< T > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABCT}
{\bkmkend AAAAAAABCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:toml::failure< T >}
{\xe \v toml::failure< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b failure} & {\b toml::failure}< T >::operator= (const {\b failure}< T > & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABCU}
{\bkmkend AAAAAAABCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::failure< T >}
{\xe \v toml::failure< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b failure} & {\b toml::failure}< T >::operator= ({\b failure}< T > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABCV}
{\bkmkend AAAAAAABCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:toml::failure< T >}
{\xe \v toml::failure< T >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b value_type} {\b toml::failure}< T >::value}}
\par
{\bkmkstart AAAAAAABCW}
{\bkmkend AAAAAAABCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b result.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::from< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::from< T >}
{\xe \v toml::from< T >}
{\bkmkstart AAAAAAABCX}
{\bkmkend AAAAAAABCX}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b from.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Game Class Reference\par \pard\plain 
{\tc\tcl2 \v Game}
{\xe \v Game}
{\bkmkstart AAAAAAAAFY}
{\bkmkend AAAAAAAAFY}
\par
{
{\f2 #include <Game.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Game} (unsigned int h=600U, unsigned int w=800U)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D1\'81\'D0\'BE\'D0\'B7\'D0\'B4\'D0\'B0\'D1\'82\'D1\'8C \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82 \'D0\'98\'D0\'B3\'D1\'80\'D1\'8B, \'D1\'81 \'D0\'BE\'D0\'BA\'D0\'BD\'D0\'BE\'D0\'BC \'D1\'81 \'D1\'83\'D0\'BA\'D0\'B0\'D0\'B7\'D0\'B0\'D0\'BD\'D0\'BD\'D1\'8B\'D0\'BC\'D0\'B8 \'D1\'80\'D0\'B0\'D0\'B7\'D0\'BC\'D0\'B5\'D1\'80\'D0\'B0\'D0\'BC\'D0\'B8 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b run} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'B7\'D0\'B0\'D0\'BF\'D1\'83\'D1\'81\'D1\'82\'D0\'B8\'D1\'82\'D1\'8C \'D0\'B8\'D0\'B3\'D1\'80\'D1\'83 }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Game\:Game}
{\xe \v Game\:Game}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Game::Game (unsigned int  {\i h} = {\f2 600U}, unsigned int  {\i w} = {\f2 800U})}}
\par
{\bkmkstart AAAAAAAAFZ}
{\bkmkend AAAAAAAAFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D1\'81\'D0\'BE\'D0\'B7\'D0\'B4\'D0\'B0\'D1\'82\'D1\'8C \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82 \'D0\'98\'D0\'B3\'D1\'80\'D1\'8B, \'D1\'81 \'D0\'BE\'D0\'BA\'D0\'BD\'D0\'BE\'D0\'BC \'D1\'81 \'D1\'83\'D0\'BA\'D0\'B0\'D0\'B7\'D0\'B0\'D0\'BD\'D0\'BD\'D1\'8B\'D0\'BC\'D0\'B8 \'D1\'80\'D0\'B0\'D0\'B7\'D0\'BC\'D0\'B5\'D1\'80\'D0\'B0\'D0\'BC\'D0\'B8 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i h} \cell }{\'D0\'B2\'D1\'8B\'D1\'81\'D0\'BE\'D1\'82\'D0\'B0 \'D0\'BE\'D0\'BA\'D0\'BD\'D0\'B0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i w} \cell }{\'D1\'88\'D0\'B8\'D1\'80\'D0\'B8\'D0\'BD\'D0\'B0 \'D0\'BE\'D0\'BA\'D0\'BD\'D0\'B0 \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v run\:Game}
{\xe \v Game\:run}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Game::run ()}}
\par
{\bkmkstart AAAAAAAAGA}
{\bkmkend AAAAAAAAGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'B7\'D0\'B0\'D0\'BF\'D1\'83\'D1\'81\'D1\'82\'D0\'B8\'D1\'82\'D1\'8C \'D0\'B8\'D0\'B3\'D1\'80\'D1\'83 }}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Game/{\b Game.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Game/{\b Game.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GameObject Class Reference\par \pard\plain 
{\tc\tcl2 \v GameObject}
{\xe \v GameObject}
{\bkmkstart AAAAAAAAGB}
{\bkmkend AAAAAAAAGB}
\par
{
{\f2 #include <GameObject.hpp>}}\par
Inheritance diagram for GameObject:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_game_object.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GameObject} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GameObject} (const sf::Vector2f &cordinates, std::vector< sf::Sprite > &sprites_array, bool {\b isCollider}=false, float scale=1, sf::Vector2f boxCollider=\{0, 0\})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9A\'D0\'BB\'D0\'B0\'D1\'81\'D1\'81 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GameObject} (const sf::Vector2f &cordinates, const sf::Sprite &sprite, bool {\b isCollider}=false, float scale=1, sf::Vector2f boxCollider=\{0, 0\})\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9A\'D0\'BB\'D0\'B0\'D1\'81\'D1\'81 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} (sf::RenderTarget &surface, sf::RenderStates states) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b nextState} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D0\'BC\'D0\'B5\'D0\'BD\'D1\'8F\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82 \'D0\'B0\'D0\'BD\'D0\'B8\'D0\'BC\'D0\'B0\'D1\'86\'D0\'B8\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 \'D0\'BD\'D0\'B0 \'D1\'81\'D0\'BB\'D0\'B5\'D0\'B4\'D1\'83\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isCollider} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 bool - \'D1\'8F\'D0\'B2\'D0\'BB\'D1\'8F\'D0\'B5\'D1\'82\'D1\'81\'D1\'8F \'D0\'BB\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B9 \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 \'D0\'BA\'D0\'BE\'D0\'BB\'D0\'BB\'D0\'B0\'D0\'B9\'D0\'B4\'D0\'B5\'D1\'80\'D0\'BE\'D0\'BC }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetAnimation} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D1\'81\'D0\'B1\'D1\'80\'D0\'BE\'D1\'81\'D0\'B0 \'D0\'B0\'D0\'BD\'D0\'B8\'D0\'BC\'D0\'B0\'D1\'86\'D0\'B8\'D0\'B8 \'D0\'B4\'D0\'BE \'D0\'BD\'D0\'B0\'D1\'87\'D0\'B0\'D0\'BB\'D1\'8C\'D0\'BD\'D0\'BE\'D0\'B3\'D0\'BE \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b check_collision} ({\b GameObject} &other) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 bool - \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D1\'81\'D0\'B5\'D0\'BA\'D0\'BB\'D0\'B8\'D1\'81\'D1\'8C \'D0\'BB\'D0\'B8 \'D0\'B4\'D0\'B2\'D0\'B0 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D1\'8B\'D1\'85 \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b check_collision} (sf::FloatRect &otherFloatRect) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 bool - \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D1\'81\'D0\'B5\'D0\'BA\'D0\'BB\'D0\'B8\'D1\'81\'D1\'8C \'D0\'BB\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B9 \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82 \'D0\'B8 FloatRect. }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getGameObjectRect} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 FloatRect \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isLastAnimationState} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 bool - \'D1\'8F\'D0\'B2\'D0\'BB\'D1\'8F\'D0\'B5\'D1\'82\'D1\'81\'D1\'8F \'D0\'BB\'D0\'B8 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'83\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82 \'D0\'BF\'D0\'BE\'D1\'81\'D0\'BB\'D0\'B5\'D0\'B4\'D0\'BD\'D0\'B8\'D0\'BC \'D0\'B2 \'D0\'B0\'D0\'BD\'D0\'B8\'D0\'BC\'D0\'B0\'D1\'86\'D0\'B8\'D0\'B8 }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b m_scale}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b stopAtEnd} = false\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< sf::Sprite > {\b m_sprites_array}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Sprite {\b m_sprite}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\b GameObject} class have animation state which says what sprite index use to draw \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v GameObject\:GameObject}
{\xe \v GameObject\:GameObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GameObject::GameObject ()}}
\par
{\bkmkstart AAAAAAAAGC}
{\bkmkend AAAAAAAAGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v GameObject\:GameObject}
{\xe \v GameObject\:GameObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GameObject::GameObject (const sf::Vector2f &  {\i cordinates}, std::vector< sf::Sprite > &  {\i sprites_array}, bool  {\i isCollider} = {\f2 false}, float  {\i scale} = {\f2 1}, sf::Vector2f  {\i boxCollider} = {\f2 \{0,\~ 0\}})}}
\par
{\bkmkstart AAAAAAAAGD}
{\bkmkend AAAAAAAAGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9A\'D0\'BB\'D0\'B0\'D1\'81\'D1\'81 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cordinates} \cell }{\'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'B2\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sprites_array} \cell }{\'D0\'B2\'D0\'B5\'D0\'BA\'D1\'82\'D0\'BE\'D1\'80 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'BE\'D0\'B2(\'D0\'B4\'D0\'BB\'D1\'8F \'D0\'B0\'D0\'BD\'D0\'B8\'D0\'BC\'D0\'B0\'D1\'86\'D0\'B8\'D0\'B8) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i isCollider} \cell }{bool - \'D1\'8F\'D0\'B2\'D0\'BB\'D1\'8F\'D0\'B5\'D1\'82\'D1\'81\'D1\'8F \'D0\'BB\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B9 \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82 \'D0\'BA\'D0\'BE\'D0\'BB\'D0\'BB\'D0\'B0\'D0\'B9\'D0\'B4\'D0\'B5\'D1\'80\'D0\'BE\'D0\'BC \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i scale} \cell }{\'D0\'BA\'D0\'BE\'D1\'8D\'D1\'84\'D1\'84\'D0\'B8\'D1\'86\'D0\'B8\'D0\'B5\'D0\'BD\'D1\'82 \'D1\'83\'D0\'B2\'D0\'B5\'D0\'BB\'D0\'B8\'D1\'87\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8F \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'B0 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i boxCollider} \cell }{\'D1\'80\'D0\'B0\'D0\'B7\'D0\'BC\'D0\'B5\'D1\'80\'D1\'8B \'D0\'BA\'D0\'B2\'D0\'B0\'D0\'B4\'D1\'80\'D0\'B0\'D1\'82\'D0\'B0 \'D0\'BA\'D0\'BE\'D0\'BB\'D0\'BB\'D0\'B8\'D0\'B7\'D0\'B8\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 \cell }
{\row }
}
}}
{\xe \v GameObject\:GameObject}
{\xe \v GameObject\:GameObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
GameObject::GameObject (const sf::Vector2f &  {\i cordinates}, const sf::Sprite &  {\i sprite}, bool  {\i isCollider} = {\f2 false}, float  {\i scale} = {\f2 1}, sf::Vector2f  {\i boxCollider} = {\f2 \{0,\~ 0\}})}}
\par
{\bkmkstart AAAAAAAAGE}
{\bkmkend AAAAAAAAGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9A\'D0\'BB\'D0\'B0\'D1\'81\'D1\'81 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i cordinates} \cell }{\'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'B2\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i sprite} \cell }{\'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i isCollider} \cell }{bool - \'D1\'8F\'D0\'B2\'D0\'BB\'D1\'8F\'D0\'B5\'D1\'82\'D1\'81\'D1\'8F \'D0\'BB\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B9 \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82 \'D0\'BA\'D0\'BE\'D0\'BB\'D0\'BB\'D0\'B0\'D0\'B9\'D0\'B4\'D0\'B5\'D1\'80\'D0\'BE\'D0\'BC \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i scale} \cell }{\'D0\'BA\'D0\'BE\'D1\'8D\'D1\'84\'D1\'84\'D0\'B8\'D1\'86\'D0\'B8\'D0\'B5\'D0\'BD\'D1\'82 \'D1\'83\'D0\'B2\'D0\'B5\'D0\'BB\'D0\'B8\'D1\'87\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8F \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'B0 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i boxCollider} \cell }{\'D1\'80\'D0\'B0\'D0\'B7\'D0\'BC\'D0\'B5\'D1\'80\'D1\'8B \'D0\'BA\'D0\'B2\'D0\'B0\'D0\'B4\'D1\'80\'D0\'B0\'D1\'82\'D0\'B0 \'D0\'BA\'D0\'BE\'D0\'BB\'D0\'BB\'D0\'B8\'D0\'B7\'D0\'B8\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v check_collision\:GameObject}
{\xe \v GameObject\:check_collision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool GameObject::check_collision ({\b GameObject} &  {\i other}) const}}
\par
{\bkmkstart AAAAAAAAGF}
{\bkmkend AAAAAAAAGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 bool - \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D1\'81\'D0\'B5\'D0\'BA\'D0\'BB\'D0\'B8\'D1\'81\'D1\'8C \'D0\'BB\'D0\'B8 \'D0\'B4\'D0\'B2\'D0\'B0 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D1\'8B\'D1\'85 \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i other} \cell }{\'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B9 \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82 \'D1\'81 \'D0\'BA\'D0\'BE\'D1\'82\'D0\'BE\'D1\'80\'D1\'8B\'D0\'BC \'D0\'BF\'D1\'80\'D0\'BE\'D0\'B2\'D0\'B5\'D1\'80\'D1\'8F\'D0\'B5\'D0\'BC \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D1\'81\'D0\'B5\'D1\'87\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true \'D0\'B5\'D1\'81\'D1\'82\'D1\'8C \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D1\'81\'D0\'B5\'D1\'87\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \par
false \'D0\'BD\'D0\'B5\'D1\'82 \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D1\'81\'D0\'B5\'D1\'87\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8F \par
}}}}
{\xe \v check_collision\:GameObject}
{\xe \v GameObject\:check_collision}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool GameObject::check_collision (sf::FloatRect &  {\i otherFloatRect}) const}}
\par
{\bkmkstart AAAAAAAAGG}
{\bkmkend AAAAAAAAGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 bool - \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D1\'81\'D0\'B5\'D0\'BA\'D0\'BB\'D0\'B8\'D1\'81\'D1\'8C \'D0\'BB\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B9 \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82 \'D0\'B8 FloatRect. }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i otherFloatRect} \cell }{FloatRect \'D1\'81 \'D0\'BA\'D0\'BE\'D1\'82\'D0\'BE\'D1\'80\'D1\'8B\'D0\'BC \'D0\'BF\'D1\'80\'D0\'BE\'D0\'B2\'D0\'B5\'D1\'80\'D1\'8F\'D0\'B5\'D0\'BC \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D1\'81\'D0\'B5\'D1\'87\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D1\'81\'D0\'B5\'D1\'87\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \'D0\'B5\'D1\'81\'D1\'82\'D1\'8C \par
false \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D1\'81\'D0\'B5\'D1\'87\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8F \'D0\'BD\'D0\'B5\'D1\'82 \par
}}}}
{\xe \v draw\:GameObject}
{\xe \v GameObject\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GameObject::draw (sf::RenderTarget &  {\i surface}, sf::RenderStates  {\i states}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAGH}
{\bkmkend AAAAAAAAGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v getGameObjectRect\:GameObject}
{\xe \v GameObject\:getGameObjectRect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::FloatRect GameObject::getGameObjectRect () const}}
\par
{\bkmkstart AAAAAAAAGI}
{\bkmkend AAAAAAAAGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 FloatRect \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
sf::FloatRect \par
}}}}
{\xe \v isCollider\:GameObject}
{\xe \v GameObject\:isCollider}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool GameObject::isCollider () const}}
\par
{\bkmkstart AAAAAAAAGJ}
{\bkmkend AAAAAAAAGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 bool - \'D1\'8F\'D0\'B2\'D0\'BB\'D1\'8F\'D0\'B5\'D1\'82\'D1\'81\'D1\'8F \'D0\'BB\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B9 \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 \'D0\'BA\'D0\'BE\'D0\'BB\'D0\'BB\'D0\'B0\'D0\'B9\'D0\'B4\'D0\'B5\'D1\'80\'D0\'BE\'D0\'BC }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true \'D1\'8F\'D0\'B2\'D0\'BB\'D1\'8F\'D0\'B5\'D1\'82\'D1\'81\'D1\'8F \par
false \'D0\'BD\'D0\'B5 \'D1\'8F\'D0\'B2\'D0\'BB\'D1\'8F\'D0\'B5\'D1\'82\'D1\'81\'D1\'8F \par
}}}}
{\xe \v isLastAnimationState\:GameObject}
{\xe \v GameObject\:isLastAnimationState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool GameObject::isLastAnimationState () const}}
\par
{\bkmkstart AAAAAAAAGK}
{\bkmkend AAAAAAAAGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 bool - \'D1\'8F\'D0\'B2\'D0\'BB\'D1\'8F\'D0\'B5\'D1\'82\'D1\'81\'D1\'8F \'D0\'BB\'D0\'B8 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'83\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82 \'D0\'BF\'D0\'BE\'D1\'81\'D0\'BB\'D0\'B5\'D0\'B4\'D0\'BD\'D0\'B8\'D0\'BC \'D0\'B2 \'D0\'B0\'D0\'BD\'D0\'B8\'D0\'BC\'D0\'B0\'D1\'86\'D0\'B8\'D0\'B8 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true \'D0\'B4\'D0\'B0, \'D1\'8F\'D0\'B2\'D0\'BB\'D1\'8F\'D0\'B5\'D1\'82\'D1\'81\'D1\'8F \par
false \'D0\'BD\'D0\'B5\'D1\'82, \'D0\'BD\'D0\'B5 \'D1\'8F\'D0\'B2\'D0\'BB\'D1\'8F\'D0\'B5\'D1\'82\'D1\'81\'D1\'8F \par
}}}}
{\xe \v nextState\:GameObject}
{\xe \v GameObject\:nextState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GameObject::nextState ()}}
\par
{\bkmkstart AAAAAAAAGL}
{\bkmkend AAAAAAAAGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D0\'BC\'D0\'B5\'D0\'BD\'D1\'8F\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82 \'D0\'B0\'D0\'BD\'D0\'B8\'D0\'BC\'D0\'B0\'D1\'86\'D0\'B8\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'B2\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BE\'D0\'B1\'D1\'8A\'D0\'B5\'D0\'BA\'D1\'82\'D0\'B0 \'D0\'BD\'D0\'B0 \'D1\'81\'D0\'BB\'D0\'B5\'D0\'B4\'D1\'83\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 }}\par
}
{\xe \v resetAnimation\:GameObject}
{\xe \v GameObject\:resetAnimation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void GameObject::resetAnimation ()}}
\par
{\bkmkstart AAAAAAAAGM}
{\bkmkend AAAAAAAAGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D1\'81\'D0\'B1\'D1\'80\'D0\'BE\'D1\'81\'D0\'B0 \'D0\'B0\'D0\'BD\'D0\'B8\'D0\'BC\'D0\'B0\'D1\'86\'D0\'B8\'D0\'B8 \'D0\'B4\'D0\'BE \'D0\'BD\'D0\'B0\'D1\'87\'D0\'B0\'D0\'BB\'D1\'8C\'D0\'BD\'D0\'BE\'D0\'B3\'D0\'BE \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'B0 }}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_scale\:GameObject}
{\xe \v GameObject\:m_scale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float GameObject::m_scale}}
\par
{\bkmkstart AAAAAAAAGN}
{\bkmkend AAAAAAAAGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_sprite\:GameObject}
{\xe \v GameObject\:m_sprite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Sprite GameObject::m_sprite}}
\par
{\bkmkstart AAAAAAAAGO}
{\bkmkend AAAAAAAAGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v m_sprites_array\:GameObject}
{\xe \v GameObject\:m_sprites_array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector<sf::Sprite> GameObject::m_sprites_array}}
\par
{\bkmkstart AAAAAAAAGP}
{\bkmkend AAAAAAAAGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v stopAtEnd\:GameObject}
{\xe \v GameObject\:stopAtEnd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool GameObject::stopAtEnd = false}}
\par
{\bkmkstart AAAAAAAAGQ}
{\bkmkend AAAAAAAAGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GameObject/{\b GameObject.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
GameObject/{\b GameObject.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_from_toml_method< T, C, Tb, A > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_from_toml_method< T, C, Tb, A >}
{\xe \v toml::detail::has_from_toml_method< T, C, Tb, A >}
{\bkmkstart AAAAAAABZH}
{\bkmkend AAAAAAABZH}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::has_from_toml_method< T, C, Tb, A >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1has__from__toml__method.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_from_toml_method_impl Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_from_toml_method_impl}
{\xe \v toml::detail::has_from_toml_method_impl}
{\bkmkstart AAAAAAABZI}
{\bkmkend AAAAAAABZI}
\par
{
{\f2 #include <traits.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class Tb, template< typename ... > class A> static std::true_type {\b check} (decltype(std::declval< T >().from_toml(std::declval<{\b ::toml::basic_value}< C, Tb, A > >())) *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class Tb, template< typename ... > class A> static std::false_type {\b check} (...)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v check\:toml::detail::has_from_toml_method_impl}
{\xe \v toml::detail::has_from_toml_method_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class Tb, template< typename ... > class A> static std::false_type toml::detail::has_from_toml_method_impl::check (  {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZJ}
{\bkmkend AAAAAAABZJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v check\:toml::detail::has_from_toml_method_impl}
{\xe \v toml::detail::has_from_toml_method_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename C , template< typename ... > class Tb, template< typename ... > class A> static std::true_type toml::detail::has_from_toml_method_impl::check (decltype(std::declval< T >().from_toml(std::declval<{\b ::toml::basic_value}< C, Tb, A > >())) * ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZK}
{\bkmkend AAAAAAABZK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_into_toml_method< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_into_toml_method< T >}
{\xe \v toml::detail::has_into_toml_method< T >}
{\bkmkstart AAAAAAABZL}
{\bkmkend AAAAAAABZL}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::has_into_toml_method< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1has__into__toml__method.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_into_toml_method_impl Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_into_toml_method_impl}
{\xe \v toml::detail::has_into_toml_method_impl}
{\bkmkstart AAAAAAABZM}
{\bkmkend AAAAAAABZM}
\par
{
{\f2 #include <traits.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::true_type {\b check} (decltype(std::declval< T >().into_toml()) *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::false_type {\b check} (...)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v check\:toml::detail::has_into_toml_method_impl}
{\xe \v toml::detail::has_into_toml_method_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::false_type toml::detail::has_into_toml_method_impl::check (  {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZN}
{\bkmkend AAAAAAABZN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v check\:toml::detail::has_into_toml_method_impl}
{\xe \v toml::detail::has_into_toml_method_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::true_type toml::detail::has_into_toml_method_impl::check (decltype(std::declval< T >().into_toml()) * ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZO}
{\bkmkend AAAAAAABZO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_iterator< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_iterator< T >}
{\xe \v toml::detail::has_iterator< T >}
{\bkmkstart AAAAAAABZP}
{\bkmkend AAAAAAABZP}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::has_iterator< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1has__iterator.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T>\par
struct toml::detail::has_iterator< T >\par
}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Intel C++ compiler can not use decltype in parent class declaration, here is a hack to work around it. {\f2 https://stackoverflow.com/a/23953090/4692076} \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_iterator_impl Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_iterator_impl}
{\xe \v toml::detail::has_iterator_impl}
{\bkmkstart AAAAAAABZQ}
{\bkmkend AAAAAAABZQ}
\par
{
{\f2 #include <traits.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::true_type {\b check} (typename T::iterator *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::false_type {\b check} (...)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v check\:toml::detail::has_iterator_impl}
{\xe \v toml::detail::has_iterator_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::false_type toml::detail::has_iterator_impl::check (  {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZR}
{\bkmkend AAAAAAABZR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v check\:toml::detail::has_iterator_impl}
{\xe \v toml::detail::has_iterator_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::true_type toml::detail::has_iterator_impl::check (typename T::iterator * ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZS}
{\bkmkend AAAAAAABZS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_key_type< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_key_type< T >}
{\xe \v toml::detail::has_key_type< T >}
{\bkmkstart AAAAAAABZT}
{\bkmkend AAAAAAABZT}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::has_key_type< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1has__key__type.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_key_type_impl Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_key_type_impl}
{\xe \v toml::detail::has_key_type_impl}
{\bkmkstart AAAAAAABZU}
{\bkmkend AAAAAAABZU}
\par
{
{\f2 #include <traits.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::true_type {\b check} (typename T::key_type *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::false_type {\b check} (...)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v check\:toml::detail::has_key_type_impl}
{\xe \v toml::detail::has_key_type_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::false_type toml::detail::has_key_type_impl::check (  {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZV}
{\bkmkend AAAAAAABZV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v check\:toml::detail::has_key_type_impl}
{\xe \v toml::detail::has_key_type_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::true_type toml::detail::has_key_type_impl::check (typename T::key_type * ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZW}
{\bkmkend AAAAAAABZW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_mapped_type< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_mapped_type< T >}
{\xe \v toml::detail::has_mapped_type< T >}
{\bkmkstart AAAAAAABZX}
{\bkmkend AAAAAAABZX}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::has_mapped_type< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1has__mapped__type.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_mapped_type_impl Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_mapped_type_impl}
{\xe \v toml::detail::has_mapped_type_impl}
{\bkmkstart AAAAAAABZY}
{\bkmkend AAAAAAABZY}
\par
{
{\f2 #include <traits.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::true_type {\b check} (typename T::mapped_type *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::false_type {\b check} (...)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v check\:toml::detail::has_mapped_type_impl}
{\xe \v toml::detail::has_mapped_type_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::false_type toml::detail::has_mapped_type_impl::check (  {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAABZZ}
{\bkmkend AAAAAAABZZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v check\:toml::detail::has_mapped_type_impl}
{\xe \v toml::detail::has_mapped_type_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::true_type toml::detail::has_mapped_type_impl::check (typename T::mapped_type * ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAA}
{\bkmkend AAAAAAACAA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_push_back_method< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_push_back_method< T >}
{\xe \v toml::detail::has_push_back_method< T >}
{\bkmkstart AAAAAAACAB}
{\bkmkend AAAAAAACAB}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::has_push_back_method< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1has__push__back__method.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_push_back_method_impl Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_push_back_method_impl}
{\xe \v toml::detail::has_push_back_method_impl}
{\bkmkstart AAAAAAACAC}
{\bkmkend AAAAAAACAC}
\par
{
{\f2 #include <traits.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::false_type {\b check} (...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::true_type {\b check} (decltype(std::declval< T >().push_back(std::declval< typename T::value_type >())) *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v check\:toml::detail::has_push_back_method_impl}
{\xe \v toml::detail::has_push_back_method_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::false_type toml::detail::has_push_back_method_impl::check (  {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAD}
{\bkmkend AAAAAAACAD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v check\:toml::detail::has_push_back_method_impl}
{\xe \v toml::detail::has_push_back_method_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::true_type toml::detail::has_push_back_method_impl::check (decltype(std::declval< T >().push_back(std::declval< typename T::value_type >())) * ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAE}
{\bkmkend AAAAAAACAE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_reserve_method< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_reserve_method< T >}
{\xe \v toml::detail::has_reserve_method< T >}
{\bkmkstart AAAAAAACAF}
{\bkmkend AAAAAAACAF}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::has_reserve_method< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1has__reserve__method.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_reserve_method_impl Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_reserve_method_impl}
{\xe \v toml::detail::has_reserve_method_impl}
{\bkmkstart AAAAAAACAG}
{\bkmkend AAAAAAACAG}
\par
{
{\f2 #include <traits.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::false_type {\b check} (...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::true_type {\b check} (decltype(std::declval< T >().reserve(std::declval< std::size_t >())) *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v check\:toml::detail::has_reserve_method_impl}
{\xe \v toml::detail::has_reserve_method_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::false_type toml::detail::has_reserve_method_impl::check (  {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAH}
{\bkmkend AAAAAAACAH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v check\:toml::detail::has_reserve_method_impl}
{\xe \v toml::detail::has_reserve_method_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::true_type toml::detail::has_reserve_method_impl::check (decltype(std::declval< T >().reserve(std::declval< std::size_t >())) * ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAI}
{\bkmkend AAAAAAACAI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_specialized_from< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_specialized_from< T >}
{\xe \v toml::detail::has_specialized_from< T >}
{\bkmkstart AAAAAAACAJ}
{\bkmkend AAAAAAACAJ}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::has_specialized_from< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1has__specialized__from.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_specialized_from_impl Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_specialized_from_impl}
{\xe \v toml::detail::has_specialized_from_impl}
{\bkmkstart AAAAAAACAK}
{\bkmkend AAAAAAACAK}
\par
{
{\f2 #include <traits.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::false_type {\b check} (...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , std::size_t S = sizeof(::toml::from<T>)> static std::true_type {\b check} ({\b ::toml::from}< T > *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v check\:toml::detail::has_specialized_from_impl}
{\xe \v toml::detail::has_specialized_from_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::false_type toml::detail::has_specialized_from_impl::check (  {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAL}
{\bkmkend AAAAAAACAL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v check\:toml::detail::has_specialized_from_impl}
{\xe \v toml::detail::has_specialized_from_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , std::size_t S = sizeof(::toml::from<T>)> static std::true_type toml::detail::has_specialized_from_impl::check ({\b ::toml::from}< T > * ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAM}
{\bkmkend AAAAAAACAM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_specialized_into< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_specialized_into< T >}
{\xe \v toml::detail::has_specialized_into< T >}
{\bkmkstart AAAAAAACAN}
{\bkmkend AAAAAAACAN}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::has_specialized_into< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1has__specialized__into.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_specialized_into_impl Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_specialized_into_impl}
{\xe \v toml::detail::has_specialized_into_impl}
{\bkmkstart AAAAAAACAO}
{\bkmkend AAAAAAACAO}
\par
{
{\f2 #include <traits.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::false_type {\b check} (...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , std::size_t S = sizeof(::toml::into<T>)> static std::true_type {\b check} ({\b ::toml::from}< T > *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v check\:toml::detail::has_specialized_into_impl}
{\xe \v toml::detail::has_specialized_into_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::false_type toml::detail::has_specialized_into_impl::check (  {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAP}
{\bkmkend AAAAAAACAP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v check\:toml::detail::has_specialized_into_impl}
{\xe \v toml::detail::has_specialized_into_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , std::size_t S = sizeof(::toml::into<T>)> static std::true_type toml::detail::has_specialized_into_impl::check ({\b ::toml::from}< T > * ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAQ}
{\bkmkend AAAAAAACAQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_value_type< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_value_type< T >}
{\xe \v toml::detail::has_value_type< T >}
{\bkmkstart AAAAAAACAR}
{\bkmkend AAAAAAACAR}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::has_value_type< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1has__value__type.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::has_value_type_impl Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::has_value_type_impl}
{\xe \v toml::detail::has_value_type_impl}
{\bkmkstart AAAAAAACAS}
{\bkmkend AAAAAAACAS}
\par
{
{\f2 #include <traits.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::true_type {\b check} (typename T::value_type *)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::false_type {\b check} (...)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v check\:toml::detail::has_value_type_impl}
{\xe \v toml::detail::has_value_type_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::false_type toml::detail::has_value_type_impl::check (  {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAT}
{\bkmkend AAAAAAACAT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v check\:toml::detail::has_value_type_impl}
{\xe \v toml::detail::has_value_type_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::true_type toml::detail::has_value_type_impl::check (typename T::value_type * ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAU}
{\bkmkend AAAAAAACAU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::in_range< Low, Up > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::in_range< Low, Up >}
{\xe \v toml::detail::in_range< Low, Up >}
{\bkmkstart AAAAAAACAV}
{\bkmkend AAAAAAACAV}
\par
{
{\f2 #include <combinator.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b result}< {\b region}, {\b none_t} > {\b invoke} ({\b location} &loc)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr char {\b upper} = Up\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static constexpr char {\b lower} = Low\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v invoke\:toml::detail::in_range< Low, Up >}
{\xe \v toml::detail::in_range< Low, Up >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<char Low, char Up> static {\b result}< {\b region}, {\b none_t} > {\b toml::detail::in_range}< Low, Up >::invoke ({\b location} &  {\i loc}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACAW}
{\bkmkend AAAAAAACAW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v lower\:toml::detail::in_range< Low, Up >}
{\xe \v toml::detail::in_range< Low, Up >\:lower}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<char L, char U> constexpr char {\b toml::detail::in_range}< L, U >::lower = Low{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACAX}
{\bkmkend AAAAAAACAX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v upper\:toml::detail::in_range< Low, Up >}
{\xe \v toml::detail::in_range< Low, Up >\:upper}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<char L, char U> constexpr char {\b toml::detail::in_range}< L, U >::upper = Up{\f2 [static]}, {\f2 [constexpr]}}}
\par
{\bkmkstart AAAAAAACAY}
{\bkmkend AAAAAAACAY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::index_sequence< Ns > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::index_sequence< Ns >}
{\xe \v toml::detail::index_sequence< Ns >}
{\bkmkstart AAAAAAACAZ}
{\bkmkend AAAAAAACAZ}
\par
{
{\f2 #include <traits.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::index_sequence_maker< N > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::index_sequence_maker< N >}
{\xe \v toml::detail::index_sequence_maker< N >}
{\bkmkstart AAAAAAACBA}
{\bkmkend AAAAAAACBA}
\par
{
{\f2 #include <traits.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b push_back_index_sequence}< typenameindex_sequence_maker< N-1 >::type, N >::type {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::index_sequence_maker< N >}
{\xe \v toml::detail::index_sequence_maker< N >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::size_t N> typedef {\b push_back_index_sequence}<typenameindex_sequence_maker<N-1>::type,N>::type {\b toml::detail::index_sequence_maker}< N >::type}}
\par
{\bkmkstart AAAAAAACBB}
{\bkmkend AAAAAAACBB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::index_sequence_maker< 0 > Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::index_sequence_maker< 0 >}
{\xe \v toml::detail::index_sequence_maker< 0 >}
{\bkmkstart AAAAAAACBC}
{\bkmkend AAAAAAACBC}
\par
{
{\f2 #include <traits.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b index_sequence}< 0 > {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::index_sequence_maker< 0 >}
{\xe \v toml::detail::index_sequence_maker< 0 >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b index_sequence}<0> {\b toml::detail::index_sequence_maker}< 0 >::type}}
\par
{\bkmkstart AAAAAAACBD}
{\bkmkend AAAAAAACBD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::internal_error Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::internal_error}
{\xe \v toml::internal_error}
{\bkmkstart AAAAAAABCY}
{\bkmkend AAAAAAABCY}
\par
{
{\f2 #include <exception.hpp>}}\par
Inheritance diagram for toml::internal_error:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1internal__error.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b internal_error} (const std::string &what_arg, const {\b source_location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~internal_error} () noexcept override=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b what} () const noexcept override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b what_}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v internal_error\:toml::internal_error}
{\xe \v toml::internal_error\:internal_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::internal_error::internal_error (const std::string &  {\i what_arg}, const {\b source_location} &  {\i loc}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABCZ}
{\bkmkend AAAAAAABCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~internal_error\:toml::internal_error}
{\xe \v toml::internal_error\:~internal_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual toml::internal_error::~internal_error (){\f2 [override]}, {\f2 [virtual]}, {\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABDA}
{\bkmkend AAAAAAABDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v what\:toml::internal_error}
{\xe \v toml::internal_error\:what}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual const char * toml::internal_error::what () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCI}
{\bkmkend AAAAAAABCI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::exception} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABCF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v what_\:toml::internal_error}
{\xe \v toml::internal_error\:what_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::internal_error::what_{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABDB}
{\bkmkend AAAAAAABDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b exception.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::into< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::into< T >}
{\xe \v toml::into< T >}
{\bkmkstart AAAAAAABDC}
{\bkmkend AAAAAAABDC}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b into.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_basic_value< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_basic_value< T >}
{\xe \v toml::detail::is_basic_value< T >}
{\bkmkstart AAAAAAACBE}
{\bkmkend AAAAAAACBE}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_basic_value< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__basic__value.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_basic_value< T & > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_basic_value< T & >}
{\xe \v toml::detail::is_basic_value< T & >}
{\bkmkstart AAAAAAACBF}
{\bkmkend AAAAAAACBF}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_basic_value< T & >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__basic__value_3_01_t_01_6_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_basic_value< T const & > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_basic_value< T const & >}
{\xe \v toml::detail::is_basic_value< T const & >}
{\bkmkstart AAAAAAACBG}
{\bkmkend AAAAAAACBG}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_basic_value< T const & >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__basic__value_3_01_t_01const_01_6_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_basic_value< T const volatile & > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_basic_value< T const volatile & >}
{\xe \v toml::detail::is_basic_value< T const volatile & >}
{\bkmkstart AAAAAAACBH}
{\bkmkend AAAAAAACBH}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_basic_value< T const volatile & >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__basic__value_3_01_t_01const_01volatile_01_6_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_basic_value< T volatile & > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_basic_value< T volatile & >}
{\xe \v toml::detail::is_basic_value< T volatile & >}
{\bkmkstart AAAAAAACBI}
{\bkmkend AAAAAAACBI}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_basic_value< T volatile & >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__basic__value_3_01_t_01volatile_01_6_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_basic_value<::toml::basic_value< C, M, V > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_basic_value<::toml::basic_value< C, M, V > >}
{\xe \v toml::detail::is_basic_value<::toml::basic_value< C, M, V > >}
{\bkmkstart AAAAAAACBJ}
{\bkmkend AAAAAAACBJ}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_basic_value<::toml::basic_value< C, M, V > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__basic__value_3_1_1toml_1_1basic__value_3_01_c_00_01_m_00_01_v_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_chrono_duration< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_chrono_duration< T >}
{\xe \v toml::detail::is_chrono_duration< T >}
{\bkmkstart AAAAAAACBK}
{\bkmkend AAAAAAACBK}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_chrono_duration< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__chrono__duration.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_chrono_duration< std::chrono::duration< Rep, Period > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_chrono_duration< std::chrono::duration< Rep, Period > >}
{\xe \v toml::detail::is_chrono_duration< std::chrono::duration< Rep, Period > >}
{\bkmkstart AAAAAAACBL}
{\bkmkend AAAAAAACBL}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_chrono_duration< std::chrono::duration< Rep, Period > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__chrono__duration_3_01std_1_1chrono_1_1duration_3_01_rep_00_01_period_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_comparable< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_comparable< T >}
{\xe \v toml::detail::is_comparable< T >}
{\bkmkstart AAAAAAACBM}
{\bkmkend AAAAAAACBM}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_comparable< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__comparable.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_comparable_impl Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_comparable_impl}
{\xe \v toml::detail::is_comparable_impl}
{\bkmkstart AAAAAAACBN}
{\bkmkend AAAAAAACBN}
\par
{
{\f2 #include <traits.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::false_type {\b check} (...)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > static std::true_type {\b check} (decltype(std::declval< T >()< std::declval< T >()) *)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v check\:toml::detail::is_comparable_impl}
{\xe \v toml::detail::is_comparable_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::false_type toml::detail::is_comparable_impl::check (  {\i ...}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACBO}
{\bkmkend AAAAAAACBO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v check\:toml::detail::is_comparable_impl}
{\xe \v toml::detail::is_comparable_impl\:check}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static std::true_type toml::detail::is_comparable_impl::check (decltype(std::declval< T >()< std::declval< T >()) * ){\f2 [static]}}}
\par
{\bkmkstart AAAAAAACBP}
{\bkmkend AAAAAAACBP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_container< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_container< T >}
{\xe \v toml::detail::is_container< T >}
{\bkmkstart AAAAAAACBQ}
{\bkmkend AAAAAAACBQ}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_container< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__container.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_container< T & > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_container< T & >}
{\xe \v toml::detail::is_container< T & >}
{\bkmkstart AAAAAAACBR}
{\bkmkend AAAAAAACBR}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_container< T & >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__container_3_01_t_01_6_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_container< T const & > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_container< T const & >}
{\xe \v toml::detail::is_container< T const & >}
{\bkmkstart AAAAAAACBS}
{\bkmkend AAAAAAACBS}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_container< T const & >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__container_3_01_t_01const_01_6_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_container< T const volatile & > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_container< T const volatile & >}
{\xe \v toml::detail::is_container< T const volatile & >}
{\bkmkstart AAAAAAACBT}
{\bkmkend AAAAAAACBT}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_container< T const volatile & >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__container_3_01_t_01const_01volatile_01_6_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_container< T volatile & > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_container< T volatile & >}
{\xe \v toml::detail::is_container< T volatile & >}
{\bkmkstart AAAAAAACBU}
{\bkmkend AAAAAAACBU}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_container< T volatile & >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__container_3_01_t_01volatile_01_6_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_exact_toml_type< T, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_exact_toml_type< T, Value >}
{\xe \v toml::detail::is_exact_toml_type< T, Value >}
{\bkmkstart AAAAAAACBV}
{\bkmkend AAAAAAACBV}
\par
{
{\f2 #include <types.hpp>}}\par
Inheritance diagram for toml::detail::is_exact_toml_type< T, Value >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__exact__toml__type.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_exact_toml_type< T &, V > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_exact_toml_type< T &, V >}
{\xe \v toml::detail::is_exact_toml_type< T &, V >}
{\bkmkstart AAAAAAACBW}
{\bkmkend AAAAAAACBW}
\par
{
{\f2 #include <types.hpp>}}\par
Inheritance diagram for toml::detail::is_exact_toml_type< T &, V >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__exact__toml__type_3_01_t_01_6_00_01_v_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_exact_toml_type< T const &, V > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_exact_toml_type< T const &, V >}
{\xe \v toml::detail::is_exact_toml_type< T const &, V >}
{\bkmkstart AAAAAAACBX}
{\bkmkend AAAAAAACBX}
\par
{
{\f2 #include <types.hpp>}}\par
Inheritance diagram for toml::detail::is_exact_toml_type< T const &, V >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__exact__toml__type_3_01_t_01const_01_6_00_01_v_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_exact_toml_type< T const volatile &, V > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_exact_toml_type< T const volatile &, V >}
{\xe \v toml::detail::is_exact_toml_type< T const volatile &, V >}
{\bkmkstart AAAAAAACBY}
{\bkmkend AAAAAAACBY}
\par
{
{\f2 #include <types.hpp>}}\par
Inheritance diagram for toml::detail::is_exact_toml_type< T const volatile &, V >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__exact__toml__type_3_01_t_01const_01volatile_01_6_00_01_v_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_exact_toml_type< T volatile &, V > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_exact_toml_type< T volatile &, V >}
{\xe \v toml::detail::is_exact_toml_type< T volatile &, V >}
{\bkmkstart AAAAAAACBZ}
{\bkmkend AAAAAAACBZ}
\par
{
{\f2 #include <types.hpp>}}\par
Inheritance diagram for toml::detail::is_exact_toml_type< T volatile &, V >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__exact__toml__type_3_01_t_01volatile_01_6_00_01_v_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_map< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_map< T >}
{\xe \v toml::detail::is_map< T >}
{\bkmkstart AAAAAAACCA}
{\bkmkend AAAAAAACCA}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_map< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__map.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_map< T & > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_map< T & >}
{\xe \v toml::detail::is_map< T & >}
{\bkmkstart AAAAAAACCB}
{\bkmkend AAAAAAACCB}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_map< T & >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__map_3_01_t_01_6_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_map< T const & > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_map< T const & >}
{\xe \v toml::detail::is_map< T const & >}
{\bkmkstart AAAAAAACCC}
{\bkmkend AAAAAAACCC}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_map< T const & >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__map_3_01_t_01const_01_6_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_map< T const volatile & > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_map< T const volatile & >}
{\xe \v toml::detail::is_map< T const volatile & >}
{\bkmkstart AAAAAAACCD}
{\bkmkend AAAAAAACCD}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_map< T const volatile & >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__map_3_01_t_01const_01volatile_01_6_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_map< T volatile & > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_map< T volatile & >}
{\xe \v toml::detail::is_map< T volatile & >}
{\bkmkstart AAAAAAACCE}
{\bkmkend AAAAAAACCE}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_map< T volatile & >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__map_3_01_t_01volatile_01_6_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_std_forward_list< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_std_forward_list< T >}
{\xe \v toml::detail::is_std_forward_list< T >}
{\bkmkstart AAAAAAACCF}
{\bkmkend AAAAAAACCF}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_std_forward_list< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__std__forward__list.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_std_forward_list< std::forward_list< T > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_std_forward_list< std::forward_list< T > >}
{\xe \v toml::detail::is_std_forward_list< std::forward_list< T > >}
{\bkmkstart AAAAAAACCG}
{\bkmkend AAAAAAACCG}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_std_forward_list< std::forward_list< T > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__std__forward__list_3_01std_1_1forward__list_3_01_t_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_std_pair< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_std_pair< T >}
{\xe \v toml::detail::is_std_pair< T >}
{\bkmkstart AAAAAAACCH}
{\bkmkend AAAAAAACCH}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_std_pair< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__std__pair.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_std_pair< std::pair< T1, T2 > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_std_pair< std::pair< T1, T2 > >}
{\xe \v toml::detail::is_std_pair< std::pair< T1, T2 > >}
{\bkmkstart AAAAAAACCI}
{\bkmkend AAAAAAACCI}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_std_pair< std::pair< T1, T2 > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__std__pair_3_01std_1_1pair_3_01_t1_00_01_t2_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_std_tuple< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_std_tuple< T >}
{\xe \v toml::detail::is_std_tuple< T >}
{\bkmkstart AAAAAAACCJ}
{\bkmkend AAAAAAACCJ}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_std_tuple< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__std__tuple.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_std_tuple< std::tuple< Ts... > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_std_tuple< std::tuple< Ts... > >}
{\xe \v toml::detail::is_std_tuple< std::tuple< Ts... > >}
{\bkmkstart AAAAAAACCK}
{\bkmkend AAAAAAACCK}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_std_tuple< std::tuple< Ts... > >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__std__tuple_3_01std_1_1tuple_3_01_ts_8_8_8_01_4_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::is_string_literal< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::is_string_literal< T >}
{\xe \v toml::detail::is_string_literal< T >}
{\bkmkstart AAAAAAACCL}
{\bkmkend AAAAAAACCL}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::is_string_literal< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1is__string__literal.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::last_one_in_pack< T, Ts > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::last_one_in_pack< T, Ts >}
{\xe \v toml::detail::last_one_in_pack< T, Ts >}
{\bkmkstart AAAAAAACCM}
{\bkmkend AAAAAAACCM}
\par
{
{\f2 #include <utility.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = typename {\b last_one_in_pack}< Ts... >::type\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::last_one_in_pack< T, Ts >}
{\xe \v toml::detail::last_one_in_pack< T, Ts >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename ... Ts> using {\b toml::detail::last_one_in_pack}< T, Ts >::type =  typename {\b last_one_in_pack}<Ts...>::type}}
\par
{\bkmkstart AAAAAAACCN}
{\bkmkend AAAAAAACCN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b utility.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::last_one_in_pack< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::last_one_in_pack< T >}
{\xe \v toml::detail::last_one_in_pack< T >}
{\bkmkstart AAAAAAACCO}
{\bkmkend AAAAAAACCO}
\par
{
{\f2 #include <utility.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = T\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::last_one_in_pack< T >}
{\xe \v toml::detail::last_one_in_pack< T >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b toml::detail::last_one_in_pack}< T >::type =  T}}
\par
{\bkmkstart AAAAAAACCP}
{\bkmkend AAAAAAACCP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b utility.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::local_date Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::local_date}
{\xe \v toml::local_date}
{\bkmkstart AAAAAAABDD}
{\bkmkend AAAAAAABDD}
\par
{
{\f2 #include <datetime.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} (int y, {\b month_t} m, int d)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} (const std::tm &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} (const std::chrono::system_clock::time_point &tp)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} (const std::time_t t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::chrono::system_clock::time_point} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::time_t} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~local_date} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} ({\b local_date} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} ({\b local_date} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} & {\b operator=} ({\b local_date} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} & {\b operator=} ({\b local_date} &&)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::int16_t {\b year}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint8_t {\b month}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint8_t {\b day}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v local_date\:toml::local_date}
{\xe \v toml::local_date\:local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_date::local_date (int  {\i y}, {\b month_t}  {\i m}, int  {\i d}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDE}
{\bkmkend AAAAAAABDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_date\:toml::local_date}
{\xe \v toml::local_date\:local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_date::local_date (const std::tm &  {\i t}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABDF}
{\bkmkend AAAAAAABDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_date\:toml::local_date}
{\xe \v toml::local_date\:local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_date::local_date (const std::chrono::system_clock::time_point &  {\i tp}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABDG}
{\bkmkend AAAAAAABDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_date\:toml::local_date}
{\xe \v toml::local_date\:local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_date::local_date (const std::time_t  {\i t}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABDH}
{\bkmkend AAAAAAABDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_date\:toml::local_date}
{\xe \v toml::local_date\:local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_date::local_date (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABDI}
{\bkmkend AAAAAAABDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~local_date\:toml::local_date}
{\xe \v toml::local_date\:~local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_date::~local_date (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABDJ}
{\bkmkend AAAAAAABDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_date\:toml::local_date}
{\xe \v toml::local_date\:local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_date::local_date ({\b local_date} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABDK}
{\bkmkend AAAAAAABDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_date\:toml::local_date}
{\xe \v toml::local_date\:local_date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_date::local_date ({\b local_date} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABDL}
{\bkmkend AAAAAAABDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator std::chrono::system_clock::time_point\:toml::local_date}
{\xe \v toml::local_date\:operator std::chrono::system_clock::time_point}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_date::operator std::chrono::system_clock::time_point () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDM}
{\bkmkend AAAAAAABDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator std::time_t\:toml::local_date}
{\xe \v toml::local_date\:operator std::time_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_date::operator std::time_t () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDN}
{\bkmkend AAAAAAABDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::local_date}
{\xe \v toml::local_date\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b local_date} & toml::local_date::operator= ({\b local_date} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABDO}
{\bkmkend AAAAAAABDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::local_date}
{\xe \v toml::local_date\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b local_date} & toml::local_date::operator= ({\b local_date} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABDP}
{\bkmkend AAAAAAABDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v day\:toml::local_date}
{\xe \v toml::local_date\:day}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint8_t toml::local_date::day}}
\par
{\bkmkstart AAAAAAABDQ}
{\bkmkend AAAAAAABDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v month\:toml::local_date}
{\xe \v toml::local_date\:month}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint8_t toml::local_date::month}}
\par
{\bkmkstart AAAAAAABDR}
{\bkmkend AAAAAAABDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v year\:toml::local_date}
{\xe \v toml::local_date\:year}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::int16_t toml::local_date::year}}
\par
{\bkmkstart AAAAAAABDS}
{\bkmkend AAAAAAABDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b datetime.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::local_datetime Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::local_datetime}
{\xe \v toml::local_datetime}
{\bkmkstart AAAAAAABDT}
{\bkmkend AAAAAAABDT}
\par
{
{\f2 #include <datetime.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_datetime} ({\b local_date} d, {\b local_time} t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_datetime} (const std::tm &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_datetime} (const std::chrono::system_clock::time_point &tp)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_datetime} (const std::time_t t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::chrono::system_clock::time_point} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::time_t} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_datetime} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~local_datetime} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_datetime} ({\b local_datetime} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_datetime} ({\b local_datetime} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_datetime} & {\b operator=} ({\b local_datetime} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_datetime} & {\b operator=} ({\b local_datetime} &&)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} {\b date}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_time} {\b time}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v local_datetime\:toml::local_datetime}
{\xe \v toml::local_datetime\:local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_datetime::local_datetime ({\b local_date}  {\i d}, {\b local_time}  {\i t}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABDU}
{\bkmkend AAAAAAABDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_datetime\:toml::local_datetime}
{\xe \v toml::local_datetime\:local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_datetime::local_datetime (const std::tm &  {\i t}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABDV}
{\bkmkend AAAAAAABDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_datetime\:toml::local_datetime}
{\xe \v toml::local_datetime\:local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_datetime::local_datetime (const std::chrono::system_clock::time_point &  {\i tp}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABDW}
{\bkmkend AAAAAAABDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_datetime\:toml::local_datetime}
{\xe \v toml::local_datetime\:local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_datetime::local_datetime (const std::time_t  {\i t}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABDX}
{\bkmkend AAAAAAABDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_datetime\:toml::local_datetime}
{\xe \v toml::local_datetime\:local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_datetime::local_datetime (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABDY}
{\bkmkend AAAAAAABDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~local_datetime\:toml::local_datetime}
{\xe \v toml::local_datetime\:~local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_datetime::~local_datetime (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABDZ}
{\bkmkend AAAAAAABDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_datetime\:toml::local_datetime}
{\xe \v toml::local_datetime\:local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_datetime::local_datetime ({\b local_datetime} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABEA}
{\bkmkend AAAAAAABEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_datetime\:toml::local_datetime}
{\xe \v toml::local_datetime\:local_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_datetime::local_datetime ({\b local_datetime} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABEB}
{\bkmkend AAAAAAABEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator std::chrono::system_clock::time_point\:toml::local_datetime}
{\xe \v toml::local_datetime\:operator std::chrono::system_clock::time_point}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_datetime::operator std::chrono::system_clock::time_point () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEC}
{\bkmkend AAAAAAABEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator std::time_t\:toml::local_datetime}
{\xe \v toml::local_datetime\:operator std::time_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_datetime::operator std::time_t () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABED}
{\bkmkend AAAAAAABED}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::local_datetime}
{\xe \v toml::local_datetime\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b local_datetime} & toml::local_datetime::operator= ({\b local_datetime} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABEE}
{\bkmkend AAAAAAABEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::local_datetime}
{\xe \v toml::local_datetime\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b local_datetime} & toml::local_datetime::operator= ({\b local_datetime} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABEF}
{\bkmkend AAAAAAABEF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v date\:toml::local_datetime}
{\xe \v toml::local_datetime\:date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b local_date} toml::local_datetime::date}}
\par
{\bkmkstart AAAAAAABEG}
{\bkmkend AAAAAAABEG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v time\:toml::local_datetime}
{\xe \v toml::local_datetime\:time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b local_time} toml::local_datetime::time}}
\par
{\bkmkstart AAAAAAABEH}
{\bkmkend AAAAAAABEH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b datetime.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::local_time Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::local_time}
{\xe \v toml::local_time}
{\bkmkstart AAAAAAABEI}
{\bkmkend AAAAAAABEI}
\par
{
{\f2 #include <datetime.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_time} (int h, int m, int s, int ms=0, int us=0, int ns=0)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_time} (const std::tm &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Rep , typename Period > {\b local_time} (const std::chrono::duration< Rep, Period > &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::chrono::nanoseconds} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_time} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~local_time} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_time} ({\b local_time} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_time} ({\b local_time} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_time} & {\b operator=} ({\b local_time} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_time} & {\b operator=} ({\b local_time} &&)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint8_t {\b hour}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint8_t {\b minute}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint8_t {\b second}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint16_t {\b millisecond}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint16_t {\b microsecond}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint16_t {\b nanosecond}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v local_time\:toml::local_time}
{\xe \v toml::local_time\:local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_time::local_time (int  {\i h}, int  {\i m}, int  {\i s}, int  {\i ms} = {\f2 0}, int  {\i us} = {\f2 0}, int  {\i ns} = {\f2 0}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEJ}
{\bkmkend AAAAAAABEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_time\:toml::local_time}
{\xe \v toml::local_time\:local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_time::local_time (const std::tm &  {\i t}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABEK}
{\bkmkend AAAAAAABEK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_time\:toml::local_time}
{\xe \v toml::local_time\:local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Rep , typename Period > toml::local_time::local_time (const std::chrono::duration< Rep, Period > &  {\i t}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABEL}
{\bkmkend AAAAAAABEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_time\:toml::local_time}
{\xe \v toml::local_time\:local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_time::local_time (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABEM}
{\bkmkend AAAAAAABEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~local_time\:toml::local_time}
{\xe \v toml::local_time\:~local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_time::~local_time (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABEN}
{\bkmkend AAAAAAABEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_time\:toml::local_time}
{\xe \v toml::local_time\:local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_time::local_time ({\b local_time} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABEO}
{\bkmkend AAAAAAABEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_time\:toml::local_time}
{\xe \v toml::local_time\:local_time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_time::local_time ({\b local_time} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABEP}
{\bkmkend AAAAAAABEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator std::chrono::nanoseconds\:toml::local_time}
{\xe \v toml::local_time\:operator std::chrono::nanoseconds}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::local_time::operator std::chrono::nanoseconds () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABEQ}
{\bkmkend AAAAAAABEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::local_time}
{\xe \v toml::local_time\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b local_time} & toml::local_time::operator= ({\b local_time} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABER}
{\bkmkend AAAAAAABER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::local_time}
{\xe \v toml::local_time\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b local_time} & toml::local_time::operator= ({\b local_time} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABES}
{\bkmkend AAAAAAABES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v hour\:toml::local_time}
{\xe \v toml::local_time\:hour}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint8_t toml::local_time::hour}}
\par
{\bkmkstart AAAAAAABET}
{\bkmkend AAAAAAABET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v microsecond\:toml::local_time}
{\xe \v toml::local_time\:microsecond}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint16_t toml::local_time::microsecond}}
\par
{\bkmkstart AAAAAAABEU}
{\bkmkend AAAAAAABEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v millisecond\:toml::local_time}
{\xe \v toml::local_time\:millisecond}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint16_t toml::local_time::millisecond}}
\par
{\bkmkstart AAAAAAABEV}
{\bkmkend AAAAAAABEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v minute\:toml::local_time}
{\xe \v toml::local_time\:minute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint8_t toml::local_time::minute}}
\par
{\bkmkstart AAAAAAABEW}
{\bkmkend AAAAAAABEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v nanosecond\:toml::local_time}
{\xe \v toml::local_time\:nanosecond}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint16_t toml::local_time::nanosecond}}
\par
{\bkmkstart AAAAAAABEX}
{\bkmkend AAAAAAABEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v second\:toml::local_time}
{\xe \v toml::local_time\:second}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint8_t toml::local_time::second}}
\par
{\bkmkstart AAAAAAABEY}
{\bkmkend AAAAAAABEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b datetime.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::location Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::location}
{\xe \v toml::detail::location}
{\bkmkstart AAAAAAACCQ}
{\bkmkend AAAAAAACCQ}
\par
{
{\f2 #include <region.hpp>}}\par
Inheritance diagram for toml::detail::location:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1location.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b const_iterator} = typename std::vector< char >::const_iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b difference_type} = typename const_iterator::difference_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b source_ptr} = std::shared_ptr< const std::vector< char > >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b location} (std::string source_name, std::vector< char > cont)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b location} (std::string source_name, const std::string &cont)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b location} (const {\b location} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b location} ({\b location} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b location} & {\b operator=} (const {\b location} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b location} & {\b operator=} ({\b location} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~location} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_ok} () const noexcept override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b front} () const noexcept override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b const_iterator} {\b iter} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b begin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b end} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b advance} ({\b difference_type} n=1) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b retrace} ({\b difference_type} n=1) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reset} ({\b const_iterator} rollback) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b str} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b name} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b line_num} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b line} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b line_begin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b line_end} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b size} () const noexcept override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b before} () const noexcept override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b after} () const noexcept override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b source_ptr} const & {\b source} () const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b source_ptr} && {\b source} () &&noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v const_iterator\:toml::detail::location}
{\xe \v toml::detail::location\:const_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::location::const_iterator} =  typename std::vector<char>::const_iterator}}
\par
{\bkmkstart AAAAAAACCR}
{\bkmkend AAAAAAACCR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v difference_type\:toml::detail::location}
{\xe \v toml::detail::location\:difference_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::location::difference_type} =  typename const_iterator::difference_type}}
\par
{\bkmkstart AAAAAAACCS}
{\bkmkend AAAAAAACCS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v source_ptr\:toml::detail::location}
{\xe \v toml::detail::location\:source_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::location::source_ptr} =  std::shared_ptr<const std::vector<char> >}}
\par
{\bkmkstart AAAAAAACCT}
{\bkmkend AAAAAAACCT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v location\:toml::detail::location}
{\xe \v toml::detail::location\:location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::location::location (std::string  {\i source_name}, std::vector< char >  {\i cont}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCU}
{\bkmkend AAAAAAACCU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v location\:toml::detail::location}
{\xe \v toml::detail::location\:location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::location::location (std::string  {\i source_name}, const std::string &  {\i cont}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACCV}
{\bkmkend AAAAAAACCV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v location\:toml::detail::location}
{\xe \v toml::detail::location\:location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::location::location (const {\b location} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACCW}
{\bkmkend AAAAAAACCW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v location\:toml::detail::location}
{\xe \v toml::detail::location\:location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::location::location ({\b location} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACCX}
{\bkmkend AAAAAAACCX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~location\:toml::detail::location}
{\xe \v toml::detail::location\:~location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::location::~location (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACCY}
{\bkmkend AAAAAAACCY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v advance\:toml::detail::location}
{\xe \v toml::detail::location\:advance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::detail::location::advance ({\b difference_type}  {\i n} = {\f2 1}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACCZ}
{\bkmkend AAAAAAACCZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v after\:toml::detail::location}
{\xe \v toml::detail::location\:after}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t toml::detail::location::after () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDA}
{\bkmkend AAAAAAACDA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v before\:toml::detail::location}
{\xe \v toml::detail::location\:before}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t toml::detail::location::before () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDC}
{\bkmkend AAAAAAACDC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v begin\:toml::detail::location}
{\xe \v toml::detail::location\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::detail::location::begin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDE}
{\bkmkend AAAAAAACDE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v end\:toml::detail::location}
{\xe \v toml::detail::location\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::detail::location::end () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDF}
{\bkmkend AAAAAAACDF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v front\:toml::detail::location}
{\xe \v toml::detail::location\:front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char toml::detail::location::front () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDG}
{\bkmkend AAAAAAACDG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v is_ok\:toml::detail::location}
{\xe \v toml::detail::location\:is_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::detail::location::is_ok () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDI}
{\bkmkend AAAAAAACDI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v iter\:toml::detail::location}
{\xe \v toml::detail::location\:iter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b const_iterator} toml::detail::location::iter () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDK}
{\bkmkend AAAAAAACDK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v line\:toml::detail::location}
{\xe \v toml::detail::location\:line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::detail::location::line () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDL}
{\bkmkend AAAAAAACDL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v line_begin\:toml::detail::location}
{\xe \v toml::detail::location\:line_begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::detail::location::line_begin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDN}
{\bkmkend AAAAAAACDN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v line_end\:toml::detail::location}
{\xe \v toml::detail::location\:line_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::detail::location::line_end () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDO}
{\bkmkend AAAAAAACDO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v line_num\:toml::detail::location}
{\xe \v toml::detail::location\:line_num}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::detail::location::line_num () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDP}
{\bkmkend AAAAAAACDP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v name\:toml::detail::location}
{\xe \v toml::detail::location\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::detail::location::name () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDR}
{\bkmkend AAAAAAACDR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v operator=\:toml::detail::location}
{\xe \v toml::detail::location\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b location} & toml::detail::location::operator= (const {\b location} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACDT}
{\bkmkend AAAAAAACDT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::detail::location}
{\xe \v toml::detail::location\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b location} & toml::detail::location::operator= ({\b location} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACDU}
{\bkmkend AAAAAAACDU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reset\:toml::detail::location}
{\xe \v toml::detail::location\:reset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::detail::location::reset ({\b const_iterator}  {\i rollback}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDV}
{\bkmkend AAAAAAACDV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v retrace\:toml::detail::location}
{\xe \v toml::detail::location\:retrace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::detail::location::retrace ({\b difference_type}  {\i n} = {\f2 1}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDW}
{\bkmkend AAAAAAACDW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size\:toml::detail::location}
{\xe \v toml::detail::location\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t toml::detail::location::size () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDX}
{\bkmkend AAAAAAACDX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v source\:toml::detail::location}
{\xe \v toml::detail::location\:source}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b source_ptr} && toml::detail::location::source () &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDZ}
{\bkmkend AAAAAAACDZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v source\:toml::detail::location}
{\xe \v toml::detail::location\:source}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b source_ptr} const  & toml::detail::location::source () const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACEA}
{\bkmkend AAAAAAACEA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v str\:toml::detail::location}
{\xe \v toml::detail::location\:str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::detail::location::str () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACEB}
{\bkmkend AAAAAAACEB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACEC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b region.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::maybe< Combinator > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::maybe< Combinator >}
{\xe \v toml::detail::maybe< Combinator >}
{\bkmkstart AAAAAAACED}
{\bkmkend AAAAAAACED}
\par
{
{\f2 #include <combinator.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b result}< {\b region}, {\b none_t} > {\b invoke} ({\b location} &loc)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v invoke\:toml::detail::maybe< Combinator >}
{\xe \v toml::detail::maybe< Combinator >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Combinator > static {\b result}< {\b region}, {\b none_t} > {\b toml::detail::maybe}< Combinator >::invoke ({\b location} &  {\i loc}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACEE}
{\bkmkend AAAAAAACEE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::negation< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::negation< T >}
{\xe \v toml::detail::negation< T >}
{\bkmkstart AAAAAAACEF}
{\bkmkend AAAAAAACEF}
\par
{
{\f2 #include <traits.hpp>}}\par
Inheritance diagram for toml::detail::negation< T >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1negation.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::none_t Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::none_t}
{\xe \v toml::detail::none_t}
{\bkmkstart AAAAAAACEG}
{\bkmkend AAAAAAACEG}
\par
{
{\f2 #include <result.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b result.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::offset_datetime Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::offset_datetime}
{\xe \v toml::offset_datetime}
{\bkmkstart AAAAAAABEZ}
{\bkmkend AAAAAAABEZ}
\par
{
{\f2 #include <datetime.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} ({\b local_date} d, {\b local_time} t, {\b time_offset} o)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} (const {\b local_datetime} &dt, {\b time_offset} o)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} (const {\b local_datetime} &ld)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} (const std::chrono::system_clock::time_point &tp)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} (const std::time_t &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} (const std::tm &t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::chrono::system_clock::time_point} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::time_t} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~offset_datetime} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} ({\b offset_datetime} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} ({\b offset_datetime} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} & {\b operator=} ({\b offset_datetime} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b offset_datetime} & {\b operator=} ({\b offset_datetime} &&)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_date} {\b date}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b local_time} {\b time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b time_offset} {\b offset}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v offset_datetime\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::offset_datetime::offset_datetime ({\b local_date}  {\i d}, {\b local_time}  {\i t}, {\b time_offset}  {\i o}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFA}
{\bkmkend AAAAAAABFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v offset_datetime\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::offset_datetime::offset_datetime (const {\b local_datetime} &  {\i dt}, {\b time_offset}  {\i o}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFB}
{\bkmkend AAAAAAABFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v offset_datetime\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::offset_datetime::offset_datetime (const {\b local_datetime} &  {\i ld}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABFC}
{\bkmkend AAAAAAABFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v offset_datetime\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::offset_datetime::offset_datetime (const std::chrono::system_clock::time_point &  {\i tp}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABFD}
{\bkmkend AAAAAAABFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v offset_datetime\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::offset_datetime::offset_datetime (const std::time_t &  {\i t}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABFE}
{\bkmkend AAAAAAABFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v offset_datetime\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::offset_datetime::offset_datetime (const std::tm &  {\i t}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABFF}
{\bkmkend AAAAAAABFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v offset_datetime\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::offset_datetime::offset_datetime (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABFG}
{\bkmkend AAAAAAABFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~offset_datetime\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:~offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::offset_datetime::~offset_datetime (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABFH}
{\bkmkend AAAAAAABFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v offset_datetime\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::offset_datetime::offset_datetime ({\b offset_datetime} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABFI}
{\bkmkend AAAAAAABFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v offset_datetime\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:offset_datetime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::offset_datetime::offset_datetime ({\b offset_datetime} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABFJ}
{\bkmkend AAAAAAABFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator std::chrono::system_clock::time_point\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:operator std::chrono::system_clock::time_point}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::offset_datetime::operator std::chrono::system_clock::time_point () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFK}
{\bkmkend AAAAAAABFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator std::time_t\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:operator std::time_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::offset_datetime::operator std::time_t () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABFL}
{\bkmkend AAAAAAABFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b offset_datetime} & toml::offset_datetime::operator= ({\b offset_datetime} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABFM}
{\bkmkend AAAAAAABFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b offset_datetime} & toml::offset_datetime::operator= ({\b offset_datetime} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABFN}
{\bkmkend AAAAAAABFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v date\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:date}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b local_date} toml::offset_datetime::date}}
\par
{\bkmkstart AAAAAAABFO}
{\bkmkend AAAAAAABFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v offset\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b time_offset} toml::offset_datetime::offset}}
\par
{\bkmkstart AAAAAAABFP}
{\bkmkend AAAAAAABFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v time\:toml::offset_datetime}
{\xe \v toml::offset_datetime\:time}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b local_time} toml::offset_datetime::time}}
\par
{\bkmkstart AAAAAAABFQ}
{\bkmkend AAAAAAABFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b datetime.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Player Class Reference\par \pard\plain 
{\tc\tcl2 \v Player}
{\xe \v Player}
{\bkmkstart AAAAAAAAGR}
{\bkmkend AAAAAAAAGR}
\par
{
{\f2 #include <Player.hpp>}}\par
Inheritance diagram for Player:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "class_player.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b HorizontalDirection} \{ {\b Left}
, {\b Right}
 \}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b VerticalDirection} \{ {\b Top}
, {\b Down}
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Player} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Player} (sf::Vector2f startPosition, sf::Vector2f velocity, spritesMap playerSprites, std::string footsteps_path, float speed=100, int health=100)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9A\'D0\'BB\'D0\'B0\'D1\'81\'D1\'81 \'D0\'98\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b changeXDirection} ({\b HorizontalDirection} direction)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BC\'D0\'B5\'D0\'BD\'D1\'8F\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B3\'D0\'BE\'D1\'80\'D0\'B8\'D0\'B7\'D0\'BE\'D0\'BD\'D0\'B0\'D1\'82\'D0\'B0\'D0\'BB\'D1\'8C\'D0\'BD\'D1\'83\'D1\'8E \'D1\'81\'D0\'BE\'D1\'81\'D1\'82\'D0\'B0\'D0\'B2\'D0\'BB\'D1\'8F\'D1\'8E\'D1\'89\'D1\'83\'D1\'8E \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b changeYDirection} ({\b VerticalDirection} direction)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BC\'D0\'B5\'D0\'BD\'D1\'8F\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B2\'D0\'B5\'D1\'80\'D1\'82\'D0\'B8\'D0\'BA\'D0\'B0\'D0\'BB\'D1\'8C\'D0\'BD\'D1\'83\'D1\'8E \'D1\'81\'D0\'BE\'D1\'81\'D1\'82\'D0\'B0\'D0\'B2\'D0\'BB\'D1\'8F\'D1\'8E\'D1\'89\'D1\'83\'D1\'8E \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetHorizontalVelocity} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D1\'81\'D0\'B1\'D1\'80\'D0\'B0\'D1\'81\'D1\'8B\'D0\'B2\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B3\'D0\'BE\'D1\'80\'D0\'B8\'D0\'B7\'D0\'BE\'D0\'BD\'D1\'82\'D0\'B0\'D0\'BB\'D1\'8C\'D0\'BD\'D1\'83\'D1\'8E \'D1\'81\'D0\'BE\'D1\'81\'D1\'82\'D0\'BE\'D0\'B2\'D0\'BB\'D1\'8F\'D1\'8E\'D1\'89\'D1\'83\'D1\'8E \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetVerticalVelocity} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D1\'81\'D0\'B1\'D1\'80\'D0\'B0\'D1\'81\'D1\'8B\'D0\'B2\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B2\'D0\'B5\'D1\'80\'D1\'82\'D0\'B8\'D0\'BA\'D0\'B0\'D0\'BB\'D1\'8C\'D0\'BD\'D1\'83\'D1\'8E \'D1\'81\'D0\'BE\'D1\'81\'D1\'82\'D0\'BE\'D0\'B2\'D0\'BB\'D1\'8F\'D1\'8E\'D1\'89\'D1\'83\'D1\'8E \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b movePlayer} (sf::Time deltaTime)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D0\'BC\'D0\'B5\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSpeed} (float speed)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B8\'D0\'B7\'D0\'BC\'D0\'B5\'D0\'BD\'D1\'8F\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D1\'8C \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isDead} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 bool - \'D1\'81\'D1\'82\'D0\'B0\'D1\'82\'D1\'83\'D1\'81 \'D1\'81\'D0\'BC\'D0\'B5\'D1\'80\'D1\'82\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resetHealth} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D1\'81\'D1\'81\'D1\'82\'D0\'B0\'D0\'BD\'D0\'B0\'D0\'B2\'D0\'BB\'D0\'B8\'D0\'B2\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B8\'D1\'81\'D1\'85\'D0\'BE\'D0\'B4\'D0\'BD\'D0\'BE\'D0\'B5 \'D0\'B7\'D0\'B4\'D1\'80\'D0\'BE\'D0\'B2\'D1\'8C\'D0\'B5 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b getPlayerPosition} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::Vector2f {\b getPlayerVelocity} () const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D1\'8C \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::FloatRect {\b getNextPosition} (sf::Time deltaTime) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 FloatRect - \'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 \'D0\'B2 \'D1\'81\'D0\'BB\'D0\'B5\'D0\'B4\'D1\'83\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'BC\'D0\'BE\'D0\'BC\'D0\'B5\'D0\'BD\'D1\'82 \'D0\'B2\'D1\'80\'D0\'B5\'D0\'BC\'D0\'B5\'D0\'BD\'D0\'B8(\'D0\'BD\'D0\'B5\'D0\'BE\'D0\'B1\'D1\'85\'D0\'BE\'D0\'B4\'D0\'B8\'D0\'BC \'D0\'B4\'D0\'BB\'D1\'8F \'D0\'BF\'D1\'80\'D0\'BE\'D0\'B2\'D0\'B5\'D1\'80\'D0\'BA\'D0\'B8 \'D0\'BA\'D0\'BE\'D0\'BB\'D0\'BB\'D0\'B8\'D0\'B7\'D0\'B8\'D0\'B8) }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b draw} (sf::RenderTarget &surface, sf::RenderStates states) const\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'BE\'D1\'82\'D1\'80\'D0\'B8\'D1\'81\'D0\'BE\'D0\'B2\'D0\'BA\'D0\'B0 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 \'D0\'BD\'D0\'B0 \'D0\'BF\'D0\'BE\'D0\'B2\'D0\'B5\'D1\'80\'D1\'85\'D0\'BD\'D0\'BE\'D1\'81\'D1\'82\'D1\'8C }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b GameObject} & {\b get_playerObject} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 {\b GameObject} \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getHit} (int hp)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9D\'D0\'B0\'D0\'BD\'D0\'B5\'D1\'81\'D1\'82\'D0\'B8 \'D1\'83\'D1\'80\'D0\'BE\'D0\'BD \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D1\'83 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b nextState} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D0\'BC\'D0\'B5\'D0\'BD\'D1\'8F\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82 \'D0\'B0\'D0\'BD\'D0\'B8\'D0\'BC\'D0\'B0\'D1\'86\'D0\'B8\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 \'D0\'BD\'D0\'B0 \'D1\'81\'D0\'BB\'D0\'B5\'D0\'B4\'D1\'83\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v HorizontalDirection\:Player}
{\xe \v Player\:HorizontalDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Player::HorizontalDirection}}}
\par
{\bkmkstart AAAAAAAAGS}
{\bkmkend AAAAAAAAGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Left\:Player}
{\xe \v Player\:Left}
{\qr Left{\bkmkstart AAAAAAAAGT}
{\bkmkend AAAAAAAAGT}
\cell }{\cell }{\row }
{\xe \v Right\:Player}
{\xe \v Player\:Right}
{\qr Right{\bkmkstart AAAAAAAAGU}
{\bkmkend AAAAAAAAGU}
\cell }{\cell }{\row }
}
}
{\xe \v VerticalDirection\:Player}
{\xe \v Player\:VerticalDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum {\b Player::VerticalDirection}}}
\par
{\bkmkstart AAAAAAAAGV}
{\bkmkend AAAAAAAAGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Enumerator:\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{\xe \v Top\:Player}
{\xe \v Player\:Top}
{\qr Top{\bkmkstart AAAAAAAAGW}
{\bkmkend AAAAAAAAGW}
\cell }{\cell }{\row }
{\xe \v Down\:Player}
{\xe \v Player\:Down}
{\qr Down{\bkmkstart AAAAAAAAGX}
{\bkmkend AAAAAAAAGX}
\cell }{\cell }{\row }
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Player\:Player}
{\xe \v Player\:Player}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Player::Player (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAGY}
{\bkmkend AAAAAAAAGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Player\:Player}
{\xe \v Player\:Player}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Player::Player (sf::Vector2f  {\i startPosition}, sf::Vector2f  {\i velocity}, spritesMap  {\i playerSprites}, std::string  {\i footsteps_path}, float  {\i speed} = {\f2 100}, int  {\i health} = {\f2 100})}}
\par
{\bkmkstart AAAAAAAAGZ}
{\bkmkend AAAAAAAAGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9A\'D0\'BB\'D0\'B0\'D1\'81\'D1\'81 \'D0\'98\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i startPosition} \cell }{\'D0\'BD\'D0\'B0\'D1\'87\'D0\'B0\'D0\'BB\'D1\'8C\'D0\'BD\'D0\'BE\'D0\'B5 \'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i velocity} \cell }{\'D0\'BD\'D0\'B0\'D1\'87\'D0\'B0\'D0\'BB\'D1\'8C\'D0\'BD\'D1\'8B\'D0\'B9 \'D0\'B2\'D0\'B5\'D0\'BA\'D1\'82\'D0\'BE\'D1\'80 \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D0\'B8 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i playerSprites} \cell }{\'D1\'81\'D0\'BB\'D0\'BE\'D0\'B2\'D0\'B0\'D1\'80\'D1\'8C \'D1\'81\'D0\'BE \'D0\'B2\'D1\'81\'D0\'B5\'D0\'BC\'D0\'B8 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'B0\'D0\'BC\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i footsteps_path} \cell }{\'D0\'BD\'D0\'B0\'D0\'B7\'D0\'B2\'D0\'B0\'D0\'BD\'D0\'B8\'D0\'B5 \'D0\'B0\'D1\'83\'D0\'B4\'D0\'B8\'D0\'BE \'D1\'81 \'D0\'B7\'D0\'B2\'D1\'83\'D0\'BA\'D0\'BE\'D0\'BC \'D1\'88\'D0\'B0\'D0\'B3\'D0\'BE\'D0\'B2 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i speed} \cell }{\'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D1\'8C \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i health} \cell }{\'D0\'BA\'D0\'BE\'D0\'BB\'D0\'B8\'D1\'87\'D0\'B5\'D1\'81\'D1\'82\'D0\'B2\'D0\'BE \'D0\'B7\'D0\'B4\'D0\'BE\'D1\'80\'D0\'BE\'D0\'B2\'D1\'8C\'D1\'8F \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v changeXDirection\:Player}
{\xe \v Player\:changeXDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Player::changeXDirection ({\b HorizontalDirection}  {\i direction})}}
\par
{\bkmkstart AAAAAAAAHA}
{\bkmkend AAAAAAAAHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BC\'D0\'B5\'D0\'BD\'D1\'8F\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B3\'D0\'BE\'D1\'80\'D0\'B8\'D0\'B7\'D0\'BE\'D0\'BD\'D0\'B0\'D1\'82\'D0\'B0\'D0\'BB\'D1\'8C\'D0\'BD\'D1\'83\'D1\'8E \'D1\'81\'D0\'BE\'D1\'81\'D1\'82\'D0\'B0\'D0\'B2\'D0\'BB\'D1\'8F\'D1\'8E\'D1\'89\'D1\'83\'D1\'8E \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i direction} \cell }{\'D0\'BD\'D0\'B0\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B2\'D0\'BB\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \'D0\'B8\'D0\'B7\'D0\'BC\'D0\'B5\'D0\'BD\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8F \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D0\'B8 \cell }
{\row }
}
}}
{\xe \v changeYDirection\:Player}
{\xe \v Player\:changeYDirection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Player::changeYDirection ({\b VerticalDirection}  {\i direction})}}
\par
{\bkmkstart AAAAAAAAHB}
{\bkmkend AAAAAAAAHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BC\'D0\'B5\'D0\'BD\'D1\'8F\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B2\'D0\'B5\'D1\'80\'D1\'82\'D0\'B8\'D0\'BA\'D0\'B0\'D0\'BB\'D1\'8C\'D0\'BD\'D1\'83\'D1\'8E \'D1\'81\'D0\'BE\'D1\'81\'D1\'82\'D0\'B0\'D0\'B2\'D0\'BB\'D1\'8F\'D1\'8E\'D1\'89\'D1\'83\'D1\'8E \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i direction} \cell }{\'D0\'BD\'D0\'B0\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B2\'D0\'BB\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \'D0\'B8\'D0\'B7\'D0\'BC\'D0\'B5\'D0\'BD\'D0\'B5\'D0\'BD\'D0\'B8\'D1\'8F \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D0\'B8 \cell }
{\row }
}
}}
{\xe \v draw\:Player}
{\xe \v Player\:draw}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Player::draw (sf::RenderTarget &  {\i surface}, sf::RenderStates  {\i states}) const{\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAAAHC}
{\bkmkend AAAAAAAAHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'BE\'D1\'82\'D1\'80\'D0\'B8\'D1\'81\'D0\'BE\'D0\'B2\'D0\'BA\'D0\'B0 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 \'D0\'BD\'D0\'B0 \'D0\'BF\'D0\'BE\'D0\'B2\'D0\'B5\'D1\'80\'D1\'85\'D0\'BD\'D0\'BE\'D1\'81\'D1\'82\'D1\'8C }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i surface} \cell }{\'D0\'BF\'D0\'BE\'D0\'B2\'D0\'B5\'D1\'80\'D1\'85\'D0\'BD\'D0\'BE\'D1\'81\'D1\'82\'D1\'8C \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i states} \cell }{\'D1\'81\'D0\'BE\'D1\'81\'D1\'82\'D0\'BE\'D1\'8F\'D0\'BD\'D0\'B8\'D0\'B5 \cell }
{\row }
}
}}
{\xe \v get_playerObject\:Player}
{\xe \v Player\:get_playerObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b GameObject} & Player::get_playerObject ()}}
\par
{\bkmkstart AAAAAAAAHD}
{\bkmkend AAAAAAAAHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 {\b GameObject} \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
{\b GameObject}& \par
}}}}
{\xe \v getHit\:Player}
{\xe \v Player\:getHit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Player::getHit (int  {\i hp})}}
\par
{\bkmkstart AAAAAAAAHE}
{\bkmkend AAAAAAAAHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9D\'D0\'B0\'D0\'BD\'D0\'B5\'D1\'81\'D1\'82\'D0\'B8 \'D1\'83\'D1\'80\'D0\'BE\'D0\'BD \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D1\'83 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i hp} \cell }{\'D0\'BA\'D0\'BE\'D0\'BB\'D0\'B8\'D1\'87\'D0\'B5\'D1\'81\'D1\'82\'D0\'B2\'D0\'BE \'D1\'83\'D1\'80\'D0\'BE\'D0\'BD\'D0\'B0 \cell }
{\row }
}
}}
{\xe \v getNextPosition\:Player}
{\xe \v Player\:getNextPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::FloatRect Player::getNextPosition (sf::Time  {\i deltaTime}) const}}
\par
{\bkmkstart AAAAAAAAHF}
{\bkmkend AAAAAAAAHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 FloatRect - \'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 \'D0\'B2 \'D1\'81\'D0\'BB\'D0\'B5\'D0\'B4\'D1\'83\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'BC\'D0\'BE\'D0\'BC\'D0\'B5\'D0\'BD\'D1\'82 \'D0\'B2\'D1\'80\'D0\'B5\'D0\'BC\'D0\'B5\'D0\'BD\'D0\'B8(\'D0\'BD\'D0\'B5\'D0\'BE\'D0\'B1\'D1\'85\'D0\'BE\'D0\'B4\'D0\'B8\'D0\'BC \'D0\'B4\'D0\'BB\'D1\'8F \'D0\'BF\'D1\'80\'D0\'BE\'D0\'B2\'D0\'B5\'D1\'80\'D0\'BA\'D0\'B8 \'D0\'BA\'D0\'BE\'D0\'BB\'D0\'BB\'D0\'B8\'D0\'B7\'D0\'B8\'D0\'B8) }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i deltaTime} \cell }{deltaTime \cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
sf::FloatRect \par
}}}}
{\xe \v getPlayerPosition\:Player}
{\xe \v Player\:getPlayerPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Vector2f Player::getPlayerPosition () const}}
\par
{\bkmkstart AAAAAAAAHG}
{\bkmkend AAAAAAAAHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'BF\'D0\'BE\'D0\'BB\'D0\'BE\'D0\'B6\'D0\'B5\'D0\'BD\'D0\'B8\'D0\'B5 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
sf::Vector2f \'D0\'BF\'D0\'BE\'D0\'B7\'D0\'B8\'D1\'86\'D0\'B8\'D1\'8F \par
}}}}
{\xe \v getPlayerVelocity\:Player}
{\xe \v Player\:getPlayerVelocity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::Vector2f Player::getPlayerVelocity () const}}
\par
{\bkmkstart AAAAAAAAHH}
{\bkmkend AAAAAAAAHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D1\'8C \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
sf::Vector2f \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D1\'8C \par
}}}}
{\xe \v isDead\:Player}
{\xe \v Player\:isDead}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool Player::isDead () const}}
\par
{\bkmkstart AAAAAAAAHI}
{\bkmkend AAAAAAAAHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 bool - \'D1\'81\'D1\'82\'D0\'B0\'D1\'82\'D1\'83\'D1\'81 \'D1\'81\'D0\'BC\'D0\'B5\'D1\'80\'D1\'82\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
true \'D0\'BC\'D0\'B5\'D1\'80\'D1\'82\'D0\'B2 \par
false \'D0\'B6\'D0\'B8\'D0\'B2 \par
}}}}
{\xe \v movePlayer\:Player}
{\xe \v Player\:movePlayer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Player::movePlayer (sf::Time  {\i deltaTime})}}
\par
{\bkmkstart AAAAAAAAHJ}
{\bkmkend AAAAAAAAHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BF\'D0\'B5\'D1\'80\'D0\'B5\'D0\'BC\'D0\'B5\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i deltaTime} \cell }{deltaTime \cell }
{\row }
}
}}
{\xe \v nextState\:Player}
{\xe \v Player\:nextState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Player::nextState ()}}
\par
{\bkmkstart AAAAAAAAHK}
{\bkmkend AAAAAAAAHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4 \'D0\'BC\'D0\'B5\'D0\'BD\'D1\'8F\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82 \'D0\'B0\'D0\'BD\'D0\'B8\'D0\'BC\'D0\'B0\'D1\'86\'D0\'B8\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 \'D0\'BD\'D0\'B0 \'D1\'81\'D0\'BB\'D0\'B5\'D0\'B4\'D1\'83\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 }}\par
}
{\xe \v resetHealth\:Player}
{\xe \v Player\:resetHealth}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Player::resetHealth ()}}
\par
{\bkmkstart AAAAAAAAHL}
{\bkmkend AAAAAAAAHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D1\'81\'D1\'81\'D1\'82\'D0\'B0\'D0\'BD\'D0\'B0\'D0\'B2\'D0\'BB\'D0\'B8\'D0\'B2\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B8\'D1\'81\'D1\'85\'D0\'BE\'D0\'B4\'D0\'BD\'D0\'BE\'D0\'B5 \'D0\'B7\'D0\'B4\'D1\'80\'D0\'BE\'D0\'B2\'D1\'8C\'D0\'B5 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }}\par
}
{\xe \v resetHorizontalVelocity\:Player}
{\xe \v Player\:resetHorizontalVelocity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Player::resetHorizontalVelocity ()}}
\par
{\bkmkstart AAAAAAAAHM}
{\bkmkend AAAAAAAAHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D1\'81\'D0\'B1\'D1\'80\'D0\'B0\'D1\'81\'D1\'8B\'D0\'B2\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B3\'D0\'BE\'D1\'80\'D0\'B8\'D0\'B7\'D0\'BE\'D0\'BD\'D1\'82\'D0\'B0\'D0\'BB\'D1\'8C\'D0\'BD\'D1\'83\'D1\'8E \'D1\'81\'D0\'BE\'D1\'81\'D1\'82\'D0\'BE\'D0\'B2\'D0\'BB\'D1\'8F\'D1\'8E\'D1\'89\'D1\'83\'D1\'8E \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }}\par
}
{\xe \v resetVerticalVelocity\:Player}
{\xe \v Player\:resetVerticalVelocity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Player::resetVerticalVelocity ()}}
\par
{\bkmkstart AAAAAAAAHN}
{\bkmkend AAAAAAAAHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D1\'81\'D0\'B1\'D1\'80\'D0\'B0\'D1\'81\'D1\'8B\'D0\'B2\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B2\'D0\'B5\'D1\'80\'D1\'82\'D0\'B8\'D0\'BA\'D0\'B0\'D0\'BB\'D1\'8C\'D0\'BD\'D1\'83\'D1\'8E \'D1\'81\'D0\'BE\'D1\'81\'D1\'82\'D0\'BE\'D0\'B2\'D0\'BB\'D1\'8F\'D1\'8E\'D1\'89\'D1\'83\'D1\'8E \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }}\par
}
{\xe \v setSpeed\:Player}
{\xe \v Player\:setSpeed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Player::setSpeed (float  {\i speed})}}
\par
{\bkmkstart AAAAAAAAHO}
{\bkmkend AAAAAAAAHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B8\'D0\'B7\'D0\'BC\'D0\'B5\'D0\'BD\'D1\'8F\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D1\'8C \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i speed} \cell }{\'D0\'BD\'D0\'BE\'D0\'B2\'D0\'B0\'D1\'8F \'D1\'81\'D0\'BA\'D0\'BE\'D1\'80\'D0\'BE\'D1\'81\'D1\'82\'D1\'8C \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Player/{\b Player.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Player/{\b Player.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::preserve_comments Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::preserve_comments}
{\xe \v toml::preserve_comments}
{\bkmkstart AAAAAAABFR}
{\bkmkend AAAAAAABFR}
\par
{
{\f2 #include <comments.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b container_type} = std::vector< std::string >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b size_type} = container_type::size_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b difference_type} = container_type::difference_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = container_type::value_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b reference} = container_type::reference\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b const_reference} = container_type::const_reference\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b pointer} = container_type::pointer\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b const_pointer} = container_type::const_pointer\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b iterator} = container_type::iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b const_iterator} = container_type::const_iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b reverse_iterator} = container_type::reverse_iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b const_reverse_iterator} = container_type::const_reverse_iterator\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b preserve_comments} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~preserve_comments} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b preserve_comments} ({\b preserve_comments} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b preserve_comments} ({\b preserve_comments} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b preserve_comments} & {\b operator=} ({\b preserve_comments} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b preserve_comments} & {\b operator=} ({\b preserve_comments} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b preserve_comments} (const std::vector< std::string > &c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b preserve_comments} (std::vector< std::string > &&c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b preserve_comments} & {\b operator=} (const std::vector< std::string > &c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b preserve_comments} & {\b operator=} (std::vector< std::string > &&c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b preserve_comments} (const {\b discard_comments} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b preserve_comments} ({\b size_type} n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b preserve_comments} ({\b size_type} n, const std::string &x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b preserve_comments} (std::initializer_list< std::string > x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator > {\b preserve_comments} (InputIterator first, InputIterator last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator > void {\b assign} (InputIterator first, InputIterator last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b assign} (std::initializer_list< std::string > ini)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b assign} ({\b size_type} n, const std::string &val)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b insert} ({\b const_iterator} p, const std::string &x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b insert} ({\b const_iterator} p, std::string &&x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b insert} ({\b const_iterator} p, {\b size_type} n, const std::string &x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator > {\b iterator} {\b insert} ({\b const_iterator} p, InputIterator first, InputIterator last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b insert} ({\b const_iterator} p, std::initializer_list< std::string > ini)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ts> {\b iterator} {\b emplace} ({\b const_iterator} p, Ts &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b erase} ({\b const_iterator} pos)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b erase} ({\b const_iterator} first, {\b const_iterator} last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b preserve_comments} &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_back} (const std::string &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b push_back} (std::string &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b pop_back} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ts> void {\b emplace_back} (Ts &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b clear} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b size_type} {\b size} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b size_type} {\b max_size} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b size_type} {\b capacity} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b empty} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reserve} ({\b size_type} n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resize} ({\b size_type} n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b resize} ({\b size_type} n, const std::string &c)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b shrink_to_fit} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b operator[]} (const {\b size_type} n) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b operator[]} (const {\b size_type} n) const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b at} (const {\b size_type} n)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b at} (const {\b size_type} n) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b front} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b front} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reference} {\b back} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reference} {\b back} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pointer} {\b data} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_pointer} {\b data} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b begin} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b iterator} {\b end} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b begin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b end} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b cbegin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b cend} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reverse_iterator} {\b rbegin} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b reverse_iterator} {\b rend} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reverse_iterator} {\b rbegin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reverse_iterator} {\b rend} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reverse_iterator} {\b crbegin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_reverse_iterator} {\b crend} () const noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator==} (const {\b preserve_comments} &, const {\b preserve_comments} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator!=} (const {\b preserve_comments} &, const {\b preserve_comments} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<} (const {\b preserve_comments} &, const {\b preserve_comments} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator<=} (const {\b preserve_comments} &, const {\b preserve_comments} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>} (const {\b preserve_comments} &, const {\b preserve_comments} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator>=} (const {\b preserve_comments} &, const {\b preserve_comments} &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b preserve_comments} &, std::vector< std::string > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} (std::vector< std::string > &, {\b preserve_comments} &)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v const_iterator\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:const_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::preserve_comments::const_iterator} =  container_type::const_iterator}}
\par
{\bkmkstart AAAAAAABFS}
{\bkmkend AAAAAAABFS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v const_pointer\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:const_pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::preserve_comments::const_pointer} =  container_type::const_pointer}}
\par
{\bkmkstart AAAAAAABFT}
{\bkmkend AAAAAAABFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v const_reference\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:const_reference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::preserve_comments::const_reference} =  container_type::const_reference}}
\par
{\bkmkstart AAAAAAABFU}
{\bkmkend AAAAAAABFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v const_reverse_iterator\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:const_reverse_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::preserve_comments::const_reverse_iterator} =  container_type::const_reverse_iterator}}
\par
{\bkmkstart AAAAAAABFV}
{\bkmkend AAAAAAABFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v container_type\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:container_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::preserve_comments::container_type} =  std::vector<std::string>}}
\par
{\bkmkstart AAAAAAABFW}
{\bkmkend AAAAAAABFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v difference_type\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:difference_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::preserve_comments::difference_type} =  container_type::difference_type}}
\par
{\bkmkstart AAAAAAABFX}
{\bkmkend AAAAAAABFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v iterator\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::preserve_comments::iterator} =  container_type::iterator}}
\par
{\bkmkstart AAAAAAABFY}
{\bkmkend AAAAAAABFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pointer\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::preserve_comments::pointer} =  container_type::pointer}}
\par
{\bkmkstart AAAAAAABFZ}
{\bkmkend AAAAAAABFZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reference\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:reference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::preserve_comments::reference} =  container_type::reference}}
\par
{\bkmkstart AAAAAAABGA}
{\bkmkend AAAAAAABGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reverse_iterator\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:reverse_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::preserve_comments::reverse_iterator} =  container_type::reverse_iterator}}
\par
{\bkmkstart AAAAAAABGB}
{\bkmkend AAAAAAABGB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size_type\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:size_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::preserve_comments::size_type} =  container_type::size_type}}
\par
{\bkmkstart AAAAAAABGC}
{\bkmkend AAAAAAABGC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value_type\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::preserve_comments::value_type} =  container_type::value_type}}
\par
{\bkmkstart AAAAAAABGD}
{\bkmkend AAAAAAABGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v preserve_comments\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:preserve_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::preserve_comments::preserve_comments (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABGE}
{\bkmkend AAAAAAABGE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~preserve_comments\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:~preserve_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::preserve_comments::~preserve_comments (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABGF}
{\bkmkend AAAAAAABGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v preserve_comments\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:preserve_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::preserve_comments::preserve_comments ({\b preserve_comments} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABGG}
{\bkmkend AAAAAAABGG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v preserve_comments\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:preserve_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::preserve_comments::preserve_comments ({\b preserve_comments} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABGH}
{\bkmkend AAAAAAABGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v preserve_comments\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:preserve_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::preserve_comments::preserve_comments (const std::vector< std::string > &  {\i c}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABGI}
{\bkmkend AAAAAAABGI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v preserve_comments\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:preserve_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::preserve_comments::preserve_comments (std::vector< std::string > &&  {\i c}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABGJ}
{\bkmkend AAAAAAABGJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v preserve_comments\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:preserve_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::preserve_comments::preserve_comments (const {\b discard_comments} & ){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABGK}
{\bkmkend AAAAAAABGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v preserve_comments\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:preserve_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::preserve_comments::preserve_comments ({\b size_type}  {\i n}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABGL}
{\bkmkend AAAAAAABGL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v preserve_comments\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:preserve_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::preserve_comments::preserve_comments ({\b size_type}  {\i n}, const std::string &  {\i x}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGM}
{\bkmkend AAAAAAABGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v preserve_comments\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:preserve_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::preserve_comments::preserve_comments (std::initializer_list< std::string >  {\i x}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGN}
{\bkmkend AAAAAAABGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v preserve_comments\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:preserve_comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename InputIterator > toml::preserve_comments::preserve_comments (InputIterator  {\i first}, InputIterator  {\i last}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGO}
{\bkmkend AAAAAAABGO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v assign\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:assign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename InputIterator > void toml::preserve_comments::assign (InputIterator  {\i first}, InputIterator  {\i last}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGP}
{\bkmkend AAAAAAABGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v assign\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:assign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::preserve_comments::assign ({\b size_type}  {\i n}, const std::string &  {\i val}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGQ}
{\bkmkend AAAAAAABGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v assign\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:assign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::preserve_comments::assign (std::initializer_list< std::string >  {\i ini}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGR}
{\bkmkend AAAAAAABGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v at\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b reference} toml::preserve_comments::at (const {\b size_type}  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGS}
{\bkmkend AAAAAAABGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v at\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:at}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reference} toml::preserve_comments::at (const {\b size_type}  {\i n}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABGT}
{\bkmkend AAAAAAABGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v back\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reference} toml::preserve_comments::back () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGU}
{\bkmkend AAAAAAABGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v back\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b reference} toml::preserve_comments::back (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGV}
{\bkmkend AAAAAAABGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v begin\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::preserve_comments::begin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGW}
{\bkmkend AAAAAAABGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v begin\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::preserve_comments::begin (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGX}
{\bkmkend AAAAAAABGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v capacity\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:capacity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b size_type} toml::preserve_comments::capacity () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGY}
{\bkmkend AAAAAAABGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v cbegin\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:cbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::preserve_comments::cbegin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABGZ}
{\bkmkend AAAAAAABGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v cend\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:cend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::preserve_comments::cend () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHA}
{\bkmkend AAAAAAABHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v clear\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::preserve_comments::clear (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHB}
{\bkmkend AAAAAAABHB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v crbegin\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:crbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reverse_iterator} toml::preserve_comments::crbegin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHC}
{\bkmkend AAAAAAABHC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v crend\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:crend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reverse_iterator} toml::preserve_comments::crend () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHD}
{\bkmkend AAAAAAABHD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v data\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_pointer} toml::preserve_comments::data () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHE}
{\bkmkend AAAAAAABHE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v data\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b pointer} toml::preserve_comments::data (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHF}
{\bkmkend AAAAAAABHF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v emplace\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:emplace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ... Ts> {\b iterator} toml::preserve_comments::emplace ({\b const_iterator}  {\i p}, Ts &&...  {\i args}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHG}
{\bkmkend AAAAAAABHG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v emplace_back\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:emplace_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename ... Ts> void toml::preserve_comments::emplace_back (Ts &&...  {\i args}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHH}
{\bkmkend AAAAAAABHH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v empty\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::preserve_comments::empty () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHI}
{\bkmkend AAAAAAABHI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v end\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::preserve_comments::end () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHJ}
{\bkmkend AAAAAAABHJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v end\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::preserve_comments::end (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHK}
{\bkmkend AAAAAAABHK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v erase\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::preserve_comments::erase ({\b const_iterator}  {\i first}, {\b const_iterator}  {\i last}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHL}
{\bkmkend AAAAAAABHL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v erase\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:erase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::preserve_comments::erase ({\b const_iterator}  {\i pos}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHM}
{\bkmkend AAAAAAABHM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v front\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reference} toml::preserve_comments::front () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHN}
{\bkmkend AAAAAAABHN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v front\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b reference} toml::preserve_comments::front (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHO}
{\bkmkend AAAAAAABHO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v insert\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::preserve_comments::insert ({\b const_iterator}  {\i p}, const std::string &  {\i x}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHP}
{\bkmkend AAAAAAABHP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v insert\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename InputIterator > {\b iterator} toml::preserve_comments::insert ({\b const_iterator}  {\i p}, InputIterator  {\i first}, InputIterator  {\i last}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHQ}
{\bkmkend AAAAAAABHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v insert\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::preserve_comments::insert ({\b const_iterator}  {\i p}, {\b size_type}  {\i n}, const std::string &  {\i x}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHR}
{\bkmkend AAAAAAABHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v insert\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::preserve_comments::insert ({\b const_iterator}  {\i p}, std::initializer_list< std::string >  {\i ini}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHS}
{\bkmkend AAAAAAABHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v insert\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:insert}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b iterator} toml::preserve_comments::insert ({\b const_iterator}  {\i p}, std::string &&  {\i x}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHT}
{\bkmkend AAAAAAABHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v max_size\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:max_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b size_type} toml::preserve_comments::max_size () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHU}
{\bkmkend AAAAAAABHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b preserve_comments} & toml::preserve_comments::operator= (const std::vector< std::string > &  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHV}
{\bkmkend AAAAAAABHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b preserve_comments} & toml::preserve_comments::operator= ({\b preserve_comments} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABHW}
{\bkmkend AAAAAAABHW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b preserve_comments} & toml::preserve_comments::operator= ({\b preserve_comments} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABHX}
{\bkmkend AAAAAAABHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b preserve_comments} & toml::preserve_comments::operator= (std::vector< std::string > &&  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABHY}
{\bkmkend AAAAAAABHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator[]\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reference} toml::preserve_comments::operator[] (const {\b size_type}  {\i n}) const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABHZ}
{\bkmkend AAAAAAABHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator[]\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b reference} toml::preserve_comments::operator[] (const {\b size_type}  {\i n}){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIA}
{\bkmkend AAAAAAABIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v pop_back\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:pop_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::preserve_comments::pop_back (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIB}
{\bkmkend AAAAAAABIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v push_back\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::preserve_comments::push_back (const std::string &  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIC}
{\bkmkend AAAAAAABIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v push_back\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:push_back}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::preserve_comments::push_back (std::string &&  {\i v}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABID}
{\bkmkend AAAAAAABID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rbegin\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:rbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reverse_iterator} toml::preserve_comments::rbegin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIE}
{\bkmkend AAAAAAABIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rbegin\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:rbegin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b reverse_iterator} toml::preserve_comments::rbegin (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIF}
{\bkmkend AAAAAAABIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rend\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:rend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_reverse_iterator} toml::preserve_comments::rend () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIG}
{\bkmkend AAAAAAABIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v rend\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:rend}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b reverse_iterator} toml::preserve_comments::rend (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIH}
{\bkmkend AAAAAAABIH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v reserve\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:reserve}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::preserve_comments::reserve ({\b size_type}  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABII}
{\bkmkend AAAAAAABII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resize\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:resize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::preserve_comments::resize ({\b size_type}  {\i n}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIJ}
{\bkmkend AAAAAAABIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v resize\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:resize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::preserve_comments::resize ({\b size_type}  {\i n}, const std::string &  {\i c}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIK}
{\bkmkend AAAAAAABIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v shrink_to_fit\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:shrink_to_fit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::preserve_comments::shrink_to_fit (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIL}
{\bkmkend AAAAAAABIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b size_type} toml::preserve_comments::size () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABIM}
{\bkmkend AAAAAAABIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v swap\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void toml::preserve_comments::swap ({\b preserve_comments} &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABIN}
{\bkmkend AAAAAAABIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Friends And Related Function Documentation\par
\pard\plain 
{\xe \v operator!=\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator!= (const {\b preserve_comments} &  {\i lhs}, const {\b preserve_comments} &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABIO}
{\bkmkend AAAAAAABIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator< (const {\b preserve_comments} &  {\i lhs}, const {\b preserve_comments} &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABIP}
{\bkmkend AAAAAAABIP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator<=\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator<= (const {\b preserve_comments} &  {\i lhs}, const {\b preserve_comments} &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABIQ}
{\bkmkend AAAAAAABIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator== (const {\b preserve_comments} &  {\i lhs}, const {\b preserve_comments} &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABIR}
{\bkmkend AAAAAAABIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator> (const {\b preserve_comments} &  {\i lhs}, const {\b preserve_comments} &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABIS}
{\bkmkend AAAAAAABIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator>=\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool operator>= (const {\b preserve_comments} &  {\i lhs}, const {\b preserve_comments} &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABIT}
{\bkmkend AAAAAAABIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v swap\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void swap ({\b preserve_comments} &  {\i lhs}, std::vector< std::string > &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABIU}
{\bkmkend AAAAAAABIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v swap\:toml::preserve_comments}
{\xe \v toml::preserve_comments\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void swap (std::vector< std::string > &  {\i lhs}, {\b preserve_comments} &  {\i rhs}){\f2 [friend]}}}
\par
{\bkmkstart AAAAAAABIV}
{\bkmkend AAAAAAABIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b comments.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PriorityQueue< T > Class Template Reference\par \pard\plain 
{\tc\tcl2 \v PriorityQueue< T >}
{\xe \v PriorityQueue< T >}
{\bkmkstart AAAAAAAAHP}
{\bkmkend AAAAAAAAHP}
\par
{
{\f2 #include <PriorityQueue.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b PriorityQueue} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b size} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b enqueue} (T item, int priority)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b size} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b empty} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b dequeue} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v PriorityQueue\:PriorityQueue< T >}
{\xe \v PriorityQueue< T >\:PriorityQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > {\b PriorityQueue}< T >{\b ::PriorityQueue} (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHQ}
{\bkmkend AAAAAAAAHQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v dequeue\:PriorityQueue< T >}
{\xe \v PriorityQueue< T >\:dequeue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > T {\b PriorityQueue}< T >::dequeue (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHR}
{\bkmkend AAAAAAAAHR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v empty\:PriorityQueue< T >}
{\xe \v PriorityQueue< T >\:empty}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > bool {\b PriorityQueue}< T >::empty () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHS}
{\bkmkend AAAAAAAAHS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v enqueue\:PriorityQueue< T >}
{\xe \v PriorityQueue< T >\:enqueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > void {\b PriorityQueue}< T >::enqueue (T  {\i item}, int  {\i priority}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHT}
{\bkmkend AAAAAAAAHT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size\:PriorityQueue< T >}
{\xe \v PriorityQueue< T >\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > int {\b PriorityQueue}< T >::size (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHU}
{\bkmkend AAAAAAAAHU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size\:PriorityQueue< T >}
{\xe \v PriorityQueue< T >\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T > size_t {\b PriorityQueue}< T >::size () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHV}
{\bkmkend AAAAAAAAHV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/PriorityQueue/{\b PriorityQueue.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::push_back_index_sequence< IS, N > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::push_back_index_sequence< IS, N >}
{\xe \v toml::detail::push_back_index_sequence< IS, N >}
{\bkmkstart AAAAAAACEH}
{\bkmkend AAAAAAACEH}
\par
{
{\f2 #include <traits.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::push_back_index_sequence< index_sequence< Ns... >, N > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::push_back_index_sequence< index_sequence< Ns... >, N >}
{\xe \v toml::detail::push_back_index_sequence< index_sequence< Ns... >, N >}
{\bkmkstart AAAAAAACEI}
{\bkmkend AAAAAAACEI}
\par
{
{\f2 #include <traits.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b index_sequence}< Ns..., N > {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::push_back_index_sequence< index_sequence< Ns... >, N >}
{\xe \v toml::detail::push_back_index_sequence< index_sequence< Ns... >, N >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<std::size_t N, std::size_t ... Ns> typedef {\b index_sequence}<Ns..., N> {\b toml::detail::push_back_index_sequence}< {\b index_sequence}< Ns... >, N >::type}}
\par
{\bkmkstart AAAAAAACEJ}
{\bkmkend AAAAAAACEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::region Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::region}
{\xe \v toml::detail::region}
{\bkmkstart AAAAAAACEK}
{\bkmkend AAAAAAACEK}
\par
{
{\f2 #include <region.hpp>}}\par
Inheritance diagram for toml::detail::region:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1region.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b const_iterator} = typename std::vector< char >::const_iterator\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b source_ptr} = std::shared_ptr< const std::vector< char > >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b region} ()=delete\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b region} (const {\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b region} ({\b location} &&loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b region} (const {\b location} &loc, {\b const_iterator} f, {\b const_iterator} l)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b region} ({\b location} &&loc, {\b const_iterator} f, {\b const_iterator} l)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b region} (const {\b region} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b region} ({\b region} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b region} & {\b operator=} (const {\b region} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b region} & {\b operator=} ({\b region} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~region} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b region} & {\b operator+=} (const {\b region} &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_ok} () const noexcept override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b front} () const noexcept override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b str} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b line} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b line_num} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b size} () const noexcept override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b before} () const noexcept override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::size_t {\b after} () const noexcept override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b contain_newline} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b line_begin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b line_end} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b begin} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b end} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b first} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b const_iterator} {\b last} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b source_ptr} const & {\b source} () const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b source_ptr} && {\b source} () &&noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b name} () const override\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< std::string > {\b comments} () const override\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v const_iterator\:toml::detail::region}
{\xe \v toml::detail::region\:const_iterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::region::const_iterator} =  typename std::vector<char>::const_iterator}}
\par
{\bkmkstart AAAAAAACEL}
{\bkmkend AAAAAAACEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v source_ptr\:toml::detail::region}
{\xe \v toml::detail::region\:source_ptr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
using {\b toml::detail::region::source_ptr} =  std::shared_ptr<const std::vector<char> >}}
\par
{\bkmkstart AAAAAAACEM}
{\bkmkend AAAAAAACEM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v region\:toml::detail::region}
{\xe \v toml::detail::region\:region}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::region::region (){\f2 [delete]}}}
\par
{\bkmkstart AAAAAAACEN}
{\bkmkend AAAAAAACEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v region\:toml::detail::region}
{\xe \v toml::detail::region\:region}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::region::region (const {\b location} &  {\i loc}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACEO}
{\bkmkend AAAAAAACEO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v region\:toml::detail::region}
{\xe \v toml::detail::region\:region}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::region::region ({\b location} &&  {\i loc}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACEP}
{\bkmkend AAAAAAACEP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v region\:toml::detail::region}
{\xe \v toml::detail::region\:region}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::region::region (const {\b location} &  {\i loc}, {\b const_iterator}  {\i f}, {\b const_iterator}  {\i l}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACEQ}
{\bkmkend AAAAAAACEQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v region\:toml::detail::region}
{\xe \v toml::detail::region\:region}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::region::region ({\b location} &&  {\i loc}, {\b const_iterator}  {\i f}, {\b const_iterator}  {\i l}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACER}
{\bkmkend AAAAAAACER}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v region\:toml::detail::region}
{\xe \v toml::detail::region\:region}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::region::region (const {\b region} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACES}
{\bkmkend AAAAAAACES}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v region\:toml::detail::region}
{\xe \v toml::detail::region\:region}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::region::region ({\b region} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACET}
{\bkmkend AAAAAAACET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~region\:toml::detail::region}
{\xe \v toml::detail::region\:~region}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::region::~region (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACEU}
{\bkmkend AAAAAAACEU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v after\:toml::detail::region}
{\xe \v toml::detail::region\:after}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t toml::detail::region::after () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACEV}
{\bkmkend AAAAAAACEV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDB \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v before\:toml::detail::region}
{\xe \v toml::detail::region\:before}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t toml::detail::region::before () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACEW}
{\bkmkend AAAAAAACEW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v begin\:toml::detail::region}
{\xe \v toml::detail::region\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::detail::region::begin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACEX}
{\bkmkend AAAAAAACEX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v comments\:toml::detail::region}
{\xe \v toml::detail::region\:comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< std::string > toml::detail::region::comments () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACEY}
{\bkmkend AAAAAAACEY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACEZ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v contain_newline\:toml::detail::region}
{\xe \v toml::detail::region\:contain_newline}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::detail::region::contain_newline () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACFA}
{\bkmkend AAAAAAACFA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v end\:toml::detail::region}
{\xe \v toml::detail::region\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::detail::region::end () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACFB}
{\bkmkend AAAAAAACFB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v first\:toml::detail::region}
{\xe \v toml::detail::region\:first}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::detail::region::first () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACFC}
{\bkmkend AAAAAAACFC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v front\:toml::detail::region}
{\xe \v toml::detail::region\:front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char toml::detail::region::front () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACFD}
{\bkmkend AAAAAAACFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDH \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v is_ok\:toml::detail::region}
{\xe \v toml::detail::region\:is_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool toml::detail::region::is_ok () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACFE}
{\bkmkend AAAAAAACFE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v last\:toml::detail::region}
{\xe \v toml::detail::region\:last}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::detail::region::last () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACFF}
{\bkmkend AAAAAAACFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v line\:toml::detail::region}
{\xe \v toml::detail::region\:line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::detail::region::line () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACFG}
{\bkmkend AAAAAAACFG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDM \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v line_begin\:toml::detail::region}
{\xe \v toml::detail::region\:line_begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::detail::region::line_begin () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACFH}
{\bkmkend AAAAAAACFH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v line_end\:toml::detail::region}
{\xe \v toml::detail::region\:line_end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b const_iterator} toml::detail::region::line_end () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACFI}
{\bkmkend AAAAAAACFI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v line_num\:toml::detail::region}
{\xe \v toml::detail::region\:line_num}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::detail::region::line_num () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACFJ}
{\bkmkend AAAAAAACFJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDQ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v name\:toml::detail::region}
{\xe \v toml::detail::region\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::detail::region::name () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACFK}
{\bkmkend AAAAAAACFK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDS \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v operator+=\:toml::detail::region}
{\xe \v toml::detail::region\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b region} & toml::detail::region::operator+= (const {\b region} &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACFL}
{\bkmkend AAAAAAACFL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::detail::region}
{\xe \v toml::detail::region\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b region} & toml::detail::region::operator= (const {\b region} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACFM}
{\bkmkend AAAAAAACFM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::detail::region}
{\xe \v toml::detail::region\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b region} & toml::detail::region::operator= ({\b region} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACFN}
{\bkmkend AAAAAAACFN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size\:toml::detail::region}
{\xe \v toml::detail::region\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::size_t toml::detail::region::size () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACFO}
{\bkmkend AAAAAAACFO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v source\:toml::detail::region}
{\xe \v toml::detail::region\:source}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b source_ptr} && toml::detail::region::source () &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACFP}
{\bkmkend AAAAAAACFP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v source\:toml::detail::region}
{\xe \v toml::detail::region\:source}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b source_ptr} const  & toml::detail::region::source () const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACFQ}
{\bkmkend AAAAAAACFQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v str\:toml::detail::region}
{\xe \v toml::detail::region\:str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::detail::region::str () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACFR}
{\bkmkend AAAAAAACFR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::detail::region_base} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACEC \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b region.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::region_base Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::region_base}
{\xe \v toml::detail::region_base}
{\bkmkstart AAAAAAACFS}
{\bkmkend AAAAAAACFS}
\par
{
{\f2 #include <region.hpp>}}\par
Inheritance diagram for toml::detail::region_base:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1region__base.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b region_base} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~region_base} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b region_base} (const {\b region_base} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b region_base} ({\b region_base} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b region_base} & {\b operator=} (const {\b region_base} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b region_base} & {\b operator=} ({\b region_base} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b is_ok} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual char {\b front} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b str} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b name} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b line} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::string {\b line_num} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::size_t {\b size} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::size_t {\b before} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::size_t {\b after} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual std::vector< std::string > {\b comments} () const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v region_base\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:region_base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::region_base::region_base (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACFT}
{\bkmkend AAAAAAACFT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~region_base\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:~region_base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual toml::detail::region_base::~region_base (){\f2 [virtual]}, {\f2 [default]}}}
\par
{\bkmkstart AAAAAAACFU}
{\bkmkend AAAAAAACFU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v region_base\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:region_base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::region_base::region_base (const {\b region_base} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACFV}
{\bkmkend AAAAAAACFV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v region_base\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:region_base}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::detail::region_base::region_base ({\b region_base} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACFW}
{\bkmkend AAAAAAACFW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v after\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:after}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::size_t toml::detail::region_base::after () const{\f2 [inline]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDB}
{\bkmkend AAAAAAACDB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b toml::detail::location} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDA \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b toml::detail::region} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACEV \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v before\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:before}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::size_t toml::detail::region_base::before () const{\f2 [inline]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDD}
{\bkmkend AAAAAAACDD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b toml::detail::location} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDC \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b toml::detail::region} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACEW \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v comments\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:comments}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::vector< std::string > toml::detail::region_base::comments () const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACEZ}
{\bkmkend AAAAAAACEZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b toml::detail::region} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACEY \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v front\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:front}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual char toml::detail::region_base::front () const{\f2 [inline]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDH}
{\bkmkend AAAAAAACDH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b toml::detail::location} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDG \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b toml::detail::region} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACFD \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v is_ok\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:is_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool toml::detail::region_base::is_ok () const{\f2 [inline]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDJ}
{\bkmkend AAAAAAACDJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b toml::detail::location} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDI \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b toml::detail::region} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACFE \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v line\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::string toml::detail::region_base::line () const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDM}
{\bkmkend AAAAAAACDM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b toml::detail::location} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDL \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b toml::detail::region} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACFG \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v line_num\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:line_num}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::string toml::detail::region_base::line_num () const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDQ}
{\bkmkend AAAAAAACDQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b toml::detail::location} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDP \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b toml::detail::region} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACFJ \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v name\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::string toml::detail::region_base::name () const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACDS}
{\bkmkend AAAAAAACDS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b toml::detail::location} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDR \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b toml::detail::region} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACFK \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v operator=\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b region_base} & toml::detail::region_base::operator= (const {\b region_base} & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACFX}
{\bkmkend AAAAAAACFX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b region_base} & toml::detail::region_base::operator= ({\b region_base} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACFY}
{\bkmkend AAAAAAACFY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v size\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::size_t toml::detail::region_base::size () const{\f2 [inline]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACDY}
{\bkmkend AAAAAAACDY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b toml::detail::location} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACDX \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b toml::detail::region} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACFO \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\xe \v str\:toml::detail::region_base}
{\xe \v toml::detail::region_base\:str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual std::string toml::detail::region_base::str () const{\f2 [inline]}, {\f2 [virtual]}}}
\par
{\bkmkstart AAAAAAACEC}
{\bkmkend AAAAAAACEC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented in {\b toml::detail::location} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACEB \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b toml::detail::region} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAACFR \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b region.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::remove_cvref< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::remove_cvref< T >}
{\xe \v toml::detail::remove_cvref< T >}
{\bkmkstart AAAAAAACFZ}
{\bkmkend AAAAAAACFZ}
\par
{
{\f2 #include <traits.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b type} = typename std::remove_cv< typename std::remove_reference< T >::type >::type\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v type\:toml::detail::remove_cvref< T >}
{\xe \v toml::detail::remove_cvref< T >\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b toml::detail::remove_cvref}< T >::type =  typename std::remove_cv< typename std::remove_reference<T>::type>::type}}
\par
{\bkmkstart AAAAAAACGA}
{\bkmkend AAAAAAACGA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b traits.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::repeat< T, N > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::repeat< T, N >}
{\xe \v toml::detail::repeat< T, N >}
{\bkmkstart AAAAAAACGB}
{\bkmkend AAAAAAACGB}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::repeat< T, at_least< N > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::repeat< T, at_least< N > >}
{\xe \v toml::detail::repeat< T, at_least< N > >}
{\bkmkstart AAAAAAACGC}
{\bkmkend AAAAAAACGC}
\par
{
{\f2 #include <combinator.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b result}< {\b region}, {\b none_t} > {\b invoke} ({\b location} &loc)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v invoke\:toml::detail::repeat< T, at_least< N > >}
{\xe \v toml::detail::repeat< T, at_least< N > >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , std::size_t N> static {\b result}< {\b region}, {\b none_t} > {\b toml::detail::repeat}< T, {\b at_least}< N > >::invoke ({\b location} &  {\i loc}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGD}
{\bkmkend AAAAAAACGD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::repeat< T, exactly< N > > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::repeat< T, exactly< N > >}
{\xe \v toml::detail::repeat< T, exactly< N > >}
{\bkmkstart AAAAAAACGE}
{\bkmkend AAAAAAACGE}
\par
{
{\f2 #include <combinator.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b result}< {\b region}, {\b none_t} > {\b invoke} ({\b location} &loc)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v invoke\:toml::detail::repeat< T, exactly< N > >}
{\xe \v toml::detail::repeat< T, exactly< N > >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , std::size_t N> static {\b result}< {\b region}, {\b none_t} > {\b toml::detail::repeat}< T, {\b exactly}< N > >::invoke ({\b location} &  {\i loc}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGF}
{\bkmkend AAAAAAACGF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::repeat< T, unlimited > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::repeat< T, unlimited >}
{\xe \v toml::detail::repeat< T, unlimited >}
{\bkmkstart AAAAAAACGG}
{\bkmkend AAAAAAACGG}
\par
{
{\f2 #include <combinator.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b result}< {\b region}, {\b none_t} > {\b invoke} ({\b location} &loc)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v invoke\:toml::detail::repeat< T, unlimited >}
{\xe \v toml::detail::repeat< T, unlimited >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > static {\b result}< {\b region}, {\b none_t} > {\b toml::detail::repeat}< T, {\b unlimited} >::invoke ({\b location} &  {\i loc}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGH}
{\bkmkend AAAAAAACGH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::result< T, E > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::result< T, E >}
{\xe \v toml::result< T, E >}
{\bkmkstart AAAAAAABIW}
{\bkmkend AAAAAAABIW}
\par
{
{\f2 #include <result.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = T\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b error_type} = E\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b success_type} = {\b success}< {\b value_type} >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b failure_type} = {\b failure}< {\b error_type} >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} (const {\b success_type} &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} (const {\b failure_type} &f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} ({\b success_type} &&s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} ({\b failure_type} &&f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b result} (const {\b success}< U > &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b result} (const {\b failure}< U > &f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b result} ({\b success}< U > &&s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b result} ({\b failure}< U > &&f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} & {\b operator=} (const {\b success_type} &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} & {\b operator=} (const {\b failure_type} &f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} & {\b operator=} ({\b success_type} &&s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} & {\b operator=} ({\b failure_type} &&f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b result} & {\b operator=} (const {\b success}< U > &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b result} & {\b operator=} (const {\b failure}< U > &f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b result} & {\b operator=} ({\b success}< U > &&s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b result} & {\b operator=} ({\b failure}< U > &&f)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~result} () noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} (const {\b result} &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} ({\b result} &&other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U , typename F > {\b result} (const {\b result}< U, F > &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U , typename F > {\b result} ({\b result}< U, F > &&other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} & {\b operator=} (const {\b result} &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} & {\b operator=} ({\b result} &&other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U , typename F > {\b result} & {\b operator=} (const {\b result}< U, F > &other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U , typename F > {\b result} & {\b operator=} ({\b result}< U, F > &&other)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_ok} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_err} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator bool} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} & {\b unwrap} () &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} const & {\b unwrap} () const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} && {\b unwrap} () &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} & {\b unwrap_or} ({\b value_type} &opt) &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} const & {\b unwrap_or} ({\b value_type} const &opt) const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} {\b unwrap_or} ({\b value_type} opt) &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b error_type} & {\b unwrap_err} () &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b error_type} const & {\b unwrap_err} () const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b error_type} && {\b unwrap_err} () &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} & {\b as_ok} () &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} const & {\b as_ok} () const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} && {\b as_ok} () &&noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b error_type} & {\b as_err} () &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b error_type} const & {\b as_err} () const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b error_type} && {\b as_err} () &&noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F > {\b result}< {\b detail::return_type_of_t}< F, {\b value_type} & >, {\b error_type} > {\b map} (F &&f) &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F > {\b result}< {\b detail::return_type_of_t}< F, {\b value_type} const & >, {\b error_type} > {\b map} (F &&f) const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F > {\b result}< {\b detail::return_type_of_t}< F, {\b value_type} && >, {\b error_type} > {\b map} (F &&f) &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F > {\b result}< {\b value_type}, {\b detail::return_type_of_t}< F, {\b error_type} & > > {\b map_err} (F &&f) &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F > {\b result}< {\b value_type}, {\b detail::return_type_of_t}< F, {\b error_type} const & > > {\b map_err} (F &&f) const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F > {\b result}< {\b value_type}, {\b detail::return_type_of_t}< F, {\b error_type} && > > {\b map_err} (F &&f) &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F , typename U > {\b detail::return_type_of_t}< F, {\b value_type} & > {\b map_or_else} (F &&f, U &&opt) &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F , typename U > {\b detail::return_type_of_t}< F, {\b value_type} const & > {\b map_or_else} (F &&f, U &&opt) const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F , typename U > {\b detail::return_type_of_t}< F, {\b value_type} && > {\b map_or_else} (F &&f, U &&opt) &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F , typename U > {\b detail::return_type_of_t}< F, {\b error_type} & > {\b map_err_or_else} (F &&f, U &&opt) &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F , typename U > {\b detail::return_type_of_t}< F, {\b error_type} const & > {\b map_err_or_else} (F &&f, U &&opt) const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F , typename U > {\b detail::return_type_of_t}< F, {\b error_type} && > {\b map_err_or_else} (F &&f, U &&opt) &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F > {\b detail::return_type_of_t}< F, {\b value_type} & > {\b and_then} (F &&f) &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F > {\b detail::return_type_of_t}< F, {\b value_type} const & > {\b and_then} (F &&f) const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F > {\b detail::return_type_of_t}< F, {\b value_type} && > {\b and_then} (F &&f) &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F > {\b detail::return_type_of_t}< F, {\b error_type} & > {\b or_else} (F &&f) &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F > {\b detail::return_type_of_t}< F, {\b error_type} const & > {\b or_else} (F &&f) const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F > {\b detail::return_type_of_t}< F, {\b error_type} && > {\b or_else} (F &&f) &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} {\b and_other} (const {\b result} &other) const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} {\b and_other} ({\b result} &&other) &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} {\b or_other} (const {\b result} &other) const &\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b result} {\b or_other} ({\b result} &&other) &&\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b swap} ({\b result}< T, E > &other)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v error_type\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:error_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > using {\b toml::result}< T, E >::error_type =  E}}
\par
{\bkmkstart AAAAAAABIX}
{\bkmkend AAAAAAABIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v failure_type\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:failure_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > using {\b toml::result}< T, E >::failure_type =  {\b failure}<{\b error_type}>}}
\par
{\bkmkstart AAAAAAABIY}
{\bkmkend AAAAAAABIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v success_type\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:success_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > using {\b toml::result}< T, E >::success_type =  {\b success}<{\b value_type}>}}
\par
{\bkmkstart AAAAAAABIZ}
{\bkmkend AAAAAAABIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value_type\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > using {\b toml::result}< T, E >::value_type =  T}}
\par
{\bkmkstart AAAAAAABJA}
{\bkmkend AAAAAAABJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v result\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b toml::result}< T, E >::result (const {\b success_type} &  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJB}
{\bkmkend AAAAAAABJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v result\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b toml::result}< T, E >::result (const {\b failure_type} &  {\i f}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJC}
{\bkmkend AAAAAAABJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v result\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b toml::result}< T, E >::result ({\b success_type} &&  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJD}
{\bkmkend AAAAAAABJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v result\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b toml::result}< T, E >::result ({\b failure_type} &&  {\i f}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJE}
{\bkmkend AAAAAAABJE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v result\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename U > {\b toml::result}< T, E >::result (const {\b success}< U > &  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJF}
{\bkmkend AAAAAAABJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v result\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename U > {\b toml::result}< T, E >::result (const {\b failure}< U > &  {\i f}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJG}
{\bkmkend AAAAAAABJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v result\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename U > {\b toml::result}< T, E >::result ({\b success}< U > &&  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJH}
{\bkmkend AAAAAAABJH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v result\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename U > {\b toml::result}< T, E >::result ({\b failure}< U > &&  {\i f}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJI}
{\bkmkend AAAAAAABJI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~result\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:~result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b toml::result}< T, E >::~{\b result} (){\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJJ}
{\bkmkend AAAAAAABJJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v result\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b toml::result}< T, E >::result (const {\b result}< T, E > &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJK}
{\bkmkend AAAAAAABJK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v result\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b toml::result}< T, E >::result ({\b result}< T, E > &&  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJL}
{\bkmkend AAAAAAABJL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v result\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename U , typename F > {\b toml::result}< T, E >::result (const {\b result}< U, F > &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJM}
{\bkmkend AAAAAAABJM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v result\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename U , typename F > {\b toml::result}< T, E >::result ({\b result}< U, F > &&  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJN}
{\bkmkend AAAAAAABJN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v and_other\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:and_other}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b result} {\b toml::result}< T, E >::and_other (const {\b result}< T, E > &  {\i other}) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJO}
{\bkmkend AAAAAAABJO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v and_other\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:and_other}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b result} {\b toml::result}< T, E >::and_other ({\b result}< T, E > &&  {\i other}) &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJP}
{\bkmkend AAAAAAABJP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v and_then\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:and_then}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F > {\b detail::return_type_of_t}< F, {\b value_type} & > {\b toml::result}< T, E >::and_then (F &&  {\i f}) &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJQ}
{\bkmkend AAAAAAABJQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v and_then\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:and_then}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F > {\b detail::return_type_of_t}< F, {\b value_type} && > {\b toml::result}< T, E >::and_then (F &&  {\i f}) &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJR}
{\bkmkend AAAAAAABJR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v and_then\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:and_then}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F > {\b detail::return_type_of_t}< F, {\b value_type} const  & > {\b toml::result}< T, E >::and_then (F &&  {\i f}) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABJS}
{\bkmkend AAAAAAABJS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_err\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:as_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b error_type} && {\b toml::result}< T, E >::as_err () &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJT}
{\bkmkend AAAAAAABJT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_err\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:as_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b error_type} & {\b toml::result}< T, E >::as_err () &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJU}
{\bkmkend AAAAAAABJU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_err\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:as_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b error_type} const  & {\b toml::result}< T, E >::as_err () const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJV}
{\bkmkend AAAAAAABJV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_ok\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:as_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b value_type} && {\b toml::result}< T, E >::as_ok () &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJW}
{\bkmkend AAAAAAABJW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_ok\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:as_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b value_type} & {\b toml::result}< T, E >::as_ok () &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJX}
{\bkmkend AAAAAAABJX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v as_ok\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:as_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b value_type} const  & {\b toml::result}< T, E >::as_ok () const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJY}
{\bkmkend AAAAAAABJY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is_err\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:is_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > bool {\b toml::result}< T, E >::is_err () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABJZ}
{\bkmkend AAAAAAABJZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v is_ok\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:is_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > bool {\b toml::result}< T, E >::is_ok () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKA}
{\bkmkend AAAAAAABKA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v map\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F > {\b result}< {\b detail::return_type_of_t}< F, {\b value_type} & >, {\b error_type} > {\b toml::result}< T, E >::map (F &&  {\i f}) &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKB}
{\bkmkend AAAAAAABKB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v map\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F > {\b result}< {\b detail::return_type_of_t}< F, {\b value_type} && >, {\b error_type} > {\b toml::result}< T, E >::map (F &&  {\i f}) &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKC}
{\bkmkend AAAAAAABKC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v map\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F > {\b result}< {\b detail::return_type_of_t}< F, {\b value_type} const  & >, {\b error_type} > {\b toml::result}< T, E >::map (F &&  {\i f}) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKD}
{\bkmkend AAAAAAABKD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v map_err\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:map_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F > {\b result}< {\b value_type}, {\b detail::return_type_of_t}< F, {\b error_type} & > > {\b toml::result}< T, E >::map_err (F &&  {\i f}) &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKE}
{\bkmkend AAAAAAABKE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v map_err\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:map_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F > {\b result}< {\b value_type}, {\b detail::return_type_of_t}< F, {\b error_type} && > > {\b toml::result}< T, E >::map_err (F &&  {\i f}) &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKF}
{\bkmkend AAAAAAABKF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v map_err\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:map_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F > {\b result}< {\b value_type}, {\b detail::return_type_of_t}< F, {\b error_type} const  & > > {\b toml::result}< T, E >::map_err (F &&  {\i f}) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKG}
{\bkmkend AAAAAAABKG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v map_err_or_else\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:map_err_or_else}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F , typename U > {\b detail::return_type_of_t}< F, {\b error_type} & > {\b toml::result}< T, E >::map_err_or_else (F &&  {\i f}, U &&  {\i opt}) &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKH}
{\bkmkend AAAAAAABKH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v map_err_or_else\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:map_err_or_else}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F , typename U > {\b detail::return_type_of_t}< F, {\b error_type} && > {\b toml::result}< T, E >::map_err_or_else (F &&  {\i f}, U &&  {\i opt}) &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKI}
{\bkmkend AAAAAAABKI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v map_err_or_else\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:map_err_or_else}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F , typename U > {\b detail::return_type_of_t}< F, {\b error_type} const  & > {\b toml::result}< T, E >::map_err_or_else (F &&  {\i f}, U &&  {\i opt}) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKJ}
{\bkmkend AAAAAAABKJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v map_or_else\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:map_or_else}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F , typename U > {\b detail::return_type_of_t}< F, {\b value_type} & > {\b toml::result}< T, E >::map_or_else (F &&  {\i f}, U &&  {\i opt}) &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKK}
{\bkmkend AAAAAAABKK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v map_or_else\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:map_or_else}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F , typename U > {\b detail::return_type_of_t}< F, {\b value_type} && > {\b toml::result}< T, E >::map_or_else (F &&  {\i f}, U &&  {\i opt}) &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKL}
{\bkmkend AAAAAAABKL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v map_or_else\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:map_or_else}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F , typename U > {\b detail::return_type_of_t}< F, {\b value_type} const  & > {\b toml::result}< T, E >::map_or_else (F &&  {\i f}, U &&  {\i opt}) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKM}
{\bkmkend AAAAAAABKM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator bool\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:operator bool}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b toml::result}< T, E >::operator bool () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABKN}
{\bkmkend AAAAAAABKN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename U > {\b result} & {\b toml::result}< T, E >::operator= (const {\b failure}< U > &  {\i f}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKO}
{\bkmkend AAAAAAABKO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b result} & {\b toml::result}< T, E >::operator= (const {\b failure_type} &  {\i f}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKP}
{\bkmkend AAAAAAABKP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b result} & {\b toml::result}< T, E >::operator= (const {\b result}< T, E > &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKQ}
{\bkmkend AAAAAAABKQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename U , typename F > {\b result} & {\b toml::result}< T, E >::operator= (const {\b result}< U, F > &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKR}
{\bkmkend AAAAAAABKR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename U > {\b result} & {\b toml::result}< T, E >::operator= (const {\b success}< U > &  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKS}
{\bkmkend AAAAAAABKS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b result} & {\b toml::result}< T, E >::operator= (const {\b success_type} &  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKT}
{\bkmkend AAAAAAABKT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename U > {\b result} & {\b toml::result}< T, E >::operator= ({\b failure}< U > &&  {\i f}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKU}
{\bkmkend AAAAAAABKU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b result} & {\b toml::result}< T, E >::operator= ({\b failure_type} &&  {\i f}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKV}
{\bkmkend AAAAAAABKV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b result} & {\b toml::result}< T, E >::operator= ({\b result}< T, E > &&  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKW}
{\bkmkend AAAAAAABKW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename U , typename F > {\b result} & {\b toml::result}< T, E >::operator= ({\b result}< U, F > &&  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKX}
{\bkmkend AAAAAAABKX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename U > {\b result} & {\b toml::result}< T, E >::operator= ({\b success}< U > &&  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKY}
{\bkmkend AAAAAAABKY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b result} & {\b toml::result}< T, E >::operator= ({\b success_type} &&  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABKZ}
{\bkmkend AAAAAAABKZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v or_else\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:or_else}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F > {\b detail::return_type_of_t}< F, {\b error_type} & > {\b toml::result}< T, E >::or_else (F &&  {\i f}) &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLA}
{\bkmkend AAAAAAABLA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v or_else\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:or_else}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F > {\b detail::return_type_of_t}< F, {\b error_type} && > {\b toml::result}< T, E >::or_else (F &&  {\i f}) &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLB}
{\bkmkend AAAAAAABLB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v or_else\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:or_else}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > template<typename F > {\b detail::return_type_of_t}< F, {\b error_type} const  & > {\b toml::result}< T, E >::or_else (F &&  {\i f}) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLC}
{\bkmkend AAAAAAABLC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v or_other\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:or_other}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b result} {\b toml::result}< T, E >::or_other (const {\b result}< T, E > &  {\i other}) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLD}
{\bkmkend AAAAAAABLD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v or_other\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:or_other}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b result} {\b toml::result}< T, E >::or_other ({\b result}< T, E > &&  {\i other}) &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLE}
{\bkmkend AAAAAAABLE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v swap\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:swap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > void {\b toml::result}< T, E >::swap ({\b result}< T, E > &  {\i other}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLF}
{\bkmkend AAAAAAABLF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v unwrap\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:unwrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b value_type} & {\b toml::result}< T, E >::unwrap () &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLG}
{\bkmkend AAAAAAABLG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v unwrap\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:unwrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b value_type} && {\b toml::result}< T, E >::unwrap () &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLH}
{\bkmkend AAAAAAABLH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v unwrap\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:unwrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b value_type} const  & {\b toml::result}< T, E >::unwrap () const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLI}
{\bkmkend AAAAAAABLI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v unwrap_err\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:unwrap_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b error_type} & {\b toml::result}< T, E >::unwrap_err () &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLJ}
{\bkmkend AAAAAAABLJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v unwrap_err\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:unwrap_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b error_type} && {\b toml::result}< T, E >::unwrap_err () &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLK}
{\bkmkend AAAAAAABLK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v unwrap_err\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:unwrap_err}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b error_type} const  & {\b toml::result}< T, E >::unwrap_err () const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLL}
{\bkmkend AAAAAAABLL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v unwrap_or\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:unwrap_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b value_type} & {\b toml::result}< T, E >::unwrap_or ({\b value_type} &  {\i opt}) &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLM}
{\bkmkend AAAAAAABLM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v unwrap_or\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:unwrap_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b value_type} const  & {\b toml::result}< T, E >::unwrap_or ({\b value_type} const &  {\i opt}) const &{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLN}
{\bkmkend AAAAAAABLN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v unwrap_or\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:unwrap_or}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b value_type} {\b toml::result}< T, E >::unwrap_or ({\b value_type}  {\i opt}) &&{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABLO}
{\bkmkend AAAAAAABLO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v fail\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:fail}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b failure_type} {\b toml::result}< T, E >::fail}}
\par
{\bkmkstart AAAAAAABLP}
{\bkmkend AAAAAAABLP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v succ\:toml::result< T, E >}
{\xe \v toml::result< T, E >\:succ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T , typename E > {\b success_type} {\b toml::result}< T, E >::succ}}
\par
{\bkmkstart AAAAAAABLQ}
{\bkmkend AAAAAAABLQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b result.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::sequence< Ts > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::sequence< Ts >}
{\xe \v toml::detail::sequence< Ts >}
{\bkmkstart AAAAAAACGI}
{\bkmkend AAAAAAACGI}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::sequence< Head > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::sequence< Head >}
{\xe \v toml::detail::sequence< Head >}
{\bkmkstart AAAAAAACGJ}
{\bkmkend AAAAAAACGJ}
\par
{
{\f2 #include <combinator.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Iterator > static {\b result}< {\b region}, {\b none_t} > {\b invoke} ({\b location} &loc, {\b region} reg, Iterator first)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v invoke\:toml::detail::sequence< Head >}
{\xe \v toml::detail::sequence< Head >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Head > template<typename Iterator > static {\b result}< {\b region}, {\b none_t} > {\b toml::detail::sequence}< Head >::invoke ({\b location} &  {\i loc}, {\b region}  {\i reg}, Iterator  {\i first}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGK}
{\bkmkend AAAAAAACGK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::sequence< Head, Tail... > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::sequence< Head, Tail... >}
{\xe \v toml::detail::sequence< Head, Tail... >}
{\bkmkstart AAAAAAACGL}
{\bkmkend AAAAAAACGL}
\par
{
{\f2 #include <combinator.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static {\b result}< {\b region}, {\b none_t} > {\b invoke} ({\b location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Iterator > static {\b result}< {\b region}, {\b none_t} > {\b invoke} ({\b location} &loc, {\b region} reg, Iterator first)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v invoke\:toml::detail::sequence< Head, Tail... >}
{\xe \v toml::detail::sequence< Head, Tail... >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Head , typename ... Tail> static {\b result}< {\b region}, {\b none_t} > {\b toml::detail::sequence}< Head, Tail... >::invoke ({\b location} &  {\i loc}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGM}
{\bkmkend AAAAAAACGM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v invoke\:toml::detail::sequence< Head, Tail... >}
{\xe \v toml::detail::sequence< Head, Tail... >\:invoke}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Head , typename ... Tail> template<typename Iterator > static {\b result}< {\b region}, {\b none_t} > {\b toml::detail::sequence}< Head, Tail... >::invoke ({\b location} &  {\i loc}, {\b region}  {\i reg}, Iterator  {\i first}){\f2 [inline]}, {\f2 [static]}}}
\par
{\bkmkstart AAAAAAACGN}
{\bkmkend AAAAAAACGN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::serializer< Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::serializer< Value >}
{\xe \v toml::serializer< Value >}
{\bkmkstart AAAAAAABLR}
{\bkmkend AAAAAAABLR}
\par
{
{\f2 #include <serializer.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = Value\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b key_type} = typename value_type::key_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b comment_type} = typename value_type::comment_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b boolean_type} = typename value_type::boolean_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b integer_type} = typename value_type::integer_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b floating_type} = typename value_type::floating_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b string_type} = typename value_type::string_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b local_time_type} = typename value_type::local_time_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b local_date_type} = typename value_type::local_date_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b local_datetime_type} = typename value_type::local_datetime_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b offset_datetime_type} = typename value_type::offset_datetime_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b array_type} = typename value_type::array_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b table_type} = typename value_type::table_type\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b serializer} (const std::size_t w=80u, const int float_prec=std::numeric_limits< {\b toml::floating} >::max_digits10, const bool can_be_inlined=false, const bool no_comment=false, std::vector< {\b toml::key} > ks=\{\}, const bool value_has_comment=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~serializer} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b operator()} (const {\b boolean_type} &b) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b operator()} (const {\b integer_type} i) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b operator()} (const {\b floating_type} f) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b operator()} (const {\b string_type} &s) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b operator()} (const {\b local_date_type} &d) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b operator()} (const {\b local_time_type} &t) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b operator()} (const {\b local_datetime_type} &dt) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b operator()} (const {\b offset_datetime_type} &odt) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b operator()} (const {\b array_type} &v) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b operator()} (const {\b table_type} &v) const\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v array_type\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:array_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::serializer}< Value >::array_type =  typename value_type::array_type}}
\par
{\bkmkstart AAAAAAABLS}
{\bkmkend AAAAAAABLS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v boolean_type\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:boolean_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::serializer}< Value >::boolean_type =  typename value_type::boolean_type}}
\par
{\bkmkstart AAAAAAABLT}
{\bkmkend AAAAAAABLT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v comment_type\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:comment_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::serializer}< Value >::comment_type =  typename value_type::comment_type}}
\par
{\bkmkstart AAAAAAABLU}
{\bkmkend AAAAAAABLU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v floating_type\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:floating_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::serializer}< Value >::floating_type =  typename value_type::floating_type}}
\par
{\bkmkstart AAAAAAABLV}
{\bkmkend AAAAAAABLV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v integer_type\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:integer_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::serializer}< Value >::integer_type =  typename value_type::integer_type}}
\par
{\bkmkstart AAAAAAABLW}
{\bkmkend AAAAAAABLW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v key_type\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:key_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::serializer}< Value >::key_type =  typename value_type::key_type}}
\par
{\bkmkstart AAAAAAABLX}
{\bkmkend AAAAAAABLX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_date_type\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:local_date_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::serializer}< Value >::local_date_type =  typename value_type::local_date_type}}
\par
{\bkmkstart AAAAAAABLY}
{\bkmkend AAAAAAABLY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_datetime_type\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:local_datetime_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::serializer}< Value >::local_datetime_type =  typename value_type::local_datetime_type}}
\par
{\bkmkstart AAAAAAABLZ}
{\bkmkend AAAAAAABLZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v local_time_type\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:local_time_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::serializer}< Value >::local_time_type =  typename value_type::local_time_type}}
\par
{\bkmkstart AAAAAAABMA}
{\bkmkend AAAAAAABMA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v offset_datetime_type\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:offset_datetime_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::serializer}< Value >::offset_datetime_type =  typename value_type::offset_datetime_type}}
\par
{\bkmkstart AAAAAAABMB}
{\bkmkend AAAAAAABMB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v string_type\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:string_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::serializer}< Value >::string_type =  typename value_type::string_type}}
\par
{\bkmkstart AAAAAAABMC}
{\bkmkend AAAAAAABMC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v table_type\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:table_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::serializer}< Value >::table_type =  typename value_type::table_type}}
\par
{\bkmkstart AAAAAAABMD}
{\bkmkend AAAAAAABMD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value_type\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > using {\b toml::serializer}< Value >::value_type =  Value}}
\par
{\bkmkstart AAAAAAABME}
{\bkmkend AAAAAAABME}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v serializer\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:serializer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > {\b toml::serializer}< Value >::serializer (const std::size_t  {\i w} = {\f2 80u}, const int  {\i float_prec} = {\f2 std::numeric_limits<{\b toml::floating}>::max_digits10}, const bool  {\i can_be_inlined} = {\f2 false}, const bool  {\i no_comment} = {\f2 false}, std::vector< {\b toml::key} >  {\i ks} = {\f2 \{\}}, const bool  {\i value_has_comment} = {\f2 false}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMF}
{\bkmkend AAAAAAABMF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~serializer\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:~serializer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > {\b toml::serializer}< Value >::~{\b serializer} (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABMG}
{\bkmkend AAAAAAABMG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > std::string {\b toml::serializer}< Value >::operator() (const {\b array_type} &  {\i v}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMH}
{\bkmkend AAAAAAABMH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator()\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > std::string {\b toml::serializer}< Value >::operator() (const {\b boolean_type} &  {\i b}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMI}
{\bkmkend AAAAAAABMI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator()\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > std::string {\b toml::serializer}< Value >::operator() (const {\b floating_type}  {\i f}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMJ}
{\bkmkend AAAAAAABMJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator()\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > std::string {\b toml::serializer}< Value >::operator() (const {\b integer_type}  {\i i}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMK}
{\bkmkend AAAAAAABMK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator()\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > std::string {\b toml::serializer}< Value >::operator() (const {\b local_date_type} &  {\i d}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABML}
{\bkmkend AAAAAAABML}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator()\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > std::string {\b toml::serializer}< Value >::operator() (const {\b local_datetime_type} &  {\i dt}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMM}
{\bkmkend AAAAAAABMM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator()\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > std::string {\b toml::serializer}< Value >::operator() (const {\b local_time_type} &  {\i t}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMN}
{\bkmkend AAAAAAABMN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator()\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > std::string {\b toml::serializer}< Value >::operator() (const {\b offset_datetime_type} &  {\i odt}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMO}
{\bkmkend AAAAAAABMO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator()\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > std::string {\b toml::serializer}< Value >::operator() (const {\b string_type} &  {\i s}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMP}
{\bkmkend AAAAAAABMP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator()\:toml::serializer< Value >}
{\xe \v toml::serializer< Value >\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename Value > std::string {\b toml::serializer}< Value >::operator() (const {\b table_type} &  {\i v}) const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMQ}
{\bkmkend AAAAAAABMQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b serializer.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SettingsManager Struct Reference\par \pard\plain 
{\tc\tcl2 \v SettingsManager}
{\xe \v SettingsManager}
{\bkmkstart AAAAAAAAHW}
{\bkmkend AAAAAAAAHW}
\par
{
{\f2 #include <SettingsManager.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SettingsManager} (std::string settingsPath="../src/settings.toml")\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'A1\'D1\'82\'D1\'80\'D1\'83\'D0\'BA\'D1\'82\'D1\'83\'D1\'80\'D0\'B0 \'D1\'81\'D0\'BE\'D0\'B4\'D0\'B5\'D1\'80\'D0\'B6\'D0\'B0\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B2\'D1\'81\'D0\'B5 \'D0\'BD\'D0\'B0\'D1\'81\'D1\'82\'D1\'80\'D0\'BE\'D0\'B9\'D0\'BA\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D1\'8B }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > T {\b get} ({\b toml::value} settingsType, std::string key)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'BD\'D0\'B0\'D1\'81\'D1\'82\'D1\'80\'D0\'BE\'D0\'B9\'D0\'BA\'D1\'83 \'D0\'BF\'D0\'BE \'D0\'BA\'D0\'BB\'D1\'8E\'D1\'87\'D1\'83 }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b toml::value} {\b PlayerSettings}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b toml::value} {\b PlayerSpritesSettings}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b toml::value} {\b SpriteSettings}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b toml::value} {\b TileIndexes}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b toml::value} {\b TileMapSettings}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b toml::value} {\b SoundSettings}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b toml::value} {\b WorldGenSettings}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b toml::value} {\b EnemySettings}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SettingsManager\:SettingsManager}
{\xe \v SettingsManager\:SettingsManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SettingsManager::SettingsManager (std::string  {\i settingsPath} = {\f2 "../src/settings.toml"})}}
\par
{\bkmkstart AAAAAAAAHX}
{\bkmkend AAAAAAAAHX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'A1\'D1\'82\'D1\'80\'D1\'83\'D0\'BA\'D1\'82\'D1\'83\'D1\'80\'D0\'B0 \'D1\'81\'D0\'BE\'D0\'B4\'D0\'B5\'D1\'80\'D0\'B6\'D0\'B0\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B2\'D1\'81\'D0\'B5 \'D0\'BD\'D0\'B0\'D1\'81\'D1\'82\'D1\'80\'D0\'BE\'D0\'B9\'D0\'BA\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D1\'8B }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i settingsPath} \cell }{\'D0\'BF\'D1\'83\'D1\'82\'D1\'8C \'D0\'BA \'D1\'84\'D0\'B0\'D0\'B9\'D0\'BB\'D1\'83 \'D0\'BD\'D0\'B0\'D1\'81\'D1\'82\'D1\'80\'D0\'BE\'D0\'B5\'D0\'BA \'D0\'B8\'D0\'B3\'D1\'80\'D1\'8B (toml) \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get\:SettingsManager}
{\xe \v SettingsManager\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > T SettingsManager::get ({\b toml::value}  {\i settingsType}, std::string  {\i key}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAAAHY}
{\bkmkend AAAAAAAAHY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'BD\'D0\'B0\'D1\'81\'D1\'82\'D1\'80\'D0\'BE\'D0\'B9\'D0\'BA\'D1\'83 \'D0\'BF\'D0\'BE \'D0\'BA\'D0\'BB\'D1\'8E\'D1\'87\'D1\'83 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i settingsType} \cell }{\'D0\'B8\'D0\'BD\'D1\'82\'D0\'B5\'D1\'80\'D0\'B5\'D1\'81\'D1\'83\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BF\'D0\'B8\'D1\'81\'D0\'BE\'D0\'BA \'D0\'BD\'D0\'B0\'D1\'81\'D1\'82\'D1\'80\'D0\'BE\'D0\'B5\'D0\'BA \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i key} \cell }{\'D0\'BA\'D0\'BB\'D1\'8E\'D1\'87(\'D0\'BD\'D0\'B0\'D0\'B7\'D0\'B2\'D0\'B0\'D0\'BD\'D0\'B8\'D0\'B5) \'D0\'BD\'D0\'B0\'D1\'81\'D1\'82\'D1\'80\'D0\'BE\'D0\'B9\'D0\'BA\'D0\'B8 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i T} \cell }{\'D1\'82\'D0\'B8\'D0\'BF \'D0\'BD\'D0\'B0\'D1\'81\'D1\'82\'D1\'80\'D0\'BE\'D0\'B9\'D0\'BA\'D0\'B8 \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v EnemySettings\:SettingsManager}
{\xe \v SettingsManager\:EnemySettings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b toml::value} SettingsManager::EnemySettings}}
\par
{\bkmkstart AAAAAAAAHZ}
{\bkmkend AAAAAAAAHZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PlayerSettings\:SettingsManager}
{\xe \v SettingsManager\:PlayerSettings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b toml::value} SettingsManager::PlayerSettings}}
\par
{\bkmkstart AAAAAAAAIA}
{\bkmkend AAAAAAAAIA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v PlayerSpritesSettings\:SettingsManager}
{\xe \v SettingsManager\:PlayerSpritesSettings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b toml::value} SettingsManager::PlayerSpritesSettings}}
\par
{\bkmkstart AAAAAAAAIB}
{\bkmkend AAAAAAAAIB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SoundSettings\:SettingsManager}
{\xe \v SettingsManager\:SoundSettings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b toml::value} SettingsManager::SoundSettings}}
\par
{\bkmkstart AAAAAAAAIC}
{\bkmkend AAAAAAAAIC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SpriteSettings\:SettingsManager}
{\xe \v SettingsManager\:SpriteSettings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b toml::value} SettingsManager::SpriteSettings}}
\par
{\bkmkstart AAAAAAAAID}
{\bkmkend AAAAAAAAID}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TileIndexes\:SettingsManager}
{\xe \v SettingsManager\:TileIndexes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b toml::value} SettingsManager::TileIndexes}}
\par
{\bkmkstart AAAAAAAAIE}
{\bkmkend AAAAAAAAIE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TileMapSettings\:SettingsManager}
{\xe \v SettingsManager\:TileMapSettings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b toml::value} SettingsManager::TileMapSettings}}
\par
{\bkmkstart AAAAAAAAIF}
{\bkmkend AAAAAAAAIF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v WorldGenSettings\:SettingsManager}
{\xe \v SettingsManager\:WorldGenSettings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b toml::value} SettingsManager::WorldGenSettings}}
\par
{\bkmkstart AAAAAAAAIG}
{\bkmkend AAAAAAAAIG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SettingsManager/{\b SettingsManager.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SettingsManager/{\b SettingsManager.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SimplexNoise Class Reference\par \pard\plain 
{\tc\tcl2 \v SimplexNoise}
{\xe \v SimplexNoise}
{\bkmkstart AAAAAAAAIH}
{\bkmkend AAAAAAAAIH}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Perlin Simplex Noise C++ Implementation (1D, 2D, 3D, 4D). }}\par
{
{\f2 #include <SimplexNoise.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b fractal} (size_t octaves, float x) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b fractal} (size_t octaves, float x, float y) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
float {\b fractal} (size_t octaves, float x, float y, float z) const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SimplexNoise} (float frequency=1.0f, float amplitude=1.0f, float lacunarity=2.0f, float persistence=0.5f)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static float {\b noise} (float x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static float {\b noise} (float x, float y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
static float {\b noise} (float x, float y, float z)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Perlin Simplex Noise C++ Implementation (1D, 2D, 3D, 4D). \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SimplexNoise\:SimplexNoise}
{\xe \v SimplexNoise\:SimplexNoise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SimplexNoise::SimplexNoise (float  {\i frequency} = {\f2 1.0f}, float  {\i amplitude} = {\f2 1.0f}, float  {\i lacunarity} = {\f2 2.0f}, float  {\i persistence} = {\f2 0.5f}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAAAII}
{\bkmkend AAAAAAAAII}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Constructor of to initialize a fractal noise summation\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i frequency} \cell }{Frequency ("width") of the first octave of noise (default to 1.0) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i amplitude} \cell }{Amplitude ("height") of the first octave of noise (default to 1.0) \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i lacunarity} \cell }{Lacunarity specifies the frequency multiplier between successive octaves (default to 2.0). \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i persistence} \cell }{Persistence is the loss of amplitude between successive octaves (usually 1/lacunarity) \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v fractal\:SimplexNoise}
{\xe \v SimplexNoise\:fractal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float SimplexNoise::fractal (size_t  {\i octaves}, float  {\i x}) const}}
\par
{\bkmkstart AAAAAAAAIJ}
{\bkmkend AAAAAAAAIJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fractal/Fractional Brownian Motion (fBm) summation of 1D Perlin Simplex noise\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i octaves} \cell }{number of fraction of noise to sum \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i x} \cell }{float coordinate\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Noise value in the range[-1; 1], value of 0 on all integer coordinates. \par
}}}}
{\xe \v fractal\:SimplexNoise}
{\xe \v SimplexNoise\:fractal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float SimplexNoise::fractal (size_t  {\i octaves}, float  {\i x}, float  {\i y}) const}}
\par
{\bkmkstart AAAAAAAAIK}
{\bkmkend AAAAAAAAIK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fractal/Fractional Brownian Motion (fBm) summation of 2D Perlin Simplex noise\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i octaves} \cell }{number of fraction of noise to sum \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i x} \cell }{x float coordinate \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i y} \cell }{y float coordinate\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Noise value in the range[-1; 1], value of 0 on all integer coordinates. \par
}}}}
{\xe \v fractal\:SimplexNoise}
{\xe \v SimplexNoise\:fractal}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float SimplexNoise::fractal (size_t  {\i octaves}, float  {\i x}, float  {\i y}, float  {\i z}) const}}
\par
{\bkmkstart AAAAAAAAIL}
{\bkmkend AAAAAAAAIL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Fractal/Fractional Brownian Motion (fBm) summation of 3D Perlin Simplex noise\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i octaves} \cell }{number of fraction of noise to sum \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i x} \cell }{x float coordinate \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i y} \cell }{y float coordinate \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i z} \cell }{z float coordinate\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Noise value in the range[-1; 1], value of 0 on all integer coordinates. \par
}}}}
{\xe \v noise\:SimplexNoise}
{\xe \v SimplexNoise\:noise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float SimplexNoise::noise (float  {\i x}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIM}
{\bkmkend AAAAAAAAIM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
1D Perlin simplex noise\par
Takes around 74ns on an AMD APU.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i x} \cell }{float coordinate\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Noise value in the range[-1; 1], value of 0 on all integer coordinates. \par
}}}}
{\xe \v noise\:SimplexNoise}
{\xe \v SimplexNoise\:noise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float SimplexNoise::noise (float  {\i x}, float  {\i y}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIN}
{\bkmkend AAAAAAAAIN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
2D Perlin simplex noise\par
Takes around 150ns on an AMD APU.\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i x} \cell }{float coordinate \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i y} \cell }{float coordinate\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Noise value in the range[-1; 1], value of 0 on all integer coordinates. \par
}}}}
{\xe \v noise\:SimplexNoise}
{\xe \v SimplexNoise\:noise}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
float SimplexNoise::noise (float  {\i x}, float  {\i y}, float  {\i z}){\f2 [static]}}}
\par
{\bkmkstart AAAAAAAAIO}
{\bkmkend AAAAAAAAIO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
3D Perlin simplex noise\par
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i x} \cell }{float coordinate \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i y} \cell }{float coordinate \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx1224
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx3061
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{in\cell }{{\i z} \cell }{float coordinate\cell }
{\row }
}
{{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Returns\par}\pard\plain \s82\li720\widctlpar\ql\adjustright \fs20\cgrid {\s17 \sa60 \sb30
Noise value in the range[-1; 1], value of 0 on all integer coordinates. \par
}}}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/SimplexNoise/{\b SimplexNoise.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/SimplexNoise/{\b SimplexNoise.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::source_location Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::source_location}
{\xe \v toml::source_location}
{\bkmkstart AAAAAAABMR}
{\bkmkend AAAAAAABMR}
\par
{
{\f2 #include <source_location.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b source_location} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b source_location} (const {\b detail::region_base} *reg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b source_location} (const {\b detail::region} &reg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b source_location} (const {\b detail::location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~source_location} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b source_location} ({\b source_location} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b source_location} ({\b source_location} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b source_location} & {\b operator=} ({\b source_location} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b source_location} & {\b operator=} ({\b source_location} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint_least32_t {\b line} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint_least32_t {\b column} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::uint_least32_t {\b region} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string const & {\b file_name} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string const & {\b line_str} () const noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v source_location\:toml::source_location}
{\xe \v toml::source_location\:source_location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::source_location::source_location (){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABMS}
{\bkmkend AAAAAAABMS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v source_location\:toml::source_location}
{\xe \v toml::source_location\:source_location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::source_location::source_location (const {\b detail::region_base} *  {\i reg}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABMT}
{\bkmkend AAAAAAABMT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v source_location\:toml::source_location}
{\xe \v toml::source_location\:source_location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::source_location::source_location (const {\b detail::region} &  {\i reg}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABMU}
{\bkmkend AAAAAAABMU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v source_location\:toml::source_location}
{\xe \v toml::source_location\:source_location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::source_location::source_location (const {\b detail::location} &  {\i loc}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABMV}
{\bkmkend AAAAAAABMV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~source_location\:toml::source_location}
{\xe \v toml::source_location\:~source_location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::source_location::~source_location (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABMW}
{\bkmkend AAAAAAABMW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v source_location\:toml::source_location}
{\xe \v toml::source_location\:source_location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::source_location::source_location ({\b source_location} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABMX}
{\bkmkend AAAAAAABMX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v source_location\:toml::source_location}
{\xe \v toml::source_location\:source_location}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::source_location::source_location ({\b source_location} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABMY}
{\bkmkend AAAAAAABMY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v column\:toml::source_location}
{\xe \v toml::source_location\:column}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint_least32_t toml::source_location::column () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABMZ}
{\bkmkend AAAAAAABMZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v file_name\:toml::source_location}
{\xe \v toml::source_location\:file_name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string const  & toml::source_location::file_name () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNA}
{\bkmkend AAAAAAABNA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v line\:toml::source_location}
{\xe \v toml::source_location\:line}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint_least32_t toml::source_location::line () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNB}
{\bkmkend AAAAAAABNB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v line_str\:toml::source_location}
{\xe \v toml::source_location\:line_str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string const  & toml::source_location::line_str () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNC}
{\bkmkend AAAAAAABNC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::source_location}
{\xe \v toml::source_location\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b source_location} & toml::source_location::operator= ({\b source_location} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABND}
{\bkmkend AAAAAAABND}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::source_location}
{\xe \v toml::source_location\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b source_location} & toml::source_location::operator= ({\b source_location} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABNE}
{\bkmkend AAAAAAABNE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v region\:toml::source_location}
{\xe \v toml::source_location\:region}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::uint_least32_t toml::source_location::region () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNF}
{\bkmkend AAAAAAABNF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b source_location.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SpriteController Struct Reference\par \pard\plain 
{\tc\tcl2 \v SpriteController}
{\xe \v SpriteController}
{\bkmkstart AAAAAAAAIP}
{\bkmkend AAAAAAAAIP}
\par
{
{\f2 #include <SpriteController.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SpriteController} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b SpriteController} ({\b SettingsManager} &settingsManager)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'A1\'D1\'82\'D1\'80\'D1\'83\'D0\'BA\'D1\'82\'D1\'83\'D1\'80\'D0\'B0, \'D1\'81\'D0\'BE\'D0\'B4\'D0\'B5\'D1\'80\'D0\'B6\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8F \'D0\'B2\'D1\'81\'D0\'B5 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D1\'8B \'D0\'B8 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D1\'8B }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b processSettings} ({\b toml::table} &table, bool isPlayerSettings=false)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BE\'D0\'B1\'D1\'80\'D0\'B0\'D0\'B1\'D0\'B0\'D1\'82\'D1\'8B\'D0\'B2\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'BE\'D0\'BF\'D1\'80\'D0\'B5\'D0\'B4\'D0\'B5\'D0\'BB\'D0\'B5\'D0\'BD\'D0\'BD\'D1\'83\'D1\'8E \'D1\'82\'D0\'B0\'D0\'B1\'D0\'BB\'D0\'B8\'D1\'86\'D1\'83 \'D0\'B8\'D0\'B7 \'D0\'BD\'D0\'B0\'D1\'81\'D1\'82\'D1\'80\'D0\'BE\'D0\'B5\'D0\'BA \'D1\'81 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'B0\'D0\'BC\'D0\'B8 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b load_textures} (std::string name, std::string path)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BE\'D0\'B1\'D1\'80\'D0\'B0\'D0\'B1\'D0\'B0\'D1\'82\'D1\'8B\'D0\'B2\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D1\'8B }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b load_player_sprites} (std::string name, std::string path, sf::Vector2u tilesize)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D1\'81\'D0\'BE\'D0\'B7\'D0\'B4\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D1\'8B \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b load_sprites} (std::string name, std::string path, sf::Vector2u tilesize)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D1\'81\'D0\'BE\'D0\'B7\'D0\'B4\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D1\'8B }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< sf::Sprite > {\b make_sprite} (sf::Texture &texture, sf::Vector2u tilesize)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D1\'81\'D0\'BE\'D0\'B7\'D0\'B4\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D1\'8B \'D0\'B8\'D0\'B7 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D1\'8B }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b configureSprites} ({\b toml::value} TileIndexSettings)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BE\'D1\'80\'D0\'B3\'D0\'B0\'D0\'BD\'D0\'B8\'D0\'B7\'D1\'83\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B8\'D0\'B7 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'BE\'D0\'B2 \'D0\'B8 \'D0\'B8\'D0\'BD\'D0\'B4\'D0\'B5\'D0\'BA\'D1\'81\'D0\'BE\'D0\'B2 \'D1\'82\'D0\'B0\'D0\'B9\'D0\'BB\'D0\'BE\'D0\'B2 \'D0\'B7\'D0\'B0\'D0\'B4\'D0\'B0\'D0\'BD\'D0\'BD\'D1\'8B\'D1\'85 \'D0\'B2 \'D0\'BD\'D0\'B0\'D1\'81\'D1\'82\'D1\'80\'D0\'BE\'D0\'B9\'D0\'BA\'D0\'B0\'D1\'85 \'D1\'81\'D0\'BB\'D0\'BE\'D0\'B2\'D0\'B0\'D1\'80\'D1\'8C }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b indexesToindex} (int i, int j)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BF\'D1\'80\'D0\'B5\'D0\'BE\'D0\'B1\'D1\'80\'D0\'B0\'D0\'B7\'D1\'83\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B8\'D0\'BD\'D0\'B4\'D0\'B5\'D0\'BA\'D1\'81\'D1\'8B \'D0\'B4\'D0\'B2\'D1\'83\'D0\'BC\'D0\'B5\'D1\'80\'D0\'BD\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BC\'D0\'B0\'D1\'81\'D1\'81\'D0\'B8\'D0\'B2\'D0\'B0 \'D0\'B2 \'D0\'B8\'D0\'BD\'D0\'B4\'D0\'B5\'D0\'BA\'D1\'81\'D1\'8B \'D0\'BE\'D0\'B4\'D0\'BD\'D0\'BE\'D0\'BC\'D0\'B5\'D1\'80\'D0\'BD\'D0\'BE\'D0\'B3\'D0\'BE }{
}\par
}\par}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< std::string, sf::Texture > {\b textures}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< std::string, std::vector< sf::Sprite > > {\b spriteArrays}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< std::string, sf::Sprite > {\b spriteObjects}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::map< std::string, std::vector< sf::Sprite > > {\b playerSprites}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::pair< int, int > {\b tilemap_size}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v SpriteController\:SpriteController}
{\xe \v SpriteController\:SpriteController}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SpriteController::SpriteController (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAAAIQ}
{\bkmkend AAAAAAAAIQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SpriteController\:SpriteController}
{\xe \v SpriteController\:SpriteController}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
SpriteController::SpriteController ({\b SettingsManager} &  {\i settingsManager})}}
\par
{\bkmkstart AAAAAAAAIR}
{\bkmkend AAAAAAAAIR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'A1\'D1\'82\'D1\'80\'D1\'83\'D0\'BA\'D1\'82\'D1\'83\'D1\'80\'D0\'B0, \'D1\'81\'D0\'BE\'D0\'B4\'D0\'B5\'D1\'80\'D0\'B6\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8F \'D0\'B2\'D1\'81\'D0\'B5 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D1\'8B \'D0\'B8 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D1\'8B }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i settingsManager} \cell }{\'D1\'81\'D1\'81\'D1\'8B\'D0\'BB\'D0\'BA\'D0\'B0 \'D0\'BD\'D0\'B0 \'D1\'81\'D1\'82\'D1\'80\'D1\'83\'D0\'BA\'D1\'82\'D1\'83\'D1\'80\'D1\'83 \'D1\'81 \'D0\'BD\'D0\'B0\'D1\'81\'D1\'82\'D1\'80\'D0\'BE\'D0\'B9\'D0\'BA\'D0\'B0\'D0\'BC\'D0\'B8 \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v configureSprites\:SpriteController}
{\xe \v SpriteController\:configureSprites}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SpriteController::configureSprites ({\b toml::value}  {\i TileIndexSettings})}}
\par
{\bkmkstart AAAAAAAAIS}
{\bkmkend AAAAAAAAIS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BE\'D1\'80\'D0\'B3\'D0\'B0\'D0\'BD\'D0\'B8\'D0\'B7\'D1\'83\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B8\'D0\'B7 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'BE\'D0\'B2 \'D0\'B8 \'D0\'B8\'D0\'BD\'D0\'B4\'D0\'B5\'D0\'BA\'D1\'81\'D0\'BE\'D0\'B2 \'D1\'82\'D0\'B0\'D0\'B9\'D0\'BB\'D0\'BE\'D0\'B2 \'D0\'B7\'D0\'B0\'D0\'B4\'D0\'B0\'D0\'BD\'D0\'BD\'D1\'8B\'D1\'85 \'D0\'B2 \'D0\'BD\'D0\'B0\'D1\'81\'D1\'82\'D1\'80\'D0\'BE\'D0\'B9\'D0\'BA\'D0\'B0\'D1\'85 \'D1\'81\'D0\'BB\'D0\'BE\'D0\'B2\'D0\'B0\'D1\'80\'D1\'8C }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i TileIndexSettings} \cell }{\'D0\'BD\'D0\'B0\'D1\'81\'D1\'82\'D1\'80\'D0\'BE\'D0\'B9\'D0\'BA\'D0\'B8, \'D0\'B7\'D0\'B0\'D0\'B4\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B5 \'D0\'B4\'D0\'BB\'D1\'8F \'D0\'BA\'D0\'B0\'D0\'B6\'D0\'B4\'D0\'BE\'D0\'B3\'D0\'BE \'D1\'82\'D0\'B0\'D0\'B9\'D0\'BB\'D0\'B0 \'D0\'B5\'D0\'B3\'D0\'BE \'D0\'BD\'D0\'B0\'D0\'B7\'D0\'B2\'D0\'B0\'D0\'BD\'D0\'B8\'D0\'B5 \'D0\'B8 \'D0\'B5\'D0\'B3\'D0\'BE \'D0\'B8\'D0\'BD\'D0\'B4\'D0\'B5\'D0\'BA\'D1\'81\'D1\'8B \cell }
{\row }
}
}}
{\xe \v indexesToindex\:SpriteController}
{\xe \v SpriteController\:indexesToindex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int SpriteController::indexesToindex (int  {\i i}, int  {\i j})}}
\par
{\bkmkstart AAAAAAAAIT}
{\bkmkend AAAAAAAAIT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BF\'D1\'80\'D0\'B5\'D0\'BE\'D0\'B1\'D1\'80\'D0\'B0\'D0\'B7\'D1\'83\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B8\'D0\'BD\'D0\'B4\'D0\'B5\'D0\'BA\'D1\'81\'D1\'8B \'D0\'B4\'D0\'B2\'D1\'83\'D0\'BC\'D0\'B5\'D1\'80\'D0\'BD\'D0\'BE\'D0\'B3\'D0\'BE \'D0\'BC\'D0\'B0\'D1\'81\'D1\'81\'D0\'B8\'D0\'B2\'D0\'B0 \'D0\'B2 \'D0\'B8\'D0\'BD\'D0\'B4\'D0\'B5\'D0\'BA\'D1\'81\'D1\'8B \'D0\'BE\'D0\'B4\'D0\'BD\'D0\'BE\'D0\'BC\'D0\'B5\'D1\'80\'D0\'BD\'D0\'BE\'D0\'B3\'D0\'BE }}\par
}
{\xe \v load_player_sprites\:SpriteController}
{\xe \v SpriteController\:load_player_sprites}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SpriteController::load_player_sprites (std::string  {\i name}, std::string  {\i path}, sf::Vector2u  {\i tilesize})}}
\par
{\bkmkstart AAAAAAAAIU}
{\bkmkend AAAAAAAAIU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D1\'81\'D0\'BE\'D0\'B7\'D0\'B4\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D1\'8B \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i name} \cell }{\'D0\'BD\'D0\'B0\'D0\'B7\'D0\'B2\'D0\'B0\'D0\'BD\'D0\'B8\'D0\'B5 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'B0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{\'D0\'BF\'D1\'83\'D1\'82\'D1\'8C \'D0\'B4\'D0\'BE \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D1\'8B \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tilesize} \cell }{\'D1\'80\'D0\'B0\'D0\'B7\'D0\'BC\'D0\'B5\'D1\'80 \'D1\'82\'D0\'B0\'D0\'B9\'D0\'BB\'D0\'BE\'D0\'B2 \'D0\'B2 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D0\'B5 \cell }
{\row }
}
}}
{\xe \v load_sprites\:SpriteController}
{\xe \v SpriteController\:load_sprites}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SpriteController::load_sprites (std::string  {\i name}, std::string  {\i path}, sf::Vector2u  {\i tilesize})}}
\par
{\bkmkstart AAAAAAAAIV}
{\bkmkend AAAAAAAAIV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D1\'81\'D0\'BE\'D0\'B7\'D0\'B4\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D1\'8B }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i name} \cell }{\'D0\'BD\'D0\'B0\'D0\'B7\'D0\'B2\'D0\'B0\'D0\'BD\'D0\'B8\'D0\'B5 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'B0 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{\'D0\'BF\'D1\'83\'D1\'82\'D1\'8C \'D0\'B4\'D0\'BE \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D1\'8B \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tilesize} \cell }{\'D1\'80\'D0\'B0\'D0\'B7\'D0\'BC\'D0\'B5\'D1\'80 \'D1\'82\'D0\'B0\'D0\'B9\'D0\'BB\'D0\'BE\'D0\'B2 \'D0\'B2 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D0\'B5 \cell }
{\row }
}
}}
{\xe \v load_textures\:SpriteController}
{\xe \v SpriteController\:load_textures}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SpriteController::load_textures (std::string  {\i name}, std::string  {\i path})}}
\par
{\bkmkstart AAAAAAAAIW}
{\bkmkend AAAAAAAAIW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BE\'D0\'B1\'D1\'80\'D0\'B0\'D0\'B1\'D0\'B0\'D1\'82\'D1\'8B\'D0\'B2\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D1\'8B }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i name} \cell }{\'D0\'BD\'D0\'B0\'D0\'B7\'D0\'B2\'D0\'B0\'D0\'BD\'D0\'B8\'D0\'B5 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D1\'8B \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i path} \cell }{\'D0\'BF\'D1\'83\'D1\'82\'D1\'8C \'D0\'B4\'D0\'BE \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D1\'8B \cell }
{\row }
}
}}
{\xe \v make_sprite\:SpriteController}
{\xe \v SpriteController\:make_sprite}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< sf::Sprite > SpriteController::make_sprite (sf::Texture &  {\i texture}, sf::Vector2u  {\i tilesize})}}
\par
{\bkmkstart AAAAAAAAIX}
{\bkmkend AAAAAAAAIX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D1\'81\'D0\'BE\'D0\'B7\'D0\'B4\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D1\'8B \'D0\'B8\'D0\'B7 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D1\'8B }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i texture} \cell }{\'D1\'81\'D1\'81\'D1\'8B\'D0\'BB\'D0\'BA\'D0\'B0 \'D0\'BD\'D0\'B0 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D1\'83 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tilesize} \cell }{\'D1\'80\'D0\'B0\'D0\'B7\'D0\'BC\'D0\'B5\'D1\'80 \'D1\'82\'D0\'B0\'D0\'B9\'D0\'BB\'D0\'BE\'D0\'B2 \'D0\'B2 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D0\'B5 \cell }
{\row }
}
}}
{\xe \v processSettings\:SpriteController}
{\xe \v SpriteController\:processSettings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SpriteController::processSettings ({\b toml::table} &  {\i table}, bool  {\i isPlayerSettings} = {\f2 false})}}
\par
{\bkmkstart AAAAAAAAIY}
{\bkmkend AAAAAAAAIY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'BE\'D0\'B1\'D1\'80\'D0\'B0\'D0\'B1\'D0\'B0\'D1\'82\'D1\'8B\'D0\'B2\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'BE\'D0\'BF\'D1\'80\'D0\'B5\'D0\'B4\'D0\'B5\'D0\'BB\'D0\'B5\'D0\'BD\'D0\'BD\'D1\'83\'D1\'8E \'D1\'82\'D0\'B0\'D0\'B1\'D0\'BB\'D0\'B8\'D1\'86\'D1\'83 \'D0\'B8\'D0\'B7 \'D0\'BD\'D0\'B0\'D1\'81\'D1\'82\'D1\'80\'D0\'BE\'D0\'B5\'D0\'BA \'D1\'81 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'B0\'D0\'BC\'D0\'B8 }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i table} \cell }{\'D1\'81\'D1\'81\'D1\'8B\'D0\'BB\'D0\'BA\'D0\'B0 \'D0\'BD\'D0\'B0 \'D1\'82\'D0\'B0\'D0\'B1\'D0\'BB\'D0\'B8\'D1\'86\'D1\'83 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i isPlayerSettings} \cell }{\'D1\'8F\'D0\'B2\'D0\'BB\'D1\'8F\'D0\'B5\'D1\'82\'D1\'81\'D1\'8F \'D0\'BB\'D0\'B8 \'D0\'BD\'D0\'B0\'D1\'81\'D1\'82\'D1\'80\'D0\'BE\'D0\'B9\'D0\'BA\'D0\'B0\'D0\'BC\'D0\'B8 \'D0\'B8\'D0\'B3\'D1\'80\'D0\'BE\'D0\'BA\'D0\'B0 \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v playerSprites\:SpriteController}
{\xe \v SpriteController\:playerSprites}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map<std::string, std::vector<sf::Sprite> > SpriteController::playerSprites}}
\par
{\bkmkstart AAAAAAAAIZ}
{\bkmkend AAAAAAAAIZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v spriteArrays\:SpriteController}
{\xe \v SpriteController\:spriteArrays}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map<std::string, std::vector<sf::Sprite> > SpriteController::spriteArrays}}
\par
{\bkmkstart AAAAAAAAJA}
{\bkmkend AAAAAAAAJA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v spriteObjects\:SpriteController}
{\xe \v SpriteController\:spriteObjects}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map<std::string, sf::Sprite> SpriteController::spriteObjects}}
\par
{\bkmkstart AAAAAAAAJB}
{\bkmkend AAAAAAAAJB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v textures\:SpriteController}
{\xe \v SpriteController\:textures}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::map<std::string, sf::Texture> SpriteController::textures}}
\par
{\bkmkstart AAAAAAAAJC}
{\bkmkend AAAAAAAAJC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v tilemap_size\:SpriteController}
{\xe \v SpriteController\:tilemap_size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::pair<int, int> SpriteController::tilemap_size}}
\par
{\bkmkstart AAAAAAAAJD}
{\bkmkend AAAAAAAAJD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SpriteContoller/{\b SpriteController.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
SpriteContoller/{\b SpriteController.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::storage< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::storage< T >}
{\xe \v toml::detail::storage< T >}
{\bkmkstart AAAAAAACGO}
{\bkmkend AAAAAAACGO}
\par
{
{\f2 #include <storage.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = T\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b storage} ({\b value_type} const &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b storage} ({\b value_type} &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~storage} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b storage} (const {\b storage} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b storage} & {\b operator=} (const {\b storage} &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b storage} ({\b storage} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b storage} & {\b operator=} ({\b storage} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b is_ok} () const noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} & {\b value} () &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} const & {\b value} () const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} && {\b value} () &&noexcept\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v value_type\:toml::detail::storage< T >}
{\xe \v toml::detail::storage< T >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b toml::detail::storage}< T >::value_type =  T}}
\par
{\bkmkstart AAAAAAACGP}
{\bkmkend AAAAAAACGP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v storage\:toml::detail::storage< T >}
{\xe \v toml::detail::storage< T >\:storage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b toml::detail::storage}< T >::storage ({\b value_type} const &  {\i v}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACGQ}
{\bkmkend AAAAAAACGQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v storage\:toml::detail::storage< T >}
{\xe \v toml::detail::storage< T >\:storage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b toml::detail::storage}< T >::storage ({\b value_type} &&  {\i v}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAACGR}
{\bkmkend AAAAAAACGR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~storage\:toml::detail::storage< T >}
{\xe \v toml::detail::storage< T >\:~storage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b toml::detail::storage}< T >::~{\b storage} (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACGS}
{\bkmkend AAAAAAACGS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v storage\:toml::detail::storage< T >}
{\xe \v toml::detail::storage< T >\:storage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b toml::detail::storage}< T >::storage (const {\b storage}< T > &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGT}
{\bkmkend AAAAAAACGT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v storage\:toml::detail::storage< T >}
{\xe \v toml::detail::storage< T >\:storage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b toml::detail::storage}< T >::storage ({\b storage}< T > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACGU}
{\bkmkend AAAAAAACGU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v is_ok\:toml::detail::storage< T >}
{\xe \v toml::detail::storage< T >\:is_ok}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > bool {\b toml::detail::storage}< T >::is_ok () const{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACGV}
{\bkmkend AAAAAAACGV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::detail::storage< T >}
{\xe \v toml::detail::storage< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b storage} & {\b toml::detail::storage}< T >::operator= (const {\b storage}< T > &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAACGW}
{\bkmkend AAAAAAACGW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::detail::storage< T >}
{\xe \v toml::detail::storage< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b storage} & {\b toml::detail::storage}< T >::operator= ({\b storage}< T > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAACGX}
{\bkmkend AAAAAAACGX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value\:toml::detail::storage< T >}
{\xe \v toml::detail::storage< T >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b value_type} && {\b toml::detail::storage}< T >::value () &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACGY}
{\bkmkend AAAAAAACGY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value\:toml::detail::storage< T >}
{\xe \v toml::detail::storage< T >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b value_type} & {\b toml::detail::storage}< T >::value () &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACGZ}
{\bkmkend AAAAAAACGZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v value\:toml::detail::storage< T >}
{\xe \v toml::detail::storage< T >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b value_type} const  & {\b toml::detail::storage}< T >::value () const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAACHA}
{\bkmkend AAAAAAACHA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b storage.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::string Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::string}
{\xe \v toml::string}
{\bkmkstart AAAAAAABNG}
{\bkmkend AAAAAAABNG}
\par
{
{\f2 #include <string.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~string} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} (const {\b string} &s)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} ({\b string} &&s)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} & {\b operator=} (const {\b string} &s)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} & {\b operator=} ({\b string} &&s)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} (const std::string &s, {\b string_t} k)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} (const char *s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} (const char *s, {\b string_t} k)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} (std::string &&s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} (std::string &&s, {\b string_t} k)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} & {\b operator=} (const std::string &s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} & {\b operator=} (std::string &&s)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::string &} () &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::string const &} () const &noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::string &&} () &&noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} & {\b operator+=} (const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} & {\b operator+=} (const char rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} & {\b operator+=} (const std::string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string} & {\b operator+=} (const {\b string} &rhs)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b string_t} {\b kind}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b str}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v string\:toml::string}
{\xe \v toml::string\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::string::string (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABNH}
{\bkmkend AAAAAAABNH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~string\:toml::string}
{\xe \v toml::string\:~string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::string::~string (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABNI}
{\bkmkend AAAAAAABNI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v string\:toml::string}
{\xe \v toml::string\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::string::string (const {\b string} &  {\i s}){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABNJ}
{\bkmkend AAAAAAABNJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v string\:toml::string}
{\xe \v toml::string\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::string::string ({\b string} &&  {\i s}){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABNK}
{\bkmkend AAAAAAABNK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v string\:toml::string}
{\xe \v toml::string\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::string::string (const std::string &  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNL}
{\bkmkend AAAAAAABNL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v string\:toml::string}
{\xe \v toml::string\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::string::string (const std::string &  {\i s}, {\b string_t}  {\i k}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNM}
{\bkmkend AAAAAAABNM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v string\:toml::string}
{\xe \v toml::string\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::string::string (const char *  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNN}
{\bkmkend AAAAAAABNN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v string\:toml::string}
{\xe \v toml::string\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::string::string (const char *  {\i s}, {\b string_t}  {\i k}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNO}
{\bkmkend AAAAAAABNO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v string\:toml::string}
{\xe \v toml::string\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::string::string (std::string &&  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNP}
{\bkmkend AAAAAAABNP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v string\:toml::string}
{\xe \v toml::string\:string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::string::string (std::string &&  {\i s}, {\b string_t}  {\i k}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNQ}
{\bkmkend AAAAAAABNQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator std::string &\:toml::string}
{\xe \v toml::string\:operator std::string &}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::string::operator std::string & () &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNR}
{\bkmkend AAAAAAABNR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator std::string &&\:toml::string}
{\xe \v toml::string\:operator std::string &&}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::string::operator std::string && () &&{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNS}
{\bkmkend AAAAAAABNS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator std::string const &\:toml::string}
{\xe \v toml::string\:operator std::string const &}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::string::operator std::string const & () const &{\f2 [inline]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABNT}
{\bkmkend AAAAAAABNT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator+=\:toml::string}
{\xe \v toml::string\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string} & toml::string::operator+= (const char *  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNU}
{\bkmkend AAAAAAABNU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator+=\:toml::string}
{\xe \v toml::string\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string} & toml::string::operator+= (const char  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNV}
{\bkmkend AAAAAAABNV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator+=\:toml::string}
{\xe \v toml::string\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string} & toml::string::operator+= (const std::string &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNW}
{\bkmkend AAAAAAABNW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator+=\:toml::string}
{\xe \v toml::string\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string} & toml::string::operator+= (const {\b string} &  {\i rhs}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNX}
{\bkmkend AAAAAAABNX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::string}
{\xe \v toml::string\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string} & toml::string::operator= (const std::string &  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABNY}
{\bkmkend AAAAAAABNY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::string}
{\xe \v toml::string\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string} & toml::string::operator= (const {\b string} &  {\i s}){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABNZ}
{\bkmkend AAAAAAABNZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::string}
{\xe \v toml::string\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string} & toml::string::operator= (std::string &&  {\i s}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOA}
{\bkmkend AAAAAAABOA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::string}
{\xe \v toml::string\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string} & toml::string::operator= ({\b string} &&  {\i s}){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABOB}
{\bkmkend AAAAAAABOB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v kind\:toml::string}
{\xe \v toml::string\:kind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b string_t} toml::string::kind}}
\par
{\bkmkstart AAAAAAABOC}
{\bkmkend AAAAAAABOC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v str\:toml::string}
{\xe \v toml::string\:str}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::string::str}}
\par
{\bkmkstart AAAAAAABOD}
{\bkmkend AAAAAAABOD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b string.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::success< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::success< T >}
{\xe \v toml::success< T >}
{\bkmkstart AAAAAAABOE}
{\bkmkend AAAAAAABOE}
\par
{
{\f2 #include <result.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b value_type} = T\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b success} (const {\b value_type} &v) noexcept(std::is_nothrow_copy_constructible< {\b value_type} >{\b ::value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b success} ({\b value_type} &&v) noexcept(std::is_nothrow_move_constructible< {\b value_type} >{\b ::value})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b success} (U &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b success} (const {\b success}< U > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename U > {\b success} ({\b success}< U > &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~success} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b success} (const {\b success} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b success} ({\b success} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b success} & {\b operator=} (const {\b success} &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b success} & {\b operator=} ({\b success} &&)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b value_type} {\b value}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v value_type\:toml::success< T >}
{\xe \v toml::success< T >\:value_type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > using {\b toml::success}< T >::value_type =  T}}
\par
{\bkmkstart AAAAAAABOF}
{\bkmkend AAAAAAABOF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v success\:toml::success< T >}
{\xe \v toml::success< T >\:success}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b toml::success}< T >::success (const {\b value_type} &  {\i v}){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOG}
{\bkmkend AAAAAAABOG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v success\:toml::success< T >}
{\xe \v toml::success< T >\:success}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b toml::success}< T >::success ({\b value_type} &&  {\i v}){\f2 [inline]}, {\f2 [explicit]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOH}
{\bkmkend AAAAAAABOH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v success\:toml::success< T >}
{\xe \v toml::success< T >\:success}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename U > {\b toml::success}< T >::success (U &&  {\i v}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABOI}
{\bkmkend AAAAAAABOI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v success\:toml::success< T >}
{\xe \v toml::success< T >\:success}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename U > {\b toml::success}< T >::success (const {\b success}< U > &  {\i v}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABOJ}
{\bkmkend AAAAAAABOJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v success\:toml::success< T >}
{\xe \v toml::success< T >\:success}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > template<typename U > {\b toml::success}< T >::success ({\b success}< U > &&  {\i v}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABOK}
{\bkmkend AAAAAAABOK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~success\:toml::success< T >}
{\xe \v toml::success< T >\:~success}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b toml::success}< T >::~{\b success} (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABOL}
{\bkmkend AAAAAAABOL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v success\:toml::success< T >}
{\xe \v toml::success< T >\:success}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b toml::success}< T >::success (const {\b success}< T > & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABOM}
{\bkmkend AAAAAAABOM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v success\:toml::success< T >}
{\xe \v toml::success< T >\:success}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b toml::success}< T >::success ({\b success}< T > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABON}
{\bkmkend AAAAAAABON}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator=\:toml::success< T >}
{\xe \v toml::success< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b success} & {\b toml::success}< T >::operator= (const {\b success}< T > & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABOO}
{\bkmkend AAAAAAABOO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::success< T >}
{\xe \v toml::success< T >\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b success} & {\b toml::success}< T >::operator= ({\b success}< T > && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABOP}
{\bkmkend AAAAAAABOP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v value\:toml::success< T >}
{\xe \v toml::success< T >\:value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T > {\b value_type} {\b toml::success}< T >::value}}
\par
{\bkmkstart AAAAAAABOQ}
{\bkmkend AAAAAAABOQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b result.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::switch_cast< T > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::switch_cast< T >}
{\xe \v toml::detail::switch_cast< T >}
{\bkmkstart AAAAAAACHB}
{\bkmkend AAAAAAACHB}
\par
{
{\f2 #include <value.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b value.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::syntax_error Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::syntax_error}
{\xe \v toml::syntax_error}
{\bkmkstart AAAAAAABOR}
{\bkmkend AAAAAAABOR}
\par
{
{\f2 #include <exception.hpp>}}\par
Inheritance diagram for toml::syntax_error:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1syntax__error.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b syntax_error} (const std::string &what_arg, const {\b source_location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~syntax_error} () noexcept override=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b what} () const noexcept override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b what_}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v syntax_error\:toml::syntax_error}
{\xe \v toml::syntax_error\:syntax_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::syntax_error::syntax_error (const std::string &  {\i what_arg}, const {\b source_location} &  {\i loc}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABOS}
{\bkmkend AAAAAAABOS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~syntax_error\:toml::syntax_error}
{\xe \v toml::syntax_error\:~syntax_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual toml::syntax_error::~syntax_error (){\f2 [override]}, {\f2 [virtual]}, {\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABOT}
{\bkmkend AAAAAAABOT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v what\:toml::syntax_error}
{\xe \v toml::syntax_error\:what}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual const char * toml::syntax_error::what () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCG}
{\bkmkend AAAAAAABCG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::exception} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABCF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v what_\:toml::syntax_error}
{\xe \v toml::syntax_error\:what_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::syntax_error::what_{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABOU}
{\bkmkend AAAAAAABOU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b exception.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TileMap Class Reference\par \pard\plain 
{\tc\tcl2 \v TileMap}
{\xe \v TileMap}
{\bkmkstart AAAAAAAAJE}
{\bkmkend AAAAAAAAJE}
\par
{
{\f2 #include <TileMap.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TileMap} (sf::Texture &tileset, const sf::Vector2u &tile_size)\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9A\'D0\'BB\'D0\'B0\'D1\'81\'D1\'81, \'D1\'81\'D0\'BE\'D0\'B7\'D0\'B4\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B2\'D0\'B5\'D0\'BA\'D1\'82\'D0\'BE\'D1\'80 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'BE\'D0\'B2 \'D0\'B8\'D0\'B7 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D1\'8B }{
}\par
}\par}
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::vector< sf::Sprite > {\b get_sprites} ()\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BE\'D0\'B7\'D0\'B4\'D0\'B0\'D0\'BD\'D0\'BD\'D1\'8B\'D0\'B9 \'D0\'B2\'D0\'B5\'D0\'BA\'D1\'82\'D0\'BE\'D1\'80 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'BE\'D0\'B2 }{
}\par
}\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v TileMap\:TileMap}
{\xe \v TileMap\:TileMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TileMap::TileMap (sf::Texture &  {\i tileset}, const sf::Vector2u &  {\i tile_size})}}
\par
{\bkmkstart AAAAAAAAJF}
{\bkmkend AAAAAAAAJF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9A\'D0\'BB\'D0\'B0\'D1\'81\'D1\'81, \'D1\'81\'D0\'BE\'D0\'B7\'D0\'B4\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D0\'B2\'D0\'B5\'D0\'BA\'D1\'82\'D0\'BE\'D1\'80 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'BE\'D0\'B2 \'D0\'B8\'D0\'B7 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D1\'8B }}\par
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{\par
{\s5\sb90\sa30\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
Parameters\par}
\pard\plain \s81\li360\widctlpar\ql\adjustright \fs20\cgrid \trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tileset} \cell }{\'D1\'81\'D1\'81\'D1\'8B\'D0\'BB\'D0\'BA\'D0\'B0 \'D0\'BD\'D0\'B0 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D1\'83 \cell }
{\row }
\trowd \trgaph108\trleft426\tblind426\trbrdrt\brdrs\brdrw10\brdrcf15 \trbrdrl\brdrs\brdrw10\brdrcf15 \trbrdrb\brdrs\brdrw10\brdrcf15 \trbrdrr\brdrs\brdrw10\brdrcf15 \trbrdrh\brdrs\brdrw10\brdrcf15 \trbrdrv\brdrs\brdrw10\brdrcf15 
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx2187
\clvertalt\clbrdrt\brdrs\brdrw10\brdrcf15 \clbrdrl\brdrs\brdrw10\brdrcf15 \clbrdrb\brdrs\brdrw10\brdrcf15 \clbrdrr \brdrs\brdrw10\brdrcf15 \cltxlrtb \cellx8748
\pard \widctlpar\intbl\adjustright
{{\i tile_size} \cell }{\'D1\'80\'D0\'B0\'D0\'B7\'D0\'BC\'D0\'B5\'D1\'80 \'D1\'82\'D0\'B0\'D0\'B9\'D0\'BB\'D0\'BE\'D0\'B2 \'D0\'B2 \'D1\'82\'D0\'B5\'D0\'BA\'D1\'81\'D1\'82\'D1\'83\'D1\'80\'D0\'B5 \cell }
{\row }
}
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v get_sprites\:TileMap}
{\xe \v TileMap\:get_sprites}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::vector< sf::Sprite > TileMap::get_sprites ()}}
\par
{\bkmkstart AAAAAAAAJG}
{\bkmkend AAAAAAAAJG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
\'D0\'9C\'D0\'B5\'D1\'82\'D0\'BE\'D0\'B4, \'D0\'B2\'D0\'BE\'D0\'B7\'D1\'80\'D0\'B0\'D1\'89\'D0\'B0\'D1\'8E\'D1\'89\'D0\'B8\'D0\'B9 \'D1\'81\'D0\'BE\'D0\'B7\'D0\'B4\'D0\'B0\'D0\'BD\'D0\'BD\'D1\'8B\'D0\'B9 \'D0\'B2\'D0\'B5\'D0\'BA\'D1\'82\'D0\'BE\'D1\'80 \'D1\'81\'D0\'BF\'D1\'80\'D0\'B0\'D0\'B9\'D1\'82\'D0\'BE\'D0\'B2 }}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TileMap/{\b TileMap.hpp}\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
TileMap/{\b TileMap.cpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::time_offset Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::time_offset}
{\xe \v toml::time_offset}
{\bkmkstart AAAAAAABOV}
{\bkmkend AAAAAAABOV}
\par
{
{\f2 #include <datetime.hpp>}}\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b time_offset} (int h, int m)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::chrono::minutes} () const\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b time_offset} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~time_offset} ()=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b time_offset} ({\b time_offset} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b time_offset} ({\b time_offset} &&)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b time_offset} & {\b operator=} ({\b time_offset} const &)=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b time_offset} & {\b operator=} ({\b time_offset} &&)=default\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::int8_t {\b hour}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::int8_t {\b minute}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v time_offset\:toml::time_offset}
{\xe \v toml::time_offset\:time_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::time_offset::time_offset (int  {\i h}, int  {\i m}){\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABOW}
{\bkmkend AAAAAAABOW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v time_offset\:toml::time_offset}
{\xe \v toml::time_offset\:time_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::time_offset::time_offset (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABOX}
{\bkmkend AAAAAAABOX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~time_offset\:toml::time_offset}
{\xe \v toml::time_offset\:~time_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::time_offset::~time_offset (){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABOY}
{\bkmkend AAAAAAABOY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v time_offset\:toml::time_offset}
{\xe \v toml::time_offset\:time_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::time_offset::time_offset ({\b time_offset} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABOZ}
{\bkmkend AAAAAAABOZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v time_offset\:toml::time_offset}
{\xe \v toml::time_offset\:time_offset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::time_offset::time_offset ({\b time_offset} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABPA}
{\bkmkend AAAAAAABPA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator std::chrono::minutes\:toml::time_offset}
{\xe \v toml::time_offset\:operator std::chrono::minutes}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::time_offset::operator std::chrono::minutes () const{\f2 [inline]}}}
\par
{\bkmkstart AAAAAAABPB}
{\bkmkend AAAAAAABPB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::time_offset}
{\xe \v toml::time_offset\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b time_offset} & toml::time_offset::operator= ({\b time_offset} && ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABPC}
{\bkmkend AAAAAAABPC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:toml::time_offset}
{\xe \v toml::time_offset\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b time_offset} & toml::time_offset::operator= ({\b time_offset} const & ){\f2 [default]}}}
\par
{\bkmkstart AAAAAAABPD}
{\bkmkend AAAAAAABPD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v hour\:toml::time_offset}
{\xe \v toml::time_offset\:hour}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::int8_t toml::time_offset::hour}}
\par
{\bkmkstart AAAAAAABPE}
{\bkmkend AAAAAAABPE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v minute\:toml::time_offset}
{\xe \v toml::time_offset\:minute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::int8_t toml::time_offset::minute}}
\par
{\bkmkstart AAAAAAABPF}
{\bkmkend AAAAAAABPF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b datetime.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::type_error Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::type_error}
{\xe \v toml::type_error}
{\bkmkstart AAAAAAABPG}
{\bkmkend AAAAAAABPG}
\par
{
{\f2 #include <exception.hpp>}}\par
Inheritance diagram for toml::type_error:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1type__error.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Member Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b type_error} (const std::string &what_arg, const {\b source_location} &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~type_error} () noexcept override=default\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b what} () const noexcept override\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b what_}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v type_error\:toml::type_error}
{\xe \v toml::type_error\:type_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
toml::type_error::type_error (const std::string &  {\i what_arg}, const {\b source_location} &  {\i loc}){\f2 [inline]}, {\f2 [explicit]}}}
\par
{\bkmkstart AAAAAAABPH}
{\bkmkend AAAAAAABPH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~type_error\:toml::type_error}
{\xe \v toml::type_error\:~type_error}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual toml::type_error::~type_error (){\f2 [override]}, {\f2 [virtual]}, {\f2 [default]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABPI}
{\bkmkend AAAAAAABPI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v what\:toml::type_error}
{\xe \v toml::type_error\:what}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual const char * toml::type_error::what () const{\f2 [inline]}, {\f2 [override]}, {\f2 [virtual]}, {\f2 [noexcept]}}}
\par
{\bkmkstart AAAAAAABCH}
{\bkmkend AAAAAAABCH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
{
Reimplemented from {\b toml::exception} ({\i p.{\field\fldedit {\*\fldinst PAGEREF AAAAAAABCF \\*MERGEFORMAT}{\fldrslt pagenum}}}).}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v what_\:toml::type_error}
{\xe \v toml::type_error\:what_}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string toml::type_error::what_{\f2 [protected]}}}
\par
{\bkmkstart AAAAAAABPJ}
{\bkmkend AAAAAAABPJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b exception.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::type_to_enum< T, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::type_to_enum< T, Value >}
{\xe \v toml::detail::type_to_enum< T, Value >}
{\bkmkstart AAAAAAACHC}
{\bkmkend AAAAAAACHC}
\par
{
{\f2 #include <types.hpp>}}\par
Inheritance diagram for toml::detail::type_to_enum< T, Value >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1type__to__enum.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::type_to_enum< boolean, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::type_to_enum< boolean, Value >}
{\xe \v toml::detail::type_to_enum< boolean, Value >}
{\bkmkstart AAAAAAACHD}
{\bkmkend AAAAAAACHD}
\par
{
{\f2 #include <types.hpp>}}\par
Inheritance diagram for toml::detail::type_to_enum< boolean, Value >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1type__to__enum_3_01boolean_00_01_value_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::type_to_enum< floating, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::type_to_enum< floating, Value >}
{\xe \v toml::detail::type_to_enum< floating, Value >}
{\bkmkstart AAAAAAACHE}
{\bkmkend AAAAAAACHE}
\par
{
{\f2 #include <types.hpp>}}\par
Inheritance diagram for toml::detail::type_to_enum< floating, Value >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1type__to__enum_3_01floating_00_01_value_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::type_to_enum< integer, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::type_to_enum< integer, Value >}
{\xe \v toml::detail::type_to_enum< integer, Value >}
{\bkmkstart AAAAAAACHF}
{\bkmkend AAAAAAACHF}
\par
{
{\f2 #include <types.hpp>}}\par
Inheritance diagram for toml::detail::type_to_enum< integer, Value >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1type__to__enum_3_01integer_00_01_value_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::type_to_enum< local_date, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::type_to_enum< local_date, Value >}
{\xe \v toml::detail::type_to_enum< local_date, Value >}
{\bkmkstart AAAAAAACHG}
{\bkmkend AAAAAAACHG}
\par
{
{\f2 #include <types.hpp>}}\par
Inheritance diagram for toml::detail::type_to_enum< local_date, Value >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1type__to__enum_3_01local__date_00_01_value_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::type_to_enum< local_datetime, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::type_to_enum< local_datetime, Value >}
{\xe \v toml::detail::type_to_enum< local_datetime, Value >}
{\bkmkstart AAAAAAACHH}
{\bkmkend AAAAAAACHH}
\par
{
{\f2 #include <types.hpp>}}\par
Inheritance diagram for toml::detail::type_to_enum< local_datetime, Value >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1type__to__enum_3_01local__datetime_00_01_value_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::type_to_enum< local_time, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::type_to_enum< local_time, Value >}
{\xe \v toml::detail::type_to_enum< local_time, Value >}
{\bkmkstart AAAAAAACHI}
{\bkmkend AAAAAAACHI}
\par
{
{\f2 #include <types.hpp>}}\par
Inheritance diagram for toml::detail::type_to_enum< local_time, Value >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1type__to__enum_3_01local__time_00_01_value_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::type_to_enum< offset_datetime, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::type_to_enum< offset_datetime, Value >}
{\xe \v toml::detail::type_to_enum< offset_datetime, Value >}
{\bkmkstart AAAAAAACHJ}
{\bkmkend AAAAAAACHJ}
\par
{
{\f2 #include <types.hpp>}}\par
Inheritance diagram for toml::detail::type_to_enum< offset_datetime, Value >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1type__to__enum_3_01offset__datetime_00_01_value_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::type_to_enum< string, Value > Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::type_to_enum< string, Value >}
{\xe \v toml::detail::type_to_enum< string, Value >}
{\bkmkstart AAAAAAACHK}
{\bkmkend AAAAAAACHK}
\par
{
{\f2 #include <types.hpp>}}\par
Inheritance diagram for toml::detail::type_to_enum< string, Value >:{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE "structtoml_1_1detail_1_1type__to__enum_3_01string_00_01_value_01_4.png" \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b types.hpp}\par
}\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml::detail::unlimited Struct Reference\par \pard\plain 
{\tc\tcl2 \v toml::detail::unlimited}
{\xe \v toml::detail::unlimited}
{\bkmkstart AAAAAAACHL}
{\bkmkend AAAAAAACHL}
\par
{
{\f2 #include <combinator.hpp>}}\par
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s121\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
external/toml/{\b combinator.hpp}\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Bullet/Bullet.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Bullet/Bullet.cpp}
{\xe \v Bullet/Bullet.cpp}
{\bkmkstart AAAAAAAABJ}
{\bkmkend AAAAAAAABJ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Bullet.hpp"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Bullet/Bullet.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v Bullet/Bullet.hpp}
{\xe \v Bullet/Bullet.hpp}
{\bkmkstart AAAAAAAABK}
{\bkmkend AAAAAAAABK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <../GameObject/GameObject.hpp>}\par
{\f2 #include <SFML/Graphics.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Bullet}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Bullet.hpp\par \pard\plain 
{\tc\tcl2 \v Bullet/Bullet.hpp}
{\xe \v Bullet/Bullet.hpp}
{\bkmkstart AAAAAAAAAA}
{\bkmkend AAAAAAAAAA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #pragma once}\par
2 {\cf21 #include <../GameObject/GameObject.hpp>}\par
3 {\cf21 #include <SFML/Graphics.hpp>}\par
4 \par
5 {\cf17 class }Bullet : {\cf17 public} sf::Drawable, {\cf17 public} sf::Transformable \{\par
6     GameObject m_bulletObject;\par
7     sf::Vector2f m_velocity;\par
8     sf::Time m_lifetime;\par
9 \par
10   {\cf17 public}:\par
11     {\cf18 bool} isExist = {\cf17 true};\par
12 \par
20     Bullet(sf::Vector2f startPosition, sf::Vector2f velocity,\par
21            std::vector<sf::Sprite> bulletSprite);\par
22 \par
26     GameObject &getBulletObject();\par
27 \par
33     {\cf18 void} moveBullet(sf::Time deltaTime);\par
34 \par
35     {\cf17 virtual} {\cf18 void} draw(sf::RenderTarget &surface, sf::RenderStates states) {\cf17 const};\par
36 \par
40     sf::FloatRect getBulletRect();\par
41 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Enemies/EyeEnemy.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Enemies/EyeEnemy.cpp}
{\xe \v Enemies/EyeEnemy.cpp}
{\bkmkstart AAAAAAAABL}
{\bkmkend AAAAAAAABL}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "EyeEnemy.hpp"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Enemies/EyeEnemy.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v Enemies/EyeEnemy.hpp}
{\xe \v Enemies/EyeEnemy.hpp}
{\bkmkstart AAAAAAAABM}
{\bkmkend AAAAAAAABM}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Audio.hpp>}\par
{\f2 #include "../GameObject/GameObject.hpp"}\par
{\f2 #include "cmath"}\par
{\f2 #include <../external/PriorityQueue/PriorityQueue.hpp>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <map>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b EyeEnemy}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EyeEnemy.hpp\par \pard\plain 
{\tc\tcl2 \v Enemies/EyeEnemy.hpp}
{\xe \v Enemies/EyeEnemy.hpp}
{\bkmkstart AAAAAAAAAB}
{\bkmkend AAAAAAAAAB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #pragma once}\par
2 {\cf21 #include <SFML/Audio.hpp>}\par
3 \par
4 {\cf21 #include "../GameObject/GameObject.hpp"}\par
5 {\cf21 #include "cmath"}\par
6 {\cf21 #include <../external/PriorityQueue/PriorityQueue.hpp>}\par
7 {\cf21 #include <algorithm>}\par
8 {\cf21 #include <map>}\par
9 \par
10 {\cf17 class }EyeEnemy : {\cf17 public} sf::Drawable, {\cf17 public} sf::Transformable \{\par
11     GameObject m_EyeEnemyObject;\par
12     {\cf18 int} m_health;\par
13     {\cf18 int} initial_health;\par
14     {\cf18 float} m_speed;\par
15     {\cf18 float} m_attack_distance;\par
16     {\cf18 bool} isHitted = {\cf17 false};\par
17     {\cf18 bool} isDead = {\cf17 false};\par
18     sf::Time attackTime;\par
19     {\cf18 bool} m_canAttack;\par
20     sf::Vector2f m_velocity;\par
21     std::vector<sf::Sprite> m_moveSprites;\par
22     std::vector<sf::Sprite> m_attackSprites;\par
23     std::vector<sf::Sprite> m_takeDamageSprites;\par
24     std::vector<sf::Sprite> m_deathSprites;\par
25 \par
26     sf::SoundBuffer m_sbuffer;\par
27     sf::Sound hitSound;\par
28 \par
29   {\cf17 public}:\par
43     EyeEnemy(sf::Vector2f startPosition, std::vector<sf::Sprite> moveSprites,\par
44              std::vector<sf::Sprite> attackSprites,\par
45              std::vector<sf::Sprite> takeDamageSprites,\par
46              std::vector<sf::Sprite> deathSprites, {\cf18 float} speed,\par
47              {\cf18 float} attack_distance, std::string enemyHitSound,\par
48              {\cf18 int} health = 100);\par
49 \par
56     {\cf18 void} moveTowards(sf::Vector2f position, sf::Time deltaTime);\par
57 \par
63     {\cf18 void} hit({\cf18 int} damage);\par
64 \par
70     sf::Vector2f calculateTowardsVector(sf::Vector2f position) {\cf17 const};\par
71 \par
79     sf::FloatRect getNextPosition(sf::Time deltaTime,\par
80                                   sf::Vector2f positionTowards) {\cf17 const};\par
81 \par
82     {\cf17 virtual} {\cf18 void} draw(sf::RenderTarget &surface, sf::RenderStates states) {\cf17 const};\par
86     GameObject &getEnemyObject();\par
90     {\cf18 bool} getDead() {\cf17 const};\par
91 \par
98     {\cf18 bool} canAttack() {\cf17 const};\par
99 \par
100     {\cf18 void} attacked();\par
101 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/PriorityQueue/PriorityQueue.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/PriorityQueue/PriorityQueue.hpp}
{\xe \v external/PriorityQueue/PriorityQueue.hpp}
{\bkmkstart AAAAAAAABN}
{\bkmkend AAAAAAAABN}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b PriorityQueue< T >}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
PriorityQueue.hpp\par \pard\plain 
{\tc\tcl2 \v external/PriorityQueue/PriorityQueue.hpp}
{\xe \v external/PriorityQueue/PriorityQueue.hpp}
{\bkmkstart AAAAAAAAAC}
{\bkmkend AAAAAAAAAC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #pragma once}\par
2 \par
3 {\cf21 #include <vector>}\par
4 \par
5 {\cf17 template} <{\cf17 class} T> {\cf17 class }PriorityQueue \{\par
6 \par
7   {\cf17 private}:\par
8     std::vector<std::pair<T, int>> elements;\par
9 \par
10   {\cf17 public}:\par
11     PriorityQueue() \{\}\par
12     {\cf18 int} size() \{ {\cf19 return} elements.size(); \}\par
13 \par
14     {\cf18 void} enqueue(T item, {\cf18 int} priority) \{\par
15         elements.push_back(std::make_pair(item, priority));\par
16     \}\par
17 \par
18     {\cf18 size_t} size(){\cf17  const }\{ {\cf19 return} elements.size(); \}\par
19 \par
20     {\cf18 bool} empty(){\cf17  const }\{ {\cf19 return} size() == 0; \}\par
21 \par
22     T dequeue() \{\par
23         {\cf18 int} bestIndex = 0;\par
24 \par
25         {\cf19 for} ({\cf18 int} i = 0; i < elements.size(); i++) \{\par
26             {\cf19 if} (elements[i].second < elements[bestIndex].second) \{\par
27                 bestIndex = i;\par
28             \}\par
29         \}\par
30 \par
31         T bestItem = elements[bestIndex].first;\par
32         elements[bestIndex].second = 100000;\par
33         {\cf19 return} bestItem;\par
34     \}\par
35 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/SimplexNoise/SimplexNoise.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/SimplexNoise/SimplexNoise.cpp}
{\xe \v external/SimplexNoise/SimplexNoise.cpp}
{\bkmkstart AAAAAAAABO}
{\bkmkend AAAAAAAABO}
\par
{
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Perlin Simplex Noise C++ Implementation (1D, 2D, 3D). }}\par
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "SimplexNoise.hpp"}\par
{\f2 #include <cstdint>}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Perlin Simplex Noise C++ Implementation (1D, 2D, 3D). \par
}{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
Copyright (c) 2014-2018 Sebastien Rombauts ({\f2 sebastien.rombauts@gmail.com})\par
This C++ implementation is based on the speed-improved Java version 2012-03-09 by Stefan Gustavson (original Java source code in the public domain). {\f2 http://webstaff.itn.liu.se/~stegu/simplexnoise/SimplexNoise.java:}{
\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Based on example code by Stefan Gustavson ({\f2 stegu@itn.liu.se}).\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Optimisations by Peter Eastman ({\f2 peastman@drizzle.stanford.edu}).\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Better rank ordering method by Stefan Gustavson in 2012.\par}
\par
This implementation is "Simplex Noise" as presented by Ken Perlin at a relatively obscure and not often cited course session "Real-Time Shading" at Siggraph 2001 (before real time shading actually took on), under the title "hardware noise". The 3D function is numerically equivalent to his Java reference code available in the PDF course notes, although I re-implemented it from scratch to get more readable code. The 1D, 2D and 4D cases were implemented from scratch by me from Ken Perlin's text.\par
Distributed under the MIT License (MIT) (See accompanying file LICENSE.txt or copy at {\f2 http://opensource.org/licenses/MIT}) \par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/SimplexNoise/SimplexNoise.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/SimplexNoise/SimplexNoise.hpp}
{\xe \v external/SimplexNoise/SimplexNoise.hpp}
{\bkmkstart AAAAAAAABP}
{\bkmkend AAAAAAAABP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstddef>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b SimplexNoise}\par
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i {\s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
A Perlin Simplex Noise C++ Implementation (1D, 2D, 3D, 4D). }}\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SimplexNoise.hpp\par \pard\plain 
{\tc\tcl2 \v external/SimplexNoise/SimplexNoise.hpp}
{\xe \v external/SimplexNoise/SimplexNoise.hpp}
{\bkmkstart AAAAAAAAAD}
{\bkmkend AAAAAAAAAD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 \par
10 {\cf21 #pragma once}\par
11 \par
12 {\cf21 #include <cstddef>} {\cf20 // size_t}\par
13 \par
17 {\cf17 class }SimplexNoise\par
18 \{\par
19 {\cf17 public}:\par
20     {\cf20 // 1D Perlin simplex noise}\par
21     {\cf17 static} {\cf18 float} noise({\cf18 float} x);\par
22     {\cf20 // 2D Perlin simplex noise}\par
23     {\cf17 static} {\cf18 float} noise({\cf18 float} x, {\cf18 float} y);\par
24     {\cf20 // 3D Perlin simplex noise}\par
25     {\cf17 static} {\cf18 float} noise({\cf18 float} x, {\cf18 float} y, {\cf18 float} z);\par
26 \par
27     {\cf20 // Fractal/Fractional Brownian Motion (fBm) noise summation}\par
28     {\cf18 float} fractal({\cf18 size_t} octaves, {\cf18 float} x) {\cf17 const};\par
29     {\cf18 float} fractal({\cf18 size_t} octaves, {\cf18 float} x, {\cf18 float} y) {\cf17 const};\par
30     {\cf18 float} fractal({\cf18 size_t} octaves, {\cf18 float} x, {\cf18 float} y, {\cf18 float} z) {\cf17 const};\par
31 \par
40     {\cf17 explicit} SimplexNoise({\cf18 float} frequency = 1.0f,\par
41                           {\cf18 float} amplitude = 1.0f,\par
42                           {\cf18 float} lacunarity = 2.0f,\par
43                           {\cf18 float} persistence = 0.5f) : mFrequency(frequency),\par
44                                                       mAmplitude(amplitude),\par
45                                                       mLacunarity(lacunarity),\par
46                                                       mPersistence(persistence)\par
47     \{\par
48     \}\par
49 \par
50 {\cf17 private}:\par
51     {\cf20 // Parameters of Fractional Brownian Motion (fBm) : sum of N "octaves" of noise}\par
52     {\cf18 float} mFrequency;   \par
53     {\cf18 float} mAmplitude;   \par
54     {\cf18 float} mLacunarity;  \par
55     {\cf18 float} mPersistence; \par
56 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml.hpp}
{\xe \v external/toml.hpp}
{\bkmkstart AAAAAAAABQ}
{\bkmkend AAAAAAAABQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "toml/parser.hpp"}\par
{\f2 #include "toml/literal.hpp"}\par
{\f2 #include "toml/serializer.hpp"}\par
{\f2 #include "toml/get.hpp"}\par
{\f2 #include "toml/macros.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_VERSION_MAJOR}\~ 3\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_VERSION_MINOR}\~ 7\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_VERSION_PATCH}\~ 1\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v TOML11_VERSION_MAJOR\:toml.hpp}
{\xe \v toml.hpp\:TOML11_VERSION_MAJOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_VERSION_MAJOR\~ 3}}
\par
{\bkmkstart AAAAAAAABR}
{\bkmkend AAAAAAAABR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_VERSION_MINOR\:toml.hpp}
{\xe \v toml.hpp\:TOML11_VERSION_MINOR}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_VERSION_MINOR\~ 7}}
\par
{\bkmkstart AAAAAAAABS}
{\bkmkend AAAAAAAABS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_VERSION_PATCH\:toml.hpp}
{\xe \v toml.hpp\:TOML11_VERSION_PATCH}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_VERSION_PATCH\~ 1}}
\par
{\bkmkstart AAAAAAAABT}
{\bkmkend AAAAAAAABT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
toml.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml.hpp}
{\xe \v external/toml.hpp}
{\bkmkstart AAAAAAAAAE}
{\bkmkend AAAAAAAAAE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 /*}\par
2 {\cf20  * The MIT License (MIT)}\par
3 {\cf20  *}\par
4 {\cf20  * Copyright (c) 2017 Toru Niina}\par
5 {\cf20  *}\par
6 {\cf20  * Permission is hereby granted, free of charge, to any person obtaining a copy}\par
7 {\cf20  * of this software and associated documentation files (the "Software"), to deal}\par
8 {\cf20  * in the Software without restriction, including without limitation the rights}\par
9 {\cf20  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell}\par
10 {\cf20  * copies of the Software, and to permit persons to whom the Software is}\par
11 {\cf20  * furnished to do so, subject to the following conditions:}\par
12 {\cf20  *}\par
13 {\cf20  * The above copyright notice and this permission notice shall be included in}\par
14 {\cf20  * all copies or substantial portions of the Software.}\par
15 {\cf20  *}\par
16 {\cf20  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR}\par
17 {\cf20  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,}\par
18 {\cf20  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE}\par
19 {\cf20  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER}\par
20 {\cf20  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,}\par
21 {\cf20  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN}\par
22 {\cf20  * THE SOFTWARE.}\par
23 {\cf20  */}\par
24 \par
25 {\cf21 #ifndef TOML_FOR_MODERN_CPP}\par
26 {\cf21 #define TOML_FOR_MODERN_CPP}\par
27 \par
28 {\cf21 #define TOML11_VERSION_MAJOR 3}\par
29 {\cf21 #define TOML11_VERSION_MINOR 7}\par
30 {\cf21 #define TOML11_VERSION_PATCH 1}\par
31 \par
32 {\cf21 #include "toml/parser.hpp"}\par
33 {\cf21 #include "toml/literal.hpp"}\par
34 {\cf21 #include "toml/serializer.hpp"}\par
35 {\cf21 #include "toml/get.hpp"}\par
36 {\cf21 #include "toml/macros.hpp"}\par
37 \par
38 {\cf21 #endif}{\cf20 // TOML_FOR_MODERN_CPP}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/color.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/color.hpp}
{\xe \v external/toml/color.hpp}
{\bkmkstart AAAAAAAABU}
{\bkmkend AAAAAAAABU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdint>}\par
{\f2 #include <ostream>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::color_ansi}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::color_ansi::detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_ERROR_MESSAGE_COLORIZED}\~ false\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b toml::color_ansi::detail::colorize_index} ()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b toml::color_ansi::colorize} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b toml::color_ansi::nocolorize} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b toml::color_ansi::reset} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b toml::color_ansi::bold} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b toml::color_ansi::grey} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b toml::color_ansi::red} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b toml::color_ansi::green} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b toml::color_ansi::yellow} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b toml::color_ansi::blue} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b toml::color_ansi::magenta} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b toml::color_ansi::cyan} (std::ostream &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ostream & {\b toml::color_ansi::white} (std::ostream &os)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v TOML11_ERROR_MESSAGE_COLORIZED\:color.hpp}
{\xe \v color.hpp\:TOML11_ERROR_MESSAGE_COLORIZED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_ERROR_MESSAGE_COLORIZED\~ false}}
\par
{\bkmkstart AAAAAAAABV}
{\bkmkend AAAAAAAABV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
color.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/color.hpp}
{\xe \v external/toml/color.hpp}
{\bkmkstart AAAAAAAAAF}
{\bkmkend AAAAAAAAAF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef TOML11_COLOR_HPP}\par
2 {\cf21 #define TOML11_COLOR_HPP}\par
3 {\cf21 #include <cstdint>}\par
4 {\cf21 #include <ostream>}\par
5 \par
6 {\cf21 #ifdef TOML11_COLORIZE_ERROR_MESSAGE}\par
7 {\cf21 #define TOML11_ERROR_MESSAGE_COLORIZED true}\par
8 {\cf21 #else}\par
9 {\cf21 #define TOML11_ERROR_MESSAGE_COLORIZED false}\par
10 {\cf21 #endif}\par
11 \par
12 {\cf17 namespace }toml\par
13 \{\par
14 \par
15 {\cf20 // put ANSI escape sequence to ostream}\par
16 {\cf17 namespace }color_ansi\par
17 \{\par
18 {\cf17 namespace }detail\par
19 \{\par
20 {\cf17 inline} {\cf18 int} colorize_index()\par
21 \{\par
22     {\cf17 static} {\cf17 const} {\cf18 int} index = std::ios_base::xalloc();\par
23     {\cf19 return} index;\par
24 \}\par
25 \} {\cf20 // detail}\par
26 \par
27 {\cf17 inline} std::ostream& colorize(std::ostream& os)\par
28 \{\par
29     {\cf20 // by default, it is zero.}\par
30     os.iword(detail::colorize_index()) = 1;\par
31     {\cf19 return} os;\par
32 \}\par
33 {\cf17 inline} std::ostream& nocolorize(std::ostream& os)\par
34 \{\par
35     os.iword(detail::colorize_index()) = 0;\par
36     {\cf19 return} os;\par
37 \}\par
38 {\cf17 inline} std::ostream& reset  (std::ostream& os)\par
39 \{{\cf19 if}(os.iword(detail::colorize_index()) == 1) \{os << {\cf22 "\\033[00m"};\} {\cf19 return} os;\}\par
40 {\cf17 inline} std::ostream& bold   (std::ostream& os)\par
41 \{{\cf19 if}(os.iword(detail::colorize_index()) == 1) \{os << {\cf22 "\\033[01m"};\} {\cf19 return} os;\}\par
42 {\cf17 inline} std::ostream& grey   (std::ostream& os)\par
43 \{{\cf19 if}(os.iword(detail::colorize_index()) == 1) \{os << {\cf22 "\\033[30m"};\} {\cf19 return} os;\}\par
44 {\cf17 inline} std::ostream& red    (std::ostream& os)\par
45 \{{\cf19 if}(os.iword(detail::colorize_index()) == 1) \{os << {\cf22 "\\033[31m"};\} {\cf19 return} os;\}\par
46 {\cf17 inline} std::ostream& green  (std::ostream& os)\par
47 \{{\cf19 if}(os.iword(detail::colorize_index()) == 1) \{os << {\cf22 "\\033[32m"};\} {\cf19 return} os;\}\par
48 {\cf17 inline} std::ostream& yellow (std::ostream& os)\par
49 \{{\cf19 if}(os.iword(detail::colorize_index()) == 1) \{os << {\cf22 "\\033[33m"};\} {\cf19 return} os;\}\par
50 {\cf17 inline} std::ostream& blue   (std::ostream& os)\par
51 \{{\cf19 if}(os.iword(detail::colorize_index()) == 1) \{os << {\cf22 "\\033[34m"};\} {\cf19 return} os;\}\par
52 {\cf17 inline} std::ostream& magenta(std::ostream& os)\par
53 \{{\cf19 if}(os.iword(detail::colorize_index()) == 1) \{os << {\cf22 "\\033[35m"};\} {\cf19 return} os;\}\par
54 {\cf17 inline} std::ostream& cyan   (std::ostream& os)\par
55 \{{\cf19 if}(os.iword(detail::colorize_index()) == 1) \{os << {\cf22 "\\033[36m"};\} {\cf19 return} os;\}\par
56 {\cf17 inline} std::ostream& white  (std::ostream& os)\par
57 \{{\cf19 if}(os.iword(detail::colorize_index()) == 1) \{os << {\cf22 "\\033[37m"};\} {\cf19 return} os;\}\par
58 \} {\cf20 // color_ansi}\par
59 \par
60 {\cf20 // ANSI escape sequence is the only and default colorization method currently}\par
61 {\cf17 namespace }color = color_ansi;\par
62 \par
63 \} {\cf20 // toml}\par
64 {\cf21 #endif}{\cf20 // TOML11_COLOR_HPP}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/combinator.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/combinator.hpp}
{\xe \v external/toml/combinator.hpp}
{\bkmkstart AAAAAAAABW}
{\bkmkend AAAAAAAABW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cassert>}\par
{\f2 #include <cctype>}\par
{\f2 #include <cstdio>}\par
{\f2 #include <array>}\par
{\f2 #include <iomanip>}\par
{\f2 #include <iterator>}\par
{\f2 #include <limits>}\par
{\f2 #include <type_traits>}\par
{\f2 #include "region.hpp"}\par
{\f2 #include "result.hpp"}\par
{\f2 #include "traits.hpp"}\par
{\f2 #include "utility.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::character< C >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::in_range< Low, Up >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::exclude< Combinator >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::maybe< Combinator >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::sequence< Head, Tail... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::sequence< Head >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::either< Head, Tail... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::either< Head >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::exactly< N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::at_least< N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::unlimited}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::repeat< T, exactly< N > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::repeat< T, at_least< N > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::repeat< T, unlimited >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toml::detail::show_char} (const char c)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
combinator.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/combinator.hpp}
{\xe \v external/toml/combinator.hpp}
{\bkmkstart AAAAAAAAAG}
{\bkmkend AAAAAAAAAG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2017.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_COMBINATOR_HPP}\par
4 {\cf21 #define TOML11_COMBINATOR_HPP}\par
5 {\cf21 #include <cassert>}\par
6 {\cf21 #include <cctype>}\par
7 {\cf21 #include <cstdio>}\par
8 \par
9 {\cf21 #include <array>}\par
10 {\cf21 #include <iomanip>}\par
11 {\cf21 #include <iterator>}\par
12 {\cf21 #include <limits>}\par
13 {\cf21 #include <type_traits>}\par
14 \par
15 {\cf21 #include "region.hpp"}\par
16 {\cf21 #include "result.hpp"}\par
17 {\cf21 #include "traits.hpp"}\par
18 {\cf21 #include "utility.hpp"}\par
19 \par
20 {\cf20 // they scans characters and returns region if it matches to the condition.}\par
21 {\cf20 // when they fail, it does not change the location.}\par
22 {\cf20 // in lexer.hpp, these are used.}\par
23 \par
24 {\cf17 namespace }toml\par
25 \{\par
26 {\cf17 namespace }detail\par
27 \{\par
28 \par
29 {\cf20 // to output character as an error message.}\par
30 {\cf17 inline} std::string show_char({\cf17 const} {\cf18 char} c)\par
31 \{\par
32     {\cf20 // It suppresses an error that occurs only in Debug mode of MSVC++ on Windows.}\par
33     {\cf20 // I'm not completely sure but they check the value of char to be in the}\par
34     {\cf20 // range [0, 256) and some of the COMPLETELY VALID utf-8 character sometimes}\par
35     {\cf20 // has negative value (if char has sign). So here it re-interprets c as}\par
36     {\cf20 // unsigned char through pointer. In general, converting pointer to a}\par
37     {\cf20 // pointer that has different type cause UB, but `(signed|unsigned)?char`}\par
38     {\cf20 // are one of the exceptions. Converting pointer only to char and std::byte}\par
39     {\cf20 // (c++17) are valid.}\par
40     {\cf19 if}(std::isgraph(*{\cf17 reinterpret_cast<}{\cf18 unsigned} {\cf18 char} const*{\cf17 >}(std::addressof(c))))\par
41     \{\par
42         {\cf19 return} std::string(1, c);\par
43     \}\par
44     {\cf19 else}\par
45     \{\par
46         std::array<char, 5> buf;\par
47         buf.fill({\cf23 '\\0'});\par
48         {\cf17 const} {\cf17 auto} r = std::snprintf(\par
49                 buf.data(), buf.size(), {\cf22 "0x%02x"}, {\cf17 static_cast<}{\cf18 int}{\cf17 >}(c) & 0xFF);\par
50         (void) r; {\cf20 // Unused variable warning}\par
51         assert(r == {\cf17 static_cast<}{\cf18 int}{\cf17 >}(buf.size()) - 1);\par
52         {\cf19 return} std::string(buf.data());\par
53     \}\par
54 \}\par
55 \par
56 {\cf17 template}<{\cf18 char} C>\par
57 {\cf17 struct }character\par
58 \{\par
59     {\cf17 static} {\cf17 constexpr} {\cf18 char} target = C;\par
60 \par
61     {\cf17 static} result<region, none_t>\par
62     invoke(location& loc)\par
63     \{\par
64         {\cf19 if}(loc.iter() == loc.end()) \{{\cf19 return} none();\}\par
65         {\cf17 const} {\cf17 auto} first = loc.iter();\par
66 \par
67         {\cf17 const} {\cf18 char} c = *(loc.iter());\par
68         {\cf19 if}(c != target)\par
69         \{\par
70             {\cf19 return} none();\par
71         \}\par
72         loc.advance(); {\cf20 // update location}\par
73 \par
74         {\cf19 return} ok(region(loc, first, loc.iter()));\par
75     \}\par
76 \};\par
77 {\cf17 template}<{\cf18 char} C>\par
78 {\cf17 constexpr} {\cf18 char} character<C>::target;\par
79 \par
80 {\cf20 // closed interval [Low, Up]. both Low and Up are included.}\par
81 {\cf17 template}<{\cf18 char} Low, {\cf18 char} Up>\par
82 {\cf17 struct }in_range\par
83 \{\par
84     {\cf20 // assuming ascii part of UTF-8...}\par
85     {\cf17 static_assert}(Low <= Up, {\cf22 "lower bound should be less than upper bound."});\par
86 \par
87     {\cf17 static} {\cf17 constexpr} {\cf18 char} upper = Up;\par
88     {\cf17 static} {\cf17 constexpr} {\cf18 char} lower = Low;\par
89 \par
90     {\cf17 static} result<region, none_t>\par
91     invoke(location& loc)\par
92     \{\par
93         {\cf19 if}(loc.iter() == loc.end()) \{{\cf19 return} none();\}\par
94         {\cf17 const} {\cf17 auto} first = loc.iter();\par
95 \par
96         {\cf17 const} {\cf18 char} c = *(loc.iter());\par
97         {\cf19 if}(c < lower || upper < c)\par
98         \{\par
99             {\cf19 return} none();\par
100         \}\par
101 \par
102         loc.advance();\par
103         {\cf19 return} ok(region(loc, first, loc.iter()));\par
104     \}\par
105 \};\par
106 {\cf17 template}<{\cf18 char} L, {\cf18 char} U> {\cf17 constexpr} {\cf18 char} in_range<L, U>::upper;\par
107 {\cf17 template}<{\cf18 char} L, {\cf18 char} U> {\cf17 constexpr} {\cf18 char} in_range<L, U>::lower;\par
108 \par
109 {\cf20 // keep iterator if `Combinator` matches. otherwise, increment `iter` by 1 char.}\par
110 {\cf20 // for detecting invalid characters, like control sequences in toml string.}\par
111 {\cf17 template}<{\cf17 typename} Combinator>\par
112 {\cf17 struct }exclude\par
113 \{\par
114     {\cf17 static} result<region, none_t>\par
115     invoke(location& loc)\par
116     \{\par
117         {\cf19 if}(loc.iter() == loc.end()) \{{\cf19 return} none();\}\par
118         {\cf17 auto} first = loc.iter();\par
119 \par
120         {\cf17 auto} rslt = Combinator::invoke(loc);\par
121         {\cf19 if}(rslt.is_ok())\par
122         \{\par
123             loc.reset(first);\par
124             {\cf19 return} none();\par
125         \}\par
126         loc.reset(std::next(first)); {\cf20 // XXX maybe loc.advance() is okay but...}\par
127         {\cf19 return} ok(region(loc, first, loc.iter()));\par
128     \}\par
129 \};\par
130 \par
131 {\cf20 // increment `iter`, if matches. otherwise, just return empty string.}\par
132 {\cf17 template}<{\cf17 typename} Combinator>\par
133 {\cf17 struct }maybe\par
134 \{\par
135     {\cf17 static} result<region, none_t>\par
136     invoke(location& loc)\par
137     \{\par
138         {\cf17 const} {\cf17 auto} rslt = Combinator::invoke(loc);\par
139         {\cf19 if}(rslt.is_ok())\par
140         \{\par
141             {\cf19 return} rslt;\par
142         \}\par
143         {\cf19 return} ok(region(loc));\par
144     \}\par
145 \};\par
146 \par
147 {\cf17 template}<{\cf17 typename} ... Ts>\par
148 {\cf17 struct }sequence;\par
149 \par
150 {\cf17 template}<{\cf17 typename} Head, {\cf17 typename} ... Tail>\par
151 {\cf17 struct }sequence<Head, Tail...>\par
152 \{\par
153     {\cf17 static} result<region, none_t>\par
154     invoke(location& loc)\par
155     \{\par
156         {\cf17 const} {\cf17 auto} first = loc.iter();\par
157         {\cf17 auto} rslt = Head::invoke(loc);\par
158         {\cf19 if}(rslt.is_err())\par
159         \{\par
160             loc.reset(first);\par
161             {\cf19 return} none();\par
162         \}\par
163         {\cf19 return} sequence<Tail...>::invoke(loc, std::move(rslt.unwrap()), first);\par
164     \}\par
165 \par
166     {\cf20 // called from the above function only, recursively.}\par
167     {\cf17 template}<{\cf17 typename} Iterator>\par
168     {\cf17 static} result<region, none_t>\par
169     invoke(location& loc, region reg, Iterator first)\par
170     \{\par
171         {\cf17 const} {\cf17 auto} rslt = Head::invoke(loc);\par
172         {\cf19 if}(rslt.is_err())\par
173         \{\par
174             loc.reset(first);\par
175             {\cf19 return} none();\par
176         \}\par
177         reg += rslt.unwrap(); {\cf20 // concat regions}\par
178         {\cf19 return} sequence<Tail...>::invoke(loc, std::move(reg), first);\par
179     \}\par
180 \};\par
181 \par
182 {\cf17 template}<{\cf17 typename} Head>\par
183 {\cf17 struct }sequence<Head>\par
184 \{\par
185     {\cf20 // would be called from sequence<T ...>::invoke only.}\par
186     {\cf17 template}<{\cf17 typename} Iterator>\par
187     {\cf17 static} result<region, none_t>\par
188     invoke(location& loc, region reg, Iterator first)\par
189     \{\par
190         {\cf17 const} {\cf17 auto} rslt = Head::invoke(loc);\par
191         {\cf19 if}(rslt.is_err())\par
192         \{\par
193             loc.reset(first);\par
194             {\cf19 return} none();\par
195         \}\par
196         reg += rslt.unwrap(); {\cf20 // concat regions}\par
197         {\cf19 return} ok(reg);\par
198     \}\par
199 \};\par
200 \par
201 {\cf17 template}<{\cf17 typename} ... Ts>\par
202 {\cf17 struct }either;\par
203 \par
204 {\cf17 template}<{\cf17 typename} Head, {\cf17 typename} ... Tail>\par
205 {\cf17 struct }either<Head, Tail...>\par
206 \{\par
207     {\cf17 static} result<region, none_t>\par
208     invoke(location& loc)\par
209     \{\par
210         {\cf17 const} {\cf17 auto} rslt = Head::invoke(loc);\par
211         {\cf19 if}(rslt.is_ok()) \{{\cf19 return} rslt;\}\par
212         {\cf19 return} either<Tail...>::invoke(loc);\par
213     \}\par
214 \};\par
215 {\cf17 template}<{\cf17 typename} Head>\par
216 {\cf17 struct }either<Head>\par
217 \{\par
218     {\cf17 static} result<region, none_t>\par
219     invoke(location& loc)\par
220     \{\par
221         {\cf19 return} Head::invoke(loc);\par
222     \}\par
223 \};\par
224 \par
225 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} N>\par
226 {\cf17 struct }repeat;\par
227 \par
228 {\cf17 template}<std::{\cf18 size_t} N> {\cf17 struct }exactly\{\};\par
229 {\cf17 template}<std::{\cf18 size_t} N> {\cf17 struct }at_least\{\};\par
230 {\cf17 struct }unlimited\{\};\par
231 \par
232 {\cf17 template}<{\cf17 typename} T, std::{\cf18 size_t} N>\par
233 {\cf17 struct }repeat<T, exactly<N>>\par
234 \{\par
235     {\cf17 static} result<region, none_t>\par
236     invoke(location& loc)\par
237     \{\par
238         region retval(loc);\par
239         {\cf17 const} {\cf17 auto} first = loc.iter();\par
240         {\cf19 for}(std::size_t i=0; i<N; ++i)\par
241         \{\par
242             {\cf17 auto} rslt = T::invoke(loc);\par
243             {\cf19 if}(rslt.is_err())\par
244             \{\par
245                 loc.reset(first);\par
246                 {\cf19 return} none();\par
247             \}\par
248             retval += rslt.unwrap();\par
249         \}\par
250         {\cf19 return} ok(std::move(retval));\par
251     \}\par
252 \};\par
253 \par
254 {\cf17 template}<{\cf17 typename} T, std::{\cf18 size_t} N>\par
255 {\cf17 struct }repeat<T, at_least<N>>\par
256 \{\par
257     {\cf17 static} result<region, none_t>\par
258     invoke(location& loc)\par
259     \{\par
260         region retval(loc);\par
261 \par
262         {\cf17 const} {\cf17 auto} first = loc.iter();\par
263         {\cf19 for}(std::size_t i=0; i<N; ++i)\par
264         \{\par
265             {\cf17 auto} rslt = T::invoke(loc);\par
266             {\cf19 if}(rslt.is_err())\par
267             \{\par
268                 loc.reset(first);\par
269                 {\cf19 return} none();\par
270             \}\par
271             retval += rslt.unwrap();\par
272         \}\par
273         {\cf19 while}({\cf17 true})\par
274         \{\par
275             {\cf17 auto} rslt = T::invoke(loc);\par
276             {\cf19 if}(rslt.is_err())\par
277             \{\par
278                 {\cf19 return} ok(std::move(retval));\par
279             \}\par
280             retval += rslt.unwrap();\par
281         \}\par
282     \}\par
283 \};\par
284 \par
285 {\cf17 template}<{\cf17 typename} T>\par
286 {\cf17 struct }repeat<T, unlimited>\par
287 \{\par
288     {\cf17 static} result<region, none_t>\par
289     invoke(location& loc)\par
290     \{\par
291         region retval(loc);\par
292         {\cf19 while}({\cf17 true})\par
293         \{\par
294             {\cf17 auto} rslt = T::invoke(loc);\par
295             {\cf19 if}(rslt.is_err())\par
296             \{\par
297                 {\cf19 return} ok(std::move(retval));\par
298             \}\par
299             retval += rslt.unwrap();\par
300         \}\par
301     \}\par
302 \};\par
303 \par
304 \} {\cf20 // detail}\par
305 \} {\cf20 // toml}\par
306 {\cf21 #endif}{\cf20 // TOML11_COMBINATOR_HPP}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/comments.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/comments.hpp}
{\xe \v external/toml/comments.hpp}
{\bkmkstart AAAAAAAABX}
{\bkmkend AAAAAAAABX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <initializer_list>}\par
{\f2 #include <iterator>}\par
{\f2 #include <stdexcept>}\par
{\f2 #include <string>}\par
{\f2 #include <type_traits>}\par
{\f2 #include <utility>}\par
{\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::preserve_comments}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::empty_iterator< T, is_const >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::discard_comments}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_DEFAULT_COMMENT_STRATEGY}\~ {\b ::toml::discard_comments}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator==} (const preserve_comments &lhs, const preserve_comments &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator!=} (const preserve_comments &lhs, const preserve_comments &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<} (const preserve_comments &lhs, const preserve_comments &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<=} (const preserve_comments &lhs, const preserve_comments &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>} (const preserve_comments &lhs, const preserve_comments &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>=} (const preserve_comments &lhs, const preserve_comments &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b toml::swap} (preserve_comments &lhs, preserve_comments &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b toml::swap} (preserve_comments &lhs, std::vector< std::string > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b toml::swap} (std::vector< std::string > &lhs, preserve_comments &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b toml::operator<<} (std::basic_ostream< charT, traits > &os, const preserve_comments &com)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> bool {\b toml::detail::operator==} (const empty_iterator< T, C > &, const empty_iterator< T, C > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> bool {\b toml::detail::operator!=} (const empty_iterator< T, C > &, const empty_iterator< T, C > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> bool {\b toml::detail::operator<} (const empty_iterator< T, C > &, const empty_iterator< T, C > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> bool {\b toml::detail::operator<=} (const empty_iterator< T, C > &, const empty_iterator< T, C > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> bool {\b toml::detail::operator>} (const empty_iterator< T, C > &, const empty_iterator< T, C > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> bool {\b toml::detail::operator>=} (const empty_iterator< T, C > &, const empty_iterator< T, C > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> empty_iterator< T, C >::difference_type {\b toml::detail::operator-} (const empty_iterator< T, C > &, const empty_iterator< T, C > &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> empty_iterator< T, C > {\b toml::detail::operator+} (typename empty_iterator< T, C >::difference_type, const empty_iterator< T, C > &rhs) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , bool C> empty_iterator< T, C > {\b toml::detail::operator+} (const empty_iterator< T, C > &lhs, typename empty_iterator< T, C >::difference_type) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator==} (const discard_comments &, const discard_comments &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator!=} (const discard_comments &, const discard_comments &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<} (const discard_comments &, const discard_comments &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<=} (const discard_comments &, const discard_comments &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>} (const discard_comments &, const discard_comments &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>=} (const discard_comments &, const discard_comments &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b toml::swap} (const discard_comments &, const discard_comments &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b toml::operator<<} (std::basic_ostream< charT, traits > &os, const discard_comments &)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v TOML11_DEFAULT_COMMENT_STRATEGY\:comments.hpp}
{\xe \v comments.hpp\:TOML11_DEFAULT_COMMENT_STRATEGY}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_DEFAULT_COMMENT_STRATEGY\~ {\b ::toml::discard_comments}}}
\par
{\bkmkstart AAAAAAAABY}
{\bkmkend AAAAAAAABY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
comments.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/comments.hpp}
{\xe \v external/toml/comments.hpp}
{\bkmkstart AAAAAAAAAH}
{\bkmkend AAAAAAAAAH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2019.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_COMMENTS_HPP}\par
4 {\cf21 #define TOML11_COMMENTS_HPP}\par
5 {\cf21 #include <initializer_list>}\par
6 {\cf21 #include <iterator>}\par
7 {\cf21 #include <stdexcept>}\par
8 {\cf21 #include <string>}\par
9 {\cf21 #include <type_traits>}\par
10 {\cf21 #include <utility>}\par
11 {\cf21 #include <vector>}\par
12 \par
13 {\cf21 #ifdef TOML11_PRESERVE_COMMENTS_BY_DEFAULT}\par
14 {\cf21 #  define TOML11_DEFAULT_COMMENT_STRATEGY ::toml::preserve_comments}\par
15 {\cf21 #else}\par
16 {\cf21 #  define TOML11_DEFAULT_COMMENT_STRATEGY ::toml::discard_comments}\par
17 {\cf21 #endif}\par
18 \par
19 {\cf20 // This file provides mainly two classes, `preserve_comments` and `discard_comments`.}\par
20 {\cf20 // Those two are a container that have the same interface as `std::vector<std::string>`}\par
21 {\cf20 // but bahaves in the opposite way. `preserve_comments` is just the same as}\par
22 {\cf20 // `std::vector<std::string>` and each `std::string` corresponds to a comment line.}\par
23 {\cf20 // Conversely, `discard_comments` discards all the strings and ignores everything}\par
24 {\cf20 // assigned in it. `discard_comments` is always empty and you will encounter an}\par
25 {\cf20 // error whenever you access to the element.}\par
26 {\cf17 namespace }toml\par
27 \{\par
28 {\cf17 struct }discard_comments; {\cf20 // forward decl}\par
29 \par
30 {\cf20 // use it in the following way}\par
31 {\cf20 //}\par
32 {\cf20 // const toml::basic_value<toml::preserve_comments> data =}\par
33 {\cf20 //     toml::parse<toml::preserve_comments>("example.toml");}\par
34 {\cf20 //}\par
35 {\cf20 // the interface is almost the same as std::vector<std::string>.}\par
36 {\cf17 struct }preserve_comments\par
37 \{\par
38     {\cf20 // `container_type` is not provided in discard_comments.}\par
39     {\cf20 // do not use this inner-type in a generic code.}\par
40     {\cf17 using }container_type         = std::vector<std::string>;\par
41 \par
42     {\cf17 using }size_type              = container_type::size_type;\par
43     {\cf17 using }difference_type        = container_type::difference_type;\par
44     {\cf17 using }value_type             = container_type::value_type;\par
45     {\cf17 using }reference              = container_type::reference;\par
46     {\cf17 using }const_reference        = container_type::const_reference;\par
47     {\cf17 using }pointer                = container_type::pointer;\par
48     {\cf17 using }const_pointer          = container_type::const_pointer;\par
49     {\cf17 using }iterator               = container_type::iterator;\par
50     {\cf17 using }const_iterator         = container_type::const_iterator;\par
51     {\cf17 using }reverse_iterator       = container_type::reverse_iterator;\par
52     {\cf17 using }const_reverse_iterator = container_type::const_reverse_iterator;\par
53 \par
54     preserve_comments()  = {\cf19 default};\par
55     ~preserve_comments() = {\cf19 default};\par
56     preserve_comments(preserve_comments {\cf17 const}&) = {\cf19 default};\par
57     preserve_comments(preserve_comments &&)     = {\cf19 default};\par
58     preserve_comments& operator=(preserve_comments {\cf17 const}&) = {\cf19 default};\par
59     preserve_comments& operator=(preserve_comments &&)     = {\cf19 default};\par
60 \par
61     {\cf17 explicit} preserve_comments({\cf17 const} std::vector<std::string>& c): comments(c)\{\}\par
62     {\cf17 explicit} preserve_comments(std::vector<std::string>&& c)\par
63         : comments(std::move(c))\par
64     \{\}\par
65     preserve_comments& operator=({\cf17 const} std::vector<std::string>& c)\par
66     \{\par
67         comments = c;\par
68         {\cf19 return} *{\cf17 this};\par
69     \}\par
70     preserve_comments& operator=(std::vector<std::string>&& c)\par
71     \{\par
72         comments = std::move(c);\par
73         {\cf19 return} *{\cf17 this};\par
74     \}\par
75 \par
76     {\cf17 explicit} preserve_comments({\cf17 const} discard_comments&) \{\}\par
77 \par
78     {\cf17 explicit} preserve_comments(size_type n): comments(n) \{\}\par
79     preserve_comments(size_type n, {\cf17 const} std::string& x): comments(n, x) \{\}\par
80     preserve_comments(std::initializer_list<std::string> x): comments(x) \{\}\par
81     {\cf17 template}<{\cf17 typename} InputIterator>\par
82     preserve_comments(InputIterator first, InputIterator last)\par
83         : comments(first, last)\par
84     \{\}\par
85 \par
86     {\cf17 template}<{\cf17 typename} InputIterator>\par
87     {\cf18 void} assign(InputIterator first, InputIterator last) \{comments.assign(first, last);\}\par
88     {\cf18 void} assign(std::initializer_list<std::string> ini)  \{comments.assign(ini);\}\par
89     {\cf18 void} assign(size_type n, {\cf17 const} std::string& val)     \{comments.assign(n, val);\}\par
90 \par
91     {\cf20 // Related to the issue #97.}\par
92     {\cf20 //}\par
93     {\cf20 // It is known that `std::vector::insert` and `std::vector::erase` in}\par
94     {\cf20 // the standard library implementation included in GCC 4.8.5 takes}\par
95     {\cf20 // `std::vector::iterator` instead of `std::vector::const_iterator`.}\par
96     {\cf20 // Because of the const-correctness, we cannot convert a `const_iterator` to}\par
97     {\cf20 // an `iterator`. It causes compilation error in GCC 4.8.5.}\par
98 {\cf21 #if defined(__GNUC__) && defined(__GNUC_MINOR__) && defined(__GNUC_PATCHLEVEL__) && !defined(__clang__)}\par
99 {\cf21 #  if (__GNUC__ * 10000 + __GNUC_MINOR__ * 100 + __GNUC_PATCHLEVEL__) <= 40805}\par
100 {\cf21 #    define TOML11_WORKAROUND_GCC_4_8_X_STANDARD_LIBRARY_IMPLEMENTATION}\par
101 {\cf21 #  endif}\par
102 {\cf21 #endif}\par
103 \par
104 {\cf21 #ifdef TOML11_WORKAROUND_GCC_4_8_X_STANDARD_LIBRARY_IMPLEMENTATION}\par
105     iterator insert(iterator p, {\cf17 const} std::string& x)\par
106     \{\par
107         {\cf19 return} comments.insert(p, x);\par
108     \}\par
109     iterator insert(iterator p, std::string&&      x)\par
110     \{\par
111         {\cf19 return} comments.insert(p, std::move(x));\par
112     \}\par
113     {\cf18 void} insert(iterator p, size_type n, {\cf17 const} std::string& x)\par
114     \{\par
115         {\cf19 return} comments.insert(p, n, x);\par
116     \}\par
117     {\cf17 template}<{\cf17 typename} InputIterator>\par
118     {\cf18 void} insert(iterator p, InputIterator first, InputIterator last)\par
119     \{\par
120         {\cf19 return} comments.insert(p, first, last);\par
121     \}\par
122     {\cf18 void} insert(iterator p, std::initializer_list<std::string> ini)\par
123     \{\par
124         {\cf19 return} comments.insert(p, ini);\par
125     \}\par
126 \par
127     {\cf17 template}<{\cf17 typename} ... Ts>\par
128     iterator emplace(iterator p, Ts&& ... args)\par
129     \{\par
130         {\cf19 return} comments.emplace(p, std::forward<Ts>(args)...);\par
131     \}\par
132 \par
133     iterator erase(iterator pos) \{{\cf19 return} comments.erase(pos);\}\par
134     iterator erase(iterator first, iterator last)\par
135     \{\par
136         {\cf19 return} comments.erase(first, last);\par
137     \}\par
138 {\cf21 #else}\par
139     iterator insert(const_iterator p, {\cf17 const} std::string& x)\par
140     \{\par
141         {\cf19 return} comments.insert(p, x);\par
142     \}\par
143     iterator insert(const_iterator p, std::string&&      x)\par
144     \{\par
145         {\cf19 return} comments.insert(p, std::move(x));\par
146     \}\par
147     iterator insert(const_iterator p, size_type n, {\cf17 const} std::string& x)\par
148     \{\par
149         {\cf19 return} comments.insert(p, n, x);\par
150     \}\par
151     {\cf17 template}<{\cf17 typename} InputIterator>\par
152     iterator insert(const_iterator p, InputIterator first, InputIterator last)\par
153     \{\par
154         {\cf19 return} comments.insert(p, first, last);\par
155     \}\par
156     iterator insert(const_iterator p, std::initializer_list<std::string> ini)\par
157     \{\par
158         {\cf19 return} comments.insert(p, ini);\par
159     \}\par
160 \par
161     {\cf17 template}<{\cf17 typename} ... Ts>\par
162     iterator emplace(const_iterator p, Ts&& ... args)\par
163     \{\par
164         {\cf19 return} comments.emplace(p, std::forward<Ts>(args)...);\par
165     \}\par
166 \par
167     iterator erase(const_iterator pos) \{{\cf19 return} comments.erase(pos);\}\par
168     iterator erase(const_iterator first, const_iterator last)\par
169     \{\par
170         {\cf19 return} comments.erase(first, last);\par
171     \}\par
172 {\cf21 #endif}\par
173 \par
174     {\cf18 void} swap(preserve_comments& other) \{comments.swap(other.comments);\}\par
175 \par
176     {\cf18 void} push_back({\cf17 const} std::string& v) \{comments.push_back(v);\}\par
177     {\cf18 void} push_back(std::string&&      v) \{comments.push_back(std::move(v));\}\par
178     {\cf18 void} pop_back()                      \{comments.pop_back();\}\par
179 \par
180     {\cf17 template}<{\cf17 typename} ... Ts>\par
181     {\cf18 void} emplace_back(Ts&& ... args) \{comments.emplace_back(std::forward<Ts>(args)...);\}\par
182 \par
183     {\cf18 void} clear() \{comments.clear();\}\par
184 \par
185     size_type size()     const noexcept \{{\cf19 return} comments.size();\}\par
186     size_type max_size() const noexcept \{{\cf19 return} comments.max_size();\}\par
187     size_type capacity() const noexcept \{{\cf19 return} comments.capacity();\}\par
188     {\cf18 bool}      empty()    const noexcept \{{\cf19 return} comments.empty();\}\par
189 \par
190     {\cf18 void} reserve(size_type n)                      \{comments.reserve(n);\}\par
191     {\cf18 void} resize(size_type n)                       \{comments.resize(n);\}\par
192     {\cf18 void} resize(size_type n, {\cf17 const} std::string& c) \{comments.resize(n, c);\}\par
193     {\cf18 void} shrink_to_fit()                           \{comments.shrink_to_fit();\}\par
194 \par
195     reference       operator[]({\cf17 const} size_type n)       {\cf17 noexcept} \{{\cf19 return} comments[n];\}\par
196     const_reference operator[]({\cf17 const} size_type n) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} comments[n];\}\par
197     reference       at({\cf17 const} size_type n)       \{{\cf19 return} comments.at(n);\}\par
198     const_reference at({\cf17 const} size_type n){\cf17  const }\{{\cf19 return} comments.at(n);\}\par
199     reference       front()       noexcept \{{\cf19 return} comments.front();\}\par
200     const_reference front() const noexcept \{{\cf19 return} comments.front();\}\par
201     reference       back()        noexcept \{{\cf19 return} comments.back();\}\par
202     const_reference back()  const noexcept \{{\cf19 return} comments.back();\}\par
203 \par
204     pointer         data()        noexcept \{{\cf19 return} comments.data();\}\par
205     const_pointer   data()  const noexcept \{{\cf19 return} comments.data();\}\par
206 \par
207     iterator       begin()        noexcept \{{\cf19 return} comments.begin();\}\par
208     iterator       end()          noexcept \{{\cf19 return} comments.end();\}\par
209     const_iterator begin()  const noexcept \{{\cf19 return} comments.begin();\}\par
210     const_iterator end()    const noexcept \{{\cf19 return} comments.end();\}\par
211     const_iterator cbegin() const noexcept \{{\cf19 return} comments.cbegin();\}\par
212     const_iterator cend()   const noexcept \{{\cf19 return} comments.cend();\}\par
213 \par
214     reverse_iterator       rbegin()        noexcept \{{\cf19 return} comments.rbegin();\}\par
215     reverse_iterator       rend()          noexcept \{{\cf19 return} comments.rend();\}\par
216     const_reverse_iterator rbegin()  const noexcept \{{\cf19 return} comments.rbegin();\}\par
217     const_reverse_iterator rend()    const noexcept \{{\cf19 return} comments.rend();\}\par
218     const_reverse_iterator crbegin() const noexcept \{{\cf19 return} comments.crbegin();\}\par
219     const_reverse_iterator crend()   const noexcept \{{\cf19 return} comments.crend();\}\par
220 \par
221     {\cf17 friend} {\cf18 bool} operator==({\cf17 const} preserve_comments&, {\cf17 const} preserve_comments&);\par
222     {\cf17 friend} {\cf18 bool} operator!=({\cf17 const} preserve_comments&, {\cf17 const} preserve_comments&);\par
223     {\cf17 friend} {\cf18 bool} operator< ({\cf17 const} preserve_comments&, {\cf17 const} preserve_comments&);\par
224     {\cf17 friend} {\cf18 bool} operator<=({\cf17 const} preserve_comments&, {\cf17 const} preserve_comments&);\par
225     {\cf17 friend} {\cf18 bool} operator> ({\cf17 const} preserve_comments&, {\cf17 const} preserve_comments&);\par
226     {\cf17 friend} {\cf18 bool} operator>=({\cf17 const} preserve_comments&, {\cf17 const} preserve_comments&);\par
227 \par
228     {\cf17 friend} {\cf18 void} swap(preserve_comments&, std::vector<std::string>&);\par
229     {\cf17 friend} {\cf18 void} swap(std::vector<std::string>&, preserve_comments&);\par
230 \par
231   {\cf17 private}:\par
232 \par
233     container_type comments;\par
234 \};\par
235 \par
236 {\cf17 inline} {\cf18 bool} operator==({\cf17 const} preserve_comments& lhs, {\cf17 const} preserve_comments& rhs) \{{\cf19 return} lhs.comments == rhs.comments;\}\par
237 {\cf17 inline} {\cf18 bool} operator!=({\cf17 const} preserve_comments& lhs, {\cf17 const} preserve_comments& rhs) \{{\cf19 return} lhs.comments != rhs.comments;\}\par
238 {\cf17 inline} {\cf18 bool} operator< ({\cf17 const} preserve_comments& lhs, {\cf17 const} preserve_comments& rhs) \{{\cf19 return} lhs.comments <  rhs.comments;\}\par
239 {\cf17 inline} {\cf18 bool} operator<=({\cf17 const} preserve_comments& lhs, {\cf17 const} preserve_comments& rhs) \{{\cf19 return} lhs.comments <= rhs.comments;\}\par
240 {\cf17 inline} {\cf18 bool} operator> ({\cf17 const} preserve_comments& lhs, {\cf17 const} preserve_comments& rhs) \{{\cf19 return} lhs.comments >  rhs.comments;\}\par
241 {\cf17 inline} {\cf18 bool} operator>=({\cf17 const} preserve_comments& lhs, {\cf17 const} preserve_comments& rhs) \{{\cf19 return} lhs.comments >= rhs.comments;\}\par
242 \par
243 {\cf17 inline} {\cf18 void} swap(preserve_comments& lhs, preserve_comments& rhs)\par
244 \{\par
245     lhs.swap(rhs);\par
246     {\cf19 return};\par
247 \}\par
248 {\cf17 inline} {\cf18 void} swap(preserve_comments& lhs, std::vector<std::string>& rhs)\par
249 \{\par
250     lhs.comments.swap(rhs);\par
251     {\cf19 return};\par
252 \}\par
253 {\cf17 inline} {\cf18 void} swap(std::vector<std::string>& lhs, preserve_comments& rhs)\par
254 \{\par
255     lhs.swap(rhs.comments);\par
256     {\cf19 return};\par
257 \}\par
258 \par
259 {\cf17 template}<{\cf17 typename} {\cf18 char}T, {\cf17 typename} traits>\par
260 std::basic_ostream<charT, traits>&\par
261 operator<<(std::basic_ostream<charT, traits>& os, {\cf17 const} preserve_comments& com)\par
262 \{\par
263     {\cf19 for}({\cf17 const} {\cf17 auto}& c : com)\par
264     \{\par
265         os << {\cf23 '#'} << c << {\cf23 '\\n'};\par
266     \}\par
267     {\cf19 return} os;\par
268 \}\par
269 \par
270 {\cf17 namespace }detail\par
271 \{\par
272 \par
273 {\cf20 // To provide the same interface with `preserve_comments`, `discard_comments`}\par
274 {\cf20 // should have an iterator. But it does not contain anything, so we need to}\par
275 {\cf20 // add an iterator that points nothing.}\par
276 {\cf20 //}\par
277 {\cf20 // It always points null, so DO NOT unwrap this iterator. It always crashes}\par
278 {\cf20 // your program.}\par
279 {\cf17 template}<{\cf17 typename} T, {\cf18 bool} is_const>\par
280 {\cf17 struct }empty_iterator\par
281 \{\par
282     {\cf17 using }value_type        = T;\par
283     {\cf17 using }reference_type    = {\cf17 typename} std::conditional<is_const, T const&, T&>::type;\par
284     {\cf17 using }pointer_type      = {\cf17 typename} std::conditional<is_const, T const*, T*>::type;\par
285     {\cf17 using }difference_type   = std::ptrdiff_t;\par
286     {\cf17 using }iterator_category = std::random_access_iterator_tag;\par
287 \par
288     empty_iterator()  = {\cf19 default};\par
289     ~empty_iterator() = {\cf19 default};\par
290     empty_iterator(empty_iterator {\cf17 const}&) = {\cf19 default};\par
291     empty_iterator(empty_iterator &&)     = {\cf19 default};\par
292     empty_iterator& operator=(empty_iterator {\cf17 const}&) = {\cf19 default};\par
293     empty_iterator& operator=(empty_iterator &&)     = {\cf19 default};\par
294 \par
295     {\cf20 // DO NOT call these operators.}\par
296     reference_type operator*()  const noexcept \{std::terminate();\}\par
297     pointer_type   operator->() const noexcept \{{\cf19 return} {\cf17 nullptr};\}\par
298     reference_type operator[](difference_type) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} this->operator*();\}\par
299 \par
300     {\cf20 // These operators do nothing.}\par
301     empty_iterator& operator++()    noexcept \{{\cf19 return} *{\cf17 this};\}\par
302     empty_iterator  operator++({\cf18 int}) {\cf17 noexcept} \{{\cf19 return} *{\cf17 this};\}\par
303     empty_iterator& operator--()    noexcept \{{\cf19 return} *{\cf17 this};\}\par
304     empty_iterator  operator--({\cf18 int}) {\cf17 noexcept} \{{\cf19 return} *{\cf17 this};\}\par
305 \par
306     empty_iterator& operator+=(difference_type) {\cf17 noexcept} \{{\cf19 return} *{\cf17 this};\}\par
307     empty_iterator& operator-=(difference_type) {\cf17 noexcept} \{{\cf19 return} *{\cf17 this};\}\par
308 \par
309     empty_iterator  operator+(difference_type) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} *{\cf17 this};\}\par
310     empty_iterator  operator-(difference_type) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} *{\cf17 this};\}\par
311 \};\par
312 \par
313 {\cf17 template}<{\cf17 typename} T, {\cf18 bool} C>\par
314 {\cf18 bool} operator==({\cf17 const} empty_iterator<T, C>&, {\cf17 const} empty_iterator<T, C>&) {\cf17 noexcept} \{{\cf19 return} {\cf17 true};\}\par
315 {\cf17 template}<{\cf17 typename} T, {\cf18 bool} C>\par
316 {\cf18 bool} operator!=({\cf17 const} empty_iterator<T, C>&, {\cf17 const} empty_iterator<T, C>&) {\cf17 noexcept} \{{\cf19 return} {\cf17 false};\}\par
317 {\cf17 template}<{\cf17 typename} T, {\cf18 bool} C>\par
318 {\cf18 bool} operator< ({\cf17 const} empty_iterator<T, C>&, {\cf17 const} empty_iterator<T, C>&) {\cf17 noexcept} \{{\cf19 return} {\cf17 false};\}\par
319 {\cf17 template}<{\cf17 typename} T, {\cf18 bool} C>\par
320 {\cf18 bool} operator<=({\cf17 const} empty_iterator<T, C>&, {\cf17 const} empty_iterator<T, C>&) {\cf17 noexcept} \{{\cf19 return} {\cf17 true};\}\par
321 {\cf17 template}<{\cf17 typename} T, {\cf18 bool} C>\par
322 {\cf18 bool} operator> ({\cf17 const} empty_iterator<T, C>&, {\cf17 const} empty_iterator<T, C>&) {\cf17 noexcept} \{{\cf19 return} {\cf17 false};\}\par
323 {\cf17 template}<{\cf17 typename} T, {\cf18 bool} C>\par
324 {\cf18 bool} operator>=({\cf17 const} empty_iterator<T, C>&, {\cf17 const} empty_iterator<T, C>&) {\cf17 noexcept} \{{\cf19 return} {\cf17 true};\}\par
325 \par
326 {\cf17 template}<{\cf17 typename} T, {\cf18 bool} C>\par
327 {\cf17 typename} empty_iterator<T, C>::difference_type\par
328 operator-({\cf17 const} empty_iterator<T, C>&, {\cf17 const} empty_iterator<T, C>&) {\cf17 noexcept} \{{\cf19 return} 0;\}\par
329 \par
330 {\cf17 template}<{\cf17 typename} T, {\cf18 bool} C>\par
331 empty_iterator<T, C>\par
332 operator+({\cf17 typename} empty_iterator<T, C>::difference_type, {\cf17 const} empty_iterator<T, C>& rhs) {\cf17 noexcept} \{{\cf19 return} rhs;\}\par
333 {\cf17 template}<{\cf17 typename} T, {\cf18 bool} C>\par
334 empty_iterator<T, C>\par
335 operator+({\cf17 const} empty_iterator<T, C>& lhs, {\cf17 typename} empty_iterator<T, C>::difference_type) {\cf17 noexcept} \{{\cf19 return} lhs;\}\par
336 \par
337 \} {\cf20 // detail}\par
338 \par
339 {\cf20 // The default comment type. It discards all the comments. It requires only one}\par
340 {\cf20 // byte to contain, so the memory footprint is smaller than preserve_comments.}\par
341 {\cf20 //}\par
342 {\cf20 // It just ignores `push_back`, `insert`, `erase`, and any other modifications.}\par
343 {\cf20 // IT always returns size() == 0, the iterator taken by `begin()` is always the}\par
344 {\cf20 // same as that of `end()`, and accessing through `operator[]` or iterators}\par
345 {\cf20 // always causes a segmentation fault. DO NOT access to the element of this.}\par
346 {\cf20 //}\par
347 {\cf20 // Why this is chose as the default type is because the last version (2.x.y)}\par
348 {\cf20 // does not contain any comments in a value. To minimize the impact on the}\par
349 {\cf20 // efficiency, this is chosen as a default.}\par
350 {\cf20 //}\par
351 {\cf20 // To reduce the memory footprint, later we can try empty base optimization (EBO).}\par
352 {\cf17 struct }discard_comments\par
353 \{\par
354     {\cf17 using }size_type              = std::size_t;\par
355     {\cf17 using }difference_type        = std::ptrdiff_t;\par
356     {\cf17 using }value_type             = std::string;\par
357     {\cf17 using }reference              = std::string&;\par
358     {\cf17 using }const_reference        = std::string {\cf17 const}&;\par
359     {\cf17 using }pointer                = std::string*;\par
360     {\cf17 using }const_pointer          = std::string {\cf17 const}*;\par
361     {\cf17 using }iterator               = detail::empty_iterator<std::string, false>;\par
362     {\cf17 using }const_iterator         = detail::empty_iterator<std::string, true>;\par
363     {\cf17 using }reverse_iterator       = detail::empty_iterator<std::string, false>;\par
364     {\cf17 using }const_reverse_iterator = detail::empty_iterator<std::string, true>;\par
365 \par
366     discard_comments() = {\cf19 default};\par
367     ~discard_comments() = {\cf19 default};\par
368     discard_comments(discard_comments {\cf17 const}&) = {\cf19 default};\par
369     discard_comments(discard_comments &&)     = {\cf19 default};\par
370     discard_comments& operator=(discard_comments {\cf17 const}&) = {\cf19 default};\par
371     discard_comments& operator=(discard_comments &&)     = {\cf19 default};\par
372 \par
373     {\cf17 explicit} discard_comments({\cf17 const} std::vector<std::string>&) {\cf17 noexcept} \{\}\par
374     {\cf17 explicit} discard_comments(std::vector<std::string>&&)      noexcept \{\}\par
375     discard_comments& operator=({\cf17 const} std::vector<std::string>&) {\cf17 noexcept} \{{\cf19 return} *{\cf17 this};\}\par
376     discard_comments& operator=(std::vector<std::string>&&)      noexcept \{{\cf19 return} *{\cf17 this};\}\par
377 \par
378     {\cf17 explicit} discard_comments({\cf17 const} preserve_comments&)        {\cf17 noexcept} \{\}\par
379 \par
380     {\cf17 explicit} discard_comments(size_type) {\cf17 noexcept} \{\}\par
381     discard_comments(size_type, {\cf17 const} std::string&) {\cf17 noexcept} \{\}\par
382     discard_comments(std::initializer_list<std::string>) {\cf17 noexcept} \{\}\par
383     {\cf17 template}<{\cf17 typename} InputIterator>\par
384     discard_comments(InputIterator, InputIterator) {\cf17 noexcept} \{\}\par
385 \par
386     {\cf17 template}<{\cf17 typename} InputIterator>\par
387     {\cf18 void} assign(InputIterator, InputIterator)       {\cf17 noexcept} \{\}\par
388     {\cf18 void} assign(std::initializer_list<std::string>) {\cf17 noexcept} \{\}\par
389     {\cf18 void} assign(size_type, {\cf17 const} std::string&)      {\cf17 noexcept} \{\}\par
390 \par
391     iterator insert(const_iterator, {\cf17 const} std::string&)                 \{{\cf19 return} iterator\{\};\}\par
392     iterator insert(const_iterator, std::string&&)                      \{{\cf19 return} iterator\{\};\}\par
393     iterator insert(const_iterator, size_type, {\cf17 const} std::string&)      \{{\cf19 return} iterator\{\};\}\par
394     {\cf17 template}<{\cf17 typename} InputIterator>\par
395     iterator insert(const_iterator, InputIterator, InputIterator)       \{{\cf19 return} iterator\{\};\}\par
396     iterator insert(const_iterator, std::initializer_list<std::string>) \{{\cf19 return} iterator\{\};\}\par
397 \par
398     {\cf17 template}<{\cf17 typename} ... Ts>\par
399     iterator emplace(const_iterator, Ts&& ...)     \{{\cf19 return} iterator\{\};\}\par
400     iterator erase(const_iterator)                 \{{\cf19 return} iterator\{\};\}\par
401     iterator erase(const_iterator, const_iterator) \{{\cf19 return} iterator\{\};\}\par
402 \par
403     {\cf18 void} swap(discard_comments&) \{{\cf19 return};\}\par
404 \par
405     {\cf18 void} push_back({\cf17 const} std::string&) \{{\cf19 return};\}\par
406     {\cf18 void} push_back(std::string&&     ) \{{\cf19 return};\}\par
407     {\cf18 void} pop_back()                    \{{\cf19 return};\}\par
408 \par
409     {\cf17 template}<{\cf17 typename} ... Ts>\par
410     {\cf18 void} emplace_back(Ts&& ...) \{{\cf19 return};\}\par
411 \par
412     {\cf18 void} clear() \{{\cf19 return};\}\par
413 \par
414     size_type size()     const noexcept \{{\cf19 return} 0;\}\par
415     size_type max_size() const noexcept \{{\cf19 return} 0;\}\par
416     size_type capacity() const noexcept \{{\cf19 return} 0;\}\par
417     {\cf18 bool}      empty()    const noexcept \{{\cf19 return} {\cf17 true};\}\par
418 \par
419     {\cf18 void} reserve(size_type)                    \{{\cf19 return};\}\par
420     {\cf18 void} resize(size_type)                     \{{\cf19 return};\}\par
421     {\cf18 void} resize(size_type, {\cf17 const} std::string&) \{{\cf19 return};\}\par
422     {\cf18 void} shrink_to_fit()                       \{{\cf19 return};\}\par
423 \par
424     {\cf20 // DO NOT access to the element of this container. This container is always}\par
425     {\cf20 // empty, so accessing through operator[], front/back, data causes address}\par
426     {\cf20 // error.}\par
427 \par
428     reference       operator[]({\cf17 const} size_type)       {\cf17 noexcept} \{{\cf19 return} *data();\}\par
429     const_reference operator[]({\cf17 const} size_type) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} *data();\}\par
430     reference       at({\cf17 const} size_type)       \{{\cf19 throw} std::out_of_range({\cf22 "toml::discard_comment is always empty."});\}\par
431     const_reference at({\cf17 const} size_type){\cf17  const }\{{\cf19 throw} std::out_of_range({\cf22 "toml::discard_comment is always empty."});\}\par
432     reference       front()       noexcept \{{\cf19 return} *data();\}\par
433     const_reference front() const noexcept \{{\cf19 return} *data();\}\par
434     reference       back()        noexcept \{{\cf19 return} *data();\}\par
435     const_reference back()  const noexcept \{{\cf19 return} *data();\}\par
436 \par
437     pointer         data()        noexcept \{{\cf19 return} {\cf17 nullptr};\}\par
438     const_pointer   data()  const noexcept \{{\cf19 return} {\cf17 nullptr};\}\par
439 \par
440     iterator       begin()        noexcept \{{\cf19 return} iterator\{\};\}\par
441     iterator       end()          noexcept \{{\cf19 return} iterator\{\};\}\par
442     const_iterator begin()  const noexcept \{{\cf19 return} const_iterator\{\};\}\par
443     const_iterator end()    const noexcept \{{\cf19 return} const_iterator\{\};\}\par
444     const_iterator cbegin() const noexcept \{{\cf19 return} const_iterator\{\};\}\par
445     const_iterator cend()   const noexcept \{{\cf19 return} const_iterator\{\};\}\par
446 \par
447     reverse_iterator       rbegin()        noexcept \{{\cf19 return} iterator\{\};\}\par
448     reverse_iterator       rend()          noexcept \{{\cf19 return} iterator\{\};\}\par
449     const_reverse_iterator rbegin()  const noexcept \{{\cf19 return} const_iterator\{\};\}\par
450     const_reverse_iterator rend()    const noexcept \{{\cf19 return} const_iterator\{\};\}\par
451     const_reverse_iterator crbegin() const noexcept \{{\cf19 return} const_iterator\{\};\}\par
452     const_reverse_iterator crend()   const noexcept \{{\cf19 return} const_iterator\{\};\}\par
453 \};\par
454 \par
455 {\cf17 inline} {\cf18 bool} operator==({\cf17 const} discard_comments&, {\cf17 const} discard_comments&) {\cf17 noexcept} \{{\cf19 return} {\cf17 true};\}\par
456 {\cf17 inline} {\cf18 bool} operator!=({\cf17 const} discard_comments&, {\cf17 const} discard_comments&) {\cf17 noexcept} \{{\cf19 return} {\cf17 false};\}\par
457 {\cf17 inline} {\cf18 bool} operator< ({\cf17 const} discard_comments&, {\cf17 const} discard_comments&) {\cf17 noexcept} \{{\cf19 return} {\cf17 false};\}\par
458 {\cf17 inline} {\cf18 bool} operator<=({\cf17 const} discard_comments&, {\cf17 const} discard_comments&) {\cf17 noexcept} \{{\cf19 return} {\cf17 true};\}\par
459 {\cf17 inline} {\cf18 bool} operator> ({\cf17 const} discard_comments&, {\cf17 const} discard_comments&) {\cf17 noexcept} \{{\cf19 return} {\cf17 false};\}\par
460 {\cf17 inline} {\cf18 bool} operator>=({\cf17 const} discard_comments&, {\cf17 const} discard_comments&) {\cf17 noexcept} \{{\cf19 return} {\cf17 true};\}\par
461 \par
462 {\cf17 inline} {\cf18 void} swap({\cf17 const} discard_comments&, {\cf17 const} discard_comments&) {\cf17 noexcept} \{{\cf19 return};\}\par
463 \par
464 {\cf17 template}<{\cf17 typename} {\cf18 char}T, {\cf17 typename} traits>\par
465 std::basic_ostream<charT, traits>&\par
466 operator<<(std::basic_ostream<charT, traits>& os, {\cf17 const} discard_comments&)\par
467 \{\par
468     {\cf19 return} os;\par
469 \}\par
470 \par
471 \} {\cf20 // toml11}\par
472 {\cf21 #endif}{\cf20 // TOML11_COMMENTS_HPP}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/datetime.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/datetime.hpp}
{\xe \v external/toml/datetime.hpp}
{\bkmkstart AAAAAAAABZ}
{\bkmkend AAAAAAAABZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdint>}\par
{\f2 #include <cstdlib>}\par
{\f2 #include <ctime>}\par
{\f2 #include <array>}\par
{\f2 #include <chrono>}\par
{\f2 #include <iomanip>}\par
{\f2 #include <ostream>}\par
{\f2 #include <tuple>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::local_date}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::local_time}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::time_offset}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::local_datetime}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::offset_datetime}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b toml::month_t} : std::uint8_t \{ {\b toml::Jan} = 0
, {\b toml::Feb} = 1
, {\b toml::Mar} = 2
, {\b toml::Apr} = 3
, {\b toml::May} = 4
, {\b toml::Jun} = 5
, {\b toml::Jul} = 6
, {\b toml::Aug} = 7
, {\b toml::Sep} = 8
, {\b toml::Oct} = 9
, {\b toml::Nov} = 10
, {\b toml::Dec} = 11
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::tm {\b toml::detail::localtime_s} (const std::time_t *src)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::tm {\b toml::detail::gmtime_s} (const std::time_t *src)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator==} (const local_date &lhs, const local_date &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator!=} (const local_date &lhs, const local_date &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<} (const local_date &lhs, const local_date &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<=} (const local_date &lhs, const local_date &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>} (const local_date &lhs, const local_date &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>=} (const local_date &lhs, const local_date &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b toml::operator<<} (std::basic_ostream< charT, traits > &os, const local_date &date)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator==} (const local_time &lhs, const local_time &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator!=} (const local_time &lhs, const local_time &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<} (const local_time &lhs, const local_time &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<=} (const local_time &lhs, const local_time &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>} (const local_time &lhs, const local_time &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>=} (const local_time &lhs, const local_time &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b toml::operator<<} (std::basic_ostream< charT, traits > &os, const local_time &time)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator==} (const time_offset &lhs, const time_offset &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator!=} (const time_offset &lhs, const time_offset &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<} (const time_offset &lhs, const time_offset &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<=} (const time_offset &lhs, const time_offset &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>} (const time_offset &lhs, const time_offset &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>=} (const time_offset &lhs, const time_offset &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b toml::operator<<} (std::basic_ostream< charT, traits > &os, const time_offset &offset)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator==} (const local_datetime &lhs, const local_datetime &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator!=} (const local_datetime &lhs, const local_datetime &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<} (const local_datetime &lhs, const local_datetime &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<=} (const local_datetime &lhs, const local_datetime &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>} (const local_datetime &lhs, const local_datetime &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>=} (const local_datetime &lhs, const local_datetime &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b toml::operator<<} (std::basic_ostream< charT, traits > &os, const local_datetime &dt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator==} (const offset_datetime &lhs, const offset_datetime &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator!=} (const offset_datetime &lhs, const offset_datetime &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<} (const offset_datetime &lhs, const offset_datetime &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<=} (const offset_datetime &lhs, const offset_datetime &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>} (const offset_datetime &lhs, const offset_datetime &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>=} (const offset_datetime &lhs, const offset_datetime &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b toml::operator<<} (std::basic_ostream< charT, traits > &os, const offset_datetime &dt)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
datetime.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/datetime.hpp}
{\xe \v external/toml/datetime.hpp}
{\bkmkstart AAAAAAAAAI}
{\bkmkend AAAAAAAAAI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2017.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_DATETIME_HPP}\par
4 {\cf21 #define TOML11_DATETIME_HPP}\par
5 {\cf21 #include <cstdint>}\par
6 {\cf21 #include <cstdlib>}\par
7 {\cf21 #include <ctime>}\par
8 \par
9 {\cf21 #include <array>}\par
10 {\cf21 #include <chrono>}\par
11 {\cf21 #include <iomanip>}\par
12 {\cf21 #include <ostream>}\par
13 {\cf21 #include <tuple>}\par
14 \par
15 {\cf17 namespace }toml\par
16 \{\par
17 \par
18 {\cf20 // To avoid non-threadsafe std::localtime. In C11 (not C++11!), localtime_s is}\par
19 {\cf20 // provided in the absolutely same purpose, but C++11 is actually not compatible}\par
20 {\cf20 // with C11. We need to dispatch the function depending on the OS.}\par
21 {\cf17 namespace }detail\par
22 \{\par
23 {\cf20 // TODO: find more sophisticated way to handle this}\par
24 {\cf21 #if defined(_MSC_VER)}\par
25 {\cf17 inline} std::tm localtime_s({\cf17 const} std::time_t* src)\par
26 \{\par
27     std::tm dst;\par
28     {\cf17 const} {\cf17 auto} result = ::localtime_s(&dst, src);\par
29     {\cf19 if} (result) \{ {\cf19 throw} std::runtime_error({\cf22 "localtime_s failed."}); \}\par
30     {\cf19 return} dst;\par
31 \}\par
32 {\cf17 inline} std::tm gmtime_s({\cf17 const} std::time_t* src)\par
33 \{\par
34     std::tm dst;\par
35     {\cf17 const} {\cf17 auto} result = ::gmtime_s(&dst, src);\par
36     {\cf19 if} (result) \{ {\cf19 throw} std::runtime_error({\cf22 "gmtime_s failed."}); \}\par
37     {\cf19 return} dst;\par
38 \}\par
39 {\cf21 #elif (defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 1) || defined(_XOPEN_SOURCE) || defined(_BSD_SOURCE) || defined(_SVID_SOURCE) || defined(_POSIX_SOURCE)}\par
40 {\cf17 inline} std::tm localtime_s({\cf17 const} std::time_t* src)\par
41 \{\par
42     std::tm dst;\par
43     {\cf17 const} {\cf17 auto} result = ::localtime_r(src, &dst);\par
44     {\cf19 if} (!result) \{ {\cf19 throw} std::runtime_error({\cf22 "localtime_r failed."}); \}\par
45     {\cf19 return} dst;\par
46 \}\par
47 {\cf17 inline} std::tm gmtime_s({\cf17 const} std::time_t* src)\par
48 \{\par
49     std::tm dst;\par
50     {\cf17 const} {\cf17 auto} result = ::gmtime_r(src, &dst);\par
51     {\cf19 if} (!result) \{ {\cf19 throw} std::runtime_error({\cf22 "gmtime_r failed."}); \}\par
52     {\cf19 return} dst;\par
53 \}\par
54 {\cf21 #else }{\cf20 // fallback. not threadsafe}\par
55 {\cf17 inline} std::tm localtime_s({\cf17 const} std::time_t* src)\par
56 \{\par
57     {\cf17 const} {\cf17 auto} result = std::localtime(src);\par
58     {\cf19 if} (!result) \{ {\cf19 throw} std::runtime_error({\cf22 "localtime failed."}); \}\par
59     {\cf19 return} *result;\par
60 \}\par
61 {\cf17 inline} std::tm gmtime_s({\cf17 const} std::time_t* src)\par
62 \{\par
63     {\cf17 const} {\cf17 auto} result = std::gmtime(src);\par
64     {\cf19 if} (!result) \{ {\cf19 throw} std::runtime_error({\cf22 "gmtime failed."}); \}\par
65     {\cf19 return} *result;\par
66 \}\par
67 {\cf21 #endif}\par
68 \} {\cf20 // detail}\par
69 \par
70 {\cf17 enum class} month_t : std::uint8_t\par
71 \{\par
72     Jan =  0,\par
73     Feb =  1,\par
74     Mar =  2,\par
75     Apr =  3,\par
76     May =  4,\par
77     Jun =  5,\par
78     Jul =  6,\par
79     Aug =  7,\par
80     Sep =  8,\par
81     Oct =  9,\par
82     Nov = 10,\par
83     Dec = 11\par
84 \};\par
85 \par
86 {\cf17 struct }local_date\par
87 \{\par
88     std::int16_t year;   {\cf20 // A.D. (like, 2018)}\par
89     std::uint8_t month;  {\cf20 // [0, 11]}\par
90     std::uint8_t day;    {\cf20 // [1, 31]}\par
91 \par
92     local_date({\cf18 int} y, month_t m, {\cf18 int} d)\par
93         : year (static_cast<std::int16_t>(y)),\par
94           month(static_cast<std::uint8_t>(m)),\par
95           day  (static_cast<std::uint8_t>(d))\par
96     \{\}\par
97 \par
98     {\cf17 explicit} local_date({\cf17 const} std::tm& t)\par
99         : year (static_cast<std::int16_t>(t.tm_year + 1900)),\par
100           month(static_cast<std::uint8_t>(t.tm_mon)),\par
101           day  (static_cast<std::uint8_t>(t.tm_mday))\par
102     \{\}\par
103 \par
104     {\cf17 explicit} local_date({\cf17 const} std::chrono::system_clock::time_point& tp)\par
105     \{\par
106         {\cf17 const} {\cf17 auto} t    = std::chrono::system_clock::to_time_t(tp);\par
107         {\cf17 const} {\cf17 auto} time = detail::localtime_s(&t);\par
108         *{\cf17 this} = local_date(time);\par
109     \}\par
110 \par
111     {\cf17 explicit} local_date({\cf17 const} std::time_t t)\par
112         : local_date(std::chrono::system_clock::from_time_t(t))\par
113     \{\}\par
114 \par
115     {\cf17 operator} std::chrono::system_clock::time_point(){\cf17  const}\par
116 {\cf17     }\{\par
117         {\cf20 // std::mktime returns date as local time zone. no conversion needed}\par
118         std::tm t;\par
119         t.tm_sec   = 0;\par
120         t.tm_min   = 0;\par
121         t.tm_hour  = 0;\par
122         t.tm_mday  = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(this->day);\par
123         t.tm_mon   = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(this->month);\par
124         t.tm_year  = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(this->year) - 1900;\par
125         t.tm_wday  = 0; {\cf20 // the value will be ignored}\par
126         t.tm_yday  = 0; {\cf20 // the value will be ignored}\par
127         t.tm_isdst = -1;\par
128         {\cf19 return} std::chrono::system_clock::from_time_t(std::mktime(&t));\par
129     \}\par
130 \par
131     {\cf17 operator} std::time_t(){\cf17  const}\par
132 {\cf17     }\{\par
133         {\cf19 return} std::chrono::system_clock::to_time_t(\par
134                 std::chrono::system_clock::time_point(*{\cf17 this}));\par
135     \}\par
136 \par
137     local_date() = {\cf19 default};\par
138     ~local_date() = {\cf19 default};\par
139     local_date(local_date {\cf17 const}&) = {\cf19 default};\par
140     local_date(local_date&&)      = {\cf19 default};\par
141     local_date& operator=(local_date {\cf17 const}&) = {\cf19 default};\par
142     local_date& operator=(local_date&&)      = {\cf19 default};\par
143 \};\par
144 \par
145 {\cf17 inline} {\cf18 bool} operator==({\cf17 const} local_date& lhs, {\cf17 const} local_date& rhs)\par
146 \{\par
147     {\cf19 return} std::make_tuple(lhs.year, lhs.month, lhs.day) ==\par
148            std::make_tuple(rhs.year, rhs.month, rhs.day);\par
149 \}\par
150 {\cf17 inline} {\cf18 bool} operator!=({\cf17 const} local_date& lhs, {\cf17 const} local_date& rhs)\par
151 \{\par
152     {\cf19 return} !(lhs == rhs);\par
153 \}\par
154 {\cf17 inline} {\cf18 bool} operator< ({\cf17 const} local_date& lhs, {\cf17 const} local_date& rhs)\par
155 \{\par
156     {\cf19 return} std::make_tuple(lhs.year, lhs.month, lhs.day) <\par
157            std::make_tuple(rhs.year, rhs.month, rhs.day);\par
158 \}\par
159 {\cf17 inline} {\cf18 bool} operator<=({\cf17 const} local_date& lhs, {\cf17 const} local_date& rhs)\par
160 \{\par
161     {\cf19 return} (lhs < rhs) || (lhs == rhs);\par
162 \}\par
163 {\cf17 inline} {\cf18 bool} operator> ({\cf17 const} local_date& lhs, {\cf17 const} local_date& rhs)\par
164 \{\par
165     {\cf19 return} !(lhs <= rhs);\par
166 \}\par
167 {\cf17 inline} {\cf18 bool} operator>=({\cf17 const} local_date& lhs, {\cf17 const} local_date& rhs)\par
168 \{\par
169     {\cf19 return} !(lhs < rhs);\par
170 \}\par
171 \par
172 {\cf17 template}<{\cf17 typename} {\cf18 char}T, {\cf17 typename} traits>\par
173 std::basic_ostream<charT, traits>&\par
174 operator<<(std::basic_ostream<charT, traits>& os, {\cf17 const} local_date& date)\par
175 \{\par
176     os << std::setfill('0') << std::setw(4) << static_cast<int>(date.year )     << {\cf23 '-'};\par
177     os << std::setfill('0') << std::setw(2) << static_cast<int>(date.month) + 1 << {\cf23 '-'};\par
178     os << std::setfill('0') << std::setw(2) << static_cast<int>(date.day  )    ;\par
179     {\cf19 return} os;\par
180 \}\par
181 \par
182 {\cf17 struct }local_time\par
183 \{\par
184     std::uint8_t  hour;        {\cf20 // [0, 23]}\par
185     std::uint8_t  minute;      {\cf20 // [0, 59]}\par
186     std::uint8_t  second;      {\cf20 // [0, 60]}\par
187     std::uint16_t millisecond; {\cf20 // [0, 999]}\par
188     std::uint16_t microsecond; {\cf20 // [0, 999]}\par
189     std::uint16_t nanosecond;  {\cf20 // [0, 999]}\par
190 \par
191     local_time({\cf18 int} h, {\cf18 int} m, {\cf18 int} s,\par
192                {\cf18 int} ms = 0, {\cf18 int} us = 0, {\cf18 int} ns = 0)\par
193         : hour  (static_cast<std::uint8_t>(h)),\par
194           minute(static_cast<std::uint8_t>(m)),\par
195           second(static_cast<std::uint8_t>(s)),\par
196           millisecond(static_cast<std::uint16_t>(ms)),\par
197           microsecond(static_cast<std::uint16_t>(us)),\par
198           nanosecond (static_cast<std::uint16_t>(ns))\par
199     \{\}\par
200 \par
201     {\cf17 explicit} local_time({\cf17 const} std::tm& t)\par
202         : hour  (static_cast<std::uint8_t>(t.tm_hour)),\par
203           minute(static_cast<std::uint8_t>(t.tm_min)),\par
204           second(static_cast<std::uint8_t>(t.tm_sec)),\par
205           millisecond(0), microsecond(0), nanosecond(0)\par
206     \{\}\par
207 \par
208     {\cf17 template}<{\cf17 typename} Rep, {\cf17 typename} Period>\par
209     {\cf17 explicit} local_time({\cf17 const} std::chrono::duration<Rep, Period>& t)\par
210     \{\par
211         {\cf17 const} {\cf17 auto} h = std::chrono::duration_cast<std::chrono::hours>(t);\par
212         this->hour = {\cf17 static_cast<}std::uint8_t{\cf17 >}(h.count());\par
213         {\cf17 const} {\cf17 auto} t2 = t - h;\par
214         {\cf17 const} {\cf17 auto} m = std::chrono::duration_cast<std::chrono::minutes>(t2);\par
215         this->minute = {\cf17 static_cast<}std::uint8_t{\cf17 >}(m.count());\par
216         {\cf17 const} {\cf17 auto} t3 = t2 - m;\par
217         {\cf17 const} {\cf17 auto} s = std::chrono::duration_cast<std::chrono::seconds>(t3);\par
218         this->second = {\cf17 static_cast<}std::uint8_t{\cf17 >}(s.count());\par
219         {\cf17 const} {\cf17 auto} t4 = t3 - s;\par
220         {\cf17 const} {\cf17 auto} ms = std::chrono::duration_cast<std::chrono::milliseconds>(t4);\par
221         this->millisecond = {\cf17 static_cast<}std::uint16_t{\cf17 >}(ms.count());\par
222         {\cf17 const} {\cf17 auto} t5 = t4 - ms;\par
223         {\cf17 const} {\cf17 auto} us = std::chrono::duration_cast<std::chrono::microseconds>(t5);\par
224         this->microsecond = {\cf17 static_cast<}std::uint16_t{\cf17 >}(us.count());\par
225         {\cf17 const} {\cf17 auto} t6 = t5 - us;\par
226         {\cf17 const} {\cf17 auto} ns = std::chrono::duration_cast<std::chrono::nanoseconds>(t6);\par
227         this->nanosecond = {\cf17 static_cast<}std::uint16_t{\cf17 >}(ns.count());\par
228     \}\par
229 \par
230     {\cf17 operator} std::chrono::nanoseconds(){\cf17  const}\par
231 {\cf17     }\{\par
232         {\cf19 return} std::chrono::nanoseconds (this->nanosecond)  +\par
233                std::chrono::microseconds(this->microsecond) +\par
234                std::chrono::milliseconds(this->millisecond) +\par
235                std::chrono::seconds(this->second) +\par
236                std::chrono::minutes(this->minute) +\par
237                std::chrono::hours(this->hour);\par
238     \}\par
239 \par
240     local_time() = {\cf19 default};\par
241     ~local_time() = {\cf19 default};\par
242     local_time(local_time {\cf17 const}&) = {\cf19 default};\par
243     local_time(local_time&&)      = {\cf19 default};\par
244     local_time& operator=(local_time {\cf17 const}&) = {\cf19 default};\par
245     local_time& operator=(local_time&&)      = {\cf19 default};\par
246 \};\par
247 \par
248 {\cf17 inline} {\cf18 bool} operator==({\cf17 const} local_time& lhs, {\cf17 const} local_time& rhs)\par
249 \{\par
250     {\cf19 return} std::make_tuple(lhs.hour, lhs.minute, lhs.second, lhs.millisecond, lhs.microsecond, lhs.nanosecond) ==\par
251            std::make_tuple(rhs.hour, rhs.minute, rhs.second, rhs.millisecond, rhs.microsecond, rhs.nanosecond);\par
252 \}\par
253 {\cf17 inline} {\cf18 bool} operator!=({\cf17 const} local_time& lhs, {\cf17 const} local_time& rhs)\par
254 \{\par
255     {\cf19 return} !(lhs == rhs);\par
256 \}\par
257 {\cf17 inline} {\cf18 bool} operator< ({\cf17 const} local_time& lhs, {\cf17 const} local_time& rhs)\par
258 \{\par
259     {\cf19 return} std::make_tuple(lhs.hour, lhs.minute, lhs.second, lhs.millisecond, lhs.microsecond, lhs.nanosecond) <\par
260            std::make_tuple(rhs.hour, rhs.minute, rhs.second, rhs.millisecond, rhs.microsecond, rhs.nanosecond);\par
261 \}\par
262 {\cf17 inline} {\cf18 bool} operator<=({\cf17 const} local_time& lhs, {\cf17 const} local_time& rhs)\par
263 \{\par
264     {\cf19 return} (lhs < rhs) || (lhs == rhs);\par
265 \}\par
266 {\cf17 inline} {\cf18 bool} operator> ({\cf17 const} local_time& lhs, {\cf17 const} local_time& rhs)\par
267 \{\par
268     {\cf19 return} !(lhs <= rhs);\par
269 \}\par
270 {\cf17 inline} {\cf18 bool} operator>=({\cf17 const} local_time& lhs, {\cf17 const} local_time& rhs)\par
271 \{\par
272     {\cf19 return} !(lhs < rhs);\par
273 \}\par
274 \par
275 {\cf17 template}<{\cf17 typename} {\cf18 char}T, {\cf17 typename} traits>\par
276 std::basic_ostream<charT, traits>&\par
277 operator<<(std::basic_ostream<charT, traits>& os, {\cf17 const} local_time& time)\par
278 \{\par
279     os << std::setfill('0') << std::setw(2) << static_cast<int>(time.hour  ) << {\cf23 ':'};\par
280     os << std::setfill('0') << std::setw(2) << static_cast<int>(time.minute) << {\cf23 ':'};\par
281     os << std::setfill('0') << std::setw(2) << static_cast<int>(time.second);\par
282     {\cf19 if}(time.millisecond != 0 || time.microsecond != 0 || time.nanosecond != 0)\par
283     \{\par
284         os << {\cf23 '.'};\par
285         os << std::setfill('0') << std::setw(3) << static_cast<int>(time.millisecond);\par
286         {\cf19 if}(time.microsecond != 0 || time.nanosecond != 0)\par
287         \{\par
288             os << std::setfill('0') << std::setw(3) << static_cast<int>(time.microsecond);\par
289             {\cf19 if}(time.nanosecond != 0)\par
290             \{\par
291                 os << std::setfill('0') << std::setw(3) << static_cast<int>(time.nanosecond);\par
292             \}\par
293         \}\par
294     \}\par
295     {\cf19 return} os;\par
296 \}\par
297 \par
298 {\cf17 struct }time_offset\par
299 \{\par
300     std::int8_t hour;   {\cf20 // [-12, 12]}\par
301     std::int8_t minute; {\cf20 // [-59, 59]}\par
302 \par
303     time_offset({\cf18 int} h, {\cf18 int} m)\par
304         : hour  (static_cast<std::int8_t>(h)),\par
305           minute(static_cast<std::int8_t>(m))\par
306     \{\}\par
307 \par
308     {\cf17 operator} std::chrono::minutes(){\cf17  const}\par
309 {\cf17     }\{\par
310         {\cf19 return} std::chrono::minutes(this->minute) +\par
311                std::chrono::hours(this->hour);\par
312     \}\par
313 \par
314     time_offset() = {\cf19 default};\par
315     ~time_offset() = {\cf19 default};\par
316     time_offset(time_offset {\cf17 const}&) = {\cf19 default};\par
317     time_offset(time_offset&&)      = {\cf19 default};\par
318     time_offset& operator=(time_offset {\cf17 const}&) = {\cf19 default};\par
319     time_offset& operator=(time_offset&&)      = {\cf19 default};\par
320 \};\par
321 \par
322 {\cf17 inline} {\cf18 bool} operator==({\cf17 const} time_offset& lhs, {\cf17 const} time_offset& rhs)\par
323 \{\par
324     {\cf19 return} std::make_tuple(lhs.hour, lhs.minute) ==\par
325            std::make_tuple(rhs.hour, rhs.minute);\par
326 \}\par
327 {\cf17 inline} {\cf18 bool} operator!=({\cf17 const} time_offset& lhs, {\cf17 const} time_offset& rhs)\par
328 \{\par
329     {\cf19 return} !(lhs == rhs);\par
330 \}\par
331 {\cf17 inline} {\cf18 bool} operator< ({\cf17 const} time_offset& lhs, {\cf17 const} time_offset& rhs)\par
332 \{\par
333     {\cf19 return} std::make_tuple(lhs.hour, lhs.minute) <\par
334            std::make_tuple(rhs.hour, rhs.minute);\par
335 \}\par
336 {\cf17 inline} {\cf18 bool} operator<=({\cf17 const} time_offset& lhs, {\cf17 const} time_offset& rhs)\par
337 \{\par
338     {\cf19 return} (lhs < rhs) || (lhs == rhs);\par
339 \}\par
340 {\cf17 inline} {\cf18 bool} operator> ({\cf17 const} time_offset& lhs, {\cf17 const} time_offset& rhs)\par
341 \{\par
342     {\cf19 return} !(lhs <= rhs);\par
343 \}\par
344 {\cf17 inline} {\cf18 bool} operator>=({\cf17 const} time_offset& lhs, {\cf17 const} time_offset& rhs)\par
345 \{\par
346     {\cf19 return} !(lhs < rhs);\par
347 \}\par
348 \par
349 {\cf17 template}<{\cf17 typename} {\cf18 char}T, {\cf17 typename} traits>\par
350 std::basic_ostream<charT, traits>&\par
351 operator<<(std::basic_ostream<charT, traits>& os, {\cf17 const} time_offset& offset)\par
352 \{\par
353     {\cf19 if}(offset.hour == 0 && offset.minute == 0)\par
354     \{\par
355         os << {\cf23 'Z'};\par
356         {\cf19 return} os;\par
357     \}\par
358     {\cf18 int} minute = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(offset.hour) * 60 + offset.minute;\par
359     {\cf19 if}(minute < 0)\{os << {\cf23 '-'}; minute = std::abs(minute);\} {\cf19 else} \{os << {\cf23 '+'};\}\par
360     os << std::setfill({\cf23 '0'}) << std::setw(2) << minute / 60 << {\cf23 ':'};\par
361     os << std::setfill({\cf23 '0'}) << std::setw(2) << minute % 60;\par
362     {\cf19 return} os;\par
363 \}\par
364 \par
365 {\cf17 struct }local_datetime\par
366 \{\par
367     local_date date;\par
368     local_time time;\par
369 \par
370     local_datetime(local_date d, local_time t): date(d), time(t) \{\}\par
371 \par
372     {\cf17 explicit} local_datetime({\cf17 const} std::tm& t): date(t), time(t)\{\}\par
373 \par
374     {\cf17 explicit} local_datetime({\cf17 const} std::chrono::system_clock::time_point& tp)\par
375     \{\par
376         {\cf17 const} {\cf17 auto} t = std::chrono::system_clock::to_time_t(tp);\par
377         std::tm ltime = detail::localtime_s(&t);\par
378 \par
379         this->date = local_date(ltime);\par
380         this->time = local_time(ltime);\par
381 \par
382         {\cf20 // std::tm lacks subsecond information, so diff between tp and tm}\par
383         {\cf20 // can be used to get millisecond & microsecond information.}\par
384         {\cf17 const} {\cf17 auto} t_diff = tp -\par
385             std::chrono::system_clock::from_time_t(std::mktime(&ltime));\par
386         this->time.millisecond = {\cf17 static_cast<}std::uint16_t{\cf17 >}(\par
387           std::chrono::duration_cast<std::chrono::milliseconds>(t_diff).count());\par
388         this->time.microsecond = {\cf17 static_cast<}std::uint16_t{\cf17 >}(\par
389           std::chrono::duration_cast<std::chrono::microseconds>(t_diff).count());\par
390         this->time.nanosecond = {\cf17 static_cast<}std::uint16_t{\cf17 >}(\par
391           std::chrono::duration_cast<std::chrono::nanoseconds >(t_diff).count());\par
392     \}\par
393 \par
394     {\cf17 explicit} local_datetime({\cf17 const} std::time_t t)\par
395         : local_datetime(std::chrono::system_clock::from_time_t(t))\par
396     \{\}\par
397 \par
398     {\cf17 operator} std::chrono::system_clock::time_point(){\cf17  const}\par
399 {\cf17     }\{\par
400         {\cf17 using }internal_duration =\par
401             {\cf17 typename} std::chrono::system_clock::time_point::duration;\par
402 \par
403         {\cf20 // Normally DST begins at A.M. 3 or 4. If we re-use conversion operator}\par
404         {\cf20 // of local_date and local_time independently, the conversion fails if}\par
405         {\cf20 // it is the day when DST begins or ends. Since local_date considers the}\par
406         {\cf20 // time is 00:00 A.M. and local_time does not consider DST because it}\par
407         {\cf20 // does not have any date information. We need to consider both date and}\par
408         {\cf20 // time information at the same time to convert it correctly.}\par
409 \par
410         std::tm t;\par
411         t.tm_sec   = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(this->time.second);\par
412         t.tm_min   = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(this->time.minute);\par
413         t.tm_hour  = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(this->time.hour);\par
414         t.tm_mday  = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(this->date.day);\par
415         t.tm_mon   = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(this->date.month);\par
416         t.tm_year  = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(this->date.year) - 1900;\par
417         t.tm_wday  = 0; {\cf20 // the value will be ignored}\par
418         t.tm_yday  = 0; {\cf20 // the value will be ignored}\par
419         t.tm_isdst = -1;\par
420 \par
421         {\cf20 // std::mktime returns date as local time zone. no conversion needed}\par
422         {\cf17 auto} dt = std::chrono::system_clock::from_time_t(std::mktime(&t));\par
423         dt += std::chrono::duration_cast<internal_duration>(\par
424                 std::chrono::milliseconds(this->time.millisecond) +\par
425                 std::chrono::microseconds(this->time.microsecond) +\par
426                 std::chrono::nanoseconds (this->time.nanosecond));\par
427         {\cf19 return} dt;\par
428     \}\par
429 \par
430     {\cf17 operator} std::time_t(){\cf17  const}\par
431 {\cf17     }\{\par
432         {\cf19 return} std::chrono::system_clock::to_time_t(\par
433                 std::chrono::system_clock::time_point(*{\cf17 this}));\par
434     \}\par
435 \par
436     local_datetime() = {\cf19 default};\par
437     ~local_datetime() = {\cf19 default};\par
438     local_datetime(local_datetime {\cf17 const}&) = {\cf19 default};\par
439     local_datetime(local_datetime&&)      = {\cf19 default};\par
440     local_datetime& operator=(local_datetime {\cf17 const}&) = {\cf19 default};\par
441     local_datetime& operator=(local_datetime&&)      = {\cf19 default};\par
442 \};\par
443 \par
444 {\cf17 inline} {\cf18 bool} operator==({\cf17 const} local_datetime& lhs, {\cf17 const} local_datetime& rhs)\par
445 \{\par
446     {\cf19 return} std::make_tuple(lhs.date, lhs.time) ==\par
447            std::make_tuple(rhs.date, rhs.time);\par
448 \}\par
449 {\cf17 inline} {\cf18 bool} operator!=({\cf17 const} local_datetime& lhs, {\cf17 const} local_datetime& rhs)\par
450 \{\par
451     {\cf19 return} !(lhs == rhs);\par
452 \}\par
453 {\cf17 inline} {\cf18 bool} operator< ({\cf17 const} local_datetime& lhs, {\cf17 const} local_datetime& rhs)\par
454 \{\par
455     {\cf19 return} std::make_tuple(lhs.date, lhs.time) <\par
456            std::make_tuple(rhs.date, rhs.time);\par
457 \}\par
458 {\cf17 inline} {\cf18 bool} operator<=({\cf17 const} local_datetime& lhs, {\cf17 const} local_datetime& rhs)\par
459 \{\par
460     {\cf19 return} (lhs < rhs) || (lhs == rhs);\par
461 \}\par
462 {\cf17 inline} {\cf18 bool} operator> ({\cf17 const} local_datetime& lhs, {\cf17 const} local_datetime& rhs)\par
463 \{\par
464     {\cf19 return} !(lhs <= rhs);\par
465 \}\par
466 {\cf17 inline} {\cf18 bool} operator>=({\cf17 const} local_datetime& lhs, {\cf17 const} local_datetime& rhs)\par
467 \{\par
468     {\cf19 return} !(lhs < rhs);\par
469 \}\par
470 \par
471 {\cf17 template}<{\cf17 typename} {\cf18 char}T, {\cf17 typename} traits>\par
472 std::basic_ostream<charT, traits>&\par
473 operator<<(std::basic_ostream<charT, traits>& os, {\cf17 const} local_datetime& dt)\par
474 \{\par
475     os << dt.date << {\cf23 'T'} << dt.time;\par
476     {\cf19 return} os;\par
477 \}\par
478 \par
479 {\cf17 struct }offset_datetime\par
480 \{\par
481     local_date  date;\par
482     local_time  time;\par
483     time_offset offset;\par
484 \par
485     offset_datetime(local_date d, local_time t, time_offset o)\par
486         : date(d), time(t), offset(o)\par
487     \{\}\par
488     offset_datetime({\cf17 const} local_datetime& dt, time_offset o)\par
489         : date(dt.date), time(dt.time), offset(o)\par
490     \{\}\par
491     {\cf17 explicit} offset_datetime({\cf17 const} local_datetime& ld)\par
492         : date(ld.date), time(ld.time), offset(get_local_offset(nullptr))\par
493           {\cf20 // use the current local timezone offset}\par
494     \{\}\par
495     {\cf17 explicit} offset_datetime({\cf17 const} std::chrono::system_clock::time_point& tp)\par
496         : offset(0, 0) {\cf20 // use gmtime}\par
497     \{\par
498         {\cf17 const} {\cf17 auto} timet = std::chrono::system_clock::to_time_t(tp);\par
499         {\cf17 const} {\cf17 auto} tm    = detail::gmtime_s(&timet);\par
500         this->date = local_date(tm);\par
501         this->time = local_time(tm);\par
502     \}\par
503     {\cf17 explicit} offset_datetime({\cf17 const} std::time_t& t)\par
504         : offset(0, 0) {\cf20 // use gmtime}\par
505     \{\par
506         {\cf17 const} {\cf17 auto} tm    = detail::gmtime_s(&t);\par
507         this->date = local_date(tm);\par
508         this->time = local_time(tm);\par
509     \}\par
510     {\cf17 explicit} offset_datetime({\cf17 const} std::tm& t)\par
511         : offset(0, 0) {\cf20 // assume gmtime}\par
512     \{\par
513         this->date = local_date(t);\par
514         this->time = local_time(t);\par
515     \}\par
516 \par
517     {\cf17 operator} std::chrono::system_clock::time_point(){\cf17  const}\par
518 {\cf17     }\{\par
519         {\cf20 // get date-time}\par
520         {\cf17 using }internal_duration =\par
521             {\cf17 typename} std::chrono::system_clock::time_point::duration;\par
522 \par
523         {\cf20 // first, convert it to local date-time information in the same way as}\par
524         {\cf20 // local_datetime does. later we will use time_t to adjust time offset.}\par
525         std::tm t;\par
526         t.tm_sec   = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(this->time.second);\par
527         t.tm_min   = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(this->time.minute);\par
528         t.tm_hour  = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(this->time.hour);\par
529         t.tm_mday  = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(this->date.day);\par
530         t.tm_mon   = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(this->date.month);\par
531         t.tm_year  = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(this->date.year) - 1900;\par
532         t.tm_wday  = 0; {\cf20 // the value will be ignored}\par
533         t.tm_yday  = 0; {\cf20 // the value will be ignored}\par
534         t.tm_isdst = -1;\par
535         {\cf17 const} std::time_t tp_loc = std::mktime(std::addressof(t));\par
536 \par
537         {\cf17 auto} tp = std::chrono::system_clock::from_time_t(tp_loc);\par
538         tp += std::chrono::duration_cast<internal_duration>(\par
539                 std::chrono::milliseconds(this->time.millisecond) +\par
540                 std::chrono::microseconds(this->time.microsecond) +\par
541                 std::chrono::nanoseconds (this->time.nanosecond));\par
542 \par
543         {\cf20 // Since mktime uses local time zone, it should be corrected.}\par
544         {\cf20 // `12:00:00+09:00` means `03:00:00Z`. So mktime returns `03:00:00Z` if}\par
545         {\cf20 // we are in `+09:00` timezone. To represent `12:00:00Z` there, we need}\par
546         {\cf20 // to add `+09:00` to `03:00:00Z`.}\par
547         {\cf20 //    Here, it uses the time_t converted from date-time info to handle}\par
548         {\cf20 // daylight saving time.}\par
549         {\cf17 const} {\cf17 auto} ofs = get_local_offset(std::addressof(tp_loc));\par
550         tp += std::chrono::hours  (ofs.hour);\par
551         tp += std::chrono::minutes(ofs.minute);\par
552 \par
553         {\cf20 // We got `12:00:00Z` by correcting local timezone applied by mktime.}\par
554         {\cf20 // Then we will apply the offset. Let's say `12:00:00-08:00` is given.}\par
555         {\cf20 // And now, we have `12:00:00Z`. `12:00:00-08:00` means `20:00:00Z`.}\par
556         {\cf20 // So we need to subtract the offset.}\par
557         tp -= std::chrono::minutes(this->offset);\par
558         {\cf19 return} tp;\par
559     \}\par
560 \par
561     {\cf17 operator} std::time_t(){\cf17  const}\par
562 {\cf17     }\{\par
563         {\cf19 return} std::chrono::system_clock::to_time_t(\par
564                 std::chrono::system_clock::time_point(*{\cf17 this}));\par
565     \}\par
566 \par
567     offset_datetime() = {\cf19 default};\par
568     ~offset_datetime() = {\cf19 default};\par
569     offset_datetime(offset_datetime {\cf17 const}&) = {\cf19 default};\par
570     offset_datetime(offset_datetime&&)      = {\cf19 default};\par
571     offset_datetime& operator=(offset_datetime {\cf17 const}&) = {\cf19 default};\par
572     offset_datetime& operator=(offset_datetime&&)      = {\cf19 default};\par
573 \par
574   {\cf17 private}:\par
575 \par
576     {\cf17 static} time_offset get_local_offset({\cf17 const} std::time_t* tp)\par
577     \{\par
578         {\cf20 // get local timezone with the same date-time information as mktime}\par
579         {\cf17 const} {\cf17 auto} t = detail::localtime_s(tp);\par
580 \par
581         std::array<char, 6> buf;\par
582         {\cf17 const} {\cf17 auto} result = std::strftime(buf.data(), 6, {\cf22 "%z"}, &t); {\cf20 // +hhmm\\0}\par
583         {\cf19 if}(result != 5)\par
584         \{\par
585             {\cf19 throw} std::runtime_error({\cf22 "toml::offset_datetime: cannot obtain "}\par
586                                      {\cf22 "timezone information of current env"});\par
587         \}\par
588         {\cf17 const} {\cf18 int} ofs = std::atoi(buf.data());\par
589         {\cf17 const} {\cf18 int} ofs_h = ofs / 100;\par
590         {\cf17 const} {\cf18 int} ofs_m = ofs - (ofs_h * 100);\par
591         {\cf19 return} time_offset(ofs_h, ofs_m);\par
592     \}\par
593 \};\par
594 \par
595 {\cf17 inline} {\cf18 bool} operator==({\cf17 const} offset_datetime& lhs, {\cf17 const} offset_datetime& rhs)\par
596 \{\par
597     {\cf19 return} std::make_tuple(lhs.date, lhs.time, lhs.offset) ==\par
598            std::make_tuple(rhs.date, rhs.time, rhs.offset);\par
599 \}\par
600 {\cf17 inline} {\cf18 bool} operator!=({\cf17 const} offset_datetime& lhs, {\cf17 const} offset_datetime& rhs)\par
601 \{\par
602     {\cf19 return} !(lhs == rhs);\par
603 \}\par
604 {\cf17 inline} {\cf18 bool} operator< ({\cf17 const} offset_datetime& lhs, {\cf17 const} offset_datetime& rhs)\par
605 \{\par
606     {\cf19 return} std::make_tuple(lhs.date, lhs.time, lhs.offset) <\par
607            std::make_tuple(rhs.date, rhs.time, rhs.offset);\par
608 \}\par
609 {\cf17 inline} {\cf18 bool} operator<=({\cf17 const} offset_datetime& lhs, {\cf17 const} offset_datetime& rhs)\par
610 \{\par
611     {\cf19 return} (lhs < rhs) || (lhs == rhs);\par
612 \}\par
613 {\cf17 inline} {\cf18 bool} operator> ({\cf17 const} offset_datetime& lhs, {\cf17 const} offset_datetime& rhs)\par
614 \{\par
615     {\cf19 return} !(lhs <= rhs);\par
616 \}\par
617 {\cf17 inline} {\cf18 bool} operator>=({\cf17 const} offset_datetime& lhs, {\cf17 const} offset_datetime& rhs)\par
618 \{\par
619     {\cf19 return} !(lhs < rhs);\par
620 \}\par
621 \par
622 {\cf17 template}<{\cf17 typename} {\cf18 char}T, {\cf17 typename} traits>\par
623 std::basic_ostream<charT, traits>&\par
624 operator<<(std::basic_ostream<charT, traits>& os, {\cf17 const} offset_datetime& dt)\par
625 \{\par
626     os << dt.date << {\cf23 'T'} << dt.time << dt.offset;\par
627     {\cf19 return} os;\par
628 \}\par
629 \par
630 \}{\cf20 //toml}\par
631 {\cf21 #endif}{\cf20 // TOML11_DATETIME}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/exception.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/exception.hpp}
{\xe \v external/toml/exception.hpp}
{\bkmkstart AAAAAAAACA}
{\bkmkend AAAAAAAACA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdexcept>}\par
{\f2 #include <string>}\par
{\f2 #include "source_location.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::exception}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::syntax_error}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::type_error}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::internal_error}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
exception.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/exception.hpp}
{\xe \v external/toml/exception.hpp}
{\bkmkstart AAAAAAAAAJ}
{\bkmkend AAAAAAAAAJ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2017.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_EXCEPTION_HPP}\par
4 {\cf21 #define TOML11_EXCEPTION_HPP}\par
5 {\cf21 #include <stdexcept>}\par
6 {\cf21 #include <string>}\par
7 \par
8 {\cf21 #include "source_location.hpp"}\par
9 \par
10 {\cf17 namespace }toml\par
11 \{\par
12 \par
13 {\cf17 struct }exception : {\cf17 public} std::exception\par
14 \{\par
15   {\cf17 public}:\par
16     {\cf17 explicit} exception({\cf17 const} source_location& loc): loc_(loc) \{\}\par
17     {\cf17 virtual} ~exception() noexcept override = default;\par
18     virtual const {\cf18 char}* what() const noexcept{\cf17  override }\{{\cf19 return} {\cf22 ""};\}\par
19     {\cf17 virtual} source_location {\cf17 const}& location() const noexcept \{{\cf19 return} loc_;\}\par
20 \par
21   {\cf17 protected}:\par
22     source_location loc_;\par
23 \};\par
24 \par
25 {\cf17 struct }syntax_error : {\cf17 public} toml::exception\par
26 \{\par
27   {\cf17 public}:\par
28     {\cf17 explicit} syntax_error({\cf17 const} std::string& what_arg, {\cf17 const} source_location& loc)\par
29         : exception(loc), what_(what_arg)\par
30     \{\}\par
31     {\cf17 virtual} ~syntax_error() noexcept override = default;\par
32     virtual const {\cf18 char}* what() const noexcept{\cf17  override }\{{\cf19 return} what_.c_str();\}\par
33 \par
34   {\cf17 protected}:\par
35     std::string what_;\par
36 \};\par
37 \par
38 {\cf17 struct }type_error : {\cf17 public} toml::exception\par
39 \{\par
40   {\cf17 public}:\par
41     {\cf17 explicit} type_error({\cf17 const} std::string& what_arg, {\cf17 const} source_location& loc)\par
42         : exception(loc), what_(what_arg)\par
43     \{\}\par
44     {\cf17 virtual} ~type_error() noexcept override = default;\par
45     virtual const {\cf18 char}* what() const noexcept{\cf17  override }\{{\cf19 return} what_.c_str();\}\par
46 \par
47   {\cf17 protected}:\par
48     std::string what_;\par
49 \};\par
50 \par
51 {\cf17 struct }internal_error : {\cf17 public} toml::exception\par
52 \{\par
53   {\cf17 public}:\par
54     {\cf17 explicit} internal_error({\cf17 const} std::string& what_arg, {\cf17 const} source_location& loc)\par
55         : exception(loc), what_(what_arg)\par
56     \{\}\par
57     {\cf17 virtual} ~internal_error() noexcept override = default;\par
58     virtual const {\cf18 char}* what() const noexcept{\cf17  override }\{{\cf19 return} what_.c_str();\}\par
59 \par
60   {\cf17 protected}:\par
61     std::string what_;\par
62 \};\par
63 \par
64 \} {\cf20 // toml}\par
65 {\cf21 #endif }{\cf20 // TOML_EXCEPTION}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/from.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/from.hpp}
{\xe \v external/toml/from.hpp}
{\bkmkstart AAAAAAAACB}
{\bkmkend AAAAAAAACB}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
from.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/from.hpp}
{\xe \v external/toml/from.hpp}
{\bkmkstart AAAAAAAAAK}
{\bkmkend AAAAAAAAAK}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2019.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_FROM_HPP}\par
4 {\cf21 #define TOML11_FROM_HPP}\par
5 \par
6 {\cf17 namespace }toml\par
7 \{\par
8 \par
9 {\cf17 template}<{\cf17 typename} T>\par
10 {\cf17 struct }from;\par
11 {\cf20 // \{}\par
12 {\cf20 //     static T from_toml(const toml::value& v)}\par
13 {\cf20 //     \{}\par
14 {\cf20 //         // User-defined conversions ...}\par
15 {\cf20 //     \}}\par
16 {\cf20 // \};}\par
17 \par
18 \} {\cf20 // toml}\par
19 {\cf21 #endif }{\cf20 // TOML11_FROM_HPP}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/get.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/get.hpp}
{\xe \v external/toml/get.hpp}
{\bkmkstart AAAAAAAACC}
{\bkmkend AAAAAAAACC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <algorithm>}\par
{\f2 #include "from.hpp"}\par
{\f2 #include "result.hpp"}\par
{\f2 #include "value.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::is_exact_toml_type< T, basic_value< C, M, V > >::value, T > & {\b toml::get} (basic_value< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::is_exact_toml_type< T, basic_value< C, M, V > >::value, T > const & {\b toml::get} (const basic_value< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::is_exact_toml_type< T, basic_value< C, M, V > >::value, T > {\b toml::get} (basic_value< C, M, V > &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< std::is_same< T, basic_value< C, M, V > >::value, T > & {\b toml::get} (basic_value< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< std::is_same< T, basic_value< C, M, V > >::value, T > const & {\b toml::get} (const basic_value< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< std::is_same< T, basic_value< C, M, V > >::value, T > {\b toml::get} (basic_value< C, M, V > &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::conjunction< detail::is_basic_value< T >, detail::negation< std::is_same< T, basic_value< C, M, V > > > >::value, T > {\b toml::get} (const basic_value< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::conjunction< std::is_integral< T >, detail::negation< std::is_same< T, bool > >, detail::negation< detail::is_exact_toml_type< T, basic_value< C, M, V > > > >::value, T > {\b toml::get} (const basic_value< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::conjunction< std::is_floating_point< T >, detail::negation< detail::is_exact_toml_type< T, basic_value< C, M, V > > > >::value, T > {\b toml::get} (const basic_value< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< std::is_same< T, std::string >::value, std::string > & {\b toml::get} (basic_value< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< std::is_same< T, std::string >::value, std::string > const & {\b toml::get} (const basic_value< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< std::is_same< T, std::string >::value, std::string > {\b toml::get} (basic_value< C, M, V > &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::is_chrono_duration< T >::value, T > {\b toml::get} (const basic_value< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< std::is_same< std::chrono::system_clock::time_point, T >::value, T > {\b toml::get} (const basic_value< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::conjunction< detail::is_container< T >, detail::has_push_back_method< T >, detail::negation< detail::is_exact_toml_type< T, basic_value< C, M, V > > > >::value, T > {\b toml::get} (const basic_value< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::conjunction< detail::is_container< T >, detail::negation< detail::has_push_back_method< T > >, detail::negation< detail::has_specialized_from< T > >, detail::negation< detail::is_exact_toml_type< T, basic_value< C, M, V > > > >::value, T > {\b toml::get} (const basic_value< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::is_std_pair< T >::value, T > {\b toml::get} (const basic_value< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::is_std_tuple< T >::value, T > {\b toml::get} (const basic_value< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::conjunction< detail::is_map< T >, detail::negation< detail::is_exact_toml_type< T, basic_value< C, M, V > > > >::value, T > {\b toml::get} (const basic_value< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::conjunction< detail::negation< detail::is_exact_toml_type< T, basic_value< C, M, V > > >, detail::has_from_toml_method< T, C, M, V >, std::is_default_constructible< T > >::value, T > {\b toml::get} (const basic_value< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::has_specialized_from< T >::value, T > {\b toml::get} (const basic_value< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::conjunction< detail::negation< detail::is_basic_value< T > >, std::is_constructible< T, const basic_value< C, M, V > & >, detail::negation< detail::has_from_toml_method< T, C, M, V > >, detail::negation< detail::has_specialized_from< T > > >::value, T > {\b toml::get} (const basic_value< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::is_std_forward_list< T >::value, T > {\b toml::get} (const basic_value< C, M, V > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Array , std::size_t ... I> T {\b toml::detail::get_tuple_impl} (const Array &a, index_sequence< I... >)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> basic_value< C, M, V > const & {\b toml::find} (const basic_value< C, M, V > &v, const key &ky)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> basic_value< C, M, V > & {\b toml::find} (basic_value< C, M, V > &v, const key &ky)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> basic_value< C, M, V > {\b toml::find} (basic_value< C, M, V > &&v, const key &ky)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> basic_value< C, M, V > const & {\b toml::find} (const basic_value< C, M, V > &v, const std::size_t idx)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> basic_value< C, M, V > & {\b toml::find} (basic_value< C, M, V > &v, const std::size_t idx)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> basic_value< C, M, V > {\b toml::find} (basic_value< C, M, V > &&v, const std::size_t idx)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > enable_if_t< conjunction< std::is_integral< remove_cvref_t< T > >, negation< std::is_same< remove_cvref_t< T >, bool > > >::value, std::size_t > {\b toml::detail::key_cast} (T &&v) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > enable_if_t< negation< conjunction< std::is_integral< remove_cvref_t< T > >, negation< std::is_same< remove_cvref_t< T >, bool > > > >::value, std::string > {\b toml::detail::key_cast} (T &&v) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V, typename Key1 , typename Key2 , typename ... Keys> const basic_value< C, M, V > & {\b toml::find} (const basic_value< C, M, V > &v, Key1 &&k1, Key2 &&k2, Keys &&... keys)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V, typename Key1 , typename Key2 , typename ... Keys> basic_value< C, M, V > & {\b toml::find} (basic_value< C, M, V > &v, Key1 &&k1, Key2 &&k2, Keys &&... keys)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V, typename Key1 , typename Key2 , typename ... Keys> basic_value< C, M, V > {\b toml::find} (basic_value< C, M, V > &&v, Key1 &&k1, Key2 &&k2, Keys &&... keys)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> basic_value< C, M, V > const & {\b toml::get_or} (const basic_value< C, M, V > &v, const basic_value< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> basic_value< C, M, V > & {\b toml::get_or} (basic_value< C, M, V > &v, basic_value< C, M, V > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> basic_value< C, M, V > {\b toml::get_or} (basic_value< C, M, V > &&v, basic_value< C, M, V > &&)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::is_exact_toml_type< T, basic_value< C, M, V > >::value, T > const & {\b toml::get_or} (const basic_value< C, M, V > &v, const T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::is_exact_toml_type< T, basic_value< C, M, V > >::value, T > & {\b toml::get_or} (basic_value< C, M, V > &v, T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::is_exact_toml_type< detail::remove_cvref_t< T >, basic_value< C, M, V > >::value, detail::remove_cvref_t< T > > {\b toml::get_or} (basic_value< C, M, V > &&v, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< std::is_same< detail::remove_cvref_t< T >, std::string >::value, std::string > const & {\b toml::get_or} (const basic_value< C, M, V > &v, const T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< std::is_same< T, std::string >::value, std::string > & {\b toml::get_or} (basic_value< C, M, V > &v, T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< std::is_same< detail::remove_cvref_t< T >, std::string >::value, std::string > {\b toml::get_or} (basic_value< C, M, V > &&v, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::is_string_literal< typename std::remove_reference< T >::type >::value, std::string > {\b toml::get_or} (const basic_value< C, M, V > &v, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::conjunction< detail::negation< detail::is_exact_toml_type< detail::remove_cvref_t< T >, basic_value< C, M, V > > >, detail::negation< std::is_same< std::string, detail::remove_cvref_t< T > > >, detail::negation< detail::is_string_literal< typename std::remove_reference< T >::type > > >::value, detail::remove_cvref_t< T > > {\b toml::get_or} (const basic_value< C, M, V > &v, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> basic_value< C, M, V > const & {\b toml::find_or} (const basic_value< C, M, V > &v, const key &ky, const basic_value< C, M, V > &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> basic_value< C, M, V > & {\b toml::find_or} (basic_value< C, M, V > &v, const {\b toml::key} &ky, basic_value< C, M, V > &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> basic_value< C, M, V > {\b toml::find_or} (basic_value< C, M, V > &&v, const {\b toml::key} &ky, basic_value< C, M, V > &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::is_exact_toml_type< T, basic_value< C, M, V > >::value, T > const & {\b toml::find_or} (const basic_value< C, M, V > &v, const key &ky, const T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::is_exact_toml_type< T, basic_value< C, M, V > >::value, T > & {\b toml::find_or} (basic_value< C, M, V > &v, const {\b toml::key} &ky, T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::is_exact_toml_type< T, basic_value< C, M, V > >::value, detail::remove_cvref_t< T > > {\b toml::find_or} (basic_value< C, M, V > &&v, const {\b toml::key} &ky, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< std::is_same< T, std::string >::value, std::string > const & {\b toml::find_or} (const basic_value< C, M, V > &v, const key &ky, const T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< std::is_same< T, std::string >::value, std::string > & {\b toml::find_or} (basic_value< C, M, V > &v, const {\b toml::key} &ky, T &opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< std::is_same< T, std::string >::value, std::string > {\b toml::find_or} (basic_value< C, M, V > &&v, const {\b toml::key} &ky, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::is_string_literal< typename std::remove_reference< T >::type >::value, std::string > {\b toml::find_or} (const basic_value< C, M, V > &v, const {\b toml::key} &ky, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> detail::enable_if_t< detail::conjunction< detail::negation< detail::is_exact_toml_type< detail::remove_cvref_t< T >, basic_value< C, M, V > > >, detail::negation< std::is_same< std::string, detail::remove_cvref_t< T > > >, detail::negation< detail::is_string_literal< typename std::remove_reference< T >::type > > >::value, detail::remove_cvref_t< T > > {\b toml::find_or} (const basic_value< C, M, V > &v, const {\b toml::key} &ky, T &&opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value , typename ... Ks, typename detail::enable_if_t<(sizeof...(Ks) > 1), std::nullptr_t >  = nullptr> auto {\b toml::find_or} (Value &&v, const {\b toml::key} &ky, Ks &&... keys) -> decltype(find_or(std::forward< Value >(v), ky, detail::last_one(std::forward< Ks >(keys)...)))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename Value , typename ... Ks, typename detail::enable_if_t<(sizeof...(Ks) > 1), std::nullptr_t >  = nullptr> auto {\b toml::find_or} (Value &&v, const {\b toml::key} &ky, Ks &&... keys) -> decltype(find_or< T >(std::forward< Value >(v), ky, detail::last_one(std::forward< Ks >(keys)...)))\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> result< T, std::string > {\b toml::expect} (const basic_value< C, M, V > &v) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> result< T, std::string > {\b toml::expect} (const basic_value< C, M, V > &v, const {\b toml::key} &k) noexcept\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename C , template< typename ... > class M, template< typename ... > class V> decltype(::toml::get< T >(std::declval< basic_value< C, M, V > const & >())) {\b toml::find} (const basic_value< C, M, V > &v, const key &ky)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
get.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/get.hpp}
{\xe \v external/toml/get.hpp}
{\bkmkstart AAAAAAAAAL}
{\bkmkend AAAAAAAAAL}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2017.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_GET_HPP}\par
4 {\cf21 #define TOML11_GET_HPP}\par
5 {\cf21 #include <algorithm>}\par
6 \par
7 {\cf21 #include "from.hpp"}\par
8 {\cf21 #include "result.hpp"}\par
9 {\cf21 #include "value.hpp"}\par
10 \par
11 {\cf17 namespace }toml\par
12 \{\par
13 \par
14 {\cf20 // ============================================================================}\par
15 {\cf20 // exact toml::* type}\par
16 \par
17 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
18          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
19 detail::enable_if_t<detail::is_exact_toml_type<T, basic_value<C, M, V>>::value, T> &\par
20 get(basic_value<C, M, V>& v)\par
21 \{\par
22     {\cf19 return} v.template cast<detail::type_to_enum<T, basic_value<C, M, V>>::value>();\par
23 \}\par
24 \par
25 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
26          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
27 detail::enable_if_t<detail::is_exact_toml_type<T, basic_value<C, M, V>>::value, T> {\cf17 const}&\par
28 get({\cf17 const} basic_value<C, M, V>& v)\par
29 \{\par
30     {\cf19 return} v.template cast<detail::type_to_enum<T, basic_value<C, M, V>>::value>();\par
31 \}\par
32 \par
33 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
34          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
35 detail::enable_if_t<detail::is_exact_toml_type<T, basic_value<C, M, V>>::value, T>\par
36 get(basic_value<C, M, V>&& v)\par
37 \{\par
38     {\cf19 return} T(std::move(v).{\cf17 template} cast<detail::type_to_enum<T, basic_value<C, M, V>>::value>());\par
39 \}\par
40 \par
41 {\cf20 // ============================================================================}\par
42 {\cf20 // T == toml::value; identity transformation.}\par
43 \par
44 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
45          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
46 {\cf17 inline} detail::enable_if_t<std::is_same<T, basic_value<C, M, V>>::value, T>&\par
47 get(basic_value<C, M, V>& v)\par
48 \{\par
49     {\cf19 return} v;\par
50 \}\par
51 \par
52 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
53          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
54 {\cf17 inline} detail::enable_if_t<std::is_same<T, basic_value<C, M, V>>::value, T> {\cf17 const}&\par
55 get({\cf17 const} basic_value<C, M, V>& v)\par
56 \{\par
57     {\cf19 return} v;\par
58 \}\par
59 \par
60 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
61          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
62 {\cf17 inline} detail::enable_if_t<std::is_same<T, basic_value<C, M, V>>::value, T>\par
63 get(basic_value<C, M, V>&& v)\par
64 \{\par
65     {\cf19 return} basic_value<C, M, V>(std::move(v));\par
66 \}\par
67 \par
68 {\cf20 // ============================================================================}\par
69 {\cf20 // T == toml::basic_value<C2, M2, V2>; basic_value -> basic_value}\par
70 \par
71 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
72          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
73 {\cf17 inline} detail::enable_if_t<detail::conjunction<detail::is_basic_value<T>,\par
74     detail::negation<std::is_same<T, basic_value<C, M, V>>>\par
75     >::value, T>\par
76 get({\cf17 const} basic_value<C, M, V>& v)\par
77 \{\par
78     {\cf19 return} T(v);\par
79 \}\par
80 \par
81 {\cf20 // ============================================================================}\par
82 {\cf20 // integer convertible from toml::Integer}\par
83 \par
84 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
85          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
86 {\cf17 inline} detail::enable_if_t<detail::conjunction<\par
87     std::is_integral<T>,                            {\cf20 // T is integral}\par
88     detail::negation<std::is_same<T, bool>>,        {\cf20 // but not bool}\par
89     detail::negation<                               {\cf20 // but not toml::integer}\par
90         detail::is_exact_toml_type<T, basic_value<C, M, V>>>\par
91     >::value, T>\par
92 get({\cf17 const} basic_value<C, M, V>& v)\par
93 \{\par
94     {\cf19 return} {\cf17 static_cast<}T{\cf17 >}(v.as_integer());\par
95 \}\par
96 \par
97 {\cf20 // ============================================================================}\par
98 {\cf20 // floating point convertible from toml::Float}\par
99 \par
100 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
101          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
102 {\cf17 inline} detail::enable_if_t<detail::conjunction<\par
103     std::is_floating_point<T>,                      {\cf20 // T is floating_point}\par
104     detail::negation<                               {\cf20 // but not toml::floating}\par
105         detail::is_exact_toml_type<T, basic_value<C, M, V>>>\par
106     >::value, T>\par
107 get({\cf17 const} basic_value<C, M, V>& v)\par
108 \{\par
109     {\cf19 return} {\cf17 static_cast<}T{\cf17 >}(v.as_floating());\par
110 \}\par
111 \par
112 {\cf20 // ============================================================================}\par
113 {\cf20 // std::string; toml uses its own toml::string, but it should be convertible to}\par
114 {\cf20 // std::string seamlessly}\par
115 \par
116 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
117          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
118 {\cf17 inline} detail::enable_if_t<std::is_same<T, std::string>::value, std::string>&\par
119 get(basic_value<C, M, V>& v)\par
120 \{\par
121     {\cf19 return} v.as_string().str;\par
122 \}\par
123 \par
124 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
125          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
126 {\cf17 inline} detail::enable_if_t<std::is_same<T, std::string>::value, std::string> {\cf17 const}&\par
127 get({\cf17 const} basic_value<C, M, V>& v)\par
128 \{\par
129     {\cf19 return} v.as_string().str;\par
130 \}\par
131 \par
132 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
133          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
134 {\cf17 inline} detail::enable_if_t<std::is_same<T, std::string>::value, std::string>\par
135 get(basic_value<C, M, V>&& v)\par
136 \{\par
137     {\cf19 return} std::string(std::move(v.as_string().str));\par
138 \}\par
139 \par
140 {\cf20 // ============================================================================}\par
141 {\cf20 // std::string_view}\par
142 \par
143 {\cf21 #if defined(TOML11_USING_STRING_VIEW) && TOML11_USING_STRING_VIEW>0}\par
144 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
145          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
146 {\cf17 inline} detail::enable_if_t<std::is_same<T, std::string_view>::value, std::string_view>\par
147 get({\cf17 const} basic_value<C, M, V>& v)\par
148 \{\par
149     {\cf19 return} std::string_view(v.as_string().str);\par
150 \}\par
151 {\cf21 #endif}\par
152 \par
153 {\cf20 // ============================================================================}\par
154 {\cf20 // std::chrono::duration from toml::local_time.}\par
155 \par
156 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
157          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
158 {\cf17 inline} detail::enable_if_t<detail::is_chrono_duration<T>::value, T>\par
159 get({\cf17 const} basic_value<C, M, V>& v)\par
160 \{\par
161     {\cf19 return} std::chrono::duration_cast<T>(\par
162             std::chrono::nanoseconds(v.as_local_time()));\par
163 \}\par
164 \par
165 {\cf20 // ============================================================================}\par
166 {\cf20 // std::chrono::system_clock::time_point from toml::datetime variants}\par
167 \par
168 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
169          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
170 {\cf17 inline} detail::enable_if_t<\par
171     std::is_same<std::chrono::system_clock::time_point, T>::value, T>\par
172 get({\cf17 const} basic_value<C, M, V>& v)\par
173 \{\par
174     {\cf19 switch}(v.type())\par
175     \{\par
176         {\cf19 case} value_t::local_date:\par
177         \{\par
178             {\cf19 return} std::chrono::system_clock::time_point(v.as_local_date());\par
179         \}\par
180         {\cf19 case} value_t::local_datetime:\par
181         \{\par
182             {\cf19 return} std::chrono::system_clock::time_point(v.as_local_datetime());\par
183         \}\par
184         {\cf19 case} value_t::offset_datetime:\par
185         \{\par
186             {\cf19 return} std::chrono::system_clock::time_point(v.as_offset_datetime());\par
187         \}\par
188         {\cf19 default}:\par
189         \{\par
190             {\cf19 throw} type_error(detail::format_underline({\cf22 "toml::value: "}\par
191                 {\cf22 "bad_cast to std::chrono::system_clock::time_point"}, \{\par
192                     \{v.location(), concat_to_string({\cf22 "the actual type is "}, v.type())\}\par
193                 \}), v.location());\par
194         \}\par
195     \}\par
196 \}\par
197 \par
198 {\cf20 // ============================================================================}\par
199 {\cf20 // forward declaration to use this recursively. ignore this and go ahead.}\par
200 \par
201 {\cf20 // array-like type with push_back(value) method}\par
202 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
203          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
204 detail::enable_if_t<detail::conjunction<\par
205     detail::is_container<T>,         {\cf20 // T is a container}\par
206     detail::has_push_back_method<T>, {\cf20 // T::push_back(value) works}\par
207     detail::negation<                {\cf20 // but not toml::array}\par
208         detail::is_exact_toml_type<T, basic_value<C, M, V>>>\par
209     >::value, T>\par
210 get({\cf17 const} basic_value<C, M, V>&);\par
211 \par
212 {\cf20 // array-like type without push_back(value) method}\par
213 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
214          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
215 detail::enable_if_t<detail::conjunction<\par
216     detail::is_container<T>,                           {\cf20 // T is a container}\par
217     detail::negation<detail::has_push_back_method<T>>, {\cf20 // w/o push_back(...)}\par
218     detail::negation<detail::has_specialized_from<T>>, {\cf20 // T does not have special conversion}\par
219     detail::negation<                                  {\cf20 // not toml::array}\par
220         detail::is_exact_toml_type<T, basic_value<C, M, V>>>\par
221     >::value, T>\par
222 get({\cf17 const} basic_value<C, M, V>&);\par
223 \par
224 {\cf20 // std::pair<T1, T2>}\par
225 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
226          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
227 detail::enable_if_t<detail::is_std_pair<T>::value, T>\par
228 get({\cf17 const} basic_value<C, M, V>&);\par
229 \par
230 {\cf20 // std::tuple<T1, T2, ...>}\par
231 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
232          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
233 detail::enable_if_t<detail::is_std_tuple<T>::value, T>\par
234 get({\cf17 const} basic_value<C, M, V>&);\par
235 \par
236 {\cf20 // map-like classes}\par
237 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
238          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
239 detail::enable_if_t<detail::conjunction<\par
240     detail::is_map<T>, {\cf20 // T is map}\par
241     detail::negation<  {\cf20 // but not toml::table}\par
242         detail::is_exact_toml_type<T, basic_value<C, M, V>>>\par
243     >::value, T>\par
244 get({\cf17 const} basic_value<C, M, V>&);\par
245 \par
246 {\cf20 // T.from_toml(v)}\par
247 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
248          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
249 detail::enable_if_t<detail::conjunction<\par
250     detail::negation<                         {\cf20 // not a toml::* type}\par
251         detail::is_exact_toml_type<T, basic_value<C, M, V>>>,\par
252     detail::has_from_toml_method<T, C, M, V>, {\cf20 // but has from_toml(toml::value)}\par
253     std::is_default_constructible<T>          {\cf20 // and default constructible}\par
254     >::value, T>\par
255 get({\cf17 const} basic_value<C, M, V>&);\par
256 \par
257 {\cf20 // toml::from<T>::from_toml(v)}\par
258 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
259          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
260 detail::enable_if_t<detail::has_specialized_from<T>::value, T>\par
261 get({\cf17 const} basic_value<C, M, V>&);\par
262 \par
263 {\cf20 // T(const toml::value&) and T is not toml::basic_value,}\par
264 {\cf20 // and it does not have `from<T>` nor `from_toml`.}\par
265 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
266          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
267 detail::enable_if_t<detail::conjunction<\par
268     detail::negation<detail::is_basic_value<T>>,\par
269     std::is_constructible<T, const basic_value<C, M, V>&>,\par
270     detail::negation<detail::has_from_toml_method<T, C, M, V>>,\par
271     detail::negation<detail::has_specialized_from<T>>\par
272     >::value, T>\par
273 get({\cf17 const} basic_value<C, M, V>&);\par
274 \par
275 {\cf20 // ============================================================================}\par
276 {\cf20 // array-like types; most likely STL container, like std::vector, etc.}\par
277 \par
278 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
279          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
280 detail::enable_if_t<detail::conjunction<\par
281     detail::is_container<T>,         {\cf20 // T is a container}\par
282     detail::has_push_back_method<T>, {\cf20 // container.push_back(elem) works}\par
283     detail::negation<                {\cf20 // but not toml::array}\par
284         detail::is_exact_toml_type<T, basic_value<C, M, V>>>\par
285     >::value, T>\par
286 get({\cf17 const} basic_value<C, M, V>& v)\par
287 \{\par
288     {\cf17 using }value_type = {\cf17 typename} T::value_type;\par
289     {\cf17 const} {\cf17 auto}& ary = v.as_array();\par
290 \par
291     T container;\par
292     try_reserve(container, ary.size());\par
293 \par
294     {\cf19 for}({\cf17 const} {\cf17 auto}& elem : ary)\par
295     \{\par
296         container.push_back(get<value_type>(elem));\par
297     \}\par
298     {\cf19 return} container;\par
299 \}\par
300 \par
301 {\cf20 // ============================================================================}\par
302 {\cf20 // std::forward_list does not have push_back, insert, or emplace.}\par
303 {\cf20 // It has insert_after, emplace_after, push_front.}\par
304 \par
305 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
306          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
307 detail::enable_if_t<detail::is_std_forward_list<T>::value, T>\par
308 get({\cf17 const} basic_value<C, M, V>& v)\par
309 \{\par
310     {\cf17 using }value_type = {\cf17 typename} T::value_type;\par
311     T container;\par
312     {\cf19 for}({\cf17 const} {\cf17 auto}& elem : v.as_array())\par
313     \{\par
314         container.push_front(get<value_type>(elem));\par
315     \}\par
316     container.reverse();\par
317     {\cf19 return} container;\par
318 \}\par
319 \par
320 {\cf20 // ============================================================================}\par
321 {\cf20 // array-like types, without push_back(). most likely [std|boost]::array.}\par
322 \par
323 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
324          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
325 detail::enable_if_t<detail::conjunction<\par
326     detail::is_container<T>,                           {\cf20 // T is a container}\par
327     detail::negation<detail::has_push_back_method<T>>, {\cf20 // w/o push_back}\par
328     detail::negation<detail::has_specialized_from<T>>, {\cf20 // T does not have special conversion}\par
329     detail::negation<                                  {\cf20 // T is not toml::array}\par
330         detail::is_exact_toml_type<T, basic_value<C, M, V>>>\par
331     >::value, T>\par
332 get({\cf17 const} basic_value<C, M, V>& v)\par
333 \{\par
334     {\cf17 using }value_type = {\cf17 typename} T::value_type;\par
335     {\cf17 const} {\cf17 auto}& ar = v.as_array();\par
336 \par
337     T container;\par
338     {\cf19 if}(ar.size() != container.size())\par
339     \{\par
340         {\cf19 throw} std::out_of_range(detail::format_underline(concat_to_string(\par
341             {\cf22 "toml::get: specified container size is "}, container.size(),\par
342             {\cf22 " but there are "}, ar.size(), {\cf22 " elements in toml array."}), \{\par
343                 \{v.location(), {\cf22 "here"}\}\par
344             \}));\par
345     \}\par
346     {\cf19 for}(std::size_t i=0; i<ar.size(); ++i)\par
347     \{\par
348         container[i] = ::toml::get<value_type>(ar[i]);\par
349     \}\par
350     {\cf19 return} container;\par
351 \}\par
352 \par
353 {\cf20 // ============================================================================}\par
354 {\cf20 // std::pair.}\par
355 \par
356 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
357          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
358 detail::enable_if_t<detail::is_std_pair<T>::value, T>\par
359 get({\cf17 const} basic_value<C, M, V>& v)\par
360 \{\par
361     {\cf17 using }first_type  = {\cf17 typename} T::first_type;\par
362     {\cf17 using }second_type = {\cf17 typename} T::second_type;\par
363 \par
364     {\cf17 const} {\cf17 auto}& ar = v.as_array();\par
365     {\cf19 if}(ar.size() != 2)\par
366     \{\par
367         {\cf19 throw} std::out_of_range(detail::format_underline(concat_to_string(\par
368             {\cf22 "toml::get: specified std::pair but there are "}, ar.size(),\par
369             {\cf22 " elements in toml array."}), \{\{v.location(), {\cf22 "here"}\}\}));\par
370     \}\par
371     {\cf19 return} std::make_pair(::toml::get<first_type >(ar.at(0)),\par
372                           ::toml::get<second_type>(ar.at(1)));\par
373 \}\par
374 \par
375 {\cf20 // ============================================================================}\par
376 {\cf20 // std::tuple.}\par
377 \par
378 {\cf17 namespace }detail\par
379 \{\par
380 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} Array, std::size_t ... I>\par
381 T get_tuple_impl({\cf17 const} Array& a, index_sequence<I...>)\par
382 \{\par
383     {\cf19 return} std::make_tuple(\par
384         ::toml::get<{\cf17 typename} std::tuple_element<I, T>::type>(a.at(I))...);\par
385 \}\par
386 \} {\cf20 // detail}\par
387 \par
388 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
389          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
390 detail::enable_if_t<detail::is_std_tuple<T>::value, T>\par
391 get({\cf17 const} basic_value<C, M, V>& v)\par
392 \{\par
393     {\cf17 const} {\cf17 auto}& ar = v.as_array();\par
394     {\cf19 if}(ar.size() != std::tuple_size<T>::value)\par
395     \{\par
396         {\cf19 throw} std::out_of_range(detail::format_underline(concat_to_string(\par
397             {\cf22 "toml::get: specified std::tuple with "},\par
398             std::tuple_size<T>::value, {\cf22 " elements, but there are "}, ar.size(),\par
399             {\cf22 " elements in toml array."}), \{\{v.location(), {\cf22 "here"}\}\}));\par
400     \}\par
401     {\cf19 return} detail::get_tuple_impl<T>(ar,\par
402             detail::make_index_sequence<std::tuple_size<T>::value>\{\});\par
403 \}\par
404 \par
405 {\cf20 // ============================================================================}\par
406 {\cf20 // map-like types; most likely STL map, like std::map or std::unordered_map.}\par
407 \par
408 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
409          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
410 detail::enable_if_t<detail::conjunction<\par
411     detail::is_map<T>, {\cf20 // T is map}\par
412     detail::negation<  {\cf20 // but not toml::array}\par
413         detail::is_exact_toml_type<T, basic_value<C, M, V>>>\par
414     >::value, T>\par
415 get({\cf17 const} basic_value<C, M, V>& v)\par
416 \{\par
417     {\cf17 using }key_type    = {\cf17 typename} T::key_type;\par
418     {\cf17 using }mapped_type = {\cf17 typename} T::mapped_type;\par
419     {\cf17 static_assert}(std::is_convertible<std::string, key_type>::value,\par
420                   {\cf22 "toml::get only supports map type of which key_type is "}\par
421                   {\cf22 "convertible from std::string."});\par
422     T map;\par
423     {\cf19 for}({\cf17 const} {\cf17 auto}& kv : v.as_table())\par
424     \{\par
425         map.emplace(key_type(kv.first), get<mapped_type>(kv.second));\par
426     \}\par
427     {\cf19 return} map;\par
428 \}\par
429 \par
430 {\cf20 // ============================================================================}\par
431 {\cf20 // user-defined, but compatible types.}\par
432 \par
433 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
434          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
435 detail::enable_if_t<detail::conjunction<\par
436     detail::negation<                         {\cf20 // not a toml::* type}\par
437         detail::is_exact_toml_type<T, basic_value<C, M, V>>>,\par
438     detail::has_from_toml_method<T, C, M, V>, {\cf20 // but has from_toml(toml::value) memfn}\par
439     std::is_default_constructible<T>          {\cf20 // and default constructible}\par
440     >::value, T>\par
441 get({\cf17 const} basic_value<C, M, V>& v)\par
442 \{\par
443     T ud;\par
444     ud.from_toml(v);\par
445     {\cf19 return} ud;\par
446 \}\par
447 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
448          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
449 detail::enable_if_t<detail::has_specialized_from<T>::value, T>\par
450 get({\cf17 const} basic_value<C, M, V>& v)\par
451 \{\par
452     return ::toml::from<T>::from_toml(v);\par
453 \}\par
454 \par
455 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
456          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
457 detail::enable_if_t<detail::conjunction<\par
458     detail::negation<detail::is_basic_value<T>>,                {\cf20 // T is not a toml::value}\par
459     std::is_constructible<T, const basic_value<C, M, V>&>,      {\cf20 // T is constructible from toml::value}\par
460     detail::negation<detail::has_from_toml_method<T, C, M, V>>, {\cf20 // and T does not have T.from_toml(v);}\par
461     detail::negation<detail::has_specialized_from<T>>           {\cf20 // and T does not have toml::from<T>\{\};}\par
462     >::value, T>\par
463 get({\cf17 const} basic_value<C, M, V>& v)\par
464 \{\par
465     {\cf19 return} T(v);\par
466 \}\par
467 \par
468 {\cf20 // ============================================================================}\par
469 {\cf20 // find}\par
470 \par
471 {\cf20 // ----------------------------------------------------------------------------}\par
472 {\cf20 // these overloads do not require to set T. and returns value itself.}\par
473 {\cf17 template}<{\cf17 typename} C,\par
474          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
475 basic_value<C, M, V> {\cf17 const}& find({\cf17 const} basic_value<C, M, V>& v, {\cf17 const} key& ky)\par
476 \{\par
477     {\cf17 const} {\cf17 auto}& tab = v.as_table();\par
478     {\cf19 if}(tab.count(ky) == 0)\par
479     \{\par
480         detail::throw_key_not_found_error(v, ky);\par
481     \}\par
482     {\cf19 return} tab.at(ky);\par
483 \}\par
484 {\cf17 template}<{\cf17 typename} C,\par
485          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
486 basic_value<C, M, V>& find(basic_value<C, M, V>& v, {\cf17 const} key& ky)\par
487 \{\par
488     {\cf17 auto}& tab = v.as_table();\par
489     {\cf19 if}(tab.count(ky) == 0)\par
490     \{\par
491         detail::throw_key_not_found_error(v, ky);\par
492     \}\par
493     {\cf19 return} tab.at(ky);\par
494 \}\par
495 {\cf17 template}<{\cf17 typename} C,\par
496          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
497 basic_value<C, M, V> find(basic_value<C, M, V>&& v, {\cf17 const} key& ky)\par
498 \{\par
499     {\cf17 typename} basic_value<C, M, V>::table_type tab = std::move(v).as_table();\par
500     {\cf19 if}(tab.count(ky) == 0)\par
501     \{\par
502         detail::throw_key_not_found_error(v, ky);\par
503     \}\par
504     {\cf19 return} basic_value<C, M, V>(std::move(tab.at(ky)));\par
505 \}\par
506 \par
507 {\cf20 // ----------------------------------------------------------------------------}\par
508 {\cf20 // find(value, idx)}\par
509 {\cf17 template}<{\cf17 typename} C,\par
510          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
511 basic_value<C, M, V> {\cf17 const}&\par
512 find({\cf17 const} basic_value<C, M, V>& v, {\cf17 const} std::size_t idx)\par
513 \{\par
514     {\cf17 const} {\cf17 auto}& ary = v.as_array();\par
515     {\cf19 if}(ary.size() <= idx)\par
516     \{\par
517         {\cf19 throw} std::out_of_range(detail::format_underline(concat_to_string(\par
518             {\cf22 "index "}, idx, {\cf22 " is out of range"}), \{\{v.location(), {\cf22 "in this array"}\}\}));\par
519     \}\par
520     {\cf19 return} ary.at(idx);\par
521 \}\par
522 {\cf17 template}<{\cf17 typename} C,\par
523          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
524 basic_value<C, M, V>& find(basic_value<C, M, V>& v, {\cf17 const} std::size_t idx)\par
525 \{\par
526     {\cf17 auto}& ary = v.as_array();\par
527     {\cf19 if}(ary.size() <= idx)\par
528     \{\par
529         {\cf19 throw} std::out_of_range(detail::format_underline(concat_to_string(\par
530             {\cf22 "index "}, idx, {\cf22 " is out of range"}), \{\{v.location(), {\cf22 "in this array"}\}\}));\par
531     \}\par
532     {\cf19 return} ary.at(idx);\par
533 \}\par
534 {\cf17 template}<{\cf17 typename} C,\par
535          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
536 basic_value<C, M, V> find(basic_value<C, M, V>&& v, {\cf17 const} std::size_t idx)\par
537 \{\par
538     {\cf17 auto}& ary = v.as_array();\par
539     {\cf19 if}(ary.size() <= idx)\par
540     \{\par
541         {\cf19 throw} std::out_of_range(detail::format_underline(concat_to_string(\par
542             {\cf22 "index "}, idx, {\cf22 " is out of range"}), \{\{v.location(), {\cf22 "in this array"}\}\}));\par
543     \}\par
544     {\cf19 return} basic_value<C, M, V>(std::move(ary.at(idx)));\par
545 \}\par
546 \par
547 {\cf20 // ----------------------------------------------------------------------------}\par
548 {\cf20 // find<T>(value, key);}\par
549 \par
550 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
551          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
552 {\cf17 decltype}(::toml::get<T>(std::declval<basic_value<C, M, V> {\cf17 const}&>()))\par
553 find({\cf17 const} basic_value<C, M, V>& v, {\cf17 const} key& ky)\par
554 \{\par
555     {\cf17 const} {\cf17 auto}& tab = v.as_table();\par
556     {\cf19 if}(tab.count(ky) == 0)\par
557     \{\par
558         detail::throw_key_not_found_error(v, ky);\par
559     \}\par
560     return ::toml::get<T>(tab.at(ky));\par
561 \}\par
562 \par
563 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
564          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
565 {\cf17 decltype}(::toml::get<T>(std::declval<basic_value<C, M, V>&>()))\par
566 find(basic_value<C, M, V>& v, {\cf17 const} key& ky)\par
567 \{\par
568     {\cf17 auto}& tab = v.as_table();\par
569     {\cf19 if}(tab.count(ky) == 0)\par
570     \{\par
571         detail::throw_key_not_found_error(v, ky);\par
572     \}\par
573     return ::toml::get<T>(tab.at(ky));\par
574 \}\par
575 \par
576 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
577          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
578 {\cf17 decltype}(::toml::get<T>(std::declval<basic_value<C, M, V>&&>()))\par
579 find(basic_value<C, M, V>&& v, {\cf17 const} key& ky)\par
580 \{\par
581     {\cf17 typename} basic_value<C, M, V>::table_type tab = std::move(v).as_table();\par
582     {\cf19 if}(tab.count(ky) == 0)\par
583     \{\par
584         detail::throw_key_not_found_error(v, ky);\par
585     \}\par
586     return ::toml::get<T>(std::move(tab.at(ky)));\par
587 \}\par
588 \par
589 {\cf20 // ----------------------------------------------------------------------------}\par
590 {\cf20 // find<T>(value, idx)}\par
591 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
592          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
593 {\cf17 decltype}(::toml::get<T>(std::declval<basic_value<C, M, V> {\cf17 const}&>()))\par
594 find({\cf17 const} basic_value<C, M, V>& v, {\cf17 const} std::size_t idx)\par
595 \{\par
596     {\cf17 const} {\cf17 auto}& ary = v.as_array();\par
597     {\cf19 if}(ary.size() <= idx)\par
598     \{\par
599         {\cf19 throw} std::out_of_range(detail::format_underline(concat_to_string(\par
600             {\cf22 "index "}, idx, {\cf22 " is out of range"}), \{\{v.location(), {\cf22 "in this array"}\}\}));\par
601     \}\par
602     return ::toml::get<T>(ary.at(idx));\par
603 \}\par
604 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
605          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
606 {\cf17 decltype}(::toml::get<T>(std::declval<basic_value<C, M, V>&>()))\par
607 find(basic_value<C, M, V>& v, {\cf17 const} std::size_t idx)\par
608 \{\par
609     {\cf17 auto}& ary = v.as_array();\par
610     {\cf19 if}(ary.size() <= idx)\par
611     \{\par
612         {\cf19 throw} std::out_of_range(detail::format_underline(concat_to_string(\par
613             {\cf22 "index "}, idx, {\cf22 " is out of range"}), \{\{v.location(), {\cf22 "in this array"}\}\}));\par
614     \}\par
615     return ::toml::get<T>(ary.at(idx));\par
616 \}\par
617 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
618          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
619 {\cf17 decltype}(::toml::get<T>(std::declval<basic_value<C, M, V>&&>()))\par
620 find(basic_value<C, M, V>&& v, {\cf17 const} std::size_t idx)\par
621 \{\par
622     {\cf17 typename} basic_value<C, M, V>::array_type ary = std::move(v).as_array();\par
623     {\cf19 if}(ary.size() <= idx)\par
624     \{\par
625         {\cf19 throw} std::out_of_range(detail::format_underline(concat_to_string(\par
626             {\cf22 "index "}, idx, {\cf22 " is out of range"}), \{\{v.location(), {\cf22 "in this array"}\}\}));\par
627     \}\par
628     return ::toml::get<T>(std::move(ary.at(idx)));\par
629 \}\par
630 \par
631 {\cf20 // --------------------------------------------------------------------------}\par
632 {\cf20 // toml::find(toml::value, toml::key, Ts&& ... keys)}\par
633 \par
634 {\cf17 namespace }detail\par
635 \{\par
636 {\cf20 // It suppresses warnings by -Wsign-conversion. Let's say we have the following}\par
637 {\cf20 // code.}\par
638 {\cf20 // ```cpp}\par
639 {\cf20 // const auto x = toml::find<std::string>(data, "array", 0);}\par
640 {\cf20 // ```}\par
641 {\cf20 // Here, the type of literal number `0` is `int`. `int` is a signed integer.}\par
642 {\cf20 // `toml::find` takes `std::size_t` as an index. So it causes implicit sign}\par
643 {\cf20 // conversion and `-Wsign-conversion` warns about it. Using `0u` instead of `0`}\par
644 {\cf20 // suppresses the warning, but it makes user code messy.}\par
645 {\cf20 //     To suppress this warning, we need to be aware of type conversion caused}\par
646 {\cf20 // by `toml::find(v, key1, key2, ... keys)`. But the thing is that the types of}\par
647 {\cf20 // keys can be any combination of \{string-like, size_t-like\}. Of course we can't}\par
648 {\cf20 // write down all the combinations. Thus we need to use some function that}\par
649 {\cf20 // recognize the type of argument and cast it into `std::string` or}\par
650 {\cf20 // `std::size_t` depending on the context.}\par
651 {\cf20 //     `key_cast` does the job. It has 2 overloads. One is invoked when the}\par
652 {\cf20 // argument type is an integer and cast the argument into `std::size_t`. The}\par
653 {\cf20 // other is invoked when the argument type is not an integer, possibly one of}\par
654 {\cf20 // std::string, const char[N] or const char*, and construct std::string from}\par
655 {\cf20 // the argument.}\par
656 {\cf20 //     `toml::find(v, k1, k2, ... ks)` uses `key_cast` before passing `ks` to}\par
657 {\cf20 // `toml::find(v, k)` to suppress -Wsign-conversion.}\par
658 \par
659 {\cf17 template}<{\cf17 typename} T>\par
660 enable_if_t<conjunction<std::is_integral<remove_cvref_t<T>>,\par
661             negation<std::is_same<remove_cvref_t<T>, {\cf18 bool}>>>::value, std::size_t>\par
662 key_cast(T&& v) {\cf17 noexcept}\par
663 \{\par
664     {\cf19 return} std::size_t(v);\par
665 \}\par
666 {\cf17 template}<{\cf17 typename} T>\par
667 enable_if_t<negation<conjunction<std::is_integral<remove_cvref_t<T>>,\par
668             negation<std::is_same<remove_cvref_t<T>, {\cf18 bool}>>>>::value, std::string>\par
669 key_cast(T&& v) {\cf17 noexcept}\par
670 \{\par
671     {\cf19 return} std::string(std::forward<T>(v));\par
672 \}\par
673 \} {\cf20 // detail}\par
674 \par
675 {\cf17 template}<{\cf17 typename} C,\par
676          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V,\par
677          {\cf17 typename} Key1, {\cf17 typename} Key2, {\cf17 typename} ... Keys>\par
678 {\cf17 const} basic_value<C, M, V>&\par
679 find({\cf17 const} basic_value<C, M, V>& v, Key1&& k1, Key2&& k2, Keys&& ... keys)\par
680 \{\par
681     return ::toml::find(::toml::find(v, detail::key_cast(k1)),\par
682             detail::key_cast(k2), std::forward<Keys>(keys)...);\par
683 \}\par
684 {\cf17 template}<{\cf17 typename} C,\par
685          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V,\par
686          {\cf17 typename} Key1, {\cf17 typename} Key2, {\cf17 typename} ... Keys>\par
687 basic_value<C, M, V>&\par
688 find(basic_value<C, M, V>& v, Key1&& k1, Key2&& k2, Keys&& ... keys)\par
689 \{\par
690     return ::toml::find(::toml::find(v, detail::key_cast(k1)),\par
691             detail::key_cast(k2), std::forward<Keys>(keys)...);\par
692 \}\par
693 {\cf17 template}<{\cf17 typename} C,\par
694          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V,\par
695          {\cf17 typename} Key1, {\cf17 typename} Key2, {\cf17 typename} ... Keys>\par
696 basic_value<C, M, V>\par
697 find(basic_value<C, M, V>&& v, Key1&& k1, Key2&& k2, Keys&& ... keys)\par
698 \{\par
699     return ::toml::find(::toml::find(std::move(v), std::forward<Key1>(k1)),\par
700             detail::key_cast(k2), std::forward<Keys>(keys)...);\par
701 \}\par
702 \par
703 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
704          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V,\par
705          {\cf17 typename} Key1, {\cf17 typename} Key2, {\cf17 typename} ... Keys>\par
706 {\cf17 decltype}(::toml::get<T>(std::declval<{\cf17 const} basic_value<C, M, V>&>()))\par
707 find({\cf17 const} basic_value<C, M, V>& v, Key1&& k1, Key2&& k2, Keys&& ... keys)\par
708 \{\par
709     return ::toml::find<T>(::toml::find(v, detail::key_cast(k1)),\par
710             detail::key_cast(k2), std::forward<Keys>(keys)...);\par
711 \}\par
712 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
713          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V,\par
714          {\cf17 typename} Key1, {\cf17 typename} Key2, {\cf17 typename} ... Keys>\par
715 {\cf17 decltype}(::toml::get<T>(std::declval<basic_value<C, M, V>&>()))\par
716 find(basic_value<C, M, V>& v, Key1&& k1, Key2&& k2, Keys&& ... keys)\par
717 \{\par
718     return ::toml::find<T>(::toml::find(v, detail::key_cast(k1)),\par
719             detail::key_cast(k2), std::forward<Keys>(keys)...);\par
720 \}\par
721 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
722          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V,\par
723          {\cf17 typename} Key1, {\cf17 typename} Key2, {\cf17 typename} ... Keys>\par
724 {\cf17 decltype}(::toml::get<T>(std::declval<basic_value<C, M, V>&&>()))\par
725 find(basic_value<C, M, V>&& v, Key1&& k1, Key2&& k2, Keys&& ... keys)\par
726 \{\par
727     return ::toml::find<T>(::toml::find(std::move(v), detail::key_cast(k1)),\par
728             detail::key_cast(k2), std::forward<Keys>(keys)...);\par
729 \}\par
730 \par
731 {\cf20 // ============================================================================}\par
732 {\cf20 // get_or(value, fallback)}\par
733 \par
734 {\cf17 template}<{\cf17 typename} C,\par
735          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
736 basic_value<C, M, V> {\cf17 const}&\par
737 get_or({\cf17 const} basic_value<C, M, V>& v, {\cf17 const} basic_value<C, M, V>&)\par
738 \{\par
739     {\cf19 return} v;\par
740 \}\par
741 {\cf17 template}<{\cf17 typename} C,\par
742          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
743 basic_value<C, M, V>&\par
744 get_or(basic_value<C, M, V>& v, basic_value<C, M, V>&)\par
745 \{\par
746     {\cf19 return} v;\par
747 \}\par
748 {\cf17 template}<{\cf17 typename} C,\par
749          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
750 basic_value<C, M, V>\par
751 get_or(basic_value<C, M, V>&& v, basic_value<C, M, V>&&)\par
752 \{\par
753     {\cf19 return} v;\par
754 \}\par
755 \par
756 {\cf20 // ----------------------------------------------------------------------------}\par
757 {\cf20 // specialization for the exact toml types (return type becomes lvalue ref)}\par
758 \par
759 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
760          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
761 detail::enable_if_t<\par
762     detail::is_exact_toml_type<T, basic_value<C, M, V>>::value, T> {\cf17 const}&\par
763 get_or({\cf17 const} basic_value<C, M, V>& v, {\cf17 const} T& opt)\par
764 \{\par
765     {\cf19 try}\par
766     \{\par
767         {\cf19 return} get<detail::remove_cvref_t<T>>(v);\par
768     \}\par
769     {\cf19 catch}(...)\par
770     \{\par
771         {\cf19 return} opt;\par
772     \}\par
773 \}\par
774 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
775          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
776 detail::enable_if_t<\par
777     detail::is_exact_toml_type<T, basic_value<C, M, V>>::value, T>&\par
778 get_or(basic_value<C, M, V>& v, T& opt)\par
779 \{\par
780     {\cf19 try}\par
781     \{\par
782         {\cf19 return} get<detail::remove_cvref_t<T>>(v);\par
783     \}\par
784     {\cf19 catch}(...)\par
785     \{\par
786         {\cf19 return} opt;\par
787     \}\par
788 \}\par
789 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
790          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
791 detail::enable_if_t<detail::is_exact_toml_type<detail::remove_cvref_t<T>,\par
792     basic_value<C, M, V>>::value, detail::remove_cvref_t<T>>\par
793 get_or(basic_value<C, M, V>&& v, T&& opt)\par
794 \{\par
795     {\cf19 try}\par
796     \{\par
797         {\cf19 return} get<detail::remove_cvref_t<T>>(std::move(v));\par
798     \}\par
799     {\cf19 catch}(...)\par
800     \{\par
801         {\cf19 return} detail::remove_cvref_t<T>(std::forward<T>(opt));\par
802     \}\par
803 \}\par
804 \par
805 {\cf20 // ----------------------------------------------------------------------------}\par
806 {\cf20 // specialization for std::string (return type becomes lvalue ref)}\par
807 \par
808 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
809          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
810 detail::enable_if_t<std::is_same<detail::remove_cvref_t<T>, std::string>::value,\par
811     std::string> {\cf17 const}&\par
812 get_or({\cf17 const} basic_value<C, M, V>& v, {\cf17 const} T& opt)\par
813 \{\par
814     {\cf19 try}\par
815     \{\par
816         {\cf19 return} v.as_string().str;\par
817     \}\par
818     {\cf19 catch}(...)\par
819     \{\par
820         {\cf19 return} opt;\par
821     \}\par
822 \}\par
823 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
824          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
825 detail::enable_if_t<std::is_same<T, std::string>::value, std::string>&\par
826 get_or(basic_value<C, M, V>& v, T& opt)\par
827 \{\par
828     {\cf19 try}\par
829     \{\par
830         {\cf19 return} v.as_string().str;\par
831     \}\par
832     {\cf19 catch}(...)\par
833     \{\par
834         {\cf19 return} opt;\par
835     \}\par
836 \}\par
837 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
838          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
839 detail::enable_if_t<\par
840     std::is_same<detail::remove_cvref_t<T>, std::string>::value, std::string>\par
841 get_or(basic_value<C, M, V>&& v, T&& opt)\par
842 \{\par
843     {\cf19 try}\par
844     \{\par
845         {\cf19 return} std::move(v.as_string().str);\par
846     \}\par
847     {\cf19 catch}(...)\par
848     \{\par
849         {\cf19 return} std::string(std::forward<T>(opt));\par
850     \}\par
851 \}\par
852 \par
853 {\cf20 // ----------------------------------------------------------------------------}\par
854 {\cf20 // specialization for string literal}\par
855 \par
856 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
857          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
858 detail::enable_if_t<detail::is_string_literal<\par
859     {\cf17 typename} std::remove_reference<T>::type>::value, std::string>\par
860 get_or({\cf17 const} basic_value<C, M, V>& v, T&& opt)\par
861 \{\par
862     {\cf19 try}\par
863     \{\par
864         {\cf19 return} std::move(v.as_string().str);\par
865     \}\par
866     {\cf19 catch}(...)\par
867     \{\par
868         {\cf19 return} std::string(std::forward<T>(opt));\par
869     \}\par
870 \}\par
871 \par
872 {\cf20 // ----------------------------------------------------------------------------}\par
873 {\cf20 // others (require type conversion and return type cannot be lvalue reference)}\par
874 \par
875 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
876          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
877 detail::enable_if_t<detail::conjunction<\par
878     detail::negation<detail::is_exact_toml_type<detail::remove_cvref_t<T>,\par
879         basic_value<C, M, V>>>,\par
880     detail::negation<std::is_same<std::string, detail::remove_cvref_t<T>>>,\par
881     detail::negation<detail::is_string_literal<\par
882         {\cf17 typename} std::remove_reference<T>::type>>\par
883     >::value, detail::remove_cvref_t<T>>\par
884 get_or({\cf17 const} basic_value<C, M, V>& v, T&& opt)\par
885 \{\par
886     {\cf19 try}\par
887     \{\par
888         {\cf19 return} get<detail::remove_cvref_t<T>>(v);\par
889     \}\par
890     {\cf19 catch}(...)\par
891     \{\par
892         {\cf19 return} detail::remove_cvref_t<T>(std::forward<T>(opt));\par
893     \}\par
894 \}\par
895 \par
896 {\cf20 // ===========================================================================}\par
897 {\cf20 // find_or(value, key, fallback)}\par
898 \par
899 {\cf17 template}<{\cf17 typename} C,\par
900          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
901 basic_value<C, M, V> {\cf17 const}&\par
902 find_or({\cf17 const} basic_value<C, M, V>& v, {\cf17 const} key& ky,\par
903         {\cf17 const} basic_value<C, M, V>& opt)\par
904 \{\par
905     {\cf19 if}(!v.is_table()) \{{\cf19 return} opt;\}\par
906     {\cf17 const} {\cf17 auto}& tab = v.as_table();\par
907     {\cf19 if}(tab.count(ky) == 0) \{{\cf19 return} opt;\}\par
908     {\cf19 return} tab.at(ky);\par
909 \}\par
910 \par
911 {\cf17 template}<{\cf17 typename} C,\par
912          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
913 basic_value<C, M, V>&\par
914 find_or(basic_value<C, M, V>& v, {\cf17 const} toml::key& ky, basic_value<C, M, V>& opt)\par
915 \{\par
916     {\cf19 if}(!v.is_table()) \{{\cf19 return} opt;\}\par
917     {\cf17 auto}& tab = v.as_table();\par
918     {\cf19 if}(tab.count(ky) == 0) \{{\cf19 return} opt;\}\par
919     {\cf19 return} tab.at(ky);\par
920 \}\par
921 \par
922 {\cf17 template}<{\cf17 typename} C,\par
923          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
924 basic_value<C, M, V>\par
925 find_or(basic_value<C, M, V>&& v, {\cf17 const} toml::key& ky, basic_value<C, M, V>&& opt)\par
926 \{\par
927     {\cf19 if}(!v.is_table()) \{{\cf19 return} opt;\}\par
928     {\cf17 auto} tab = std::move(v).as_table();\par
929     {\cf19 if}(tab.count(ky) == 0) \{{\cf19 return} opt;\}\par
930     {\cf19 return} basic_value<C, M, V>(std::move(tab.at(ky)));\par
931 \}\par
932 \par
933 {\cf20 // ---------------------------------------------------------------------------}\par
934 {\cf20 // exact types (return type can be a reference)}\par
935 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
936          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
937 detail::enable_if_t<\par
938     detail::is_exact_toml_type<T, basic_value<C, M, V>>::value, T> {\cf17 const}&\par
939 find_or({\cf17 const} basic_value<C, M, V>& v, {\cf17 const} key& ky, {\cf17 const} T& opt)\par
940 \{\par
941     {\cf19 if}(!v.is_table()) \{{\cf19 return} opt;\}\par
942     {\cf17 const} {\cf17 auto}& tab = v.as_table();\par
943     {\cf19 if}(tab.count(ky) == 0) \{{\cf19 return} opt;\}\par
944     {\cf19 return} get_or(tab.at(ky), opt);\par
945 \}\par
946 \par
947 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
948          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
949 detail::enable_if_t<\par
950     detail::is_exact_toml_type<T, basic_value<C, M, V>>::value, T>&\par
951 find_or(basic_value<C, M, V>& v, {\cf17 const} toml::key& ky, T& opt)\par
952 \{\par
953     {\cf19 if}(!v.is_table()) \{{\cf19 return} opt;\}\par
954     {\cf17 auto}& tab = v.as_table();\par
955     {\cf19 if}(tab.count(ky) == 0) \{{\cf19 return} opt;\}\par
956     {\cf19 return} get_or(tab.at(ky), opt);\par
957 \}\par
958 \par
959 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
960          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
961 detail::enable_if_t<\par
962     detail::is_exact_toml_type<T, basic_value<C, M, V>>::value,\par
963     detail::remove_cvref_t<T>>\par
964 find_or(basic_value<C, M, V>&& v, {\cf17 const} toml::key& ky, T&& opt)\par
965 \{\par
966     {\cf19 if}(!v.is_table()) \{{\cf19 return} std::forward<T>(opt);\}\par
967     {\cf17 auto} tab = std::move(v).as_table();\par
968     {\cf19 if}(tab.count(ky) == 0) \{{\cf19 return} std::forward<T>(opt);\}\par
969     {\cf19 return} get_or(std::move(tab.at(ky)), std::forward<T>(opt));\par
970 \}\par
971 \par
972 {\cf20 // ---------------------------------------------------------------------------}\par
973 {\cf20 // std::string (return type can be a reference)}\par
974 \par
975 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
976          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
977 detail::enable_if_t<std::is_same<T, std::string>::value, std::string> {\cf17 const}&\par
978 find_or({\cf17 const} basic_value<C, M, V>& v, {\cf17 const} key& ky, {\cf17 const} T& opt)\par
979 \{\par
980     {\cf19 if}(!v.is_table()) \{{\cf19 return} opt;\}\par
981     {\cf17 const} {\cf17 auto}& tab = v.as_table();\par
982     {\cf19 if}(tab.count(ky) == 0) \{{\cf19 return} opt;\}\par
983     {\cf19 return} get_or(tab.at(ky), opt);\par
984 \}\par
985 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
986          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
987 detail::enable_if_t<std::is_same<T, std::string>::value, std::string>&\par
988 find_or(basic_value<C, M, V>& v, {\cf17 const} toml::key& ky, T& opt)\par
989 \{\par
990     {\cf19 if}(!v.is_table()) \{{\cf19 return} opt;\}\par
991     {\cf17 auto}& tab = v.as_table();\par
992     {\cf19 if}(tab.count(ky) == 0) \{{\cf19 return} opt;\}\par
993     {\cf19 return} get_or(tab.at(ky), opt);\par
994 \}\par
995 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
996          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
997 detail::enable_if_t<std::is_same<T, std::string>::value, std::string>\par
998 find_or(basic_value<C, M, V>&& v, {\cf17 const} toml::key& ky, T&& opt)\par
999 \{\par
1000     {\cf19 if}(!v.is_table()) \{{\cf19 return} std::forward<T>(opt);\}\par
1001     {\cf17 auto} tab = std::move(v).as_table();\par
1002     {\cf19 if}(tab.count(ky) == 0) \{{\cf19 return} std::forward<T>(opt);\}\par
1003     {\cf19 return} get_or(std::move(tab.at(ky)), std::forward<T>(opt));\par
1004 \}\par
1005 \par
1006 {\cf20 // ---------------------------------------------------------------------------}\par
1007 {\cf20 // string literal (deduced as std::string)}\par
1008 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
1009          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
1010 detail::enable_if_t<\par
1011     detail::is_string_literal<typename std::remove_reference<T>::type>::value,\par
1012     std::string>\par
1013 find_or({\cf17 const} basic_value<C, M, V>& v, {\cf17 const} toml::key& ky, T&& opt)\par
1014 \{\par
1015     {\cf19 if}(!v.is_table()) \{{\cf19 return} std::string(opt);\}\par
1016     {\cf17 const} {\cf17 auto}& tab = v.as_table();\par
1017     {\cf19 if}(tab.count(ky) == 0) \{{\cf19 return} std::string(opt);\}\par
1018     {\cf19 return} get_or(tab.at(ky), std::forward<T>(opt));\par
1019 \}\par
1020 \par
1021 {\cf20 // ---------------------------------------------------------------------------}\par
1022 {\cf20 // others (require type conversion and return type cannot be lvalue reference)}\par
1023 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
1024          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
1025 detail::enable_if_t<detail::conjunction<\par
1026     {\cf20 // T is not an exact toml type}\par
1027     detail::negation<detail::is_exact_toml_type<\par
1028         detail::remove_cvref_t<T>, basic_value<C, M, V>>>,\par
1029     {\cf20 // T is not std::string}\par
1030     detail::negation<std::is_same<std::string, detail::remove_cvref_t<T>>>,\par
1031     {\cf20 // T is not a string literal}\par
1032     detail::negation<detail::is_string_literal<\par
1033         {\cf17 typename} std::remove_reference<T>::type>>\par
1034     >::value, detail::remove_cvref_t<T>>\par
1035 find_or({\cf17 const} basic_value<C, M, V>& v, {\cf17 const} toml::key& ky, T&& opt)\par
1036 \{\par
1037     {\cf19 if}(!v.is_table()) \{{\cf19 return} std::forward<T>(opt);\}\par
1038     {\cf17 const} {\cf17 auto}& tab = v.as_table();\par
1039     {\cf19 if}(tab.count(ky) == 0) \{{\cf19 return} std::forward<T>(opt);\}\par
1040     {\cf19 return} get_or(tab.at(ky), std::forward<T>(opt));\par
1041 \}\par
1042 \par
1043 {\cf20 // ---------------------------------------------------------------------------}\par
1044 {\cf20 // recursive find-or with type deduction (find_or(value, keys, opt))}\par
1045 \par
1046 {\cf17 template}<{\cf17 typename} Value, {\cf17 typename} ... Ks,\par
1047          {\cf17 typename} detail::enable_if_t<({\cf17 sizeof}...(Ks) > 1), std::nullptr_t> = {\cf17 nullptr}>\par
1048          {\cf20 // here we need to add SFINAE in the template parameter to avoid}\par
1049          {\cf20 // infinite recursion in type deduction on gcc}\par
1050 {\cf17 auto} find_or(Value&& v, {\cf17 const} toml::key& ky, Ks&& ... keys)\par
1051     -> {\cf17 decltype}(find_or(std::forward<Value>(v), ky, detail::last_one(std::forward<Ks>(keys)...)))\par
1052 \{\par
1053     {\cf19 if}(!v.is_table())\par
1054     \{\par
1055         {\cf19 return} detail::last_one(std::forward<Ks>(keys)...);\par
1056     \}\par
1057     {\cf17 auto}&& tab = std::forward<Value>(v).as_table();\par
1058     {\cf19 if}(tab.count(ky) == 0)\par
1059     \{\par
1060         {\cf19 return} detail::last_one(std::forward<Ks>(keys)...);\par
1061     \}\par
1062     {\cf19 return} find_or(std::forward<{\cf17 decltype}(tab)>(tab).at(ky), std::forward<Ks>(keys)...);\par
1063 \}\par
1064 \par
1065 {\cf20 // ---------------------------------------------------------------------------}\par
1066 {\cf20 // recursive find_or with explicit type specialization, find_or<int>(value, keys...)}\par
1067 \par
1068 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} Value, {\cf17 typename} ... Ks,\par
1069          {\cf17 typename} detail::enable_if_t<({\cf17 sizeof}...(Ks) > 1), std::nullptr_t> = {\cf17 nullptr}>\par
1070          {\cf20 // here we need to add SFINAE in the template parameter to avoid}\par
1071          {\cf20 // infinite recursion in type deduction on gcc}\par
1072 {\cf17 auto} find_or(Value&& v, {\cf17 const} toml::key& ky, Ks&& ... keys)\par
1073     -> {\cf17 decltype}(find_or<T>(std::forward<Value>(v), ky, detail::last_one(std::forward<Ks>(keys)...)))\par
1074 \{\par
1075     {\cf19 if}(!v.is_table())\par
1076     \{\par
1077         {\cf19 return} detail::last_one(std::forward<Ks>(keys)...);\par
1078     \}\par
1079     {\cf17 auto}&& tab = std::forward<Value>(v).as_table();\par
1080     {\cf19 if}(tab.count(ky) == 0)\par
1081     \{\par
1082         {\cf19 return} detail::last_one(std::forward<Ks>(keys)...);\par
1083     \}\par
1084     {\cf19 return} find_or(std::forward<{\cf17 decltype}(tab)>(tab).at(ky), std::forward<Ks>(keys)...);\par
1085 \}\par
1086 \par
1087 {\cf20 // ============================================================================}\par
1088 {\cf20 // expect}\par
1089 \par
1090 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
1091          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
1092 result<T, std::string> expect({\cf17 const} basic_value<C, M, V>& v) {\cf17 noexcept}\par
1093 \{\par
1094     {\cf19 try}\par
1095     \{\par
1096         {\cf19 return} ok(get<T>(v));\par
1097     \}\par
1098     {\cf19 catch}({\cf17 const} std::exception& e)\par
1099     \{\par
1100         {\cf19 return} err(e.what());\par
1101     \}\par
1102 \}\par
1103 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
1104          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
1105 result<T, std::string>\par
1106 expect({\cf17 const} basic_value<C, M, V>& v, {\cf17 const} toml::key& k) {\cf17 noexcept}\par
1107 \{\par
1108     {\cf19 try}\par
1109     \{\par
1110         {\cf19 return} ok(find<T>(v, k));\par
1111     \}\par
1112     {\cf19 catch}({\cf17 const} std::exception& e)\par
1113     \{\par
1114         {\cf19 return} err(e.what());\par
1115     \}\par
1116 \}\par
1117 \par
1118 \} {\cf20 // toml}\par
1119 {\cf21 #endif}{\cf20 // TOML11_GET}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/into.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/into.hpp}
{\xe \v external/toml/into.hpp}
{\bkmkstart AAAAAAAACD}
{\bkmkend AAAAAAAACD}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
into.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/into.hpp}
{\xe \v external/toml/into.hpp}
{\bkmkstart AAAAAAAAAM}
{\bkmkend AAAAAAAAAM}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2019.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_INTO_HPP}\par
4 {\cf21 #define TOML11_INTO_HPP}\par
5 \par
6 {\cf17 namespace }toml\par
7 \{\par
8 \par
9 {\cf17 template}<{\cf17 typename} T>\par
10 {\cf17 struct }into;\par
11 {\cf20 // \{}\par
12 {\cf20 //     static toml::value into_toml(const T& user_defined_type)}\par
13 {\cf20 //     \{}\par
14 {\cf20 //         // User-defined conversions ...}\par
15 {\cf20 //     \}}\par
16 {\cf20 // \};}\par
17 \par
18 \} {\cf20 // toml}\par
19 {\cf21 #endif }{\cf20 // TOML11_INTO_HPP}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/lexer.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/lexer.hpp}
{\xe \v external/toml/lexer.hpp}
{\bkmkstart AAAAAAAACE}
{\bkmkend AAAAAAAACE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <istream>}\par
{\f2 #include <sstream>}\par
{\f2 #include <stdexcept>}\par
{\f2 #include <fstream>}\par
{\f2 #include "combinator.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_wschar} = either< character<' '>, character<'\\t'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_ws} = repeat< lex_wschar, at_least< 1 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_newline} = either< character<'\\n'>, sequence< character<'\\r'>, character<'\\n'> > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_lower} = in_range< 'a', 'z'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_upper} = in_range< 'A', 'Z'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_alpha} = either< lex_lower, lex_upper >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_digit} = in_range< '0', '9'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_nonzero} = in_range< '1', '9'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_oct_dig} = in_range< '0', '7'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_bin_dig} = in_range< '0', '1'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_hex_dig} = either< lex_digit, in_range< 'A', 'F'>, in_range< 'a', 'f'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_hex_prefix} = sequence< character< '0'>, character< 'x'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_oct_prefix} = sequence< character< '0'>, character< 'o'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_bin_prefix} = sequence< character< '0'>, character< 'b'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_underscore} = character< '_'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_plus} = character<'+'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_minus} = character<'-'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_sign} = either< lex_plus, lex_minus >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_unsigned_dec_int} = either< sequence< lex_nonzero, repeat< either< lex_digit, sequence< lex_underscore, lex_digit > >, at_least< 1 > > >, lex_digit >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_dec_int} = sequence< maybe< lex_sign >, lex_unsigned_dec_int >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_hex_int} = sequence< lex_hex_prefix, sequence< lex_hex_dig, repeat< either< lex_hex_dig, sequence< lex_underscore, lex_hex_dig > >, unlimited > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_oct_int} = sequence< lex_oct_prefix, sequence< lex_oct_dig, repeat< either< lex_oct_dig, sequence< lex_underscore, lex_oct_dig > >, unlimited > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_bin_int} = sequence< lex_bin_prefix, sequence< lex_bin_dig, repeat< either< lex_bin_dig, sequence< lex_underscore, lex_bin_dig > >, unlimited > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_integer} = either< lex_bin_int, lex_oct_int, lex_hex_int, lex_dec_int >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_inf} = sequence< character< 'i'>, character< 'n'>, character< 'f'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_nan} = sequence< character< 'n'>, character< 'a'>, character< 'n'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_special_float} = sequence< maybe< lex_sign >, either< lex_inf, lex_nan > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_zero_prefixable_int} = sequence< lex_digit, repeat< either< lex_digit, sequence< lex_underscore, lex_digit > >, unlimited > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_fractional_part} = sequence< character<'.'>, lex_zero_prefixable_int >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_exponent_part} = sequence< either< character< 'e'>, character< 'E'> >, maybe< lex_sign >, lex_zero_prefixable_int >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_float} = either< lex_special_float, sequence< lex_dec_int, either< lex_exponent_part, sequence< lex_fractional_part, maybe< lex_exponent_part > > > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_true} = sequence< character< 't'>, character< 'r'>, character< 'u'>, character< 'e'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_false} = sequence< character< 'f'>, character< 'a'>, character< 'l'>, character< 's'>, character< 'e'> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_boolean} = either< lex_true, lex_false >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_date_fullyear} = repeat< lex_digit, exactly< 4 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_date_month} = repeat< lex_digit, exactly< 2 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_date_mday} = repeat< lex_digit, exactly< 2 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_time_delim} = either< character< 'T'>, character< 't'>, character<' '> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_time_hour} = repeat< lex_digit, exactly< 2 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_time_minute} = repeat< lex_digit, exactly< 2 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_time_second} = repeat< lex_digit, exactly< 2 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_time_secfrac} = sequence< character<'.'>, repeat< lex_digit, at_least< 1 > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_time_numoffset} = sequence< either< character<'+'>, character<'-'> >, sequence< lex_time_hour, character<':'>, lex_time_minute > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_time_offset} = either< character< 'Z'>, character< 'z'>, lex_time_numoffset >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_partial_time} = sequence< lex_time_hour, character<':'>, lex_time_minute, character<':'>, lex_time_second, maybe< lex_time_secfrac > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_full_date} = sequence< lex_date_fullyear, character<'-'>, lex_date_month, character<'-'>, lex_date_mday >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_full_time} = sequence< lex_partial_time, lex_time_offset >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_offset_date_time} = sequence< lex_full_date, lex_time_delim, lex_full_time >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_local_date_time} = sequence< lex_full_date, lex_time_delim, lex_partial_time >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_local_date} = lex_full_date\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_local_time} = lex_partial_time\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_quotation_mark} = character<'"'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_basic_unescaped} = exclude< either< in_range< 0x00, 0x08 >, in_range< 0x0A, 0x1F >, character< 0x22 >, character< 0x5C >, character< 0x7F > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_escape} = character<'\\\\'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_escape_unicode_short} = sequence< character< 'u'>, repeat< lex_hex_dig, exactly< 4 > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_escape_unicode_long} = sequence< character< 'U'>, repeat< lex_hex_dig, exactly< 8 > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_escape_seq_char} = either< character<'"'>, character<'\\\\'>, character<'b'>, character<'f'>, character<'n'>, character<'r'>, character<'t'>, lex_escape_unicode_short, lex_escape_unicode_long >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_escaped} = sequence< lex_escape, lex_escape_seq_char >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_basic_char} = either< lex_basic_unescaped, lex_escaped >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_basic_string} = sequence< lex_quotation_mark, repeat< lex_basic_char, unlimited >, lex_quotation_mark >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_ml_basic_string_delim} = repeat< lex_quotation_mark, exactly< 3 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_ml_basic_string_open} = lex_ml_basic_string_delim\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_ml_basic_string_close} = sequence< repeat< lex_quotation_mark, exactly< 3 > >, maybe< lex_quotation_mark >, maybe< lex_quotation_mark > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_ml_basic_unescaped} = exclude< either< in_range< 0x00, 0x08 >, in_range< 0x0A, 0x1F >, character< 0x5C >, character< 0x7F >, lex_ml_basic_string_delim > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_ml_basic_escaped_newline} = sequence< lex_escape, maybe< lex_ws >, lex_newline, repeat< either< lex_ws, lex_newline >, unlimited > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_ml_basic_char} = either< lex_ml_basic_unescaped, lex_escaped >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_ml_basic_body} = repeat< either< lex_ml_basic_char, lex_newline, lex_ml_basic_escaped_newline >, unlimited >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_ml_basic_string} = sequence< lex_ml_basic_string_open, lex_ml_basic_body, lex_ml_basic_string_close >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_literal_char} = exclude< either< in_range< 0x00, 0x08 >, in_range< 0x0A, 0x1F >, character< 0x7F >, character< 0x27 > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_apostrophe} = character<'\\''>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_literal_string} = sequence< lex_apostrophe, repeat< lex_literal_char, unlimited >, lex_apostrophe >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_ml_literal_string_delim} = repeat< lex_apostrophe, exactly< 3 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_ml_literal_string_open} = lex_ml_literal_string_delim\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_ml_literal_string_close} = sequence< repeat< lex_apostrophe, exactly< 3 > >, maybe< lex_apostrophe >, maybe< lex_apostrophe > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_ml_literal_char} = exclude< either< in_range< 0x00, 0x08 >, in_range< 0x0A, 0x1F >, character< 0x7F >, lex_ml_literal_string_delim > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_ml_literal_body} = repeat< either< lex_ml_literal_char, lex_newline >, unlimited >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_ml_literal_string} = sequence< lex_ml_literal_string_open, lex_ml_literal_body, lex_ml_literal_string_close >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_string} = either< lex_ml_basic_string, lex_basic_string, lex_ml_literal_string, lex_literal_string >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_dot_sep} = sequence< maybe< lex_ws >, character<'.'>, maybe< lex_ws > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_unquoted_key} = repeat< either< lex_alpha, lex_digit, character<'-'>, character< '_'> >, at_least< 1 > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_quoted_key} = either< lex_basic_string, lex_literal_string >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_simple_key} = either< lex_unquoted_key, lex_quoted_key >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_dotted_key} = sequence< lex_simple_key, repeat< sequence< lex_dot_sep, lex_simple_key >, at_least< 1 > > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_key} = either< lex_dotted_key, lex_simple_key >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_keyval_sep} = sequence< maybe< lex_ws >, character<'='>, maybe< lex_ws > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_std_table_open} = character<'['>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_std_table_close} = character<']'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_std_table} = sequence< lex_std_table_open, maybe< lex_ws >, lex_key, maybe< lex_ws >, lex_std_table_close >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_array_table_open} = sequence< lex_std_table_open, lex_std_table_open >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_array_table_close} = sequence< lex_std_table_close, lex_std_table_close >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_array_table} = sequence< lex_array_table_open, maybe< lex_ws >, lex_key, maybe< lex_ws >, lex_array_table_close >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_utf8_1byte} = in_range< 0x00, 0x7F >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_utf8_2byte} = sequence< in_range< static_cast< char >(0xC2), static_cast< char >(0xDF)>, in_range< static_cast< char >(0x80), static_cast< char >(0xBF)> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_utf8_3byte} = sequence< either< sequence< character< static_cast< char >(0xE0)>, in_range< static_cast< char >(0xA0), static_cast< char >(0xBF)> >, sequence< in_range< static_cast< char >(0xE1), static_cast< char >(0xEC)>, in_range< static_cast< char >(0x80), static_cast< char >(0xBF)> >, sequence< character< static_cast< char >(0xED)>, in_range< static_cast< char >(0x80), static_cast< char >(0x9F)> >, sequence< in_range< static_cast< char >(0xEE), static_cast< char >(0xEF)>, in_range< static_cast< char >(0x80), static_cast< char >(0xBF)> > >, in_range< static_cast< char >(0x80), static_cast< char >(0xBF)> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_utf8_4byte} = sequence< either< sequence< character< static_cast< char >(0xF0)>, in_range< static_cast< char >(0x90), static_cast< char >(0xBF)> >, sequence< in_range< static_cast< char >(0xF1), static_cast< char >(0xF3)>, in_range< static_cast< char >(0x80), static_cast< char >(0xBF)> >, sequence< character< static_cast< char >(0xF4)>, in_range< static_cast< char >(0x80), static_cast< char >(0x8F)> > >, in_range< static_cast< char >(0x80), static_cast< char >(0xBF)>, in_range< static_cast< char >(0x80), static_cast< char >(0xBF)> >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_utf8_code} = either< lex_utf8_1byte, lex_utf8_2byte, lex_utf8_3byte, lex_utf8_4byte >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_comment_start_symbol} = character<'#'>\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_non_eol_ascii} = either< character< 0x09 >, in_range< 0x20, 0x7E > >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::detail::lex_comment} = sequence< lex_comment_start_symbol, repeat< either< lex_non_eol_ascii, lex_utf8_2byte, lex_utf8_3byte, lex_utf8_4byte >, unlimited > >\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
lexer.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/lexer.hpp}
{\xe \v external/toml/lexer.hpp}
{\bkmkstart AAAAAAAAAN}
{\bkmkend AAAAAAAAAN}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2017.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_LEXER_HPP}\par
4 {\cf21 #define TOML11_LEXER_HPP}\par
5 {\cf21 #include <istream>}\par
6 {\cf21 #include <sstream>}\par
7 {\cf21 #include <stdexcept>}\par
8 {\cf21 #include <fstream>}\par
9 \par
10 {\cf21 #include "combinator.hpp"}\par
11 \par
12 {\cf17 namespace }toml\par
13 \{\par
14 {\cf17 namespace }detail\par
15 \{\par
16 \par
17 {\cf20 // these scans contents from current location in a container of char}\par
18 {\cf20 // and extract a region that matches their own pattern.}\par
19 {\cf20 // to see the implementation of each component, see combinator.hpp.}\par
20 \par
21 {\cf17 using }lex_wschar  = either<character<' '>, character<'\\t'>>;\par
22 {\cf17 using }lex_ws      = repeat<lex_wschar, at_least<1>>;\par
23 {\cf17 using }lex_newline = either<character<'\\n'>,\par
24                            sequence<character<'\\r'>, character<'\\n'>>>;\par
25 {\cf17 using }lex_lower   = in_range<'a', 'z'>;\par
26 {\cf17 using }lex_upper   = in_range<'A', 'Z'>;\par
27 {\cf17 using }lex_alpha   = either<lex_lower, lex_upper>;\par
28 {\cf17 using }lex_digit   = in_range<'0', '9'>;\par
29 {\cf17 using }lex_nonzero = in_range<'1', '9'>;\par
30 {\cf17 using }lex_oct_dig = in_range<'0', '7'>;\par
31 {\cf17 using }lex_bin_dig = in_range<'0', '1'>;\par
32 {\cf17 using }lex_hex_dig = either<lex_digit, in_range<'A', 'F'>, in_range<'a', 'f'>>;\par
33 \par
34 {\cf17 using }lex_hex_prefix = sequence<character<'0'>, character<'x'>>;\par
35 {\cf17 using }lex_oct_prefix = sequence<character<'0'>, character<'o'>>;\par
36 {\cf17 using }lex_bin_prefix = sequence<character<'0'>, character<'b'>>;\par
37 {\cf17 using }lex_underscore = character<'_'>;\par
38 {\cf17 using }lex_plus       = character<'+'>;\par
39 {\cf17 using }lex_minus      = character<{\cf23 '-'}>;\par
40 {\cf17 using }lex_sign       = either<lex_plus, lex_minus>;\par
41 \par
42 {\cf20 // digit | nonzero 1*(digit | _ digit)}\par
43 {\cf17 using }lex_unsigned_dec_int = either<sequence<lex_nonzero, repeat<\par
44     either<lex_digit, sequence<lex_underscore, lex_digit>>, at_least<1>>>,\par
45     lex_digit>;\par
46 {\cf20 // (+|-)? unsigned_dec_int}\par
47 {\cf17 using }lex_dec_int = sequence<maybe<lex_sign>, lex_unsigned_dec_int>;\par
48 \par
49 {\cf20 // hex_prefix hex_dig *(hex_dig | _ hex_dig)}\par
50 {\cf17 using }lex_hex_int = sequence<lex_hex_prefix, sequence<lex_hex_dig, repeat<\par
51     either<lex_hex_dig, sequence<lex_underscore, lex_hex_dig>>, unlimited>>>;\par
52 {\cf20 // oct_prefix oct_dig *(oct_dig | _ oct_dig)}\par
53 {\cf17 using }lex_oct_int = sequence<lex_oct_prefix, sequence<lex_oct_dig, repeat<\par
54     either<lex_oct_dig, sequence<lex_underscore, lex_oct_dig>>, unlimited>>>;\par
55 {\cf20 // bin_prefix bin_dig *(bin_dig | _ bin_dig)}\par
56 {\cf17 using }lex_bin_int = sequence<lex_bin_prefix, sequence<lex_bin_dig, repeat<\par
57     either<lex_bin_dig, sequence<lex_underscore, lex_bin_dig>>, unlimited>>>;\par
58 \par
59 {\cf20 // (dec_int | hex_int | oct_int | bin_int)}\par
60 {\cf17 using }lex_integer = either<lex_bin_int, lex_oct_int, lex_hex_int, lex_dec_int>;\par
61 \par
62 {\cf20 // ===========================================================================}\par
63 \par
64 {\cf17 using }lex_inf = sequence<character<'i'>, character<'n'>, character<'f'>>;\par
65 {\cf17 using }lex_nan = sequence<character<'n'>, character<'a'>, character<'n'>>;\par
66 {\cf17 using }lex_special_float = sequence<maybe<lex_sign>, either<lex_inf, lex_nan>>;\par
67 \par
68 {\cf17 using }lex_zero_prefixable_int = sequence<lex_digit, repeat<either<lex_digit,\par
69     sequence<lex_underscore, lex_digit>>, unlimited>>;\par
70 \par
71 {\cf17 using }lex_fractional_part = sequence<character<{\cf23 '.'}>, lex_zero_prefixable_int>;\par
72 \par
73 {\cf17 using }lex_exponent_part   = sequence<either<character<'e'>, character<'E'>>,\par
74         maybe<lex_sign>, lex_zero_prefixable_int>;\par
75 \par
76 {\cf17 using }lex_float = either<lex_special_float,\par
77       sequence<lex_dec_int, either<lex_exponent_part,\par
78       sequence<lex_fractional_part, maybe<lex_exponent_part>>>>>;\par
79 \par
80 {\cf20 // ===========================================================================}\par
81 \par
82 {\cf17 using }lex_true = sequence<character<'t'>, character<'r'>,\par
83                           character<'u'>, character<'e'>>;\par
84 {\cf17 using }lex_false = sequence<character<'f'>, character<'a'>, character<'l'>,\par
85                            character<'s'>, character<'e'>>;\par
86 {\cf17 using }lex_boolean = either<lex_true, lex_false>;\par
87 \par
88 {\cf20 // ===========================================================================}\par
89 \par
90 {\cf17 using }lex_date_fullyear = repeat<lex_digit, exactly<4>>;\par
91 {\cf17 using }lex_date_month    = repeat<lex_digit, exactly<2>>;\par
92 {\cf17 using }lex_date_mday     = repeat<lex_digit, exactly<2>>;\par
93 {\cf17 using }lex_time_delim    = either<character<'T'>, character<'t'>, character<' '>>;\par
94 {\cf17 using }lex_time_hour     = repeat<lex_digit, exactly<2>>;\par
95 {\cf17 using }lex_time_minute   = repeat<lex_digit, exactly<2>>;\par
96 {\cf17 using }lex_time_second   = repeat<lex_digit, exactly<2>>;\par
97 {\cf17 using }lex_time_secfrac  = sequence<character<{\cf23 '.'}>,\par
98                                    repeat<lex_digit, at_least<1>>>;\par
99 \par
100 {\cf17 using }lex_time_numoffset = sequence<either<character<'+'>, character<{\cf23 '-'}>>,\par
101                                     sequence<lex_time_hour, character<':'>,\par
102                                              lex_time_minute>>;\par
103 {\cf17 using }lex_time_offset = either<character<'Z'>, character<'z'>,\par
104                                lex_time_numoffset>;\par
105 \par
106 {\cf17 using }lex_partial_time = sequence<lex_time_hour,   character<':'>,\par
107                                   lex_time_minute, character<':'>,\par
108                                   lex_time_second, maybe<lex_time_secfrac>>;\par
109 {\cf17 using }lex_full_date    = sequence<lex_date_fullyear, character<{\cf23 '-'}>,\par
110                                   lex_date_month,    character<{\cf23 '-'}>,\par
111                                   lex_date_mday>;\par
112 {\cf17 using }lex_full_time    = sequence<lex_partial_time, lex_time_offset>;\par
113 \par
114 {\cf17 using }lex_offset_date_time = sequence<lex_full_date, lex_time_delim, lex_full_time>;\par
115 {\cf17 using }lex_local_date_time  = sequence<lex_full_date, lex_time_delim, lex_partial_time>;\par
116 {\cf17 using }lex_local_date       = lex_full_date;\par
117 {\cf17 using }lex_local_time       = lex_partial_time;\par
118 \par
119 {\cf20 // ===========================================================================}\par
120 \par
121 {\cf17 using }lex_quotation_mark  = character<{\cf23 '"'}>;\par
122 {\cf17 using }lex_basic_unescaped = exclude<either<in_range<0x00, 0x08>, {\cf20 // 0x09 (tab) is allowed}\par
123                                            in_range<0x0A, 0x1F>,\par
124                                            character<0x22>, character<0x5C>,\par
125                                            character<0x7F>>>;\par
126 \par
127 {\cf17 using }lex_escape          = character<'\\\\'>;\par
128 {\cf17 using }lex_escape_unicode_short = sequence<character<'u'>,\par
129                                           repeat<lex_hex_dig, exactly<4>>>;\par
130 {\cf17 using }lex_escape_unicode_long  = sequence<character<'U'>,\par
131                                           repeat<lex_hex_dig, exactly<8>>>;\par
132 {\cf17 using }lex_escape_seq_char = either<character<{\cf23 '"'}>, character<'\\\\'>,\par
133                                    character<'b'>, character<'f'>,\par
134                                    character<'n'>, character<'r'>,\par
135                                    character<'t'>,\par
136                                    lex_escape_unicode_short,\par
137                                    lex_escape_unicode_long\par
138                                    >;\par
139 {\cf17 using }lex_escaped      = sequence<lex_escape, lex_escape_seq_char>;\par
140 {\cf17 using }lex_basic_char   = either<lex_basic_unescaped, lex_escaped>;\par
141 {\cf17 using }lex_basic_string = sequence<lex_quotation_mark,\par
142                                   repeat<lex_basic_char, unlimited>,\par
143                                   lex_quotation_mark>;\par
144 \par
145 {\cf20 // After toml post-v0.5.0, it is explicitly clarified how quotes in ml-strings}\par
146 {\cf20 // are allowed to be used.}\par
147 {\cf20 // After this, the following strings are *explicitly* allowed.}\par
148 {\cf20 // - One or two `"`s in a multi-line basic string is allowed wherever it is.}\par
149 {\cf20 // - Three consecutive `"`s in a multi-line basic string is considered as a delimiter.}\par
150 {\cf20 // - One or two `"`s can appear just before or after the delimiter.}\par
151 {\cf20 // ```toml}\par
152 {\cf20 // str4 = """Here are two quotation marks: "". Simple enough."""}\par
153 {\cf20 // str5 = """Here are three quotation marks: ""\\"."""}\par
154 {\cf20 // str6 = """Here are fifteen quotation marks: ""\\"""\\"""\\"""\\"""\\"."""}\par
155 {\cf20 // str7 = """"This," she said, "is just a pointless statement.""""}\par
156 {\cf20 // ```}\par
157 {\cf20 // In the current implementation (v3.3.0), it is difficult to parse `str7` in}\par
158 {\cf20 // the above example. It is difficult to recognize `"` at the end of string body}\par
159 {\cf20 // collectly. It will be misunderstood as a `"""` delimiter and an additional,}\par
160 {\cf20 // invalid `"`. Like this:}\par
161 {\cf20 // ```console}\par
162 {\cf20 //   what():  [error] toml::parse_table: invalid line format}\par
163 {\cf20 //  --> hoge.toml}\par
164 {\cf20 //     |}\par
165 {\cf20 //  13 | str7 = """"This," she said, "is just a pointless statement.""""}\par
166 {\cf20 //     |                                                               ^- expected newline, but got '"'.}\par
167 {\cf20 // ```}\par
168 {\cf20 // As a quick workaround for this problem, `lex_ml_basic_string_delim` was}\par
169 {\cf20 // split into two, `lex_ml_basic_string_open` and `lex_ml_basic_string_close`.}\par
170 {\cf20 // `lex_ml_basic_string_open` allows only `"""`. `_close` allows 3-5 `"`s.}\par
171 {\cf20 // In parse_ml_basic_string() function, the trailing `"`s will be attached to}\par
172 {\cf20 // the string body.}\par
173 {\cf20 //}\par
174 {\cf17 using }lex_ml_basic_string_delim = repeat<lex_quotation_mark, exactly<3>>;\par
175 {\cf17 using }lex_ml_basic_string_open  = lex_ml_basic_string_delim;\par
176 {\cf17 using }lex_ml_basic_string_close = sequence<\par
177         repeat<lex_quotation_mark, exactly<3>>,\par
178         maybe<lex_quotation_mark>, maybe<lex_quotation_mark>\par
179     >;\par
180 \par
181 {\cf17 using }lex_ml_basic_unescaped    = exclude<either<in_range<0x00, 0x08>, {\cf20 // 0x09 is tab}\par
182                                                  in_range<0x0A, 0x1F>,\par
183                                                  character<0x5C>, {\cf20 // backslash}\par
184                                                  character<0x7F>, {\cf20 // DEL}\par
185                                                  lex_ml_basic_string_delim>>;\par
186 \par
187 {\cf17 using }lex_ml_basic_escaped_newline = sequence<\par
188         lex_escape, maybe<lex_ws>, lex_newline,\par
189         repeat<either<lex_ws, lex_newline>, unlimited>>;\par
190 \par
191 {\cf17 using }lex_ml_basic_char = either<lex_ml_basic_unescaped, lex_escaped>;\par
192 {\cf17 using }lex_ml_basic_body = repeat<either<lex_ml_basic_char, lex_newline,\par
193                                         lex_ml_basic_escaped_newline>,\par
194                                  unlimited>;\par
195 {\cf17 using }lex_ml_basic_string = sequence<lex_ml_basic_string_open,\par
196                                      lex_ml_basic_body,\par
197                                      lex_ml_basic_string_close>;\par
198 \par
199 {\cf17 using }lex_literal_char = exclude<either<in_range<0x00, 0x08>, in_range<0x0A, 0x1F>,\par
200                                         character<0x7F>, character<0x27>>>;\par
201 {\cf17 using }lex_apostrophe = character<'\\''>;\par
202 {\cf17 using }lex_literal_string = sequence<lex_apostrophe,\par
203                                     repeat<lex_literal_char, unlimited>,\par
204                                     lex_apostrophe>;\par
205 \par
206 {\cf20 // the same reason as above.}\par
207 {\cf17 using }lex_ml_literal_string_delim = repeat<lex_apostrophe, exactly<3>>;\par
208 {\cf17 using }lex_ml_literal_string_open  = lex_ml_literal_string_delim;\par
209 {\cf17 using }lex_ml_literal_string_close = sequence<\par
210         repeat<lex_apostrophe, exactly<3>>,\par
211         maybe<lex_apostrophe>, maybe<lex_apostrophe>\par
212     >;\par
213 \par
214 {\cf17 using }lex_ml_literal_char = exclude<either<in_range<0x00, 0x08>,\par
215                                            in_range<0x0A, 0x1F>,\par
216                                            character<0x7F>,\par
217                                            lex_ml_literal_string_delim>>;\par
218 {\cf17 using }lex_ml_literal_body = repeat<either<lex_ml_literal_char, lex_newline>,\par
219                                    unlimited>;\par
220 {\cf17 using }lex_ml_literal_string = sequence<lex_ml_literal_string_open,\par
221                                        lex_ml_literal_body,\par
222                                        lex_ml_literal_string_close>;\par
223 \par
224 {\cf17 using }lex_string = either<lex_ml_basic_string,   lex_basic_string,\par
225                           lex_ml_literal_string, lex_literal_string>;\par
226 \par
227 {\cf20 // ===========================================================================}\par
228 {\cf17 using }lex_dot_sep = sequence<maybe<lex_ws>, character<{\cf23 '.'}>, maybe<lex_ws>>;\par
229 \par
230 {\cf17 using }lex_unquoted_key = repeat<either<lex_alpha, lex_digit,\par
231                                        character<{\cf23 '-'}>, character<'_'>>,\par
232                                 at_least<1>>;\par
233 {\cf17 using }lex_quoted_key = either<lex_basic_string, lex_literal_string>;\par
234 {\cf17 using }lex_simple_key = either<lex_unquoted_key, lex_quoted_key>;\par
235 {\cf17 using }lex_dotted_key = sequence<lex_simple_key,\par
236                                 repeat<sequence<lex_dot_sep, lex_simple_key>,\par
237                                        at_least<1>\par
238                                        >\par
239                                 >;\par
240 {\cf17 using }lex_key = either<lex_dotted_key, lex_simple_key>;\par
241 \par
242 {\cf17 using }lex_keyval_sep = sequence<maybe<lex_ws>,\par
243                                 character<'='>,\par
244                                 maybe<lex_ws>>;\par
245 \par
246 {\cf17 using }lex_std_table_open  = character<'['>;\par
247 {\cf17 using }lex_std_table_close = character<']'>;\par
248 {\cf17 using }lex_std_table       = sequence<lex_std_table_open,\par
249                                      maybe<lex_ws>,\par
250                                      lex_key,\par
251                                      maybe<lex_ws>,\par
252                                      lex_std_table_close>;\par
253 \par
254 {\cf17 using }lex_array_table_open  = sequence<lex_std_table_open,  lex_std_table_open>;\par
255 {\cf17 using }lex_array_table_close = sequence<lex_std_table_close, lex_std_table_close>;\par
256 {\cf17 using }lex_array_table       = sequence<lex_array_table_open,\par
257                                        maybe<lex_ws>,\par
258                                        lex_key,\par
259                                        maybe<lex_ws>,\par
260                                        lex_array_table_close>;\par
261 \par
262 {\cf17 using }lex_utf8_1byte = in_range<0x00, 0x7F>;\par
263 {\cf17 using }lex_utf8_2byte = sequence<\par
264         in_range<static_cast<char>(0xC2), {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xDF)>,\par
265         in_range<{\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80), {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xBF)>\par
266     >;\par
267 {\cf17 using }lex_utf8_3byte = sequence<either<\par
268         sequence<character<static_cast<char>(0xE0)>,                          in_range<static_cast<char>(0xA0), {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xBF)>>,\par
269         sequence<in_range <{\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xE1), {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xEC)>, in_range<{\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80), {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xBF)>>,\par
270         sequence<character<{\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xED)>,                          in_range<static_cast<char>(0x80), {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x9F)>>,\par
271         sequence<in_range <{\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xEE), {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xEF)>, in_range<{\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80), {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xBF)>>\par
272     >, in_range<{\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80), {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xBF)>>;\par
273 {\cf17 using }lex_utf8_4byte = sequence<either<\par
274         sequence<character<static_cast<char>(0xF0)>,                          in_range<static_cast<char>(0x90), {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xBF)>>,\par
275         sequence<in_range <{\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xF1), {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xF3)>, in_range<{\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80), {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xBF)>>,\par
276         sequence<character<{\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xF4)>,                          in_range<static_cast<char>(0x80), {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x8F)>>\par
277     >, in_range<{\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80), {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xBF)>,\par
278        in_range<{\cf17 static_cast<}{\cf18 char}{\cf17 >}(0x80), {\cf17 static_cast<}{\cf18 char}{\cf17 >}(0xBF)>>;\par
279 {\cf17 using }lex_utf8_code = either<\par
280         lex_utf8_1byte,\par
281         lex_utf8_2byte,\par
282         lex_utf8_3byte,\par
283         lex_utf8_4byte\par
284     >;\par
285 \par
286 {\cf17 using }lex_comment_start_symbol = character<'#'>;\par
287 {\cf17 using }lex_non_eol_ascii = either<character<0x09>, in_range<0x20, 0x7E>>;\par
288 {\cf17 using }lex_comment = sequence<lex_comment_start_symbol, repeat<either<\par
289     lex_non_eol_ascii, lex_utf8_2byte, lex_utf8_3byte, lex_utf8_4byte>, unlimited>>;\par
290 \par
291 \} {\cf20 // detail}\par
292 \} {\cf20 // toml}\par
293 {\cf21 #endif }{\cf20 // TOML_LEXER_HPP}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/literal.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/literal.hpp}
{\xe \v external/toml/literal.hpp}
{\bkmkstart AAAAAAAACF}
{\bkmkend AAAAAAAACF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "parser.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::literals}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::literals::toml_literals}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
inline {\b ::toml::basic_value}< {\b TOML11_DEFAULT_COMMENT_STRATEGY}, std::unordered_map, std::vector > {\b toml::literals::toml_literals::literal_internal_impl} ({\b ::toml::detail::location} loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
inline {\b ::toml::basic_value}< {\b TOML11_DEFAULT_COMMENT_STRATEGY}, std::unordered_map, std::vector > {\b toml::literals::toml_literals::operator""_toml} (const char *str, std::size_t len)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
literal.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/literal.hpp}
{\xe \v external/toml/literal.hpp}
{\bkmkstart AAAAAAAAAO}
{\bkmkend AAAAAAAAAO}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2019.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_LITERAL_HPP}\par
4 {\cf21 #define TOML11_LITERAL_HPP}\par
5 {\cf21 #include "parser.hpp"}\par
6 \par
7 {\cf17 namespace }toml\par
8 \{\par
9 {\cf17 inline} {\cf17 namespace }literals\par
10 \{\par
11 {\cf17 inline} {\cf17 namespace }toml_literals\par
12 \{\par
13 \par
14 {\cf20 // implementation}\par
15 inline ::toml::basic_value<TOML11_DEFAULT_COMMENT_STRATEGY, std::unordered_map, std::vector>\par
16 literal_internal_impl(::toml::detail::location loc)\par
17 \{\par
18     {\cf17 using }value_type = ::toml::basic_value<\par
19         TOML11_DEFAULT_COMMENT_STRATEGY, std::unordered_map, std::vector>;\par
20     {\cf20 // if there are some comments or empty lines, skip them.}\par
21     {\cf17 using }skip_line = ::toml::detail::repeat<toml::detail::sequence<\par
22             ::toml::detail::maybe<::toml::detail::lex_ws>,\par
23             ::toml::detail::maybe<::toml::detail::lex_comment>,\par
24             ::toml::detail::lex_newline\par
25         >, ::toml::detail::at_least<1>>;\par
26     skip_line::invoke(loc);\par
27 \par
28     {\cf20 // if there are some whitespaces before a value, skip them.}\par
29     {\cf17 using }skip_ws = ::toml::detail::repeat<\par
30         ::toml::detail::lex_ws, ::toml::detail::at_least<1>>;\par
31     skip_ws::invoke(loc);\par
32 \par
33     {\cf20 // to distinguish arrays and tables, first check it is a table or not.}\par
34     {\cf20 //}\par
35     {\cf20 // "[1,2,3]"_toml;   // this is an array}\par
36     {\cf20 // "[table]"_toml;   // a table that has an empty table named "table" inside.}\par
37     {\cf20 // "[[1,2,3]]"_toml; // this is an array of arrays}\par
38     {\cf20 // "[[table]]"_toml; // this is a table that has an array of tables inside.}\par
39     {\cf20 //}\par
40     {\cf20 // "[[1]]"_toml;     // this can be both... (currently it becomes a table)}\par
41     {\cf20 // "1 = [\{\}]"_toml;  // this is a table that has an array of table named 1.}\par
42     {\cf20 // "[[1,]]"_toml;    // this is an array of arrays.}\par
43     {\cf20 // "[[1],]"_toml;    // this also.}\par
44 \par
45     {\cf17 const} {\cf17 auto} the_front = loc.iter();\par
46 \par
47     {\cf17 const} {\cf18 bool} is_table_key = ::toml::detail::lex_std_table::invoke(loc);\par
48     loc.reset(the_front);\par
49 \par
50     {\cf17 const} {\cf18 bool} is_aots_key  = ::toml::detail::lex_array_table::invoke(loc);\par
51     loc.reset(the_front);\par
52 \par
53     {\cf20 // If it is neither a table-key or a array-of-table-key, it may be a value.}\par
54     {\cf19 if}(!is_table_key && !is_aots_key)\par
55     \{\par
56         {\cf19 if}({\cf17 auto} data = ::toml::detail::parse_value<value_type>(loc))\par
57         \{\par
58             {\cf19 return} data.unwrap();\par
59         \}\par
60     \}\par
61 \par
62     {\cf20 // Note that still it can be a table, because the literal might be something}\par
63     {\cf20 // like the following.}\par
64     {\cf20 // ```cpp}\par
65     {\cf20 // R"( // c++11 raw string literals}\par
66     {\cf20 //   key = "value"}\par
67     {\cf20 //   int = 42}\par
68     {\cf20 // )"_toml;}\par
69     {\cf20 // ```}\par
70     {\cf20 // It is a valid toml file.}\par
71     {\cf20 // It should be parsed as if we parse a file with this content.}\par
72 \par
73     {\cf19 if}({\cf17 auto} data = ::toml::detail::parse_toml_file<value_type>(loc))\par
74     \{\par
75         {\cf19 return} data.unwrap();\par
76     \}\par
77     {\cf19 else} {\cf20 // none of them.}\par
78     \{\par
79         throw ::toml::syntax_error(data.unwrap_err(), source_location(loc));\par
80     \}\par
81 \par
82 \}\par
83 \par
84 inline ::toml::basic_value<TOML11_DEFAULT_COMMENT_STRATEGY, std::unordered_map, std::vector>\par
85 {\cf17 operator}{\cf22 ""} _toml({\cf17 const} {\cf18 char}* str, std::size_t len)\par
86 \{\par
87     ::toml::detail::location loc(\par
88             std::string({\cf22 "TOML literal encoded in a C++ code"}),\par
89             std::vector<char>(str, str + len));\par
90     {\cf20 // literal length does not include the null character at the end.}\par
91     {\cf19 return} literal_internal_impl(std::move(loc));\par
92 \}\par
93 \par
94 {\cf20 // value of __cplusplus in C++2a/20 mode is not fixed yet along compilers.}\par
95 {\cf20 // So here we use the feature test macro for `char8_t` itself.}\par
96 {\cf21 #if defined(__cpp_char8_t) && __cpp_char8_t >= 201811L}\par
97 {\cf20 // value of u8"" literal has been changed from char to char8_t and char8_t is}\par
98 {\cf20 // NOT compatible to char}\par
99 inline ::toml::basic_value<TOML11_DEFAULT_COMMENT_STRATEGY, std::unordered_map, std::vector>\par
100 {\cf17 operator}{\cf22 ""} _toml({\cf17 const} {\cf18 char8_t}* str, std::size_t len)\par
101 \{\par
102     ::toml::detail::location loc(\par
103             std::string({\cf22 "TOML literal encoded in a C++ code"}),\par
104             std::vector<char>({\cf17 reinterpret_cast<}{\cf17 const }{\cf18 char}*{\cf17 >}(str),\par
105                               {\cf17 reinterpret_cast<}{\cf17 const }{\cf18 char}*{\cf17 >}(str) + len));\par
106     {\cf19 return} literal_internal_impl(std::move(loc));\par
107 \}\par
108 {\cf21 #endif}\par
109 \par
110 \} {\cf20 // toml_literals}\par
111 \} {\cf20 // literals}\par
112 \} {\cf20 // toml}\par
113 {\cf21 #endif}{\cf20 //TOML11_LITERAL_HPP}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/macros.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/macros.hpp}
{\xe \v external/toml/macros.hpp}
{\bkmkstart AAAAAAAACG}
{\bkmkend AAAAAAAACG}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_STRINGIZE_AUX}(x)\~ #x\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_STRINGIZE}(x)\~ {\b TOML11_STRINGIZE_AUX}(x)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_CONCATENATE_AUX}(x,  y)\~ x##y\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_CONCATENATE}(x,  y)\~ {\b TOML11_CONCATENATE_AUX}(x, y)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_INDEX_RSEQ}()\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_ARGS_SIZE_IMPL}(ARG1,  ARG2,  ARG3,  ARG4,  ARG5,  ARG6,  ARG7,  ARG8,  ARG9,  ARG10,  ARG11,  ARG12,  ARG13,  ARG14,  ARG15,  ARG16,  ARG17,  ARG18,  ARG19,  ARG20,  ARG21,  ARG22,  ARG23,  ARG24,  ARG25,  ARG26,  ARG27,  ARG28,  ARG29,  ARG30,  ARG31,  ARG32,  N, ...)\~ N\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_ARGS_SIZE_AUX}(...)\~ {\b TOML11_ARGS_SIZE_IMPL}(__VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_ARGS_SIZE}(...)\~ {\b TOML11_ARGS_SIZE_AUX}(__VA_ARGS__, {\b TOML11_INDEX_RSEQ}())\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_1}(FUNCTOR,  ARG1)\~ FUNCTOR(ARG1)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_2}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_1}( FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_3}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_2}( FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_4}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_3}( FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_5}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_4}( FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_6}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_5}( FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_7}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_6}( FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_8}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_7}( FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_9}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_8}( FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_10}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_9}( FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_11}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_10}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_12}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_11}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_13}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_12}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_14}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_13}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_15}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_14}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_16}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_15}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_17}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_16}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_18}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_17}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_19}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_18}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_20}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_19}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_21}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_20}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_22}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_21}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_23}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_22}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_24}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_23}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_25}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_24}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_26}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_25}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_27}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_26}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_28}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_27}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_29}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_28}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_30}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_29}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_31}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_30}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS_AUX_32}(FUNCTOR,  ARG1, ...)\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_31}(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FOR_EACH_VA_ARGS}(FUNCTOR, ...)\~     {\b TOML11_CONCATENATE}(TOML11_FOR_EACH_VA_ARGS_AUX_, {\b TOML11_ARGS_SIZE}(__VA_ARGS__))(FUNCTOR, __VA_ARGS__)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_FIND_MEMBER_VARIABLE_FROM_VALUE}(VAR_NAME)\~     obj.VAR_NAME = {\b toml::find}<decltype(obj.VAR_NAME)>(v, {\b TOML11_STRINGIZE}(VAR_NAME));\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_ASSIGN_MEMBER_VARIABLE_TO_VALUE}(VAR_NAME)\~     v[{\b TOML11_STRINGIZE}(VAR_NAME)] = obj.VAR_NAME;\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_DEFINE_CONVERSION_NON_INTRUSIVE}(NAME, ...)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v TOML11_ARGS_SIZE\:macros.hpp}
{\xe \v macros.hpp\:TOML11_ARGS_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_ARGS_SIZE(  {\i ...})\~ {\b TOML11_ARGS_SIZE_AUX}(__VA_ARGS__, {\b TOML11_INDEX_RSEQ}())}}
\par
{\bkmkstart AAAAAAAACH}
{\bkmkend AAAAAAAACH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_ARGS_SIZE_AUX\:macros.hpp}
{\xe \v macros.hpp\:TOML11_ARGS_SIZE_AUX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_ARGS_SIZE_AUX(  {\i ...})\~ {\b TOML11_ARGS_SIZE_IMPL}(__VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAACI}
{\bkmkend AAAAAAAACI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_ARGS_SIZE_IMPL\:macros.hpp}
{\xe \v macros.hpp\:TOML11_ARGS_SIZE_IMPL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_ARGS_SIZE_IMPL( ARG1,  ARG2,  ARG3,  ARG4,  ARG5,  ARG6,  ARG7,  ARG8,  ARG9,  ARG10,  ARG11,  ARG12,  ARG13,  ARG14,  ARG15,  ARG16,  ARG17,  ARG18,  ARG19,  ARG20,  ARG21,  ARG22,  ARG23,  ARG24,  ARG25,  ARG26,  ARG27,  ARG28,  ARG29,  ARG30,  ARG31,  ARG32,  N,   {\i ...})\~ N}}
\par
{\bkmkstart AAAAAAAACJ}
{\bkmkend AAAAAAAACJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_ASSIGN_MEMBER_VARIABLE_TO_VALUE\:macros.hpp}
{\xe \v macros.hpp\:TOML11_ASSIGN_MEMBER_VARIABLE_TO_VALUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_ASSIGN_MEMBER_VARIABLE_TO_VALUE( VAR_NAME)\~     v[{\b TOML11_STRINGIZE}(VAR_NAME)] = obj.VAR_NAME;}}
\par
{\bkmkstart AAAAAAAACK}
{\bkmkend AAAAAAAACK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_CONCATENATE\:macros.hpp}
{\xe \v macros.hpp\:TOML11_CONCATENATE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_CONCATENATE( x,  y)\~ {\b TOML11_CONCATENATE_AUX}(x, y)}}
\par
{\bkmkstart AAAAAAAACL}
{\bkmkend AAAAAAAACL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_CONCATENATE_AUX\:macros.hpp}
{\xe \v macros.hpp\:TOML11_CONCATENATE_AUX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_CONCATENATE_AUX( x,  y)\~ x##y}}
\par
{\bkmkstart AAAAAAAACM}
{\bkmkend AAAAAAAACM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_DEFINE_CONVERSION_NON_INTRUSIVE\:macros.hpp}
{\xe \v macros.hpp\:TOML11_DEFINE_CONVERSION_NON_INTRUSIVE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_DEFINE_CONVERSION_NON_INTRUSIVE( NAME,   {\i ...})}}
\par
{\bkmkstart AAAAAAAACN}
{\bkmkend AAAAAAAACN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 namespace }toml \{                                                                     \\\par
    template<>                                                                           \\\par
    struct from<NAME>                                                                    \\\par
    \{                                                                                    \\\par
        template<{\cf17 typename} C, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T,                             \\\par
                 template<{\cf17 typename} ...> {\cf17 class }A>                                         \\\par
        static NAME from_toml({\cf17 const} basic_value<C, T, A>& v)                             \\\par
        \{                                                                                \\\par
            NAME obj;                                                                    \\\par
            TOML11_FOR_EACH_VA_ARGS(TOML11_FIND_MEMBER_VARIABLE_FROM_VALUE, __VA_ARGS__) \\\par
            return obj;                                                                  \\\par
        \}                                                                                \\\par
    \};                                                                                   \\\par
    template<>                                                                           \\\par
    struct into<NAME>                                                                    \\\par
    \{                                                                                    \\\par
        static value into_toml({\cf17 const} NAME& obj)                                          \\\par
        \{                                                                                \\\par
            ::toml::value v = ::toml::table\{\};                                           \\\par
            TOML11_FOR_EACH_VA_ARGS(TOML11_ASSIGN_MEMBER_VARIABLE_TO_VALUE, __VA_ARGS__) \\\par
            return v;                                                                    \\\par
        \}                                                                                \\\par
    \};                                                                                   \\\par
    \} {\cf20 /* toml */}\par
}
}
{\xe \v TOML11_FIND_MEMBER_VARIABLE_FROM_VALUE\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FIND_MEMBER_VARIABLE_FROM_VALUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FIND_MEMBER_VARIABLE_FROM_VALUE( VAR_NAME)\~     obj.VAR_NAME = {\b toml::find}<decltype(obj.VAR_NAME)>(v, {\b TOML11_STRINGIZE}(VAR_NAME));}}
\par
{\bkmkstart AAAAAAAACO}
{\bkmkend AAAAAAAACO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS( FUNCTOR,   {\i ...})\~     {\b TOML11_CONCATENATE}(TOML11_FOR_EACH_VA_ARGS_AUX_, {\b TOML11_ARGS_SIZE}(__VA_ARGS__))(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAACP}
{\bkmkend AAAAAAAACP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_1\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_1}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_1( FUNCTOR,  ARG1)\~ FUNCTOR(ARG1)}}
\par
{\bkmkstart AAAAAAAACQ}
{\bkmkend AAAAAAAACQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_10\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_10}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_10( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_9}( FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAACR}
{\bkmkend AAAAAAAACR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_11\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_11}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_11( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_10}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAACS}
{\bkmkend AAAAAAAACS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_12\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_12}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_12( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_11}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAACT}
{\bkmkend AAAAAAAACT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_13\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_13}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_13( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_12}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAACU}
{\bkmkend AAAAAAAACU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_14\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_14}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_14( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_13}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAACV}
{\bkmkend AAAAAAAACV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_15\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_15}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_15( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_14}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAACW}
{\bkmkend AAAAAAAACW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_16\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_16}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_16( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_15}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAACX}
{\bkmkend AAAAAAAACX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_17\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_17}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_17( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_16}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAACY}
{\bkmkend AAAAAAAACY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_18\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_18}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_18( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_17}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAACZ}
{\bkmkend AAAAAAAACZ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_19\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_19}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_19( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_18}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADA}
{\bkmkend AAAAAAAADA}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_2\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_2}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_2( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_1}( FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADB}
{\bkmkend AAAAAAAADB}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_20\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_20}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_20( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_19}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADC}
{\bkmkend AAAAAAAADC}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_21\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_21}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_21( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_20}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADD}
{\bkmkend AAAAAAAADD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_22\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_22}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_22( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_21}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADE}
{\bkmkend AAAAAAAADE}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_23\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_23}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_23( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_22}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADF}
{\bkmkend AAAAAAAADF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_24\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_24}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_24( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_23}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADG}
{\bkmkend AAAAAAAADG}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_25\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_25}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_25( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_24}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADH}
{\bkmkend AAAAAAAADH}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_26\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_26}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_26( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_25}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADI}
{\bkmkend AAAAAAAADI}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_27\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_27}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_27( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_26}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADJ}
{\bkmkend AAAAAAAADJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_28\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_28}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_28( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_27}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADK}
{\bkmkend AAAAAAAADK}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_29\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_29}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_29( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_28}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADL}
{\bkmkend AAAAAAAADL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_3\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_3}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_3( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_2}( FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADM}
{\bkmkend AAAAAAAADM}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_30\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_30}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_30( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_29}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADN}
{\bkmkend AAAAAAAADN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_31\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_31}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_31( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_30}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADO}
{\bkmkend AAAAAAAADO}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_32\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_32}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_32( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_31}(FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADP}
{\bkmkend AAAAAAAADP}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_4\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_4}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_4( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_3}( FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADQ}
{\bkmkend AAAAAAAADQ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_5\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_5}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_5( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_4}( FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADR}
{\bkmkend AAAAAAAADR}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_6\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_6}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_6( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_5}( FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADS}
{\bkmkend AAAAAAAADS}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_7\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_7}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_7( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_6}( FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADT}
{\bkmkend AAAAAAAADT}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_8\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_8}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_8( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_7}( FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADU}
{\bkmkend AAAAAAAADU}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_FOR_EACH_VA_ARGS_AUX_9\:macros.hpp}
{\xe \v macros.hpp\:TOML11_FOR_EACH_VA_ARGS_AUX_9}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_FOR_EACH_VA_ARGS_AUX_9( FUNCTOR,  ARG1,   {\i ...})\~ FUNCTOR(ARG1) {\b TOML11_FOR_EACH_VA_ARGS_AUX_8}( FUNCTOR, __VA_ARGS__)}}
\par
{\bkmkstart AAAAAAAADV}
{\bkmkend AAAAAAAADV}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_INDEX_RSEQ\:macros.hpp}
{\xe \v macros.hpp\:TOML11_INDEX_RSEQ}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_INDEX_RSEQ()}}
\par
{\bkmkstart AAAAAAAADW}
{\bkmkend AAAAAAAADW}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, \\\par
    16, 15, 14, 13, 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1, 0\par
}
}
{\xe \v TOML11_STRINGIZE\:macros.hpp}
{\xe \v macros.hpp\:TOML11_STRINGIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_STRINGIZE( x)\~ {\b TOML11_STRINGIZE_AUX}(x)}}
\par
{\bkmkstart AAAAAAAADX}
{\bkmkend AAAAAAAADX}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v TOML11_STRINGIZE_AUX\:macros.hpp}
{\xe \v macros.hpp\:TOML11_STRINGIZE_AUX}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_STRINGIZE_AUX( x)\~ #x}}
\par
{\bkmkstart AAAAAAAADY}
{\bkmkend AAAAAAAADY}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
macros.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/macros.hpp}
{\xe \v external/toml/macros.hpp}
{\bkmkstart AAAAAAAAAP}
{\bkmkend AAAAAAAAAP}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef TOML11_MACROS_HPP}\par
2 {\cf21 #define TOML11_MACROS_HPP}\par
3 \par
4 {\cf21 #define TOML11_STRINGIZE_AUX(x) #x}\par
5 {\cf21 #define TOML11_STRINGIZE(x)     TOML11_STRINGIZE_AUX(x)}\par
6 \par
7 {\cf21 #define TOML11_CONCATENATE_AUX(x, y) x##y}\par
8 {\cf21 #define TOML11_CONCATENATE(x, y)     TOML11_CONCATENATE_AUX(x, y)}\par
9 \par
10 {\cf20 // ============================================================================}\par
11 {\cf20 // TOML11_DEFINE_CONVERSION_NON_INTRUSIVE}\par
12 \par
13 {\cf21 #ifndef TOML11_WITHOUT_DEFINE_NON_INTRUSIVE}\par
14 \par
15 {\cf20 // ----------------------------------------------------------------------------}\par
16 {\cf20 // TOML11_ARGS_SIZE}\par
17 \par
18 {\cf21 #define TOML11_INDEX_RSEQ() \\}\par
19 {\cf21     32, 31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19, 18, 17, \\}\par
20 {\cf21     16, 15, 14, 13, 12, 11, 10,  9,  8,  7,  6,  5,  4,  3,  2,  1, 0}\par
21 {\cf21 #define TOML11_ARGS_SIZE_IMPL(\\}\par
22 {\cf21     ARG1,  ARG2,  ARG3,  ARG4,  ARG5,  ARG6,  ARG7,  ARG8,  ARG9,  ARG10, \\}\par
23 {\cf21     ARG11, ARG12, ARG13, ARG14, ARG15, ARG16, ARG17, ARG18, ARG19, ARG20, \\}\par
24 {\cf21     ARG21, ARG22, ARG23, ARG24, ARG25, ARG26, ARG27, ARG28, ARG29, ARG30, \\}\par
25 {\cf21     ARG31, ARG32, N, ...) N}\par
26 {\cf21 #define TOML11_ARGS_SIZE_AUX(...) TOML11_ARGS_SIZE_IMPL(__VA_ARGS__)}\par
27 {\cf21 #define TOML11_ARGS_SIZE(...) TOML11_ARGS_SIZE_AUX(__VA_ARGS__, TOML11_INDEX_RSEQ())}\par
28 \par
29 {\cf20 // ----------------------------------------------------------------------------}\par
30 {\cf20 // TOML11_FOR_EACH_VA_ARGS}\par
31 \par
32 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_1( FUNCTOR, ARG1     ) FUNCTOR(ARG1)}\par
33 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_2( FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_1( FUNCTOR, __VA_ARGS__)}\par
34 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_3( FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_2( FUNCTOR, __VA_ARGS__)}\par
35 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_4( FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_3( FUNCTOR, __VA_ARGS__)}\par
36 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_5( FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_4( FUNCTOR, __VA_ARGS__)}\par
37 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_6( FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_5( FUNCTOR, __VA_ARGS__)}\par
38 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_7( FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_6( FUNCTOR, __VA_ARGS__)}\par
39 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_8( FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_7( FUNCTOR, __VA_ARGS__)}\par
40 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_9( FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_8( FUNCTOR, __VA_ARGS__)}\par
41 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_10(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_9( FUNCTOR, __VA_ARGS__)}\par
42 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_11(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_10(FUNCTOR, __VA_ARGS__)}\par
43 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_12(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_11(FUNCTOR, __VA_ARGS__)}\par
44 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_13(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_12(FUNCTOR, __VA_ARGS__)}\par
45 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_14(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_13(FUNCTOR, __VA_ARGS__)}\par
46 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_15(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_14(FUNCTOR, __VA_ARGS__)}\par
47 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_16(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_15(FUNCTOR, __VA_ARGS__)}\par
48 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_17(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_16(FUNCTOR, __VA_ARGS__)}\par
49 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_18(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_17(FUNCTOR, __VA_ARGS__)}\par
50 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_19(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_18(FUNCTOR, __VA_ARGS__)}\par
51 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_20(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_19(FUNCTOR, __VA_ARGS__)}\par
52 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_21(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_20(FUNCTOR, __VA_ARGS__)}\par
53 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_22(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_21(FUNCTOR, __VA_ARGS__)}\par
54 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_23(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_22(FUNCTOR, __VA_ARGS__)}\par
55 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_24(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_23(FUNCTOR, __VA_ARGS__)}\par
56 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_25(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_24(FUNCTOR, __VA_ARGS__)}\par
57 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_26(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_25(FUNCTOR, __VA_ARGS__)}\par
58 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_27(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_26(FUNCTOR, __VA_ARGS__)}\par
59 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_28(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_27(FUNCTOR, __VA_ARGS__)}\par
60 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_29(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_28(FUNCTOR, __VA_ARGS__)}\par
61 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_30(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_29(FUNCTOR, __VA_ARGS__)}\par
62 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_31(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_30(FUNCTOR, __VA_ARGS__)}\par
63 {\cf21 #define TOML11_FOR_EACH_VA_ARGS_AUX_32(FUNCTOR, ARG1, ...) FUNCTOR(ARG1) TOML11_FOR_EACH_VA_ARGS_AUX_31(FUNCTOR, __VA_ARGS__)}\par
64 \par
65 {\cf21 #define TOML11_FOR_EACH_VA_ARGS(FUNCTOR, ...)\\}\par
66 {\cf21     TOML11_CONCATENATE(TOML11_FOR_EACH_VA_ARGS_AUX_, TOML11_ARGS_SIZE(__VA_ARGS__))(FUNCTOR, __VA_ARGS__)}\par
67 \par
68 {\cf20 // ----------------------------------------------------------------------------}\par
69 {\cf20 // TOML11_DEFINE_CONVERSION_NON_INTRUSIVE}\par
70 \par
71 {\cf20 // use it in the following way.}\par
72 {\cf20 // ```cpp}\par
73 {\cf20 // namespace foo}\par
74 {\cf20 // \{}\par
75 {\cf20 // struct Foo}\par
76 {\cf20 // \{}\par
77 {\cf20 //     std::string s;}\par
78 {\cf20 //     double      d;}\par
79 {\cf20 //     int         i;}\par
80 {\cf20 // \};}\par
81 {\cf20 // \} // foo}\par
82 {\cf20 //}\par
83 {\cf20 // TOML11_DEFINE_CONVERSION_NON_INTRUSIVE(foo::Foo, s, d, i)}\par
84 {\cf20 // ```}\par
85 {\cf20 // And then you can use `toml::find<foo::Foo>(file, "foo");`}\par
86 {\cf20 //}\par
87 {\cf21 #define TOML11_FIND_MEMBER_VARIABLE_FROM_VALUE(VAR_NAME)\\}\par
88 {\cf21     obj.VAR_NAME = toml::find<decltype(obj.VAR_NAME)>(v, TOML11_STRINGIZE(VAR_NAME));}\par
89 \par
90 {\cf21 #define TOML11_ASSIGN_MEMBER_VARIABLE_TO_VALUE(VAR_NAME)\\}\par
91 {\cf21     v[TOML11_STRINGIZE(VAR_NAME)] = obj.VAR_NAME;}\par
92 \par
93 {\cf21 #define TOML11_DEFINE_CONVERSION_NON_INTRUSIVE(NAME, ...)\\}\par
94 {\cf21     namespace toml \{                                                                     \\}\par
95 {\cf21     template<>                                                                           \\}\par
96 {\cf21     struct from<NAME>                                                                    \\}\par
97 {\cf21     \{                                                                                    \\}\par
98 {\cf21         template<typename C, template<typename ...> class T,                             \\}\par
99 {\cf21                  template<typename ...> class A>                                         \\}\par
100 {\cf21         static NAME from_toml(const basic_value<C, T, A>& v)                             \\}\par
101 {\cf21         \{                                                                                \\}\par
102 {\cf21             NAME obj;                                                                    \\}\par
103 {\cf21             TOML11_FOR_EACH_VA_ARGS(TOML11_FIND_MEMBER_VARIABLE_FROM_VALUE, __VA_ARGS__) \\}\par
104 {\cf21             return obj;                                                                  \\}\par
105 {\cf21         \}                                                                                \\}\par
106 {\cf21     \};                                                                                   \\}\par
107 {\cf21     template<>                                                                           \\}\par
108 {\cf21     struct into<NAME>                                                                    \\}\par
109 {\cf21     \{                                                                                    \\}\par
110 {\cf21         static value into_toml(const NAME& obj)                                          \\}\par
111 {\cf21         \{                                                                                \\}\par
112 {\cf21             ::toml::value v = ::toml::table\{\};                                           \\}\par
113 {\cf21             TOML11_FOR_EACH_VA_ARGS(TOML11_ASSIGN_MEMBER_VARIABLE_TO_VALUE, __VA_ARGS__) \\}\par
114 {\cf21             return v;                                                                    \\}\par
115 {\cf21         \}                                                                                \\}\par
116 {\cf21     \};                                                                                   \\}\par
117 {\cf21     \} }{\cf20 /* toml */}{\cf21 }\par
118 \par
119 {\cf21 #endif}{\cf20 // TOML11_WITHOUT_DEFINE_NON_INTRUSIVE}\par
120 \par
121 {\cf21 #endif}{\cf20 // TOML11_MACROS_HPP}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/parser.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/parser.hpp}
{\xe \v external/toml/parser.hpp}
{\bkmkstart AAAAAAAADZ}
{\bkmkend AAAAAAAADZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstring>}\par
{\f2 #include <fstream>}\par
{\f2 #include <sstream>}\par
{\f2 #include "combinator.hpp"}\par
{\f2 #include "lexer.hpp"}\par
{\f2 #include "region.hpp"}\par
{\f2 #include "result.hpp"}\par
{\f2 #include "types.hpp"}\par
{\f2 #include "value.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< boolean, region >, std::string > {\b toml::detail::parse_boolean} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< integer, region >, std::string > {\b toml::detail::parse_binary_integer} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< integer, region >, std::string > {\b toml::detail::parse_octal_integer} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< integer, region >, std::string > {\b toml::detail::parse_hexadecimal_integer} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< integer, region >, std::string > {\b toml::detail::parse_integer} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< floating, region >, std::string > {\b toml::detail::parse_floating} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toml::detail::read_utf8_codepoint} (const region &reg, const location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::string, std::string > {\b toml::detail::parse_escape_sequence} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::ptrdiff_t {\b toml::detail::check_utf8_validity} (const std::string &reg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< {\b toml::string}, region >, std::string > {\b toml::detail::parse_ml_basic_string} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< {\b toml::string}, region >, std::string > {\b toml::detail::parse_basic_string} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< {\b toml::string}, region >, std::string > {\b toml::detail::parse_ml_literal_string} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< {\b toml::string}, region >, std::string > {\b toml::detail::parse_literal_string} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< {\b toml::string}, region >, std::string > {\b toml::detail::parse_string} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< local_date, region >, std::string > {\b toml::detail::parse_local_date} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< local_time, region >, std::string > {\b toml::detail::parse_local_time} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< local_datetime, region >, std::string > {\b toml::detail::parse_local_datetime} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< offset_datetime, region >, std::string > {\b toml::detail::parse_offset_datetime} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< key, region >, std::string > {\b toml::detail::parse_simple_key} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< std::vector< key >, region >, std::string > {\b toml::detail::parse_key} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > result< Value, std::string > {\b toml::detail::parse_value} (location &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > result< std::pair< typename Value::array_type, region >, std::string > {\b toml::detail::parse_array} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > result< std::pair< std::pair< std::vector< key >, region >, Value >, std::string > {\b toml::detail::parse_key_value_pair} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename InputIterator > std::string {\b toml::detail::format_dotted_keys} (InputIterator first, const InputIterator last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< std::vector< key >, region >, std::string > {\b toml::detail::parse_table_key} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > result< std::pair< typename Value::table_type, region >, std::string > {\b toml::detail::parse_inline_table} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value , typename Iterator > bool {\b toml::detail::is_valid_forward_table_definition} (const Value &fwd, const Value &inserting, Iterator key_first, Iterator key_curr, Iterator key_last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value , typename InputIterator > result< bool, std::string > {\b toml::detail::insert_nested_key} (typename Value::table_type &root, const Value &v, InputIterator iter, const InputIterator last, region key_reg, const bool is_array_of_table=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< value_t, std::string > {\b toml::detail::guess_number_type} (const location &l)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< value_t, std::string > {\b toml::detail::guess_value_type} (const location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value , typename T > result< Value, std::string > {\b toml::detail::parse_value_helper} (result< std::pair< T, region >, std::string > rslt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
result< std::pair< std::vector< key >, region >, std::string > {\b toml::detail::parse_array_table_key} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > result< typename Value::table_type, std::string > {\b toml::detail::parse_ml_table} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > result< Value, std::string > {\b toml::detail::parse_toml_file} (location &loc)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Comment  = TOML11_DEFAULT_COMMENT_STRATEGY, template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> basic_value< Comment, Table, Array > {\b toml::parse} (std::istream &is, const std::string &fname="unknown file")\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Comment  = TOML11_DEFAULT_COMMENT_STRATEGY, template< typename ... > class Table = std::unordered_map, template< typename ... > class Array = std::vector> basic_value< Comment, Table, Array > {\b toml::parse} (const std::string &fname)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
parser.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/parser.hpp}
{\xe \v external/toml/parser.hpp}
{\bkmkstart AAAAAAAAAQ}
{\bkmkend AAAAAAAAAQ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2017.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_PARSER_HPP}\par
4 {\cf21 #define TOML11_PARSER_HPP}\par
5 {\cf21 #include <cstring>}\par
6 {\cf21 #include <fstream>}\par
7 {\cf21 #include <sstream>}\par
8 \par
9 {\cf21 #include "combinator.hpp"}\par
10 {\cf21 #include "lexer.hpp"}\par
11 {\cf21 #include "region.hpp"}\par
12 {\cf21 #include "result.hpp"}\par
13 {\cf21 #include "types.hpp"}\par
14 {\cf21 #include "value.hpp"}\par
15 \par
16 {\cf21 #ifndef TOML11_DISABLE_STD_FILESYSTEM}\par
17 {\cf21 #ifdef __cpp_lib_filesystem}\par
18 {\cf21 #if __has_include(<filesystem>)}\par
19 {\cf21 #define TOML11_HAS_STD_FILESYSTEM}\par
20 {\cf21 #include <filesystem>}\par
21 {\cf21 #endif }{\cf20 // has_include(<string_view>)}\par
22 {\cf21 #endif }{\cf20 // __cpp_lib_filesystem}\par
23 {\cf21 #endif }{\cf20 // TOML11_DISABLE_STD_FILESYSTEM}\par
24 \par
25 {\cf17 namespace }toml\par
26 \{\par
27 {\cf17 namespace }detail\par
28 \{\par
29 \par
30 {\cf17 inline} result<std::pair<boolean, region>, std::string>\par
31 parse_boolean(location& loc)\par
32 \{\par
33     {\cf17 const} {\cf17 auto} first = loc.iter();\par
34     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_boolean::invoke(loc))\par
35     \{\par
36         {\cf17 const} {\cf17 auto} reg = token.unwrap();\par
37         {\cf19 if}     (reg.str() == {\cf22 "true"})  \{{\cf19 return} ok(std::make_pair({\cf17 true},  reg));\}\par
38         {\cf19 else} {\cf19 if}(reg.str() == {\cf22 "false"}) \{{\cf19 return} ok(std::make_pair({\cf17 false}, reg));\}\par
39         {\cf19 else} {\cf20 // internal error.}\par
40         \{\par
41             {\cf19 throw} internal_error(format_underline(\par
42                 {\cf22 "toml::parse_boolean: internal error"},\par
43                 \{\{source_location(reg), {\cf22 "invalid token"}\}\}),\par
44                 source_location(reg));\par
45         \}\par
46     \}\par
47     loc.reset(first); {\cf20 //rollback}\par
48     {\cf19 return} err(format_underline({\cf22 "toml::parse_boolean: "},\par
49                \{\{source_location(loc), {\cf22 "the next token is not a boolean"}\}\}));\par
50 \}\par
51 \par
52 {\cf17 inline} result<std::pair<integer, region>, std::string>\par
53 parse_binary_integer(location& loc)\par
54 \{\par
55     {\cf17 const} {\cf17 auto} first = loc.iter();\par
56     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_bin_int::invoke(loc))\par
57     \{\par
58         {\cf17 auto} str = token.unwrap().str();\par
59         assert(str.size() > 2); {\cf20 // minimum -> 0b1}\par
60         integer retval(0), base(1);\par
61         {\cf19 for}({\cf17 auto} i(str.rbegin()), e(str.rend() - 2); i!=e; ++i)\par
62         \{\par
63             {\cf19 if}     (*i == {\cf23 '1'})\{retval += base; base *= 2;\}\par
64             {\cf19 else} {\cf19 if}(*i == {\cf23 '0'})\{base *= 2;\}\par
65             {\cf19 else} {\cf19 if}(*i == {\cf23 '_'})\{{\cf20 /* do nothing. */}\}\par
66             {\cf19 else} {\cf20 // internal error.}\par
67             \{\par
68                 {\cf19 throw} internal_error(format_underline(\par
69                     {\cf22 "toml::parse_integer: internal error"},\par
70                     \{\{source_location(token.unwrap()), {\cf22 "invalid token"}\}\}),\par
71                     source_location(loc));\par
72             \}\par
73         \}\par
74         {\cf19 return} ok(std::make_pair(retval, token.unwrap()));\par
75     \}\par
76     loc.reset(first);\par
77     {\cf19 return} err(format_underline({\cf22 "toml::parse_binary_integer:"},\par
78                \{\{source_location(loc), {\cf22 "the next token is not an integer"}\}\}));\par
79 \}\par
80 \par
81 {\cf17 inline} result<std::pair<integer, region>, std::string>\par
82 parse_octal_integer(location& loc)\par
83 \{\par
84     {\cf17 const} {\cf17 auto} first = loc.iter();\par
85     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_oct_int::invoke(loc))\par
86     \{\par
87         {\cf17 auto} str = token.unwrap().str();\par
88         str.erase(std::remove(str.begin(), str.end(), {\cf23 '_'}), str.end());\par
89         str.erase(str.begin()); str.erase(str.begin()); {\cf20 // remove `0o` prefix}\par
90 \par
91         std::istringstream iss(str);\par
92         integer retval(0);\par
93         iss >> std::oct >> retval;\par
94         {\cf19 return} ok(std::make_pair(retval, token.unwrap()));\par
95     \}\par
96     loc.reset(first);\par
97     {\cf19 return} err(format_underline({\cf22 "toml::parse_octal_integer:"},\par
98                \{\{source_location(loc), {\cf22 "the next token is not an integer"}\}\}));\par
99 \}\par
100 \par
101 {\cf17 inline} result<std::pair<integer, region>, std::string>\par
102 parse_hexadecimal_integer(location& loc)\par
103 \{\par
104     {\cf17 const} {\cf17 auto} first = loc.iter();\par
105     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_hex_int::invoke(loc))\par
106     \{\par
107         {\cf17 auto} str = token.unwrap().str();\par
108         str.erase(std::remove(str.begin(), str.end(), {\cf23 '_'}), str.end());\par
109         str.erase(str.begin()); str.erase(str.begin()); {\cf20 // remove `0x` prefix}\par
110 \par
111         std::istringstream iss(str);\par
112         integer retval(0);\par
113         iss >> std::hex >> retval;\par
114         {\cf19 return} ok(std::make_pair(retval, token.unwrap()));\par
115     \}\par
116     loc.reset(first);\par
117     {\cf19 return} err(format_underline({\cf22 "toml::parse_hexadecimal_integer"},\par
118                \{\{source_location(loc), {\cf22 "the next token is not an integer"}\}\}));\par
119 \}\par
120 \par
121 {\cf17 inline} result<std::pair<integer, region>, std::string>\par
122 parse_integer(location& loc)\par
123 \{\par
124     {\cf17 const} {\cf17 auto} first = loc.iter();\par
125     {\cf19 if}(first != loc.end() && *first == {\cf23 '0'})\par
126     \{\par
127         {\cf17 const} {\cf17 auto} second = std::next(first);\par
128         {\cf19 if}(second == loc.end()) {\cf20 // the token is just zero.}\par
129         \{\par
130             loc.advance();\par
131             {\cf19 return} ok(std::make_pair(0, region(loc, first, second)));\par
132         \}\par
133 \par
134         {\cf19 if}(*second == {\cf23 'b'}) \{{\cf19 return} parse_binary_integer     (loc);\} {\cf20 // 0b1100}\par
135         {\cf19 if}(*second == {\cf23 'o'}) \{{\cf19 return} parse_octal_integer      (loc);\} {\cf20 // 0o775}\par
136         {\cf19 if}(*second == {\cf23 'x'}) \{{\cf19 return} parse_hexadecimal_integer(loc);\} {\cf20 // 0xC0FFEE}\par
137 \par
138         {\cf19 if}(std::isdigit(*second))\par
139         \{\par
140             {\cf19 return} err(format_underline({\cf22 "toml::parse_integer: "}\par
141                 {\cf22 "leading zero in an Integer is not allowed."},\par
142                 \{\{source_location(loc), {\cf22 "leading zero"}\}\}));\par
143         \}\par
144         {\cf19 else} {\cf19 if}(std::isalpha(*second))\par
145         \{\par
146              {\cf19 return} err(format_underline({\cf22 "toml::parse_integer: "}\par
147                 {\cf22 "unknown integer prefix appeared."},\par
148                 \{\{source_location(loc), {\cf22 "none of 0x, 0o, 0b"}\}\}));\par
149         \}\par
150     \}\par
151 \par
152     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_dec_int::invoke(loc))\par
153     \{\par
154         {\cf17 auto} str = token.unwrap().str();\par
155         str.erase(std::remove(str.begin(), str.end(), {\cf23 '_'}), str.end());\par
156 \par
157         std::istringstream iss(str);\par
158         integer retval(0);\par
159         iss >> retval;\par
160         {\cf19 return} ok(std::make_pair(retval, token.unwrap()));\par
161     \}\par
162     loc.reset(first);\par
163     {\cf19 return} err(format_underline({\cf22 "toml::parse_integer: "},\par
164                \{\{source_location(loc), {\cf22 "the next token is not an integer"}\}\}));\par
165 \}\par
166 \par
167 {\cf17 inline} result<std::pair<floating, region>, std::string>\par
168 parse_floating(location& loc)\par
169 \{\par
170     {\cf17 const} {\cf17 auto} first = loc.iter();\par
171     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_float::invoke(loc))\par
172     \{\par
173         {\cf17 auto} str = token.unwrap().str();\par
174         {\cf19 if}(str == {\cf22 "inf"} || str == {\cf22 "+inf"})\par
175         \{\par
176             {\cf19 if}(std::numeric_limits<floating>::has_infinity)\par
177             \{\par
178                 {\cf19 return} ok(std::make_pair(\par
179                     std::numeric_limits<floating>::infinity(), token.unwrap()));\par
180             \}\par
181             {\cf19 else}\par
182             \{\par
183                 {\cf19 throw} std::domain_error({\cf22 "toml::parse_floating: inf value found"}\par
184                     {\cf22 " but the current environment does not support inf. Please"}\par
185                     {\cf22 " make sure that the floating-point implementation conforms"}\par
186                     {\cf22 " IEEE 754/ISO 60559 international standard."});\par
187             \}\par
188         \}\par
189         {\cf19 else} {\cf19 if}(str == {\cf22 "-inf"})\par
190         \{\par
191             {\cf19 if}(std::numeric_limits<floating>::has_infinity)\par
192             \{\par
193                 {\cf19 return} ok(std::make_pair(\par
194                     -std::numeric_limits<floating>::infinity(), token.unwrap()));\par
195             \}\par
196             {\cf19 else}\par
197             \{\par
198                 {\cf19 throw} std::domain_error({\cf22 "toml::parse_floating: inf value found"}\par
199                     {\cf22 " but the current environment does not support inf. Please"}\par
200                     {\cf22 " make sure that the floating-point implementation conforms"}\par
201                     {\cf22 " IEEE 754/ISO 60559 international standard."});\par
202             \}\par
203         \}\par
204         {\cf19 else} {\cf19 if}(str == {\cf22 "nan"} || str == {\cf22 "+nan"})\par
205         \{\par
206             {\cf19 if}(std::numeric_limits<floating>::has_quiet_NaN)\par
207             \{\par
208                 {\cf19 return} ok(std::make_pair(\par
209                     std::numeric_limits<floating>::quiet_NaN(), token.unwrap()));\par
210             \}\par
211             {\cf19 else} {\cf19 if}(std::numeric_limits<floating>::has_signaling_NaN)\par
212             \{\par
213                 {\cf19 return} ok(std::make_pair(\par
214                     std::numeric_limits<floating>::signaling_NaN(), token.unwrap()));\par
215             \}\par
216             {\cf19 else}\par
217             \{\par
218                 {\cf19 throw} std::domain_error({\cf22 "toml::parse_floating: NaN value found"}\par
219                     {\cf22 " but the current environment does not support NaN. Please"}\par
220                     {\cf22 " make sure that the floating-point implementation conforms"}\par
221                     {\cf22 " IEEE 754/ISO 60559 international standard."});\par
222             \}\par
223         \}\par
224         {\cf19 else} {\cf19 if}(str == {\cf22 "-nan"})\par
225         \{\par
226             {\cf19 if}(std::numeric_limits<floating>::has_quiet_NaN)\par
227             \{\par
228                 {\cf19 return} ok(std::make_pair(\par
229                     -std::numeric_limits<floating>::quiet_NaN(), token.unwrap()));\par
230             \}\par
231             {\cf19 else} {\cf19 if}(std::numeric_limits<floating>::has_signaling_NaN)\par
232             \{\par
233                 {\cf19 return} ok(std::make_pair(\par
234                     -std::numeric_limits<floating>::signaling_NaN(), token.unwrap()));\par
235             \}\par
236             {\cf19 else}\par
237             \{\par
238                 {\cf19 throw} std::domain_error({\cf22 "toml::parse_floating: NaN value found"}\par
239                     {\cf22 " but the current environment does not support NaN. Please"}\par
240                     {\cf22 " make sure that the floating-point implementation conforms"}\par
241                     {\cf22 " IEEE 754/ISO 60559 international standard."});\par
242             \}\par
243         \}\par
244         str.erase(std::remove(str.begin(), str.end(), {\cf23 '_'}), str.end());\par
245         std::istringstream iss(str);\par
246         floating v(0.0);\par
247         iss >> v;\par
248         {\cf19 return} ok(std::make_pair(v, token.unwrap()));\par
249     \}\par
250     loc.reset(first);\par
251     {\cf19 return} err(format_underline({\cf22 "toml::parse_floating: "},\par
252                \{\{source_location(loc), {\cf22 "the next token is not a float"}\}\}));\par
253 \}\par
254 \par
255 {\cf17 inline} std::string read_utf8_codepoint({\cf17 const} region& reg, {\cf17 const} location& loc)\par
256 \{\par
257     {\cf17 const} {\cf17 auto} str = reg.str().substr(1);\par
258     std::uint_least32_t codepoint;\par
259     std::istringstream iss(str);\par
260     iss >> std::hex >> codepoint;\par
261 \par
262     {\cf17 const} {\cf17 auto} to_char = []({\cf17 const} std::uint_least32_t i) {\cf17 noexcept} -> {\cf18 char} \{\par
263         {\cf17 const} {\cf17 auto} uc = {\cf17 static_cast<}{\cf18 unsigned} {\cf18 char}{\cf17 >}(i);\par
264         {\cf19 return} *{\cf17 reinterpret_cast<}{\cf17 const }{\cf18 char}*{\cf17 >}(std::addressof(uc));\par
265     \};\par
266 \par
267     std::string character;\par
268     {\cf19 if}(codepoint < 0x80) {\cf20 // U+0000 ... U+0079 ; just an ASCII.}\par
269     \{\par
270         character += {\cf17 static_cast<}{\cf18 char}{\cf17 >}(codepoint);\par
271     \}\par
272     {\cf19 else} {\cf19 if}(codepoint < 0x800) {\cf20 //U+0080 ... U+07FF}\par
273     \{\par
274         {\cf20 // 110yyyyx 10xxxxxx; 0x3f == 0b0011'1111}\par
275         character += to_char(0xC0| codepoint >> 6);\par
276         character += to_char(0x80|(codepoint & 0x3F));\par
277     \}\par
278     {\cf19 else} {\cf19 if}(codepoint < 0x10000) {\cf20 // U+0800...U+FFFF}\par
279     \{\par
280         {\cf19 if}(0xD800 <= codepoint && codepoint <= 0xDFFF)\par
281         \{\par
282             {\cf19 throw} syntax_error(format_underline(\par
283                 {\cf22 "toml::read_utf8_codepoint: codepoints in the range "}\par
284                 {\cf22 "[0xD800, 0xDFFF] are not valid UTF-8."}, \{\{\par
285                     source_location(loc), {\cf22 "not a valid UTF-8 codepoint"}\par
286                 \}\}), source_location(loc));\par
287         \}\par
288         assert(codepoint < 0xD800 || 0xDFFF < codepoint);\par
289         {\cf20 // 1110yyyy 10yxxxxx 10xxxxxx}\par
290         character += to_char(0xE0| codepoint >> 12);\par
291         character += to_char(0x80|(codepoint >> 6 & 0x3F));\par
292         character += to_char(0x80|(codepoint      & 0x3F));\par
293     \}\par
294     {\cf19 else} {\cf19 if}(codepoint < 0x110000) {\cf20 // U+010000 ... U+10FFFF}\par
295     \{\par
296         {\cf20 // 11110yyy 10yyxxxx 10xxxxxx 10xxxxxx}\par
297         character += to_char(0xF0| codepoint >> 18);\par
298         character += to_char(0x80|(codepoint >> 12 & 0x3F));\par
299         character += to_char(0x80|(codepoint >> 6  & 0x3F));\par
300         character += to_char(0x80|(codepoint       & 0x3F));\par
301     \}\par
302     {\cf19 else} {\cf20 // out of UTF-8 region}\par
303     \{\par
304         {\cf19 throw} syntax_error(format_underline({\cf22 "toml::read_utf8_codepoint:"}\par
305             {\cf22 " input codepoint is too large."},\par
306             \{\{source_location(loc), {\cf22 "should be in [0x00..0x10FFFF]"}\}\}),\par
307             source_location(loc));\par
308     \}\par
309     {\cf19 return} character;\par
310 \}\par
311 \par
312 {\cf17 inline} result<std::string, std::string> parse_escape_sequence(location& loc)\par
313 \{\par
314     {\cf17 const} {\cf17 auto} first = loc.iter();\par
315     {\cf19 if}(first == loc.end() || *first != {\cf23 '\\\\'})\par
316     \{\par
317         {\cf19 return} err(format_underline({\cf22 "toml::parse_escape_sequence: "}, \{\{\par
318             source_location(loc), {\cf22 "the next token is not a backslash \\"\\\\\\""}\}\}));\par
319     \}\par
320     loc.advance();\par
321     {\cf19 switch}(*loc.iter())\par
322     \{\par
323         {\cf19 case} {\cf23 '\\\\'}:\{loc.advance(); {\cf19 return} ok(std::string({\cf22 "\\\\"}));\}\par
324         {\cf19 case} {\cf23 '"'} :\{loc.advance(); {\cf19 return} ok(std::string({\cf22 "\\""}));\}\par
325         {\cf19 case} {\cf23 'b'} :\{loc.advance(); {\cf19 return} ok(std::string({\cf22 "\\b"}));\}\par
326         {\cf19 case} {\cf23 't'} :\{loc.advance(); {\cf19 return} ok(std::string({\cf22 "\\t"}));\}\par
327         {\cf19 case} {\cf23 'n'} :\{loc.advance(); {\cf19 return} ok(std::string({\cf22 "\\n"}));\}\par
328         {\cf19 case} {\cf23 'f'} :\{loc.advance(); {\cf19 return} ok(std::string({\cf22 "\\f"}));\}\par
329         {\cf19 case} {\cf23 'r'} :\{loc.advance(); {\cf19 return} ok(std::string({\cf22 "\\r"}));\}\par
330         {\cf19 case} {\cf23 'u'} :\par
331         \{\par
332             {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_escape_unicode_short::invoke(loc))\par
333             \{\par
334                 {\cf19 return} ok(read_utf8_codepoint(token.unwrap(), loc));\par
335             \}\par
336             {\cf19 else}\par
337             \{\par
338                 {\cf19 return} err(format_underline({\cf22 "parse_escape_sequence: "}\par
339                            {\cf22 "invalid token found in UTF-8 codepoint uXXXX."},\par
340                            \{\{source_location(loc), {\cf22 "here"}\}\}));\par
341             \}\par
342         \}\par
343         {\cf19 case} {\cf23 'U'}:\par
344         \{\par
345             {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_escape_unicode_long::invoke(loc))\par
346             \{\par
347                 {\cf19 return} ok(read_utf8_codepoint(token.unwrap(), loc));\par
348             \}\par
349             {\cf19 else}\par
350             \{\par
351                 {\cf19 return} err(format_underline({\cf22 "parse_escape_sequence: "}\par
352                            {\cf22 "invalid token found in UTF-8 codepoint Uxxxxxxxx"},\par
353                            \{\{source_location(loc), {\cf22 "here"}\}\}));\par
354             \}\par
355         \}\par
356     \}\par
357 \par
358     {\cf17 const} {\cf17 auto} msg = format_underline({\cf22 "parse_escape_sequence: "}\par
359            {\cf22 "unknown escape sequence appeared."}, \{\{source_location(loc),\par
360            {\cf22 "escape sequence is one of \\\\, \\", b, t, n, f, r, uxxxx, Uxxxxxxxx"}\}\},\par
361            {\cf20 /* Hints = */}\{{\cf22 "if you want to write backslash as just one backslash, "}\par
362            {\cf22 "use literal string like: regex    = '<\\\\i\\\\c*\\\\s*>'"}\});\par
363     loc.reset(first);\par
364     {\cf19 return} err(msg);\par
365 \}\par
366 \par
367 {\cf17 inline} std::ptrdiff_t check_utf8_validity({\cf17 const} std::string& reg)\par
368 \{\par
369     location loc({\cf22 "tmp"}, reg);\par
370     {\cf17 const} {\cf17 auto} u8 = repeat<lex_utf8_code, unlimited>::invoke(loc);\par
371     {\cf19 if}(!u8 || loc.iter() != loc.end())\par
372     \{\par
373         {\cf17 const} {\cf17 auto} error_location = std::distance(loc.begin(), loc.iter());\par
374         assert(0 <= error_location);\par
375         {\cf19 return} error_location;\par
376     \}\par
377     {\cf19 return} -1;\par
378 \}\par
379 \par
380 {\cf17 inline} result<std::pair<toml::string, region>, std::string>\par
381 parse_ml_basic_string(location& loc)\par
382 \{\par
383     {\cf17 const} {\cf17 auto} first = loc.iter();\par
384     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_ml_basic_string::invoke(loc))\par
385     \{\par
386         {\cf17 auto} inner_loc = loc;\par
387         inner_loc.reset(first);\par
388 \par
389         std::string retval;\par
390         retval.reserve(token.unwrap().size());\par
391 \par
392         {\cf17 auto} delim = lex_ml_basic_string_open::invoke(inner_loc);\par
393         {\cf19 if}(!delim)\par
394         \{\par
395             {\cf19 throw} internal_error(format_underline(\par
396                 {\cf22 "parse_ml_basic_string: invalid token"},\par
397                 \{\{source_location(inner_loc), {\cf22 "should be \\"\\"\\""}\}\}),\par
398                 source_location(inner_loc));\par
399         \}\par
400         {\cf20 // immediate newline is ignored (if exists)}\par
401         {\cf20 /* discard return value */} lex_newline::invoke(inner_loc);\par
402 \par
403         delim = none();\par
404         {\cf19 while}(!delim)\par
405         \{\par
406             {\cf17 using }lex_unescaped_seq = repeat<\par
407                 either<lex_ml_basic_unescaped, lex_newline>, unlimited>;\par
408             {\cf19 if}({\cf17 auto} unescaped = lex_unescaped_seq::invoke(inner_loc))\par
409             \{\par
410                 retval += unescaped.unwrap().str();\par
411             \}\par
412             {\cf19 if}({\cf17 auto} escaped = parse_escape_sequence(inner_loc))\par
413             \{\par
414                 retval += escaped.unwrap();\par
415             \}\par
416             {\cf19 if}({\cf17 auto} esc_nl = lex_ml_basic_escaped_newline::invoke(inner_loc))\par
417             \{\par
418                 {\cf20 // ignore newline after escape until next non-ws char}\par
419             \}\par
420             {\cf19 if}(inner_loc.iter() == inner_loc.end())\par
421             \{\par
422                 {\cf19 throw} internal_error(format_underline(\par
423                     {\cf22 "parse_ml_basic_string: unexpected end of region"},\par
424                     \{\{source_location(inner_loc), {\cf22 "not sufficient token"}\}\}),\par
425                     source_location(inner_loc));\par
426             \}\par
427             delim = lex_ml_basic_string_close::invoke(inner_loc);\par
428         \}\par
429         {\cf20 // `lex_ml_basic_string_close` allows 3 to 5 `"`s to allow 1 or 2 `"`s}\par
430         {\cf20 // at just before the delimiter. Here, we need to attach `"`s at the}\par
431         {\cf20 // end of the string body, if it exists.}\par
432         {\cf20 // For detail, see the definition of `lex_ml_basic_string_close`.}\par
433         assert(std::all_of(delim.unwrap().first(), delim.unwrap().last(),\par
434                            []({\cf17 const} {\cf18 char} c) {\cf17 noexcept} \{return c == {\cf22 '\\"'};\}));\par
435         {\cf19 switch}(delim.unwrap().size())\par
436         \{\par
437             {\cf19 case} 3: \{{\cf19 break};\}\par
438             {\cf19 case} 4: \{retval += {\cf22 "\\""};  {\cf19 break};\}\par
439             {\cf19 case} 5: \{retval += {\cf22 "\\"\\""}; {\cf19 break};\}\par
440             {\cf19 default}:\par
441             \{\par
442                 {\cf19 throw} internal_error(format_underline(\par
443                     {\cf22 "parse_ml_basic_string: closing delimiter has invalid length"},\par
444                     \{\{source_location(inner_loc), {\cf22 "end of this"}\}\}),\par
445                     source_location(inner_loc));\par
446             \}\par
447         \}\par
448 \par
449         {\cf17 const} {\cf17 auto} err_loc = check_utf8_validity(token.unwrap().str());\par
450         {\cf19 if}(err_loc == -1)\par
451         \{\par
452             {\cf19 return} ok(std::make_pair(toml::string(retval), token.unwrap()));\par
453         \}\par
454         {\cf19 else}\par
455         \{\par
456             inner_loc.reset(first);\par
457             inner_loc.advance(err_loc);\par
458             {\cf19 throw} syntax_error(format_underline(\par
459                 {\cf22 "parse_ml_basic_string: invalid utf8 sequence found"},\par
460                 \{\{source_location(inner_loc), {\cf22 "here"}\}\}),\par
461                 source_location(inner_loc));\par
462         \}\par
463     \}\par
464     {\cf19 else}\par
465     \{\par
466         loc.reset(first);\par
467         {\cf19 return} err(format_underline({\cf22 "toml::parse_ml_basic_string: "}\par
468                    {\cf22 "the next token is not a valid multiline string"},\par
469                    \{\{source_location(loc), {\cf22 "here"}\}\}));\par
470     \}\par
471 \}\par
472 \par
473 {\cf17 inline} result<std::pair<toml::string, region>, std::string>\par
474 parse_basic_string(location& loc)\par
475 \{\par
476     {\cf17 const} {\cf17 auto} first = loc.iter();\par
477     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_basic_string::invoke(loc))\par
478     \{\par
479         {\cf17 auto} inner_loc = loc;\par
480         inner_loc.reset(first);\par
481 \par
482         {\cf17 auto} quot = lex_quotation_mark::invoke(inner_loc);\par
483         {\cf19 if}(!quot)\par
484         \{\par
485             {\cf19 throw} internal_error(format_underline({\cf22 "parse_basic_string: "}\par
486                 {\cf22 "invalid token"}, \{\{source_location(inner_loc), {\cf22 "should be \\""}\}\}),\par
487                 source_location(inner_loc));\par
488         \}\par
489 \par
490         std::string retval;\par
491         retval.reserve(token.unwrap().size());\par
492 \par
493         quot = none();\par
494         {\cf19 while}(!quot)\par
495         \{\par
496             {\cf17 using }lex_unescaped_seq = repeat<lex_basic_unescaped, unlimited>;\par
497             {\cf19 if}({\cf17 auto} unescaped = lex_unescaped_seq::invoke(inner_loc))\par
498             \{\par
499                 retval += unescaped.unwrap().str();\par
500             \}\par
501             {\cf19 if}({\cf17 auto} escaped = parse_escape_sequence(inner_loc))\par
502             \{\par
503                 retval += escaped.unwrap();\par
504             \}\par
505             {\cf19 if}(inner_loc.iter() == inner_loc.end())\par
506             \{\par
507                 {\cf19 throw} internal_error(format_underline(\par
508                     {\cf22 "parse_basic_string: unexpected end of region"},\par
509                     \{\{source_location(inner_loc), {\cf22 "not sufficient token"}\}\}),\par
510                     source_location(inner_loc));\par
511             \}\par
512             quot = lex_quotation_mark::invoke(inner_loc);\par
513         \}\par
514 \par
515         {\cf17 const} {\cf17 auto} err_loc = check_utf8_validity(token.unwrap().str());\par
516         {\cf19 if}(err_loc == -1)\par
517         \{\par
518             {\cf19 return} ok(std::make_pair(toml::string(retval), token.unwrap()));\par
519         \}\par
520         {\cf19 else}\par
521         \{\par
522             inner_loc.reset(first);\par
523             inner_loc.advance(err_loc);\par
524             {\cf19 throw} syntax_error(format_underline(\par
525                 {\cf22 "parse_ml_basic_string: invalid utf8 sequence found"},\par
526                 \{\{source_location(inner_loc), {\cf22 "here"}\}\}),\par
527                 source_location(inner_loc));\par
528         \}\par
529     \}\par
530     {\cf19 else}\par
531     \{\par
532         loc.reset(first); {\cf20 // rollback}\par
533         {\cf19 return} err(format_underline({\cf22 "toml::parse_basic_string: "}\par
534                    {\cf22 "the next token is not a valid string"},\par
535                    \{\{source_location(loc), {\cf22 "here"}\}\}));\par
536     \}\par
537 \}\par
538 \par
539 {\cf17 inline} result<std::pair<toml::string, region>, std::string>\par
540 parse_ml_literal_string(location& loc)\par
541 \{\par
542     {\cf17 const} {\cf17 auto} first = loc.iter();\par
543     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_ml_literal_string::invoke(loc))\par
544     \{\par
545         location inner_loc(loc.name(), token.unwrap().str());\par
546 \par
547         {\cf17 const} {\cf17 auto} open = lex_ml_literal_string_open::invoke(inner_loc);\par
548         {\cf19 if}(!open)\par
549         \{\par
550             {\cf19 throw} internal_error(format_underline(\par
551                 {\cf22 "parse_ml_literal_string: invalid token"},\par
552                 \{\{source_location(inner_loc), {\cf22 "should be '''"}\}\}),\par
553                 source_location(inner_loc));\par
554         \}\par
555         {\cf20 // immediate newline is ignored (if exists)}\par
556         {\cf20 /* discard return value */} lex_newline::invoke(inner_loc);\par
557 \par
558         {\cf17 const} {\cf17 auto} body = lex_ml_literal_body::invoke(inner_loc);\par
559 \par
560         {\cf17 const} {\cf17 auto} close = lex_ml_literal_string_close::invoke(inner_loc);\par
561         {\cf19 if}(!close)\par
562         \{\par
563             {\cf19 throw} internal_error(format_underline(\par
564                 {\cf22 "parse_ml_literal_string: invalid token"},\par
565                 \{\{source_location(inner_loc), {\cf22 "should be '''"}\}\}),\par
566                 source_location(inner_loc));\par
567         \}\par
568         {\cf20 // `lex_ml_literal_string_close` allows 3 to 5 `'`s to allow 1 or 2 `'`s}\par
569         {\cf20 // at just before the delimiter. Here, we need to attach `'`s at the}\par
570         {\cf20 // end of the string body, if it exists.}\par
571         {\cf20 // For detail, see the definition of `lex_ml_basic_string_close`.}\par
572 \par
573         std::string retval = body.unwrap().str();\par
574         assert(std::all_of(close.unwrap().first(), close.unwrap().last(),\par
575                            []({\cf17 const} {\cf18 char} c) {\cf17 noexcept} \{return c == {\cf22 '\\''};\}));\par
576         {\cf19 switch}(close.unwrap().size())\par
577         \{\par
578             {\cf19 case} 3: \{{\cf19 break};\}\par
579             {\cf19 case} 4: \{retval += {\cf22 "'"};  {\cf19 break};\}\par
580             {\cf19 case} 5: \{retval += {\cf22 "''"}; {\cf19 break};\}\par
581             {\cf19 default}:\par
582             \{\par
583                 {\cf19 throw} internal_error(format_underline(\par
584                     {\cf22 "parse_ml_literal_string: closing delimiter has invalid length"},\par
585                     \{\{source_location(inner_loc), {\cf22 "end of this"}\}\}),\par
586                     source_location(inner_loc));\par
587             \}\par
588         \}\par
589 \par
590         {\cf17 const} {\cf17 auto} err_loc = check_utf8_validity(token.unwrap().str());\par
591         {\cf19 if}(err_loc == -1)\par
592         \{\par
593             {\cf19 return} ok(std::make_pair(toml::string(retval, toml::string_t::literal),\par
594                                      token.unwrap()));\par
595         \}\par
596         {\cf19 else}\par
597         \{\par
598             inner_loc.reset(first);\par
599             inner_loc.advance(err_loc);\par
600             {\cf19 throw} syntax_error(format_underline(\par
601                 {\cf22 "parse_ml_basic_string: invalid utf8 sequence found"},\par
602                 \{\{source_location(inner_loc), {\cf22 "here"}\}\}),\par
603                 source_location(inner_loc));\par
604         \}\par
605     \}\par
606     {\cf19 else}\par
607     \{\par
608         loc.reset(first); {\cf20 // rollback}\par
609         {\cf19 return} err(format_underline({\cf22 "toml::parse_ml_literal_string: "}\par
610                    {\cf22 "the next token is not a valid multiline literal string"},\par
611                    \{\{source_location(loc), {\cf22 "here"}\}\}));\par
612     \}\par
613 \}\par
614 \par
615 {\cf17 inline} result<std::pair<toml::string, region>, std::string>\par
616 parse_literal_string(location& loc)\par
617 \{\par
618     {\cf17 const} {\cf17 auto} first = loc.iter();\par
619     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_literal_string::invoke(loc))\par
620     \{\par
621         location inner_loc(loc.name(), token.unwrap().str());\par
622 \par
623         {\cf17 const} {\cf17 auto} open = lex_apostrophe::invoke(inner_loc);\par
624         {\cf19 if}(!open)\par
625         \{\par
626             {\cf19 throw} internal_error(format_underline(\par
627                 {\cf22 "parse_literal_string: invalid token"},\par
628                 \{\{source_location(inner_loc), {\cf22 "should be '"}\}\}),\par
629                 source_location(inner_loc));\par
630         \}\par
631 \par
632         {\cf17 const} {\cf17 auto} body = repeat<lex_literal_char, unlimited>::invoke(inner_loc);\par
633 \par
634         {\cf17 const} {\cf17 auto} close = lex_apostrophe::invoke(inner_loc);\par
635         {\cf19 if}(!close)\par
636         \{\par
637             {\cf19 throw} internal_error(format_underline(\par
638                 {\cf22 "parse_literal_string: invalid token"},\par
639                 \{\{source_location(inner_loc), {\cf22 "should be '"}\}\}),\par
640                 source_location(inner_loc));\par
641         \}\par
642 \par
643         {\cf17 const} {\cf17 auto} err_loc = check_utf8_validity(token.unwrap().str());\par
644         {\cf19 if}(err_loc == -1)\par
645         \{\par
646             {\cf19 return} ok(std::make_pair(\par
647                       toml::string(body.unwrap().str(), toml::string_t::literal),\par
648                       token.unwrap()));\par
649         \}\par
650         {\cf19 else}\par
651         \{\par
652             inner_loc.reset(first);\par
653             inner_loc.advance(err_loc);\par
654             {\cf19 throw} syntax_error(format_underline(\par
655                 {\cf22 "parse_ml_basic_string: invalid utf8 sequence found"},\par
656                 \{\{source_location(inner_loc), {\cf22 "here"}\}\}),\par
657                 source_location(inner_loc));\par
658         \}\par
659     \}\par
660     {\cf19 else}\par
661     \{\par
662         loc.reset(first); {\cf20 // rollback}\par
663         {\cf19 return} err(format_underline({\cf22 "toml::parse_literal_string: "}\par
664                    {\cf22 "the next token is not a valid literal string"},\par
665                    \{\{source_location(loc), {\cf22 "here"}\}\}));\par
666     \}\par
667 \}\par
668 \par
669 {\cf17 inline} result<std::pair<toml::string, region>, std::string>\par
670 parse_string(location& loc)\par
671 \{\par
672     {\cf19 if}(loc.iter() != loc.end() && *(loc.iter()) == {\cf23 '"'})\par
673     \{\par
674         {\cf19 if}(loc.iter() + 1 != loc.end() && *(loc.iter() + 1) == {\cf23 '"'} &&\par
675            loc.iter() + 2 != loc.end() && *(loc.iter() + 2) == {\cf23 '"'})\par
676         \{\par
677             {\cf19 return} parse_ml_basic_string(loc);\par
678         \}\par
679         {\cf19 else}\par
680         \{\par
681             {\cf19 return} parse_basic_string(loc);\par
682         \}\par
683     \}\par
684     {\cf19 else} {\cf19 if}(loc.iter() != loc.end() && *(loc.iter()) == {\cf23 '\\''})\par
685     \{\par
686         {\cf19 if}(loc.iter() + 1 != loc.end() && *(loc.iter() + 1) == {\cf23 '\\''} &&\par
687            loc.iter() + 2 != loc.end() && *(loc.iter() + 2) == {\cf23 '\\''})\par
688         \{\par
689             {\cf19 return} parse_ml_literal_string(loc);\par
690         \}\par
691         {\cf19 else}\par
692         \{\par
693             {\cf19 return} parse_literal_string(loc);\par
694         \}\par
695     \}\par
696     {\cf19 return} err(format_underline({\cf22 "toml::parse_string: "},\par
697                 \{\{source_location(loc), {\cf22 "the next token is not a string"}\}\}));\par
698 \}\par
699 \par
700 {\cf17 inline} result<std::pair<local_date, region>, std::string>\par
701 parse_local_date(location& loc)\par
702 \{\par
703     {\cf17 const} {\cf17 auto} first = loc.iter();\par
704     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_local_date::invoke(loc))\par
705     \{\par
706         location inner_loc(loc.name(), token.unwrap().str());\par
707 \par
708         {\cf17 const} {\cf17 auto} y = lex_date_fullyear::invoke(inner_loc);\par
709         {\cf19 if}(!y || inner_loc.iter() == inner_loc.end() || *inner_loc.iter() != {\cf23 '-'})\par
710         \{\par
711             {\cf19 throw} internal_error(format_underline(\par
712                 {\cf22 "toml::parse_inner_local_date: invalid year format"},\par
713                 \{\{source_location(inner_loc), {\cf22 "should be `-`"}\}\}),\par
714                 source_location(inner_loc));\par
715         \}\par
716         inner_loc.advance();\par
717         {\cf17 const} {\cf17 auto} m = lex_date_month::invoke(inner_loc);\par
718         {\cf19 if}(!m || inner_loc.iter() == inner_loc.end() || *inner_loc.iter() != {\cf23 '-'})\par
719         \{\par
720             {\cf19 throw} internal_error(format_underline(\par
721                 {\cf22 "toml::parse_local_date: invalid month format"},\par
722                 \{\{source_location(inner_loc), {\cf22 "should be `-`"}\}\}),\par
723                 source_location(inner_loc));\par
724         \}\par
725         inner_loc.advance();\par
726         {\cf17 const} {\cf17 auto} d = lex_date_mday::invoke(inner_loc);\par
727         {\cf19 if}(!d)\par
728         \{\par
729             {\cf19 throw} internal_error(format_underline(\par
730                 {\cf22 "toml::parse_local_date: invalid day format"},\par
731                 \{\{source_location(inner_loc), {\cf22 "here"}\}\}),\par
732                 source_location(inner_loc));\par
733         \}\par
734 \par
735         {\cf17 const} {\cf17 auto} year  = {\cf17 static_cast<}std::int16_t{\cf17 >}(from_string<int>(y.unwrap().str(), 0));\par
736         {\cf17 const} {\cf17 auto} month = {\cf17 static_cast<}std::int8_t {\cf17 >}(from_string<int>(m.unwrap().str(), 0));\par
737         {\cf17 const} {\cf17 auto} day   = {\cf17 static_cast<}std::int8_t {\cf17 >}(from_string<int>(d.unwrap().str(), 0));\par
738 \par
739         {\cf20 // We briefly check whether the input date is valid or not. But here, we}\par
740         {\cf20 // only check if the RFC3339 compliance.}\par
741         {\cf20 //     Actually there are several special date that does not exist,}\par
742         {\cf20 // because of historical reasons, such as 1582/10/5-1582/10/14 (only in}\par
743         {\cf20 // several countries). But here, we do not care about such a complicated}\par
744         {\cf20 // rule. It makes the code complicated and there is only low probability}\par
745         {\cf20 // that such a specific date is needed in practice. If someone need to}\par
746         {\cf20 // validate date accurately, that means that the one need a specialized}\par
747         {\cf20 // library for their purpose in a different layer.}\par
748         \{\par
749             {\cf17 const} {\cf18 bool} is_leap = (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0));\par
750             {\cf17 const} {\cf17 auto} max_day = (month == 2) ? (is_leap ? 29 : 28) :\par
751                 ((month == 4 || month == 6 || month == 9 || month == 11) ? 30 : 31);\par
752 \par
753             {\cf19 if}((month < 1 || 12 < month) || (day < 1 || max_day < day))\par
754             \{\par
755                 {\cf19 throw} syntax_error(format_underline({\cf22 "toml::parse_date: "}\par
756                     {\cf22 "invalid date: it does not conform RFC3339."}, \{\{\par
757                     source_location(loc), {\cf22 "month should be 01-12, day should be"}\par
758                     {\cf22 " 01-28,29,30,31, depending on month/year."}\par
759                     \}\}), source_location(inner_loc));\par
760             \}\par
761         \}\par
762         {\cf19 return} ok(std::make_pair(local_date(year, {\cf17 static_cast<}month_t{\cf17 >}(month - 1), day),\par
763                                  token.unwrap()));\par
764     \}\par
765     {\cf19 else}\par
766     \{\par
767         loc.reset(first);\par
768         {\cf19 return} err(format_underline({\cf22 "toml::parse_local_date: "},\par
769             \{\{source_location(loc), {\cf22 "the next token is not a local_date"}\}\}));\par
770     \}\par
771 \}\par
772 \par
773 {\cf17 inline} result<std::pair<local_time, region>, std::string>\par
774 parse_local_time(location& loc)\par
775 \{\par
776     {\cf17 const} {\cf17 auto} first = loc.iter();\par
777     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_local_time::invoke(loc))\par
778     \{\par
779         location inner_loc(loc.name(), token.unwrap().str());\par
780 \par
781         {\cf17 const} {\cf17 auto} h = lex_time_hour::invoke(inner_loc);\par
782         {\cf19 if}(!h || inner_loc.iter() == inner_loc.end() || *inner_loc.iter() != {\cf23 ':'})\par
783         \{\par
784             {\cf19 throw} internal_error(format_underline(\par
785                 {\cf22 "toml::parse_local_time: invalid year format"},\par
786                 \{\{source_location(inner_loc), {\cf22 "should be `:`"}\}\}),\par
787                 source_location(inner_loc));\par
788         \}\par
789         inner_loc.advance();\par
790         {\cf17 const} {\cf17 auto} m = lex_time_minute::invoke(inner_loc);\par
791         {\cf19 if}(!m || inner_loc.iter() == inner_loc.end() || *inner_loc.iter() != {\cf23 ':'})\par
792         \{\par
793             {\cf19 throw} internal_error(format_underline(\par
794                 {\cf22 "toml::parse_local_time: invalid month format"},\par
795                 \{\{source_location(inner_loc), {\cf22 "should be `:`"}\}\}),\par
796                 source_location(inner_loc));\par
797         \}\par
798         inner_loc.advance();\par
799         {\cf17 const} {\cf17 auto} s = lex_time_second::invoke(inner_loc);\par
800         {\cf19 if}(!s)\par
801         \{\par
802             {\cf19 throw} internal_error(format_underline(\par
803                 {\cf22 "toml::parse_local_time: invalid second format"},\par
804                 \{\{source_location(inner_loc), {\cf22 "here"}\}\}),\par
805                 source_location(inner_loc));\par
806         \}\par
807 \par
808         {\cf17 const} {\cf18 int} hour   = from_string<int>(h.unwrap().str(), 0);\par
809         {\cf17 const} {\cf18 int} minute = from_string<int>(m.unwrap().str(), 0);\par
810         {\cf17 const} {\cf18 int} second = from_string<int>(s.unwrap().str(), 0);\par
811 \par
812         {\cf19 if}((hour   < 0 || 23 < hour) || (minute < 0 || 59 < minute) ||\par
813            (second < 0 || 60 < second)) {\cf20 // it may be leap second}\par
814         \{\par
815             {\cf19 throw} syntax_error(format_underline({\cf22 "toml::parse_time: "}\par
816                 {\cf22 "invalid time: it does not conform RFC3339."}, \{\{\par
817                 source_location(loc), {\cf22 "hour should be 00-23, minute should be"}\par
818                 {\cf22 " 00-59, second should be 00-60 (depending on the leap"}\par
819                 {\cf22 " second rules.)"}\}\}), source_location(inner_loc));\par
820         \}\par
821 \par
822         local_time time(hour, minute, second, 0, 0);\par
823 \par
824         {\cf17 const} {\cf17 auto} before_secfrac = inner_loc.iter();\par
825         {\cf19 if}({\cf17 const} {\cf17 auto} secfrac = lex_time_secfrac::invoke(inner_loc))\par
826         \{\par
827             {\cf17 auto} sf = secfrac.unwrap().str();\par
828             sf.erase(sf.begin()); {\cf20 // sf.front() == '.'}\par
829             {\cf19 switch}(sf.size() % 3)\par
830             \{\par
831                 {\cf19 case} 2:  sf += {\cf23 '0'};  {\cf19 break};\par
832                 {\cf19 case} 1:  sf += {\cf22 "00"}; {\cf19 break};\par
833                 {\cf19 case} 0:  {\cf19 break};\par
834                 {\cf19 default}: {\cf19 break};\par
835             \}\par
836             {\cf19 if}(sf.size() >= 9)\par
837             \{\par
838                 time.millisecond = from_string<std::uint16_t>(sf.substr(0, 3), 0u);\par
839                 time.microsecond = from_string<std::uint16_t>(sf.substr(3, 3), 0u);\par
840                 time.nanosecond  = from_string<std::uint16_t>(sf.substr(6, 3), 0u);\par
841             \}\par
842             {\cf19 else} {\cf19 if}(sf.size() >= 6)\par
843             \{\par
844                 time.millisecond = from_string<std::uint16_t>(sf.substr(0, 3), 0u);\par
845                 time.microsecond = from_string<std::uint16_t>(sf.substr(3, 3), 0u);\par
846             \}\par
847             {\cf19 else} {\cf19 if}(sf.size() >= 3)\par
848             \{\par
849                 time.millisecond = from_string<std::uint16_t>(sf, 0u);\par
850                 time.microsecond = 0u;\par
851             \}\par
852         \}\par
853         {\cf19 else}\par
854         \{\par
855             {\cf19 if}(before_secfrac != inner_loc.iter())\par
856             \{\par
857                 {\cf19 throw} internal_error(format_underline(\par
858                     {\cf22 "toml::parse_local_time: invalid subsecond format"},\par
859                     \{\{source_location(inner_loc), {\cf22 "here"}\}\}),\par
860                 source_location(inner_loc));\par
861             \}\par
862         \}\par
863         {\cf19 return} ok(std::make_pair(time, token.unwrap()));\par
864     \}\par
865     {\cf19 else}\par
866     \{\par
867         loc.reset(first);\par
868         {\cf19 return} err(format_underline({\cf22 "toml::parse_local_time: "},\par
869             \{\{source_location(loc), {\cf22 "the next token is not a local_time"}\}\}));\par
870     \}\par
871 \}\par
872 \par
873 {\cf17 inline} result<std::pair<local_datetime, region>, std::string>\par
874 parse_local_datetime(location& loc)\par
875 \{\par
876     {\cf17 const} {\cf17 auto} first = loc.iter();\par
877     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_local_date_time::invoke(loc))\par
878     \{\par
879         location inner_loc(loc.name(), token.unwrap().str());\par
880         {\cf17 const} {\cf17 auto} date = parse_local_date(inner_loc);\par
881         {\cf19 if}(!date || inner_loc.iter() == inner_loc.end())\par
882         \{\par
883             {\cf19 throw} internal_error(format_underline(\par
884                 {\cf22 "toml::parse_local_datetime: invalid datetime format"},\par
885                 \{\{source_location(inner_loc), {\cf22 "date, not datetime"}\}\}),\par
886                 source_location(inner_loc));\par
887         \}\par
888         {\cf17 const} {\cf18 char} delim = *(inner_loc.iter());\par
889         {\cf19 if}(delim != {\cf23 'T'} && delim != {\cf23 't'} && delim != {\cf23 ' '})\par
890         \{\par
891             {\cf19 throw} internal_error(format_underline(\par
892                 {\cf22 "toml::parse_local_datetime: invalid datetime format"},\par
893                 \{\{source_location(inner_loc), {\cf22 "should be `T` or ` ` (space)"}\}\}),\par
894                 source_location(inner_loc));\par
895         \}\par
896         inner_loc.advance();\par
897         {\cf17 const} {\cf17 auto} time = parse_local_time(inner_loc);\par
898         {\cf19 if}(!time)\par
899         \{\par
900             {\cf19 throw} internal_error(format_underline(\par
901                 {\cf22 "toml::parse_local_datetime: invalid datetime format"},\par
902                 \{\{source_location(inner_loc), {\cf22 "invalid time format"}\}\}),\par
903                 source_location(inner_loc));\par
904         \}\par
905         {\cf19 return} ok(std::make_pair(\par
906             local_datetime(date.unwrap().first, time.unwrap().first),\par
907             token.unwrap()));\par
908     \}\par
909     {\cf19 else}\par
910     \{\par
911         loc.reset(first);\par
912         {\cf19 return} err(format_underline({\cf22 "toml::parse_local_datetime: "},\par
913             \{\{source_location(loc), {\cf22 "the next token is not a local_datetime"}\}\}));\par
914     \}\par
915 \}\par
916 \par
917 {\cf17 inline} result<std::pair<offset_datetime, region>, std::string>\par
918 parse_offset_datetime(location& loc)\par
919 \{\par
920     {\cf17 const} {\cf17 auto} first = loc.iter();\par
921     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_offset_date_time::invoke(loc))\par
922     \{\par
923         location inner_loc(loc.name(), token.unwrap().str());\par
924         {\cf17 const} {\cf17 auto} datetime = parse_local_datetime(inner_loc);\par
925         {\cf19 if}(!datetime || inner_loc.iter() == inner_loc.end())\par
926         \{\par
927             {\cf19 throw} internal_error(format_underline(\par
928                 {\cf22 "toml::parse_offset_datetime: invalid datetime format"},\par
929                 \{\{source_location(inner_loc), {\cf22 "date, not datetime"}\}\}),\par
930                 source_location(inner_loc));\par
931         \}\par
932         time_offset offset(0, 0);\par
933         {\cf19 if}({\cf17 const} {\cf17 auto} ofs = lex_time_numoffset::invoke(inner_loc))\par
934         \{\par
935             {\cf17 const} {\cf17 auto} str = ofs.unwrap().str();\par
936 \par
937             {\cf17 const} {\cf17 auto} hour   = from_string<int>(str.substr(1,2), 0);\par
938             {\cf17 const} {\cf17 auto} minute = from_string<int>(str.substr(4,2), 0);\par
939 \par
940             {\cf19 if}((hour < 0 || 23 < hour) || (minute < 0 || 59 < minute))\par
941             \{\par
942                 {\cf19 throw} syntax_error(format_underline({\cf22 "toml::parse_offset_datetime: "}\par
943                     {\cf22 "invalid offset: it does not conform RFC3339."}, \{\{\par
944                     source_location(loc), {\cf22 "month should be 01-12, day should be"}\par
945                     {\cf22 " 01-28,29,30,31, depending on month/year."}\par
946                     \}\}), source_location(inner_loc));\par
947             \}\par
948 \par
949             {\cf19 if}(str.front() == {\cf23 '+'})\par
950             \{\par
951                 offset = time_offset(hour, minute);\par
952             \}\par
953             {\cf19 else}\par
954             \{\par
955                 offset = time_offset(-hour, -minute);\par
956             \}\par
957         \}\par
958         {\cf19 else} {\cf19 if}(*inner_loc.iter() != {\cf23 'Z'} && *inner_loc.iter() != {\cf23 'z'})\par
959         \{\par
960             {\cf19 throw} internal_error(format_underline(\par
961                 {\cf22 "toml::parse_offset_datetime: invalid datetime format"},\par
962                 \{\{source_location(inner_loc), {\cf22 "should be `Z` or `+HH:MM`"}\}\}),\par
963                 source_location(inner_loc));\par
964         \}\par
965         {\cf19 return} ok(std::make_pair(offset_datetime(datetime.unwrap().first, offset),\par
966                                  token.unwrap()));\par
967     \}\par
968     {\cf19 else}\par
969     \{\par
970         loc.reset(first);\par
971         {\cf19 return} err(format_underline({\cf22 "toml::parse_offset_datetime: "},\par
972             \{\{source_location(loc), {\cf22 "the next token is not a offset_datetime"}\}\}));\par
973     \}\par
974 \}\par
975 \par
976 {\cf17 inline} result<std::pair<key, region>, std::string>\par
977 parse_simple_key(location& loc)\par
978 \{\par
979     {\cf19 if}({\cf17 const} {\cf17 auto} bstr = parse_basic_string(loc))\par
980     \{\par
981         {\cf19 return} ok(std::make_pair(bstr.unwrap().first.str, bstr.unwrap().second));\par
982     \}\par
983     {\cf19 if}({\cf17 const} {\cf17 auto} lstr = parse_literal_string(loc))\par
984     \{\par
985         {\cf19 return} ok(std::make_pair(lstr.unwrap().first.str, lstr.unwrap().second));\par
986     \}\par
987     {\cf19 if}({\cf17 const} {\cf17 auto} bare = lex_unquoted_key::invoke(loc))\par
988     \{\par
989         {\cf17 const} {\cf17 auto} reg = bare.unwrap();\par
990         {\cf19 return} ok(std::make_pair(reg.str(), reg));\par
991     \}\par
992     {\cf19 return} err(format_underline({\cf22 "toml::parse_simple_key: "},\par
993             \{\{source_location(loc), {\cf22 "the next token is not a simple key"}\}\}));\par
994 \}\par
995 \par
996 {\cf20 // dotted key become vector of keys}\par
997 {\cf17 inline} result<std::pair<std::vector<key>, region>, std::string>\par
998 parse_key(location& loc)\par
999 \{\par
1000     {\cf17 const} {\cf17 auto} first = loc.iter();\par
1001     {\cf20 // dotted key -> `foo.bar.baz` where several single keys are chained by}\par
1002     {\cf20 // dots. Whitespaces between keys and dots are allowed.}\par
1003     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_dotted_key::invoke(loc))\par
1004     \{\par
1005         {\cf17 const} {\cf17 auto} reg = token.unwrap();\par
1006         location inner_loc(loc.name(), reg.str());\par
1007         std::vector<key> keys;\par
1008 \par
1009         {\cf19 while}(inner_loc.iter() != inner_loc.end())\par
1010         \{\par
1011             lex_ws::invoke(inner_loc);\par
1012             {\cf19 if}({\cf17 const} {\cf17 auto} k = parse_simple_key(inner_loc))\par
1013             \{\par
1014                 keys.push_back(k.unwrap().first);\par
1015             \}\par
1016             {\cf19 else}\par
1017             \{\par
1018                 {\cf19 throw} internal_error(format_underline(\par
1019                     {\cf22 "toml::detail::parse_key: dotted key contains invalid key"},\par
1020                     \{\{source_location(inner_loc), k.unwrap_err()\}\}),\par
1021                     source_location(inner_loc));\par
1022             \}\par
1023 \par
1024             lex_ws::invoke(inner_loc);\par
1025             {\cf19 if}(inner_loc.iter() == inner_loc.end())\par
1026             \{\par
1027                 {\cf19 break};\par
1028             \}\par
1029             {\cf19 else} {\cf19 if}(*inner_loc.iter() == {\cf23 '.'})\par
1030             \{\par
1031                 inner_loc.advance(); {\cf20 // to skip `.`}\par
1032             \}\par
1033             {\cf19 else}\par
1034             \{\par
1035                 {\cf19 throw} internal_error(format_underline({\cf22 "toml::parse_key: "}\par
1036                     {\cf22 "dotted key contains invalid key "},\par
1037                     \{\{source_location(inner_loc), {\cf22 "should be `.`"}\}\}),\par
1038                     source_location(inner_loc));\par
1039             \}\par
1040         \}\par
1041         {\cf19 return} ok(std::make_pair(keys, reg));\par
1042     \}\par
1043     loc.reset(first);\par
1044 \par
1045     {\cf20 // simple_key: a single (basic_string|literal_string|bare key)}\par
1046     {\cf19 if}({\cf17 const} {\cf17 auto} smpl = parse_simple_key(loc))\par
1047     \{\par
1048         {\cf19 return} ok(std::make_pair(std::vector<key>(1, smpl.unwrap().first),\par
1049                                  smpl.unwrap().second));\par
1050     \}\par
1051     {\cf19 return} err(format_underline({\cf22 "toml::parse_key: an invalid key appeared."},\par
1052                 \{\{source_location(loc), {\cf22 "is not a valid key"}\}\}, \{\par
1053                 {\cf22 "bare keys  : non-empty strings composed only of [A-Za-z0-9_-]."},\par
1054                 {\cf22 "quoted keys: same as \\"basic strings\\" or 'literal strings'."},\par
1055                 {\cf22 "dotted keys: sequence of bare or quoted keys joined with a dot."}\par
1056                 \}));\par
1057 \}\par
1058 \par
1059 {\cf20 // forward-decl to implement parse_array and parse_table}\par
1060 {\cf17 template}<{\cf17 typename} Value>\par
1061 result<Value, std::string> parse_value(location&);\par
1062 \par
1063 {\cf17 template}<{\cf17 typename} Value>\par
1064 result<std::pair<typename Value::array_type, region>, std::string>\par
1065 parse_array(location& loc)\par
1066 \{\par
1067     {\cf17 using }value_type = Value;\par
1068     {\cf17 using }array_type = {\cf17 typename} value_type::array_type;\par
1069 \par
1070     {\cf17 const} {\cf17 auto} first = loc.iter();\par
1071     {\cf19 if}(loc.iter() == loc.end())\par
1072     \{\par
1073         {\cf19 return} err({\cf22 "toml::parse_array: input is empty"});\par
1074     \}\par
1075     {\cf19 if}(*loc.iter() != {\cf23 '['})\par
1076     \{\par
1077         {\cf19 return} err({\cf22 "toml::parse_array: token is not an array"});\par
1078     \}\par
1079     loc.advance();\par
1080 \par
1081     {\cf17 using }lex_ws_comment_newline = repeat<\par
1082         either<lex_wschar, lex_newline, lex_comment>, unlimited>;\par
1083 \par
1084     array_type retval;\par
1085     {\cf19 while}(loc.iter() != loc.end())\par
1086     \{\par
1087         lex_ws_comment_newline::invoke(loc); {\cf20 // skip}\par
1088 \par
1089         {\cf19 if}(loc.iter() != loc.end() && *loc.iter() == {\cf23 ']'})\par
1090         \{\par
1091             loc.advance(); {\cf20 // skip ']'}\par
1092             {\cf19 return} ok(std::make_pair(retval,\par
1093                       region(loc, first, loc.iter())));\par
1094         \}\par
1095 \par
1096         {\cf19 if}({\cf17 auto} val = parse_value<value_type>(loc))\par
1097         \{\par
1098             {\cf20 // After TOML v1.0.0-rc.1, array becomes to be able to have values}\par
1099             {\cf20 // with different types. So here we will omit this by default.}\par
1100             {\cf20 //}\par
1101             {\cf20 // But some of the test-suite checks if the parser accepts a hetero-}\par
1102             {\cf20 // geneous arrays, so we keep this for a while.}\par
1103 {\cf21 #ifdef TOML11_DISALLOW_HETEROGENEOUS_ARRAYS}\par
1104             {\cf19 if}(!retval.empty() && retval.front().type() != val.as_ok().type())\par
1105             \{\par
1106                 {\cf17 auto} array_start_loc = loc;\par
1107                 array_start_loc.reset(first);\par
1108 \par
1109                 {\cf19 throw} syntax_error(format_underline({\cf22 "toml::parse_array: "}\par
1110                     {\cf22 "type of elements should be the same each other."}, \{\par
1111                         \{source_location(array_start_loc), {\cf22 "array starts here"}\},\par
1112                         \{\par
1113                             retval.front().location(),\par
1114                             {\cf22 "value has type "} + stringize(retval.front().type())\par
1115                         \},\par
1116                         \{\par
1117                             val.unwrap().location(),\par
1118                             {\cf22 "value has different type, "} + stringize(val.unwrap().type())\par
1119                         \}\par
1120                     \}), source_location(loc));\par
1121             \}\par
1122 {\cf21 #endif}\par
1123             retval.push_back(std::move(val.unwrap()));\par
1124         \}\par
1125         {\cf19 else}\par
1126         \{\par
1127             {\cf17 auto} array_start_loc = loc;\par
1128             array_start_loc.reset(first);\par
1129 \par
1130             {\cf19 throw} syntax_error(format_underline({\cf22 "toml::parse_array: "}\par
1131                 {\cf22 "value having invalid format appeared in an array"}, \{\par
1132                     \{source_location(array_start_loc), {\cf22 "array starts here"}\},\par
1133                     \{source_location(loc), {\cf22 "it is not a valid value."}\}\par
1134                 \}), source_location(loc));\par
1135         \}\par
1136 \par
1137         {\cf17 using }lex_array_separator = sequence<maybe<lex_ws_comment_newline>, character<','>>;\par
1138         {\cf17 const} {\cf17 auto} sp = lex_array_separator::invoke(loc);\par
1139         {\cf19 if}(!sp)\par
1140         \{\par
1141             lex_ws_comment_newline::invoke(loc);\par
1142             {\cf19 if}(loc.iter() != loc.end() && *loc.iter() == {\cf23 ']'})\par
1143             \{\par
1144                 loc.advance(); {\cf20 // skip ']'}\par
1145                 {\cf19 return} ok(std::make_pair(retval,\par
1146                           region(loc, first, loc.iter())));\par
1147             \}\par
1148             {\cf19 else}\par
1149             \{\par
1150                 {\cf17 auto} array_start_loc = loc;\par
1151                 array_start_loc.reset(first);\par
1152 \par
1153                 {\cf19 throw} syntax_error(format_underline({\cf22 "toml::parse_array:"}\par
1154                     {\cf22 " missing array separator `,` after a value"}, \{\par
1155                         \{source_location(array_start_loc), {\cf22 "array starts here"}\},\par
1156                         \{source_location(loc),             {\cf22 "should be `,`"}\}\par
1157                     \}), source_location(loc));\par
1158             \}\par
1159         \}\par
1160     \}\par
1161     loc.reset(first);\par
1162     {\cf19 throw} syntax_error(format_underline({\cf22 "toml::parse_array: "}\par
1163             {\cf22 "array did not closed by `]`"},\par
1164             \{\{source_location(loc), {\cf22 "should be closed"}\}\}),\par
1165             source_location(loc));\par
1166 \}\par
1167 \par
1168 {\cf17 template}<{\cf17 typename} Value>\par
1169 result<std::pair<std::pair<std::vector<key>, region>, Value>, std::string>\par
1170 parse_key_value_pair(location& loc)\par
1171 \{\par
1172     {\cf17 using }value_type = Value;\par
1173 \par
1174     {\cf17 const} {\cf17 auto} first = loc.iter();\par
1175     {\cf17 auto} key_reg = parse_key(loc);\par
1176     {\cf19 if}(!key_reg)\par
1177     \{\par
1178         std::string msg = std::move(key_reg.unwrap_err());\par
1179         {\cf20 // if the next token is keyvalue-separator, it means that there are no}\par
1180         {\cf20 // key. then we need to show error as "empty key is not allowed".}\par
1181         {\cf19 if}({\cf17 const} {\cf17 auto} keyval_sep = lex_keyval_sep::invoke(loc))\par
1182         \{\par
1183             loc.reset(first);\par
1184             msg = format_underline({\cf22 "toml::parse_key_value_pair: "}\par
1185                 {\cf22 "empty key is not allowed."},\par
1186                 \{\{source_location(loc), {\cf22 "key expected before '='"}\}\});\par
1187         \}\par
1188         {\cf19 return} err(std::move(msg));\par
1189     \}\par
1190 \par
1191     {\cf17 const} {\cf17 auto} kvsp = lex_keyval_sep::invoke(loc);\par
1192     {\cf19 if}(!kvsp)\par
1193     \{\par
1194         std::string msg;\par
1195         {\cf20 // if the line contains '=' after the invalid sequence, possibly the}\par
1196         {\cf20 // error is in the key (like, invalid character in bare key).}\par
1197         {\cf17 const} {\cf17 auto} line_end = std::find(loc.iter(), loc.end(), {\cf23 '\\n'});\par
1198         {\cf19 if}(std::find(loc.iter(), line_end, {\cf23 '='}) != line_end)\par
1199         \{\par
1200             msg = format_underline({\cf22 "toml::parse_key_value_pair: "}\par
1201                 {\cf22 "invalid format for key"},\par
1202                 \{\{source_location(loc), {\cf22 "invalid character in key"}\}\},\par
1203                 \{{\cf22 "Did you forget '.' to separate dotted-key?"},\par
1204                 {\cf22 "Allowed characters for bare key are [0-9a-zA-Z_-]."}\});\par
1205         \}\par
1206         {\cf19 else} {\cf20 // if not, the error is lack of key-value separator.}\par
1207         \{\par
1208             msg = format_underline({\cf22 "toml::parse_key_value_pair: "}\par
1209                 {\cf22 "missing key-value separator `=`"},\par
1210                 \{\{source_location(loc), {\cf22 "should be `=`"}\}\});\par
1211         \}\par
1212         loc.reset(first);\par
1213         {\cf19 return} err(std::move(msg));\par
1214     \}\par
1215 \par
1216     {\cf17 const} {\cf17 auto} after_kvsp = loc.iter(); {\cf20 // err msg}\par
1217     {\cf17 auto} val = parse_value<value_type>(loc);\par
1218     {\cf19 if}(!val)\par
1219     \{\par
1220         std::string msg;\par
1221         loc.reset(after_kvsp);\par
1222         {\cf20 // check there is something not a comment/whitespace after `=`}\par
1223         {\cf19 if}(sequence<maybe<lex_ws>, maybe<lex_comment>, lex_newline>::invoke(loc))\par
1224         \{\par
1225             loc.reset(after_kvsp);\par
1226             msg = format_underline({\cf22 "toml::parse_key_value_pair: "}\par
1227                     {\cf22 "missing value after key-value separator '='"},\par
1228                     \{\{source_location(loc), {\cf22 "expected value, but got nothing"}\}\});\par
1229         \}\par
1230         {\cf19 else} {\cf20 // there is something not a comment/whitespace, so invalid format.}\par
1231         \{\par
1232             msg = std::move(val.unwrap_err());\par
1233         \}\par
1234         loc.reset(first);\par
1235         {\cf19 return} err(msg);\par
1236     \}\par
1237     {\cf19 return} ok(std::make_pair(std::move(key_reg.unwrap()),\par
1238                              std::move(val.unwrap())));\par
1239 \}\par
1240 \par
1241 {\cf20 // for error messages.}\par
1242 {\cf17 template}<{\cf17 typename} InputIterator>\par
1243 std::string format_dotted_keys(InputIterator first, {\cf17 const} InputIterator last)\par
1244 \{\par
1245     {\cf17 static_assert}(std::is_same<key,\par
1246         {\cf17 typename} std::iterator_traits<InputIterator>::value_type>::value,{\cf22 ""});\par
1247 \par
1248     std::string retval(*first++);\par
1249     {\cf19 for}(; first != last; ++first)\par
1250     \{\par
1251         retval += {\cf23 '.'};\par
1252         retval += *first;\par
1253     \}\par
1254     {\cf19 return} retval;\par
1255 \}\par
1256 \par
1257 {\cf20 // forward decl for is_valid_forward_table_definition}\par
1258 result<std::pair<std::vector<key>, region>, std::string>\par
1259 parse_table_key(location& loc);\par
1260 {\cf17 template}<{\cf17 typename} Value>\par
1261 result<std::pair<typename Value::table_type, region>, std::string>\par
1262 parse_inline_table(location& loc);\par
1263 \par
1264 {\cf20 // The following toml file is allowed.}\par
1265 {\cf20 // ```toml}\par
1266 {\cf20 // [a.b.c]     # here, table `a` has element `b`.}\par
1267 {\cf20 // foo = "bar"}\par
1268 {\cf20 // [a]         # merge a = \{baz = "qux"\} to a = \{b = \{...\}\}}\par
1269 {\cf20 // baz = "qux"}\par
1270 {\cf20 // ```}\par
1271 {\cf20 // But the following is not allowed.}\par
1272 {\cf20 // ```toml}\par
1273 {\cf20 // [a]}\par
1274 {\cf20 // b.c.foo = "bar"}\par
1275 {\cf20 // [a]             # error! the same table [a] defined!}\par
1276 {\cf20 // baz = "qux"}\par
1277 {\cf20 // ```}\par
1278 {\cf20 // The following is neither allowed.}\par
1279 {\cf20 // ```toml}\par
1280 {\cf20 // a = \{ b.c.foo = "bar"\}}\par
1281 {\cf20 // [a]             # error! the same table [a] defined!}\par
1282 {\cf20 // baz = "qux"}\par
1283 {\cf20 // ```}\par
1284 {\cf20 // Here, it parses region of `tab->at(k)` as a table key and check the depth}\par
1285 {\cf20 // of the key. If the key region points deeper node, it would be allowed.}\par
1286 {\cf20 // Otherwise, the key points the same node. It would be rejected.}\par
1287 {\cf17 template}<{\cf17 typename} Value, {\cf17 typename} Iterator>\par
1288 {\cf18 bool} is_valid_forward_table_definition({\cf17 const} Value& fwd, {\cf17 const} Value& inserting,\par
1289         Iterator key_first, Iterator key_curr, Iterator key_last)\par
1290 \{\par
1291     {\cf20 // ------------------------------------------------------------------------}\par
1292     {\cf20 // check type of the value to be inserted/merged}\par
1293 \par
1294     std::string inserting_reg = {\cf22 ""};\par
1295     {\cf19 if}({\cf17 const} {\cf17 auto} ptr = detail::get_region(inserting))\par
1296     \{\par
1297         inserting_reg = ptr->str();\par
1298     \}\par
1299     location inserting_def({\cf22 "internal"}, std::move(inserting_reg));\par
1300     {\cf19 if}({\cf17 const} {\cf17 auto} inlinetable = parse_inline_table<Value>(inserting_def))\par
1301     \{\par
1302         {\cf20 // check if we are overwriting existing table.}\par
1303         {\cf20 // ```toml}\par
1304         {\cf20 // # NG}\par
1305         {\cf20 // a.b = 42}\par
1306         {\cf20 // a = \{d = 3.14\}}\par
1307         {\cf20 // ```}\par
1308         {\cf20 // Inserting an inline table to a existing super-table is not allowed in}\par
1309         {\cf20 // any case. If we found it, we can reject it without further checking.}\par
1310         {\cf19 return} {\cf17 false};\par
1311     \}\par
1312 \par
1313     {\cf20 // Valid and invalid cases when inserting to the [a.b] table:}\par
1314     {\cf20 //}\par
1315     {\cf20 // ## Invalid}\par
1316     {\cf20 //}\par
1317     {\cf20 // ```toml}\par
1318     {\cf20 // # invalid}\par
1319     {\cf20 // [a]}\par
1320     {\cf20 // b.c.d = "foo"}\par
1321     {\cf20 // [a.b]       # a.b is already defined and closed}\par
1322     {\cf20 // d = "bar"}\par
1323     {\cf20 // ```}\par
1324     {\cf20 // ```toml}\par
1325     {\cf20 // # invalid}\par
1326     {\cf20 // a = \{b.c.d = "foo"\}}\par
1327     {\cf20 // [a.b] # a is already defined and inline table is closed}\par
1328     {\cf20 // d = "bar"}\par
1329     {\cf20 // ```}\par
1330     {\cf20 // ```toml}\par
1331     {\cf20 // # invalid}\par
1332     {\cf20 // a.b.c.d = "foo"}\par
1333     {\cf20 // [a.b] # a.b is already defined and dotted-key table is closed}\par
1334     {\cf20 // d = "bar"}\par
1335     {\cf20 // ```}\par
1336     {\cf20 //}\par
1337     {\cf20 // ## Valid}\par
1338     {\cf20 //}\par
1339     {\cf20 // ```toml}\par
1340     {\cf20 // # OK. a.b is defined, but is *overwritable*}\par
1341     {\cf20 // [a.b.c]}\par
1342     {\cf20 // d = "foo"}\par
1343     {\cf20 // [a.b]}\par
1344     {\cf20 // d = "bar"}\par
1345     {\cf20 // ```}\par
1346     {\cf20 // ```toml}\par
1347     {\cf20 // # OK. a.b is defined, but is *overwritable*}\par
1348     {\cf20 // [a]}\par
1349     {\cf20 // b.c.d = "foo"}\par
1350     {\cf20 // b.e = "bar"}\par
1351     {\cf20 // ```}\par
1352 \par
1353     {\cf20 // ------------------------------------------------------------------------}\par
1354     {\cf20 // check table defined before}\par
1355 \par
1356     std::string internal = {\cf22 ""};\par
1357     {\cf19 if}({\cf17 const} {\cf17 auto} ptr = detail::get_region(fwd))\par
1358     \{\par
1359         internal = ptr->str();\par
1360     \}\par
1361     location def({\cf22 "internal"}, std::move(internal));\par
1362     {\cf19 if}({\cf17 const} {\cf17 auto} tabkeys = parse_table_key(def)) {\cf20 // [table.key]}\par
1363     \{\par
1364         {\cf20 // table keys always contains all the nodes from the root.}\par
1365         {\cf17 const} {\cf17 auto}& tks = tabkeys.unwrap().first;\par
1366         {\cf19 if}(std::size_t(std::distance(key_first, key_last)) == tks.size() &&\par
1367            std::equal(tks.begin(), tks.end(), key_first))\par
1368         \{\par
1369             {\cf20 // the keys are equivalent. it is not allowed.}\par
1370             {\cf19 return} {\cf17 false};\par
1371         \}\par
1372         {\cf20 // the keys are not equivalent. it is allowed.}\par
1373         {\cf19 return} {\cf17 true};\par
1374     \}\par
1375     {\cf19 if}({\cf17 const} {\cf17 auto} dotkeys = parse_key(def)) {\cf20 // a.b.c = "foo"}\par
1376     \{\par
1377         {\cf20 // consider the following case.}\par
1378         {\cf20 // [a]}\par
1379         {\cf20 // b.c = \{d = 42\}}\par
1380         {\cf20 // [a.b.c]}\par
1381         {\cf20 // e = 2.71}\par
1382         {\cf20 // this defines the table [a.b.c] twice. no?}\par
1383         {\cf19 if}({\cf17 const} {\cf17 auto} reopening_dotkey_by_table = parse_table_key(inserting_def))\par
1384         \{\par
1385             {\cf20 // re-opening a dotkey-defined table by a table is invalid.}\par
1386             {\cf20 // only dotkey can append a key-val. Like:}\par
1387             {\cf20 // ```toml}\par
1388             {\cf20 // a.b.c = "foo"}\par
1389             {\cf20 // a.b.d = "bar" # OK. reopen `a.b` by dotkey}\par
1390             {\cf20 // [a.b]}\par
1391             {\cf20 // e = "bar" # Invalid. re-opening `a.b` by [a.b] is not allowed.}\par
1392             {\cf20 // ```}\par
1393             {\cf19 return} {\cf17 false};\par
1394         \}\par
1395 \par
1396         {\cf20 // a dotted key starts from the node representing a table in which the}\par
1397         {\cf20 // dotted key belongs to.}\par
1398         {\cf17 const} {\cf17 auto}& dks = dotkeys.unwrap().first;\par
1399         {\cf19 if}(std::size_t(std::distance(key_curr, key_last)) == dks.size() &&\par
1400            std::equal(dks.begin(), dks.end(), key_curr))\par
1401         \{\par
1402             {\cf20 // the keys are equivalent. it is not allowed.}\par
1403             {\cf19 return} {\cf17 false};\par
1404         \}\par
1405         {\cf20 // the keys are not equivalent. it is allowed.}\par
1406         {\cf19 return} {\cf17 true};\par
1407     \}\par
1408     {\cf19 return} {\cf17 false};\par
1409 \}\par
1410 \par
1411 {\cf17 template}<{\cf17 typename} Value, {\cf17 typename} InputIterator>\par
1412 result<bool, std::string>\par
1413 insert_nested_key({\cf17 typename} Value::table_type& root, {\cf17 const} Value& v,\par
1414                   InputIterator iter, {\cf17 const} InputIterator last,\par
1415                   region key_reg,\par
1416                   {\cf17 const} {\cf18 bool} is_array_of_table = {\cf17 false})\par
1417 \{\par
1418     {\cf17 static_assert}(std::is_same<key,\par
1419         {\cf17 typename} std::iterator_traits<InputIterator>::value_type>::value,{\cf22 ""});\par
1420 \par
1421     {\cf17 using }value_type = Value;\par
1422     {\cf17 using }table_type = {\cf17 typename} value_type::table_type;\par
1423     {\cf17 using }array_type = {\cf17 typename} value_type::array_type;\par
1424 \par
1425     {\cf17 const} {\cf17 auto} first = iter;\par
1426     assert(iter != last);\par
1427 \par
1428     table_type* tab = std::addressof(root);\par
1429     {\cf19 for}(; iter != last; ++iter) {\cf20 // search recursively}\par
1430     \{\par
1431         {\cf17 const} key& k = *iter;\par
1432         {\cf19 if}(std::next(iter) == last) {\cf20 // k is the last key}\par
1433         \{\par
1434             {\cf20 // XXX if the value is array-of-tables, there can be several}\par
1435             {\cf20 //     tables that are in the same array. in that case, we need to}\par
1436             {\cf20 //     find the last element and insert it to there.}\par
1437             {\cf19 if}(is_array_of_table)\par
1438             \{\par
1439                 {\cf19 if}(tab->count(k) == 1) {\cf20 // there is already an array of table}\par
1440                 \{\par
1441                     {\cf19 if}(tab->at(k).is_table())\par
1442                     \{\par
1443                         {\cf20 // show special err msg for conflicting table}\par
1444                         {\cf19 throw} syntax_error(format_underline(concat_to_string(\par
1445                             {\cf22 "toml::insert_value: array of table (\\""},\par
1446                             format_dotted_keys(first, last),\par
1447                             {\cf22 "\\") cannot be defined"}), \{\par
1448                                 \{tab->at(k).location(), {\cf22 "table already defined"}\},\par
1449                                 \{v.location(), {\cf22 "this conflicts with the previous table"}\}\par
1450                             \}), v.location());\par
1451                     \}\par
1452                     {\cf19 else} {\cf19 if}(!(tab->at(k).is_array()))\par
1453                     \{\par
1454                         {\cf19 throw} syntax_error(format_underline(concat_to_string(\par
1455                             {\cf22 "toml::insert_value: array of table (\\""},\par
1456                             format_dotted_keys(first, last), {\cf22 "\\") collides with"}\par
1457                             {\cf22 " existing value"}), \{\par
1458                                 \{tab->at(k).location(),\par
1459                                  concat_to_string({\cf22 "this "}, tab->at(k).type(),\par
1460                                                   {\cf22 " value already exists"})\},\par
1461                                 \{v.location(),\par
1462                                  {\cf22 "while inserting this array-of-tables"}\}\par
1463                             \}), v.location());\par
1464                     \}\par
1465                     {\cf20 // the above if-else-if checks tab->at(k) is an array}\par
1466                     {\cf17 auto}& a = tab->at(k).as_array();\par
1467                     {\cf20 // If table element is defined as [[array_of_tables]], it}\par
1468                     {\cf20 // cannot be an empty array. If an array of tables is}\par
1469                     {\cf20 // defined as `aot = []`, it cannot be appended.}\par
1470                     {\cf19 if}(a.empty() || !(a.front().is_table()))\par
1471                     \{\par
1472                         {\cf19 throw} syntax_error(format_underline(concat_to_string(\par
1473                             {\cf22 "toml::insert_value: array of table (\\""},\par
1474                             format_dotted_keys(first, last), {\cf22 "\\") collides with"}\par
1475                             {\cf22 " existing value"}), \{\par
1476                                 \{tab->at(k).location(),\par
1477                                  concat_to_string({\cf22 "this "}, tab->at(k).type(),\par
1478                                                   {\cf22 " value already exists"})\},\par
1479                                 \{v.location(),\par
1480                                  {\cf22 "while inserting this array-of-tables"}\}\par
1481                             \}), v.location());\par
1482                     \}\par
1483                     {\cf20 // avoid conflicting array of table like the following.}\par
1484                     {\cf20 // ```toml}\par
1485                     {\cf20 // a = [\{b = 42\}] # define a as an array of *inline* tables}\par
1486                     {\cf20 // [[a]]          # a is an array of *multi-line* tables}\par
1487                     {\cf20 // b = 54}\par
1488                     {\cf20 // ```}\par
1489                     {\cf20 // Here, from the type information, these cannot be detected}\par
1490                     {\cf20 // because inline table is also a table.}\par
1491                     {\cf20 // But toml v0.5.0 explicitly says it is invalid. The above}\par
1492                     {\cf20 // array-of-tables has a static size and appending to the}\par
1493                     {\cf20 // array is invalid.}\par
1494                     {\cf20 // In this library, multi-line table value has a region}\par
1495                     {\cf20 // that points to the key of the table (e.g. [[a]]). By}\par
1496                     {\cf20 // comparing the first two letters in key, we can detect}\par
1497                     {\cf20 // the array-of-table is inline or multiline.}\par
1498                     {\cf19 if}({\cf17 const} {\cf17 auto} ptr = detail::get_region(a.front()))\par
1499                     \{\par
1500                         {\cf19 if}(ptr->str().substr(0,2) != {\cf22 "[["})\par
1501                         \{\par
1502                             {\cf19 throw} syntax_error(format_underline(concat_to_string(\par
1503                                 {\cf22 "toml::insert_value: array of table (\\""},\par
1504                                 format_dotted_keys(first, last), {\cf22 "\\") collides "}\par
1505                                 {\cf22 "with existing array-of-tables"}), \{\par
1506                                     \{tab->at(k).location(),\par
1507                                      concat_to_string({\cf22 "this "}, tab->at(k).type(),\par
1508                                                       {\cf22 " value has static size"})\},\par
1509                                     \{v.location(),\par
1510                                      {\cf22 "appending it to the statically sized array"}\}\par
1511                                 \}), v.location());\par
1512                         \}\par
1513                     \}\par
1514                     a.push_back(v);\par
1515                     {\cf19 return} ok({\cf17 true});\par
1516                 \}\par
1517                 {\cf19 else} {\cf20 // if not, we need to create the array of table}\par
1518                 \{\par
1519                     {\cf20 // XXX: Consider the following array of tables.}\par
1520                     {\cf20 // ```toml}\par
1521                     {\cf20 // # This is a comment.}\par
1522                     {\cf20 // [[aot]]}\par
1523                     {\cf20 // foo = "bar"}\par
1524                     {\cf20 // ```}\par
1525                     {\cf20 // Here, the comment is for `aot`. But here, actually two}\par
1526                     {\cf20 // values are defined. An array that contains tables, named}\par
1527                     {\cf20 // `aot`, and the 0th element of the `aot`, `\{foo = "bar"\}`.}\par
1528                     {\cf20 // Those two are different from each other. But both of them}\par
1529                     {\cf20 // points to the same portion of the TOML file, `[[aot]]`,}\par
1530                     {\cf20 // so `key_reg.comments()` returns `# This is a comment`.}\par
1531                     {\cf20 // If it is assigned as a comment of `aot` defined here, the}\par
1532                     {\cf20 // comment will be duplicated. Both the `aot` itself and}\par
1533                     {\cf20 // the 0-th element will have the same comment. This causes}\par
1534                     {\cf20 // "duplication of the same comments" bug when the data is}\par
1535                     {\cf20 // serialized.}\par
1536                     {\cf20 //     Next, consider the following.}\par
1537                     {\cf20 // ```toml}\par
1538                     {\cf20 // # comment 1}\par
1539                     {\cf20 // aot = [}\par
1540                     {\cf20 //     # comment 2}\par
1541                     {\cf20 //     \{foo = "bar"\},}\par
1542                     {\cf20 // ]}\par
1543                     {\cf20 // ```}\par
1544                     {\cf20 // In this case, we can distinguish those two comments. So}\par
1545                     {\cf20 // here we need to add "comment 1" to the `aot` and}\par
1546                     {\cf20 // "comment 2" to the 0th element of that.}\par
1547                     {\cf20 //     To distinguish those two, we check the key region.}\par
1548                     std::vector<std::string> comments\{{\cf20 /* empty by default */}\};\par
1549                     {\cf19 if}(key_reg.str().substr(0, 2) != {\cf22 "[["})\par
1550                     \{\par
1551                         comments = key_reg.comments();\par
1552                     \}\par
1553                     value_type aot(array_type(1, v), key_reg, std::move(comments));\par
1554                     tab->insert(std::make_pair(k, aot));\par
1555                     {\cf19 return} ok({\cf17 true});\par
1556                 \}\par
1557             \} {\cf20 // end if(array of table)}\par
1558 \par
1559             {\cf19 if}(tab->count(k) == 1)\par
1560             \{\par
1561                 {\cf19 if}(tab->at(k).is_table() && v.is_table())\par
1562                 \{\par
1563                     {\cf19 if}(!is_valid_forward_table_definition(\par
1564                                 tab->at(k), v, first, iter, last))\par
1565                     \{\par
1566                         {\cf19 throw} syntax_error(format_underline(concat_to_string(\par
1567                             {\cf22 "toml::insert_value: table (\\""},\par
1568                             format_dotted_keys(first, last),\par
1569                             {\cf22 "\\") already exists."}), \{\par
1570                                 \{tab->at(k).location(), {\cf22 "table already exists here"}\},\par
1571                                 \{v.location(), {\cf22 "table defined twice"}\}\par
1572                             \}), v.location());\par
1573                     \}\par
1574                     {\cf20 // to allow the following toml file.}\par
1575                     {\cf20 // [a.b.c]}\par
1576                     {\cf20 // d = 42}\par
1577                     {\cf20 // [a]}\par
1578                     {\cf20 // e = 2.71}\par
1579                     {\cf17 auto}& t = tab->at(k).as_table();\par
1580                     {\cf19 for}({\cf17 const} {\cf17 auto}& kv : v.as_table())\par
1581                     \{\par
1582                         {\cf19 if}(tab->at(k).contains(kv.first))\par
1583                         \{\par
1584                             {\cf19 throw} syntax_error(format_underline(concat_to_string(\par
1585                                 {\cf22 "toml::insert_value: value (\\""},\par
1586                                 format_dotted_keys(first, last),\par
1587                                 {\cf22 "\\") already exists."}), \{\par
1588                                     \{t.at(kv.first).location(), {\cf22 "already exists here"}\},\par
1589                                     \{v.location(), {\cf22 "this defined twice"}\}\par
1590                                 \}), v.location());\par
1591                         \}\par
1592                         t[kv.first] = kv.second;\par
1593                     \}\par
1594                     detail::change_region(tab->at(k), key_reg);\par
1595                     {\cf19 return} ok({\cf17 true});\par
1596                 \}\par
1597                 {\cf19 else} {\cf19 if}(v.is_table()                     &&\par
1598                         tab->at(k).is_array()            &&\par
1599                         tab->at(k).as_array().size() > 0 &&\par
1600                         tab->at(k).as_array().front().is_table())\par
1601                 \{\par
1602                     {\cf19 throw} syntax_error(format_underline(concat_to_string(\par
1603                         {\cf22 "toml::insert_value: array of tables (\\""},\par
1604                         format_dotted_keys(first, last), {\cf22 "\\") already exists."}), \{\par
1605                             \{tab->at(k).location(), {\cf22 "array of tables defined here"}\},\par
1606                             \{v.location(), {\cf22 "table conflicts with the previous array of table"}\}\par
1607                         \}), v.location());\par
1608                 \}\par
1609                 {\cf19 else}\par
1610                 \{\par
1611                     {\cf19 throw} syntax_error(format_underline(concat_to_string(\par
1612                         {\cf22 "toml::insert_value: value (\\""},\par
1613                         format_dotted_keys(first, last), {\cf22 "\\") already exists."}), \{\par
1614                             \{tab->at(k).location(), {\cf22 "value already exists here"}\},\par
1615                             \{v.location(), {\cf22 "value defined twice"}\}\par
1616                         \}), v.location());\par
1617                 \}\par
1618             \}\par
1619             tab->insert(std::make_pair(k, v));\par
1620             {\cf19 return} ok({\cf17 true});\par
1621         \}\par
1622         {\cf19 else} {\cf20 // k is not the last one, we should insert recursively}\par
1623         \{\par
1624             {\cf20 // if there is no corresponding value, insert it first.}\par
1625             {\cf20 // related: you don't need to write}\par
1626             {\cf20 // # [x]}\par
1627             {\cf20 // # [x.y]}\par
1628             {\cf20 // to write}\par
1629             {\cf20 // [x.y.z]}\par
1630             {\cf19 if}(tab->count(k) == 0)\par
1631             \{\par
1632                 {\cf20 // a table that is defined implicitly doesn't have any comments.}\par
1633                 (*tab)[k] = value_type(table_type\{\}, key_reg, \{{\cf20 /*no comment*/}\});\par
1634             \}\par
1635 \par
1636             {\cf20 // type checking...}\par
1637             {\cf19 if}(tab->at(k).is_table())\par
1638             \{\par
1639                 {\cf20 // According to toml-lang/toml:36d3091b3 "Clarify that inline}\par
1640                 {\cf20 // tables are immutable", check if it adds key-value pair to an}\par
1641                 {\cf20 // inline table.}\par
1642                 {\cf19 if}({\cf17 const} {\cf17 auto}* ptr = get_region(tab->at(k)))\par
1643                 \{\par
1644                     {\cf20 // here, if the value is a (multi-line) table, the region}\par
1645                     {\cf20 // should be something like `[table-name]`.}\par
1646                     {\cf19 if}(ptr->front() == {\cf23 '\{'})\par
1647                     \{\par
1648                         {\cf19 throw} syntax_error(format_underline(concat_to_string(\par
1649                             {\cf22 "toml::insert_value: inserting to an inline table ("},\par
1650                             format_dotted_keys(first, std::next(iter)),\par
1651                             {\cf22 ") but inline tables are immutable"}), \{\par
1652                                 \{tab->at(k).location(), {\cf22 "inline tables are immutable"}\},\par
1653                                 \{v.location(), {\cf22 "inserting this"}\}\par
1654                             \}), v.location());\par
1655                     \}\par
1656                 \}\par
1657                 tab = std::addressof((*tab)[k].as_table());\par
1658             \}\par
1659             {\cf19 else} {\cf19 if}(tab->at(k).is_array()) {\cf20 // inserting to array-of-tables?}\par
1660             \{\par
1661                 {\cf17 auto}& a = (*tab)[k].as_array();\par
1662                 {\cf19 if}(!a.back().is_table())\par
1663                 \{\par
1664                     {\cf19 throw} syntax_error(format_underline(concat_to_string(\par
1665                         {\cf22 "toml::insert_value: target ("},\par
1666                         format_dotted_keys(first, std::next(iter)),\par
1667                         {\cf22 ") is neither table nor an array of tables"}), \{\par
1668                             \{a.back().location(), concat_to_string(\par
1669                                     {\cf22 "actual type is "}, a.back().type())\},\par
1670                             \{v.location(), {\cf22 "inserting this"}\}\par
1671                         \}), v.location());\par
1672                 \}\par
1673                 tab = std::addressof(a.back().as_table());\par
1674             \}\par
1675             {\cf19 else}\par
1676             \{\par
1677                 {\cf19 throw} syntax_error(format_underline(concat_to_string(\par
1678                     {\cf22 "toml::insert_value: target ("},\par
1679                     format_dotted_keys(first, std::next(iter)),\par
1680                     {\cf22 ") is neither table nor an array of tables"}), \{\par
1681                         \{tab->at(k).location(), concat_to_string(\par
1682                                 {\cf22 "actual type is "}, tab->at(k).type())\},\par
1683                         \{v.location(), {\cf22 "inserting this"}\}\par
1684                     \}), v.location());\par
1685             \}\par
1686         \}\par
1687     \}\par
1688     {\cf19 return} err(std::string({\cf22 "toml::detail::insert_nested_key: never reach here"}));\par
1689 \}\par
1690 \par
1691 {\cf17 template}<{\cf17 typename} Value>\par
1692 result<std::pair<typename Value::table_type, region>, std::string>\par
1693 parse_inline_table(location& loc)\par
1694 \{\par
1695     {\cf17 using }value_type = Value;\par
1696     {\cf17 using }table_type = {\cf17 typename} value_type::table_type;\par
1697 \par
1698     {\cf17 const} {\cf17 auto} first = loc.iter();\par
1699     table_type retval;\par
1700     {\cf19 if}(!(loc.iter() != loc.end() && *loc.iter() == {\cf23 '\{'}))\par
1701     \{\par
1702         {\cf19 return} err(format_underline({\cf22 "toml::parse_inline_table: "},\par
1703             \{\{source_location(loc), {\cf22 "the next token is not an inline table"}\}\}));\par
1704     \}\par
1705     loc.advance();\par
1706 \par
1707     {\cf20 // check if the inline table is an empty table = \{ \}}\par
1708     maybe<lex_ws>::invoke(loc);\par
1709     {\cf19 if}(loc.iter() != loc.end() && *loc.iter() == {\cf23 '\}'})\par
1710     \{\par
1711         loc.advance(); {\cf20 // skip `\}`}\par
1712         {\cf19 return} ok(std::make_pair(retval, region(loc, first, loc.iter())));\par
1713     \}\par
1714 \par
1715     {\cf20 // it starts from "\{". it should be formatted as inline-table}\par
1716     {\cf19 while}(loc.iter() != loc.end())\par
1717     \{\par
1718         {\cf17 const} {\cf17 auto} kv_r = parse_key_value_pair<value_type>(loc);\par
1719         {\cf19 if}(!kv_r)\par
1720         \{\par
1721             {\cf19 return} err(kv_r.unwrap_err());\par
1722         \}\par
1723 \par
1724         {\cf17 const} {\cf17 auto}&              kvpair  = kv_r.unwrap();\par
1725         {\cf17 const} std::vector<key>&  keys    = kvpair.first.first;\par
1726         {\cf17 const} {\cf17 auto}&              key_reg = kvpair.first.second;\par
1727         {\cf17 const} value_type&        val     = kvpair.second;\par
1728 \par
1729         {\cf17 const} {\cf17 auto} inserted =\par
1730             insert_nested_key(retval, val, keys.begin(), keys.end(), key_reg);\par
1731         {\cf19 if}(!inserted)\par
1732         \{\par
1733             {\cf19 throw} internal_error({\cf22 "toml::parse_inline_table: "}\par
1734                 {\cf22 "failed to insert value into table: "} + inserted.unwrap_err(),\par
1735                 source_location(loc));\par
1736         \}\par
1737 \par
1738         {\cf17 using }lex_table_separator = sequence<maybe<lex_ws>, character<','>>;\par
1739         {\cf17 const} {\cf17 auto} sp = lex_table_separator::invoke(loc);\par
1740 \par
1741         {\cf19 if}(!sp)\par
1742         \{\par
1743             maybe<lex_ws>::invoke(loc);\par
1744 \par
1745             {\cf19 if}(loc.iter() == loc.end())\par
1746             \{\par
1747                 {\cf19 throw} syntax_error(format_underline(\par
1748                     {\cf22 "toml::parse_inline_table: missing table separator `\}` "},\par
1749                     \{\{source_location(loc), {\cf22 "should be `\}`"}\}\}),\par
1750                     source_location(loc));\par
1751             \}\par
1752             {\cf19 else} {\cf19 if}(*loc.iter() == {\cf23 '\}'})\par
1753             \{\par
1754                 loc.advance(); {\cf20 // skip `\}`}\par
1755                 {\cf19 return} ok(std::make_pair(\par
1756                             retval, region(loc, first, loc.iter())));\par
1757             \}\par
1758             {\cf19 else} {\cf19 if}(*loc.iter() == {\cf23 '#'} || *loc.iter() == {\cf23 '\\r'} || *loc.iter() == {\cf23 '\\n'})\par
1759             \{\par
1760                 {\cf19 throw} syntax_error(format_underline(\par
1761                     {\cf22 "toml::parse_inline_table: missing curly brace `\}`"},\par
1762                     \{\{source_location(loc), {\cf22 "should be `\}`"}\}\}),\par
1763                     source_location(loc));\par
1764             \}\par
1765             {\cf19 else}\par
1766             \{\par
1767                 {\cf19 throw} syntax_error(format_underline(\par
1768                     {\cf22 "toml::parse_inline_table: missing table separator `,` "},\par
1769                     \{\{source_location(loc), {\cf22 "should be `,`"}\}\}),\par
1770                     source_location(loc));\par
1771             \}\par
1772         \}\par
1773         {\cf19 else} {\cf20 // `,` is found}\par
1774         \{\par
1775             maybe<lex_ws>::invoke(loc);\par
1776             {\cf19 if}(loc.iter() != loc.end() && *loc.iter() == {\cf23 '\}'})\par
1777             \{\par
1778                 {\cf19 throw} syntax_error(format_underline(\par
1779                     {\cf22 "toml::parse_inline_table: trailing comma is not allowed in"}\par
1780                     {\cf22 " an inline table"},\par
1781                     \{\{source_location(loc), {\cf22 "should be `\}`"}\}\}),\par
1782                     source_location(loc));\par
1783             \}\par
1784         \}\par
1785     \}\par
1786     loc.reset(first);\par
1787     {\cf19 throw} syntax_error(format_underline({\cf22 "toml::parse_inline_table: "}\par
1788             {\cf22 "inline table did not closed by `\}`"},\par
1789             \{\{source_location(loc), {\cf22 "should be closed"}\}\}),\par
1790             source_location(loc));\par
1791 \}\par
1792 \par
1793 {\cf17 inline} result<value_t, std::string> guess_number_type({\cf17 const} location& l)\par
1794 \{\par
1795     {\cf20 // This function tries to find some (common) mistakes by checking characters}\par
1796     {\cf20 // that follows the last character of a value. But it is often difficult}\par
1797     {\cf20 // because some non-newline characters can appear after a value. E.g.}\par
1798     {\cf20 // spaces, tabs, commas (in an array or inline table), closing brackets}\par
1799     {\cf20 // (of an array or inline table), comment-sign (#). Since this function}\par
1800     {\cf20 // does not parse further, those characters are always allowed to be there.}\par
1801     location loc = l;\par
1802 \par
1803     {\cf19 if}(lex_offset_date_time::invoke(loc)) \{{\cf19 return} ok(value_t::offset_datetime);\}\par
1804     loc.reset(l.iter());\par
1805 \par
1806     {\cf19 if}(lex_local_date_time::invoke(loc))\par
1807     \{\par
1808         {\cf20 // bad offset may appear after this.}\par
1809         {\cf19 if}(loc.iter() != loc.end() && (*loc.iter() == {\cf23 '+'} || *loc.iter() == {\cf23 '-'}\par
1810                     || *loc.iter() == {\cf23 'Z'} || *loc.iter() == {\cf23 'z'}))\par
1811         \{\par
1812             {\cf19 return} err(format_underline({\cf22 "bad offset: should be [+-]HH:MM or Z"},\par
1813                         \{\{source_location(loc), {\cf22 "[+-]HH:MM or Z"}\}\},\par
1814                         \{{\cf22 "pass: +09:00, -05:30"}, {\cf22 "fail: +9:00, -5:30"}\}));\par
1815         \}\par
1816         {\cf19 return} ok(value_t::local_datetime);\par
1817     \}\par
1818     loc.reset(l.iter());\par
1819 \par
1820     {\cf19 if}(lex_local_date::invoke(loc))\par
1821     \{\par
1822         {\cf20 // bad time may appear after this.}\par
1823         {\cf20 // A space is allowed as a delimiter between local time. But there are}\par
1824         {\cf20 // both cases in which a space becomes valid or invalid.}\par
1825         {\cf20 // - invalid: 2019-06-16 7:00:00}\par
1826         {\cf20 // - valid  : 2019-06-16 07:00:00}\par
1827         {\cf19 if}(loc.iter() != loc.end())\par
1828         \{\par
1829             {\cf17 const} {\cf17 auto} c = *loc.iter();\par
1830             {\cf19 if}(c == {\cf23 'T'} || c == {\cf23 't'})\par
1831             \{\par
1832                 {\cf19 return} err(format_underline({\cf22 "bad time: should be HH:MM:SS.subsec"},\par
1833                         \{\{source_location(loc), {\cf22 "HH:MM:SS.subsec"}\}\},\par
1834                         \{{\cf22 "pass: 1979-05-27T07:32:00, 1979-05-27 07:32:00.999999"},\par
1835                          {\cf22 "fail: 1979-05-27T7:32:00, 1979-05-27 17:32"}\}));\par
1836             \}\par
1837             {\cf19 if}({\cf23 '0'} <= c && c <= {\cf23 '9'})\par
1838             \{\par
1839                 {\cf19 return} err(format_underline({\cf22 "bad time: missing T"},\par
1840                         \{\{source_location(loc), {\cf22 "T or space required here"}\}\},\par
1841                         \{{\cf22 "pass: 1979-05-27T07:32:00, 1979-05-27 07:32:00.999999"},\par
1842                          {\cf22 "fail: 1979-05-27T7:32:00, 1979-05-27 7:32"}\}));\par
1843             \}\par
1844             {\cf19 if}(c == {\cf23 ' '} && std::next(loc.iter()) != loc.end() &&\par
1845                 ({\cf23 '0'} <= *std::next(loc.iter()) && *std::next(loc.iter())<= {\cf23 '9'}))\par
1846             \{\par
1847                 loc.advance();\par
1848                 {\cf19 return} err(format_underline({\cf22 "bad time: should be HH:MM:SS.subsec"},\par
1849                         \{\{source_location(loc), {\cf22 "HH:MM:SS.subsec"}\}\},\par
1850                         \{{\cf22 "pass: 1979-05-27T07:32:00, 1979-05-27 07:32:00.999999"},\par
1851                          {\cf22 "fail: 1979-05-27T7:32:00, 1979-05-27 7:32"}\}));\par
1852             \}\par
1853         \}\par
1854         {\cf19 return} ok(value_t::local_date);\par
1855     \}\par
1856     loc.reset(l.iter());\par
1857 \par
1858     {\cf19 if}(lex_local_time::invoke(loc)) \{{\cf19 return} ok(value_t::local_time);\}\par
1859     loc.reset(l.iter());\par
1860 \par
1861     {\cf19 if}(lex_float::invoke(loc))\par
1862     \{\par
1863         {\cf19 if}(loc.iter() != loc.end() && *loc.iter() == {\cf23 '_'})\par
1864         \{\par
1865             {\cf19 return} err(format_underline({\cf22 "bad float: `_` should be surrounded by digits"},\par
1866                         \{\{source_location(loc), {\cf22 "here"}\}\},\par
1867                         \{{\cf22 "pass: +1.0, -2e-2, 3.141_592_653_589, inf, nan"},\par
1868                          {\cf22 "fail: .0, 1., _1.0, 1.0_, 1_.0, 1.0__0"}\}));\par
1869         \}\par
1870         {\cf19 return} ok(value_t::floating);\par
1871     \}\par
1872     loc.reset(l.iter());\par
1873 \par
1874     {\cf19 if}(lex_integer::invoke(loc))\par
1875     \{\par
1876         {\cf19 if}(loc.iter() != loc.end())\par
1877         \{\par
1878             {\cf17 const} {\cf17 auto} c = *loc.iter();\par
1879             {\cf19 if}(c == {\cf23 '_'})\par
1880             \{\par
1881                 {\cf19 return} err(format_underline({\cf22 "bad integer: `_` should be surrounded by digits"},\par
1882                             \{\{source_location(loc), {\cf22 "here"}\}\},\par
1883                             \{{\cf22 "pass: -42, 1_000, 1_2_3_4_5, 0xC0FFEE, 0b0010, 0o755"},\par
1884                              {\cf22 "fail: 1__000, 0123"}\}));\par
1885             \}\par
1886             {\cf19 if}({\cf23 '0'} <= c && c <= {\cf23 '9'})\par
1887             \{\par
1888                 {\cf20 // leading zero. point '0'}\par
1889                 loc.retrace();\par
1890                 {\cf19 return} err(format_underline({\cf22 "bad integer: leading zero"},\par
1891                             \{\{source_location(loc), {\cf22 "here"}\}\},\par
1892                             \{{\cf22 "pass: -42, 1_000, 1_2_3_4_5, 0xC0FFEE, 0b0010, 0o755"},\par
1893                              {\cf22 "fail: 1__000, 0123"}\}));\par
1894             \}\par
1895             {\cf19 if}(c == {\cf23 ':'} || c == {\cf23 '-'})\par
1896             \{\par
1897                 {\cf19 return} err(format_underline({\cf22 "bad datetime: invalid format"},\par
1898                             \{\{source_location(loc), {\cf22 "here"}\}\},\par
1899                             \{{\cf22 "pass: 1979-05-27T07:32:00-07:00, 1979-05-27 07:32:00.999999Z"},\par
1900                              {\cf22 "fail: 1979-05-27T7:32:00-7:00, 1979-05-27 7:32-00:30"}\}));\par
1901             \}\par
1902             {\cf19 if}(c == {\cf23 '.'} || c == {\cf23 'e'} || c == {\cf23 'E'})\par
1903             \{\par
1904                 {\cf19 return} err(format_underline({\cf22 "bad float: invalid format"},\par
1905                             \{\{source_location(loc), {\cf22 "here"}\}\},\par
1906                             \{{\cf22 "pass: +1.0, -2e-2, 3.141_592_653_589, inf, nan"},\par
1907                              {\cf22 "fail: .0, 1., _1.0, 1.0_, 1_.0, 1.0__0"}\}));\par
1908             \}\par
1909         \}\par
1910         {\cf19 return} ok(value_t::integer);\par
1911     \}\par
1912     {\cf19 if}(loc.iter() != loc.end() && *loc.iter() == {\cf23 '.'})\par
1913     \{\par
1914         {\cf19 return} err(format_underline({\cf22 "bad float: invalid format"},\par
1915                 \{\{source_location(loc), {\cf22 "integer part required before this"}\}\},\par
1916                 \{{\cf22 "pass: +1.0, -2e-2, 3.141_592_653_589, inf, nan"},\par
1917                  {\cf22 "fail: .0, 1., _1.0, 1.0_, 1_.0, 1.0__0"}\}));\par
1918     \}\par
1919     {\cf19 if}(loc.iter() != loc.end() && *loc.iter() == {\cf23 '_'})\par
1920     \{\par
1921         {\cf19 return} err(format_underline({\cf22 "bad number: `_` should be surrounded by digits"},\par
1922                 \{\{source_location(loc), {\cf22 "`_` is not surrounded by digits"}\}\},\par
1923                 \{{\cf22 "pass: -42, 1_000, 1_2_3_4_5, 0xC0FFEE, 0b0010, 0o755"},\par
1924                  {\cf22 "fail: 1__000, 0123"}\}));\par
1925     \}\par
1926     {\cf19 return} err(format_underline({\cf22 "bad format: unknown value appeared"},\par
1927                 \{\{source_location(loc), {\cf22 "here"}\}\}));\par
1928 \}\par
1929 \par
1930 {\cf17 inline} result<value_t, std::string> guess_value_type({\cf17 const} location& loc)\par
1931 \{\par
1932     {\cf19 switch}(*loc.iter())\par
1933     \{\par
1934         {\cf19 case} {\cf23 '"'} : \{{\cf19 return} ok(value_t::string);  \}\par
1935         {\cf19 case} {\cf23 '\\''}: \{{\cf19 return} ok(value_t::string);  \}\par
1936         {\cf19 case} {\cf23 't'} : \{{\cf19 return} ok(value_t::boolean); \}\par
1937         {\cf19 case} {\cf23 'f'} : \{{\cf19 return} ok(value_t::boolean); \}\par
1938         {\cf19 case} {\cf23 '['} : \{{\cf19 return} ok(value_t::array);   \}\par
1939         {\cf19 case} {\cf23 '\{'} : \{{\cf19 return} ok(value_t::table);   \}\par
1940         {\cf19 case} {\cf23 'i'} : \{{\cf19 return} ok(value_t::floating);\} {\cf20 // inf.}\par
1941         {\cf19 case} {\cf23 'n'} : \{{\cf19 return} ok(value_t::floating);\} {\cf20 // nan.}\par
1942         default  : \{{\cf19 return} guess_number_type(loc);\}\par
1943     \}\par
1944 \}\par
1945 \par
1946 {\cf17 template}<{\cf17 typename} Value, {\cf17 typename} T>\par
1947 result<Value, std::string>\par
1948 parse_value_helper(result<std::pair<T, region>, std::string> rslt)\par
1949 \{\par
1950     {\cf19 if}(rslt.is_ok())\par
1951     \{\par
1952         {\cf17 auto} comments = rslt.as_ok().second.comments();\par
1953         {\cf19 return} ok(Value(std::move(rslt.as_ok()), std::move(comments)));\par
1954     \}\par
1955     {\cf19 else}\par
1956     \{\par
1957         {\cf19 return} err(std::move(rslt.as_err()));\par
1958     \}\par
1959 \}\par
1960 \par
1961 {\cf17 template}<{\cf17 typename} Value>\par
1962 result<Value, std::string> parse_value(location& loc)\par
1963 \{\par
1964     {\cf17 const} {\cf17 auto} first = loc.iter();\par
1965     {\cf19 if}(first == loc.end())\par
1966     \{\par
1967         {\cf19 return} err(format_underline({\cf22 "toml::parse_value: input is empty"},\par
1968                    \{\{source_location(loc), {\cf22 ""}\}\}));\par
1969     \}\par
1970 \par
1971     {\cf17 const} {\cf17 auto} type = guess_value_type(loc);\par
1972     {\cf19 if}(!type)\par
1973     \{\par
1974         {\cf19 return} err(type.unwrap_err());\par
1975     \}\par
1976 \par
1977     {\cf19 switch}(type.unwrap())\par
1978     \{\par
1979         {\cf19 case} value_t::boolean        : \{{\cf19 return} parse_value_helper<Value>(parse_boolean(loc)            );\}\par
1980         {\cf19 case} value_t::integer        : \{{\cf19 return} parse_value_helper<Value>(parse_integer(loc)            );\}\par
1981         {\cf19 case} value_t::floating       : \{{\cf19 return} parse_value_helper<Value>(parse_floating(loc)           );\}\par
1982         {\cf19 case} value_t::string         : \{{\cf19 return} parse_value_helper<Value>(parse_string(loc)             );\}\par
1983         {\cf19 case} value_t::offset_datetime: \{{\cf19 return} parse_value_helper<Value>(parse_offset_datetime(loc)    );\}\par
1984         {\cf19 case} value_t::local_datetime : \{{\cf19 return} parse_value_helper<Value>(parse_local_datetime(loc)     );\}\par
1985         {\cf19 case} value_t::local_date     : \{{\cf19 return} parse_value_helper<Value>(parse_local_date(loc)         );\}\par
1986         {\cf19 case} value_t::local_time     : \{{\cf19 return} parse_value_helper<Value>(parse_local_time(loc)         );\}\par
1987         {\cf19 case} value_t::array          : \{{\cf19 return} parse_value_helper<Value>(parse_array<Value>(loc)       );\}\par
1988         {\cf19 case} value_t::table          : \{{\cf19 return} parse_value_helper<Value>(parse_inline_table<Value>(loc));\}\par
1989         {\cf19 default}:\par
1990         \{\par
1991             {\cf17 const} {\cf17 auto} msg = format_underline({\cf22 "toml::parse_value: "}\par
1992                     {\cf22 "unknown token appeared"}, \{\{source_location(loc), {\cf22 "unknown"}\}\});\par
1993             loc.reset(first);\par
1994             {\cf19 return} err(msg);\par
1995         \}\par
1996     \}\par
1997 \}\par
1998 \par
1999 {\cf17 inline} result<std::pair<std::vector<key>, region>, std::string>\par
2000 parse_table_key(location& loc)\par
2001 \{\par
2002     {\cf19 if}({\cf17 auto} token = lex_std_table::invoke(loc))\par
2003     \{\par
2004         location inner_loc(loc.name(), token.unwrap().str());\par
2005 \par
2006         {\cf17 const} {\cf17 auto} open = lex_std_table_open::invoke(inner_loc);\par
2007         {\cf19 if}(!open || inner_loc.iter() == inner_loc.end())\par
2008         \{\par
2009             {\cf19 throw} internal_error(format_underline(\par
2010                 {\cf22 "toml::parse_table_key: no `[`"},\par
2011                 \{\{source_location(inner_loc), {\cf22 "should be `[`"}\}\}),\par
2012                 source_location(inner_loc));\par
2013         \}\par
2014         {\cf20 // to skip [ a . b . c ]}\par
2015         {\cf20 //          ^----------- this whitespace}\par
2016         lex_ws::invoke(inner_loc);\par
2017         {\cf17 const} {\cf17 auto} keys = parse_key(inner_loc);\par
2018         {\cf19 if}(!keys)\par
2019         \{\par
2020             {\cf19 throw} internal_error(format_underline(\par
2021                 {\cf22 "toml::parse_table_key: invalid key"},\par
2022                 \{\{source_location(inner_loc), {\cf22 "not key"}\}\}),\par
2023                 source_location(inner_loc));\par
2024         \}\par
2025         {\cf20 // to skip [ a . b . c ]}\par
2026         {\cf20 //                    ^-- this whitespace}\par
2027         lex_ws::invoke(inner_loc);\par
2028         {\cf17 const} {\cf17 auto} close = lex_std_table_close::invoke(inner_loc);\par
2029         {\cf19 if}(!close)\par
2030         \{\par
2031             {\cf19 throw} internal_error(format_underline(\par
2032                 {\cf22 "toml::parse_table_key: no `]`"},\par
2033                 \{\{source_location(inner_loc), {\cf22 "should be `]`"}\}\}),\par
2034                 source_location(inner_loc));\par
2035         \}\par
2036 \par
2037         {\cf20 // after [table.key], newline or EOF(empty table) required.}\par
2038         {\cf19 if}(loc.iter() != loc.end())\par
2039         \{\par
2040             {\cf17 using }lex_newline_after_table_key =\par
2041                 sequence<maybe<lex_ws>, maybe<lex_comment>, lex_newline>;\par
2042             {\cf17 const} {\cf17 auto} nl = lex_newline_after_table_key::invoke(loc);\par
2043             {\cf19 if}(!nl)\par
2044             \{\par
2045                 {\cf19 throw} syntax_error(format_underline(\par
2046                     {\cf22 "toml::parse_table_key: newline required after [table.key]"},\par
2047                     \{\{source_location(loc), {\cf22 "expected newline"}\}\}),\par
2048                     source_location(loc));\par
2049             \}\par
2050         \}\par
2051         {\cf19 return} ok(std::make_pair(keys.unwrap().first, token.unwrap()));\par
2052     \}\par
2053     {\cf19 else}\par
2054     \{\par
2055         {\cf19 return} err(format_underline({\cf22 "toml::parse_table_key: "}\par
2056             {\cf22 "not a valid table key"}, \{\{source_location(loc), {\cf22 "here"}\}\}));\par
2057     \}\par
2058 \}\par
2059 \par
2060 {\cf17 inline} result<std::pair<std::vector<key>, region>, std::string>\par
2061 parse_array_table_key(location& loc)\par
2062 \{\par
2063     {\cf19 if}({\cf17 auto} token = lex_array_table::invoke(loc))\par
2064     \{\par
2065         location inner_loc(loc.name(), token.unwrap().str());\par
2066 \par
2067         {\cf17 const} {\cf17 auto} open = lex_array_table_open::invoke(inner_loc);\par
2068         {\cf19 if}(!open || inner_loc.iter() == inner_loc.end())\par
2069         \{\par
2070             {\cf19 throw} internal_error(format_underline(\par
2071                 {\cf22 "toml::parse_array_table_key: no `[[`"},\par
2072                 \{\{source_location(inner_loc), {\cf22 "should be `[[`"}\}\}),\par
2073                 source_location(inner_loc));\par
2074         \}\par
2075         lex_ws::invoke(inner_loc);\par
2076         {\cf17 const} {\cf17 auto} keys = parse_key(inner_loc);\par
2077         {\cf19 if}(!keys)\par
2078         \{\par
2079             {\cf19 throw} internal_error(format_underline(\par
2080                 {\cf22 "toml::parse_array_table_key: invalid key"},\par
2081                 \{\{source_location(inner_loc), {\cf22 "not a key"}\}\}),\par
2082                 source_location(inner_loc));\par
2083         \}\par
2084         lex_ws::invoke(inner_loc);\par
2085         {\cf17 const} {\cf17 auto} close = lex_array_table_close::invoke(inner_loc);\par
2086         {\cf19 if}(!close)\par
2087         \{\par
2088             {\cf19 throw} internal_error(format_underline(\par
2089                 {\cf22 "toml::parse_table_key: no `]]`"},\par
2090                 \{\{source_location(inner_loc), {\cf22 "should be `]]`"}\}\}),\par
2091                 source_location(inner_loc));\par
2092         \}\par
2093 \par
2094         {\cf20 // after [[table.key]], newline or EOF(empty table) required.}\par
2095         {\cf19 if}(loc.iter() != loc.end())\par
2096         \{\par
2097             {\cf17 using }lex_newline_after_table_key =\par
2098                 sequence<maybe<lex_ws>, maybe<lex_comment>, lex_newline>;\par
2099             {\cf17 const} {\cf17 auto} nl = lex_newline_after_table_key::invoke(loc);\par
2100             {\cf19 if}(!nl)\par
2101             \{\par
2102                 {\cf19 throw} syntax_error(format_underline({\cf22 "toml::"}\par
2103                     {\cf22 "parse_array_table_key: newline required after [[table.key]]"},\par
2104                     \{\{source_location(loc), {\cf22 "expected newline"}\}\}),\par
2105                     source_location(loc));\par
2106             \}\par
2107         \}\par
2108         {\cf19 return} ok(std::make_pair(keys.unwrap().first, token.unwrap()));\par
2109     \}\par
2110     {\cf19 else}\par
2111     \{\par
2112         {\cf19 return} err(format_underline({\cf22 "toml::parse_array_table_key: "}\par
2113             {\cf22 "not a valid table key"}, \{\{source_location(loc), {\cf22 "here"}\}\}));\par
2114     \}\par
2115 \}\par
2116 \par
2117 {\cf20 // parse table body (key-value pairs until the iter hits the next [tablekey])}\par
2118 {\cf17 template}<{\cf17 typename} Value>\par
2119 result<typename Value::table_type, std::string>\par
2120 parse_ml_table(location& loc)\par
2121 \{\par
2122     {\cf17 using }value_type = Value;\par
2123     {\cf17 using }table_type = {\cf17 typename} value_type::table_type;\par
2124 \par
2125     {\cf17 const} {\cf17 auto} first = loc.iter();\par
2126     {\cf19 if}(first == loc.end())\par
2127     \{\par
2128         {\cf19 return} ok(table_type\{\});\par
2129     \}\par
2130 \par
2131     {\cf20 // XXX at lest one newline is needed.}\par
2132     {\cf17 using }skip_line = repeat<\par
2133         sequence<maybe<lex_ws>, maybe<lex_comment>, lex_newline>, at_least<1>>;\par
2134     skip_line::invoke(loc);\par
2135     lex_ws::invoke(loc);\par
2136 \par
2137     table_type tab;\par
2138     {\cf19 while}(loc.iter() != loc.end())\par
2139     \{\par
2140         lex_ws::invoke(loc);\par
2141         {\cf17 const} {\cf17 auto} before = loc.iter();\par
2142         {\cf19 if}({\cf17 const} {\cf17 auto} tmp = parse_array_table_key(loc)) {\cf20 // next table found}\par
2143         \{\par
2144             loc.reset(before);\par
2145             {\cf19 return} ok(tab);\par
2146         \}\par
2147         {\cf19 if}({\cf17 const} {\cf17 auto} tmp = parse_table_key(loc)) {\cf20 // next table found}\par
2148         \{\par
2149             loc.reset(before);\par
2150             {\cf19 return} ok(tab);\par
2151         \}\par
2152 \par
2153         {\cf19 if}({\cf17 const} {\cf17 auto} kv = parse_key_value_pair<value_type>(loc))\par
2154         \{\par
2155             {\cf17 const} {\cf17 auto}&              kvpair  = kv.unwrap();\par
2156             {\cf17 const} std::vector<key>&  keys    = kvpair.first.first;\par
2157             {\cf17 const} {\cf17 auto}&              key_reg = kvpair.first.second;\par
2158             {\cf17 const} value_type&        val     = kvpair.second;\par
2159             {\cf17 const} {\cf17 auto} inserted =\par
2160                 insert_nested_key(tab, val, keys.begin(), keys.end(), key_reg);\par
2161             {\cf19 if}(!inserted)\par
2162             \{\par
2163                 {\cf19 return} err(inserted.unwrap_err());\par
2164             \}\par
2165         \}\par
2166         {\cf19 else}\par
2167         \{\par
2168             {\cf19 return} err(kv.unwrap_err());\par
2169         \}\par
2170 \par
2171         {\cf20 // comment lines are skipped by the above function call.}\par
2172         {\cf20 // However, since the `skip_line` requires at least 1 newline, it fails}\par
2173         {\cf20 // if the file ends with ws and/or comment without newline.}\par
2174         {\cf20 // `skip_line` matches `ws? + comment? + newline`, not `ws` or `comment`}\par
2175         {\cf20 // itself. To skip the last ws and/or comment, call lexers.}\par
2176         {\cf20 // It does not matter if these fails, so the return value is discarded.}\par
2177         lex_ws::invoke(loc);\par
2178         lex_comment::invoke(loc);\par
2179 \par
2180         {\cf20 // skip_line is (whitespace? comment? newline)_\{1,\}. multiple empty lines}\par
2181         {\cf20 // and comments after the last key-value pairs are allowed.}\par
2182         {\cf17 const} {\cf17 auto} newline = skip_line::invoke(loc);\par
2183         {\cf19 if}(!newline && loc.iter() != loc.end())\par
2184         \{\par
2185             {\cf17 const} {\cf17 auto} before2 = loc.iter();\par
2186             lex_ws::invoke(loc); {\cf20 // skip whitespace}\par
2187             {\cf17 const} {\cf17 auto} msg = format_underline({\cf22 "toml::parse_table: "}\par
2188                 {\cf22 "invalid line format"}, \{\{source_location(loc), concat_to_string(\par
2189                 {\cf22 "expected newline, but got '"}, show_char(*loc.iter()), {\cf22 "'."})\}\});\par
2190             loc.reset(before2);\par
2191             {\cf19 return} err(msg);\par
2192         \}\par
2193 \par
2194         {\cf20 // the skip_lines only matches with lines that includes newline.}\par
2195         {\cf20 // to skip the last line that includes comment and/or whitespace}\par
2196         {\cf20 // but no newline, call them one more time.}\par
2197         lex_ws::invoke(loc);\par
2198         lex_comment::invoke(loc);\par
2199     \}\par
2200     {\cf19 return} ok(tab);\par
2201 \}\par
2202 \par
2203 {\cf17 template}<{\cf17 typename} Value>\par
2204 result<Value, std::string> parse_toml_file(location& loc)\par
2205 \{\par
2206     {\cf17 using }value_type = Value;\par
2207     {\cf17 using }table_type = {\cf17 typename} value_type::table_type;\par
2208 \par
2209     {\cf17 const} {\cf17 auto} first = loc.iter();\par
2210     {\cf19 if}(first == loc.end())\par
2211     \{\par
2212         {\cf20 // For empty files, return an empty table with an empty region (zero-length).}\par
2213         {\cf20 // Without the region, error messages would miss the filename.}\par
2214         {\cf19 return} ok(value_type(table_type\{\}, region(loc, first, first), \{\}));\par
2215     \}\par
2216 \par
2217     {\cf20 // put the first line as a region of a file}\par
2218     {\cf20 // Here first != loc.end(), so taking std::next is okay}\par
2219     {\cf17 const} region file(loc, first, std::next(loc.iter()));\par
2220 \par
2221     {\cf20 // The first successive comments that are separated from the first value}\par
2222     {\cf20 // by an empty line are for a file itself.}\par
2223     {\cf20 // ```toml}\par
2224     {\cf20 // # this is a comment for a file.}\par
2225     {\cf20 //}\par
2226     {\cf20 // key = "the first value"}\par
2227     {\cf20 // ```}\par
2228     {\cf20 // ```toml}\par
2229     {\cf20 // # this is a comment for "the first value".}\par
2230     {\cf20 // key = "the first value"}\par
2231     {\cf20 // ```}\par
2232     std::vector<std::string> comments;\par
2233     {\cf17 using }lex_first_comments = sequence<\par
2234         repeat<sequence<maybe<lex_ws>, lex_comment, lex_newline>, at_least<1>>,\par
2235         sequence<maybe<lex_ws>, lex_newline>\par
2236         >;\par
2237     {\cf19 if}({\cf17 const} {\cf17 auto} token = lex_first_comments::invoke(loc))\par
2238     \{\par
2239         location inner_loc(loc.name(), token.unwrap().str());\par
2240         {\cf19 while}(inner_loc.iter() != inner_loc.end())\par
2241         \{\par
2242             maybe<lex_ws>::invoke(inner_loc); {\cf20 // remove ws if exists}\par
2243             {\cf19 if}(lex_newline::invoke(inner_loc))\par
2244             \{\par
2245                 assert(inner_loc.iter() == inner_loc.end());\par
2246                 {\cf19 break}; {\cf20 // empty line found.}\par
2247             \}\par
2248             {\cf17 auto} com = lex_comment::invoke(inner_loc).unwrap().str();\par
2249             com.erase(com.begin()); {\cf20 // remove # sign}\par
2250             comments.push_back(std::move(com));\par
2251             lex_newline::invoke(inner_loc);\par
2252         \}\par
2253     \}\par
2254 \par
2255     table_type data;\par
2256     {\cf20 // root object is also a table, but without [tablename]}\par
2257     {\cf19 if}({\cf17 const} {\cf17 auto} tab = parse_ml_table<value_type>(loc))\par
2258     \{\par
2259         data = std::move(tab.unwrap());\par
2260     \}\par
2261     {\cf19 else} {\cf20 // failed (empty table is regarded as success in parse_ml_table)}\par
2262     \{\par
2263         {\cf19 return} err(tab.unwrap_err());\par
2264     \}\par
2265     {\cf19 while}(loc.iter() != loc.end())\par
2266     \{\par
2267         {\cf20 // here, the region of [table] is regarded as the table-key because}\par
2268         {\cf20 // the table body is normally too big and it is not so informative}\par
2269         {\cf20 // if the first key-value pair of the table is shown in the error}\par
2270         {\cf20 // message.}\par
2271         {\cf19 if}({\cf17 const} {\cf17 auto} tabkey = parse_array_table_key(loc))\par
2272         \{\par
2273             {\cf17 const} {\cf17 auto} tab = parse_ml_table<value_type>(loc);\par
2274             {\cf19 if}(!tab)\{{\cf19 return} err(tab.unwrap_err());\}\par
2275 \par
2276             {\cf17 const} {\cf17 auto}& tk   = tabkey.unwrap();\par
2277             {\cf17 const} {\cf17 auto}& keys = tk.first;\par
2278             {\cf17 const} {\cf17 auto}& reg  = tk.second;\par
2279 \par
2280             {\cf17 const} {\cf17 auto} inserted = insert_nested_key(data,\par
2281                     value_type(tab.unwrap(), reg, reg.comments()),\par
2282                     keys.begin(), keys.end(), reg,\par
2283                     {\cf20 /*is_array_of_table=*/} {\cf17 true});\par
2284             {\cf19 if}(!inserted) \{{\cf19 return} err(inserted.unwrap_err());\}\par
2285 \par
2286             {\cf19 continue};\par
2287         \}\par
2288         {\cf19 if}({\cf17 const} {\cf17 auto} tabkey = parse_table_key(loc))\par
2289         \{\par
2290             {\cf17 const} {\cf17 auto} tab = parse_ml_table<value_type>(loc);\par
2291             {\cf19 if}(!tab)\{{\cf19 return} err(tab.unwrap_err());\}\par
2292 \par
2293             {\cf17 const} {\cf17 auto}& tk   = tabkey.unwrap();\par
2294             {\cf17 const} {\cf17 auto}& keys = tk.first;\par
2295             {\cf17 const} {\cf17 auto}& reg  = tk.second;\par
2296 \par
2297             {\cf17 const} {\cf17 auto} inserted = insert_nested_key(data,\par
2298                 value_type(tab.unwrap(), reg, reg.comments()),\par
2299                 keys.begin(), keys.end(), reg);\par
2300             {\cf19 if}(!inserted) \{{\cf19 return} err(inserted.unwrap_err());\}\par
2301 \par
2302             {\cf19 continue};\par
2303         \}\par
2304         {\cf19 return} err(format_underline({\cf22 "toml::parse_toml_file: "}\par
2305             {\cf22 "unknown line appeared"}, \{\{source_location(loc), {\cf22 "unknown format"}\}\}));\par
2306     \}\par
2307 \par
2308     {\cf19 return} ok(Value(std::move(data), file, comments));\par
2309 \}\par
2310 \par
2311 \} {\cf20 // detail}\par
2312 \par
2313 {\cf17 template}<{\cf17 typename}                     Comment = TOML11_DEFAULT_COMMENT_STRATEGY,\par
2314          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }Table   = std::unordered_map,\par
2315          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }Array   = std::vector>\par
2316 basic_value<Comment, Table, Array>\par
2317 parse(std::istream& is, {\cf17 const} std::string& fname = {\cf22 "unknown file"})\par
2318 \{\par
2319     {\cf17 using }value_type = basic_value<Comment, Table, Array>;\par
2320 \par
2321     {\cf17 const} {\cf17 auto} beg = is.tellg();\par
2322     is.seekg(0, std::ios::end);\par
2323     {\cf17 const} {\cf17 auto} end = is.tellg();\par
2324     {\cf17 const} {\cf17 auto} fsize = end - beg;\par
2325     is.seekg(beg);\par
2326 \par
2327     {\cf20 // read whole file as a sequence of char}\par
2328     assert(fsize >= 0);\par
2329     std::vector<char> letters({\cf17 static_cast<}std::size_t{\cf17 >}(fsize));\par
2330     is.read(letters.data(), fsize);\par
2331 \par
2332     {\cf20 // append LF.}\par
2333     {\cf20 // Although TOML does not require LF at the EOF, to make parsing logic}\par
2334     {\cf20 // simpler, we "normalize" the content by adding LF if it does not exist.}\par
2335     {\cf20 // It also checks if the last char is CR, to avoid changing the meaning.}\par
2336     {\cf20 // This is not the *best* way to deal with the last character, but is a}\par
2337     {\cf20 // simple and quick fix.}\par
2338     {\cf19 if}(!letters.empty() && letters.back() != {\cf23 '\\n'} && letters.back() != {\cf23 '\\r'})\par
2339     \{\par
2340         letters.push_back({\cf23 '\\n'});\par
2341     \}\par
2342 \par
2343     detail::location loc(std::move(fname), std::move(letters));\par
2344 \par
2345     {\cf20 // skip BOM if exists.}\par
2346     {\cf20 // XXX component of BOM (like 0xEF) exceeds the representable range of}\par
2347     {\cf20 // signed char, so on some (actually, most) of the environment, these cannot}\par
2348     {\cf20 // be compared to char. However, since we are always out of luck, we need to}\par
2349     {\cf20 // check our chars are equivalent to BOM. To do this, first we need to}\par
2350     {\cf20 // convert char to unsigned char to guarantee the comparability.}\par
2351     {\cf19 if}(loc.source()->size() >= 3)\par
2352     \{\par
2353         std::array<unsigned char, 3> BOM;\par
2354         std::memcpy(BOM.data(), loc.source()->data(), 3);\par
2355         {\cf19 if}(BOM[0] == 0xEF && BOM[1] == 0xBB && BOM[2] == 0xBF)\par
2356         \{\par
2357             loc.advance(3); {\cf20 // BOM found. skip.}\par
2358         \}\par
2359     \}\par
2360 \par
2361     {\cf17 const} {\cf17 auto} data = detail::parse_toml_file<value_type>(loc);\par
2362     {\cf19 if}(!data)\par
2363     \{\par
2364         {\cf19 throw} syntax_error(data.unwrap_err(), source_location(loc));\par
2365     \}\par
2366     {\cf19 return} data.unwrap();\par
2367 \}\par
2368 \par
2369 {\cf17 template}<{\cf17 typename}                     Comment = TOML11_DEFAULT_COMMENT_STRATEGY,\par
2370          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }Table   = std::unordered_map,\par
2371          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }Array   = std::vector>\par
2372 basic_value<Comment, Table, Array> parse({\cf17 const} std::string& fname)\par
2373 \{\par
2374     std::ifstream ifs(fname.c_str(), std::ios_base::binary);\par
2375     {\cf19 if}(!ifs.good())\par
2376     \{\par
2377         {\cf19 throw} std::runtime_error({\cf22 "toml::parse: file open error -> "} + fname);\par
2378     \}\par
2379     {\cf19 return} parse<Comment, Table, Array>(ifs, fname);\par
2380 \}\par
2381 \par
2382 {\cf21 #ifdef TOML11_HAS_STD_FILESYSTEM}\par
2383 {\cf20 // This function just forwards `parse("filename.toml")` to std::string version}\par
2384 {\cf20 // to avoid the ambiguity in overload resolution.}\par
2385 {\cf20 //}\par
2386 {\cf20 // Both std::string and std::filesystem::path are convertible from const char*.}\par
2387 {\cf20 // Without this, both parse(std::string) and parse(std::filesystem::path)}\par
2388 {\cf20 // matches to parse("filename.toml"). This breaks the existing code.}\par
2389 {\cf20 //}\par
2390 {\cf20 // This function exactly matches to the invocation with c-string.}\par
2391 {\cf20 // So this function is preferred than others and the ambiguity disappears.}\par
2392 {\cf17 template}<{\cf17 typename}                     Comment = TOML11_DEFAULT_COMMENT_STRATEGY,\par
2393          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }Table   = std::unordered_map,\par
2394          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }Array   = std::vector>\par
2395 basic_value<Comment, Table, Array> parse({\cf17 const} {\cf18 char}* fname)\par
2396 \{\par
2397     {\cf19 return} parse<Comment, Table, Array>(std::string(fname));\par
2398 \}\par
2399 \par
2400 {\cf17 template}<{\cf17 typename}                     Comment = TOML11_DEFAULT_COMMENT_STRATEGY,\par
2401          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }Table   = std::unordered_map,\par
2402          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }Array   = std::vector>\par
2403 basic_value<Comment, Table, Array> parse({\cf17 const} std::filesystem::path& fpath)\par
2404 \{\par
2405     std::ifstream ifs(fpath, std::ios_base::binary);\par
2406     {\cf19 if}(!ifs.good())\par
2407     \{\par
2408         {\cf19 throw} std::runtime_error({\cf22 "toml::parse: file open error -> "} +\par
2409                                  fpath.string());\par
2410     \}\par
2411     {\cf19 return} parse<Comment, Table, Array>(ifs, fpath.string());\par
2412 \}\par
2413 {\cf21 #endif }{\cf20 // TOML11_HAS_STD_FILESYSTEM}\par
2414 \par
2415 \} {\cf20 // toml}\par
2416 {\cf21 #endif}{\cf20 // TOML11_PARSER_HPP}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/region.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/region.hpp}
{\xe \v external/toml/region.hpp}
{\bkmkstart AAAAAAAAEA}
{\bkmkend AAAAAAAAEA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <memory>}\par
{\f2 #include <vector>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <initializer_list>}\par
{\f2 #include <iterator>}\par
{\f2 #include <iomanip>}\par
{\f2 #include <cassert>}\par
{\f2 #include "color.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::region_base}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::location}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::region}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Iterator > std::string {\b toml::detail::make_string} (Iterator first, Iterator last)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toml::detail::make_string} (std::size_t len, char c)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
region.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/region.hpp}
{\xe \v external/toml/region.hpp}
{\bkmkstart AAAAAAAAAR}
{\bkmkend AAAAAAAAAR}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2017.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_REGION_HPP}\par
4 {\cf21 #define TOML11_REGION_HPP}\par
5 {\cf21 #include <memory>}\par
6 {\cf21 #include <vector>}\par
7 {\cf21 #include <algorithm>}\par
8 {\cf21 #include <initializer_list>}\par
9 {\cf21 #include <iterator>}\par
10 {\cf21 #include <iomanip>}\par
11 {\cf21 #include <cassert>}\par
12 {\cf21 #include "color.hpp"}\par
13 \par
14 {\cf17 namespace }toml\par
15 \{\par
16 {\cf17 namespace }detail\par
17 \{\par
18 \par
19 {\cf20 // helper function to avoid std::string(0, 'c') or std::string(iter, iter)}\par
20 {\cf17 template}<{\cf17 typename} Iterator>\par
21 std::string make_string(Iterator first, Iterator last)\par
22 \{\par
23     {\cf19 if}(first == last) \{{\cf19 return} {\cf22 ""};\}\par
24     {\cf19 return} std::string(first, last);\par
25 \}\par
26 {\cf17 inline} std::string make_string(std::size_t len, {\cf18 char} c)\par
27 \{\par
28     {\cf19 if}(len == 0) \{{\cf19 return} {\cf22 ""};\}\par
29     {\cf19 return} std::string(len, c);\par
30 \}\par
31 \par
32 {\cf20 // region_base is a base class of location and region that are defined below.}\par
33 {\cf20 // it will be used to generate better error messages.}\par
34 {\cf17 struct }region_base\par
35 \{\par
36     region_base() = {\cf19 default};\par
37     {\cf17 virtual} ~region_base() = {\cf19 default};\par
38     region_base({\cf17 const} region_base&) = {\cf19 default};\par
39     region_base(region_base&&     ) = {\cf19 default};\par
40     region_base& operator=({\cf17 const} region_base&) = {\cf19 default};\par
41     region_base& operator=(region_base&&     ) = {\cf19 default};\par
42 \par
43     {\cf17 virtual} {\cf18 bool} is_ok()           const noexcept \{{\cf19 return} {\cf17 false};\}\par
44     {\cf17 virtual} {\cf18 char} front()           const noexcept \{{\cf19 return} {\cf23 '\\0'};\}\par
45 \par
46     {\cf17 virtual} std::string str(){\cf17       const }\{{\cf19 return} std::string({\cf22 "unknown region"});\}\par
47     {\cf17 virtual} std::string name(){\cf17      const }\{{\cf19 return} std::string({\cf22 "unknown file"});\}\par
48     {\cf17 virtual} std::string line(){\cf17      const }\{{\cf19 return} std::string({\cf22 "unknown line"});\}\par
49     {\cf17 virtual} std::string line_num(){\cf17  const }\{{\cf19 return} std::string({\cf22 "?"});\}\par
50 \par
51     {\cf20 // length of the region}\par
52     {\cf17 virtual} std::size_t size()     const noexcept \{{\cf19 return} 0;\}\par
53     {\cf20 // number of characters in the line before the region}\par
54     {\cf17 virtual} std::size_t before()   const noexcept \{{\cf19 return} 0;\}\par
55     {\cf20 // number of characters in the line after the region}\par
56     {\cf17 virtual} std::size_t after()    const noexcept \{{\cf19 return} 0;\}\par
57 \par
58     {\cf17 virtual} std::vector<std::string> comments(){\cf17  const }\{{\cf19 return} \{\};\}\par
59     {\cf20 // ```toml}\par
60     {\cf20 // # comment_before}\par
61     {\cf20 // key = "value" # comment_inline}\par
62     {\cf20 // ```}\par
63 \};\par
64 \par
65 {\cf20 // location represents a position in a container, which contains a file content.}\par
66 {\cf20 // it can be considered as a region that contains only one character.}\par
67 {\cf20 //}\par
68 {\cf20 // it contains pointer to the file content and iterator that points the current}\par
69 {\cf20 // location.}\par
70 {\cf17 struct }location final : {\cf17 public} region_base\par
71 \{\par
72     {\cf17 using }const_iterator  = {\cf17 typename} std::vector<char>::const_iterator;\par
73     {\cf17 using }difference_type = {\cf17 typename} const_iterator::difference_type;\par
74     {\cf17 using }source_ptr      = std::shared_ptr<const std::vector<char>>;\par
75 \par
76     location(std::string source_name, std::vector<char> cont)\par
77       : source_(std::make_shared<std::vector<char>>(std::move(cont))),\par
78         line_number_(1), source_name_(std::move(source_name)), iter_(source_->cbegin())\par
79     \{\}\par
80     location(std::string source_name, {\cf17 const} std::string& cont)\par
81       : source_(std::make_shared<std::vector<char>>(cont.begin(), cont.end())),\par
82         line_number_(1), source_name_(std::move(source_name)), iter_(source_->cbegin())\par
83     \{\}\par
84 \par
85     location({\cf17 const} location&) = {\cf19 default};\par
86     location(location&&)      = {\cf19 default};\par
87     location& operator=({\cf17 const} location&) = {\cf19 default};\par
88     location& operator=(location&&)      = {\cf19 default};\par
89     ~location() = {\cf19 default};\par
90 \par
91     {\cf18 bool} is_ok() const noexcept{\cf17  override }\{{\cf19 return} {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(source_);\}\par
92     {\cf18 char} front() const noexcept{\cf17  override }\{{\cf19 return} *iter_;\}\par
93 \par
94     {\cf20 // this const prohibits codes like `++(loc.iter())`.}\par
95     {\cf17 const} const_iterator iter()  const noexcept \{{\cf19 return} iter_;\}\par
96 \par
97     const_iterator begin() const noexcept \{{\cf19 return} source_->cbegin();\}\par
98     const_iterator end()   const noexcept \{{\cf19 return} source_->cend();\}\par
99 \par
100     {\cf20 // XXX `location::line_num()` used to be implemented using `std::count` to}\par
101     {\cf20 // count a number of '\\n'. But with a long toml file (typically, 10k lines),}\par
102     {\cf20 // it becomes intolerably slow because each time it generates error messages,}\par
103     {\cf20 // it counts '\\n' from thousands of characters. To workaround it, I decided}\par
104     {\cf20 // to introduce `location::line_number_` member variable and synchronize it}\par
105     {\cf20 // to the location changes the point to look. So an overload of `iter()`}\par
106     {\cf20 // which returns mutable reference is removed and `advance()`, `retrace()`}\par
107     {\cf20 // and `reset()` is added.}\par
108     {\cf18 void} advance(difference_type n = 1) noexcept\par
109     \{\par
110         this->line_number_ += {\cf17 static_cast<}std::size_t{\cf17 >}(\par
111                 std::count(this->iter_, std::next(this->iter_, n), {\cf23 '\\n'}));\par
112         this->iter_ += n;\par
113         {\cf19 return};\par
114     \}\par
115     {\cf18 void} retrace(difference_type n = 1) noexcept\par
116     \{\par
117         this->line_number_ -= {\cf17 static_cast<}std::size_t{\cf17 >}(\par
118                 std::count(std::prev(this->iter_, n), this->iter_, {\cf23 '\\n'}));\par
119         this->iter_ -= n;\par
120         {\cf19 return};\par
121     \}\par
122     {\cf18 void} reset(const_iterator rollback) {\cf17 noexcept}\par
123     \{\par
124         {\cf20 // since c++11, std::distance works in both ways for random-access}\par
125         {\cf20 // iterators and returns a negative value if `first > last`.}\par
126         {\cf19 if}(0 <= std::distance(rollback, this->iter_)) {\cf20 // rollback < iter}\par
127         \{\par
128             this->line_number_ -= {\cf17 static_cast<}std::size_t{\cf17 >}(\par
129                     std::count(rollback, this->iter_, {\cf23 '\\n'}));\par
130         \}\par
131         {\cf19 else} {\cf20 // iter < rollback [[unlikely]]}\par
132         \{\par
133             this->line_number_ += {\cf17 static_cast<}std::size_t{\cf17 >}(\par
134                     std::count(this->iter_, rollback, {\cf23 '\\n'}));\par
135         \}\par
136         this->iter_ = rollback;\par
137         {\cf19 return};\par
138     \}\par
139 \par
140     std::string str(){\cf17   const override }\{{\cf19 return} make_string(1, *this->iter());\}\par
141     std::string name(){\cf17  const override }\{{\cf19 return} source_name_;\}\par
142 \par
143     std::string line_num(){\cf17  const override}\par
144 {\cf17     }\{\par
145         {\cf19 return} std::to_string(this->line_number_);\par
146     \}\par
147 \par
148     std::string line(){\cf17  const override}\par
149 {\cf17     }\{\par
150         {\cf19 return} make_string(this->line_begin(), this->line_end());\par
151     \}\par
152 \par
153     const_iterator line_begin() const noexcept\par
154     \{\par
155         {\cf17 using }reverse_iterator = std::reverse_iterator<const_iterator>;\par
156         {\cf19 return} std::find(reverse_iterator(this->iter()),\par
157                          reverse_iterator(this->begin()), {\cf23 '\\n'}).base();\par
158     \}\par
159     const_iterator line_end() const noexcept\par
160     \{\par
161         {\cf19 return} std::find(this->iter(), this->end(), {\cf23 '\\n'});\par
162     \}\par
163 \par
164     {\cf20 // location is always points a character. so the size is 1.}\par
165     std::size_t size() const noexcept{\cf17  override}\par
166 {\cf17     }\{\par
167         {\cf19 return} 1u;\par
168     \}\par
169     std::size_t before() const noexcept{\cf17  override}\par
170 {\cf17     }\{\par
171         {\cf17 const} {\cf17 auto} sz = std::distance(this->line_begin(), this->iter());\par
172         assert(sz >= 0);\par
173         {\cf19 return} {\cf17 static_cast<}std::size_t{\cf17 >}(sz);\par
174     \}\par
175     std::size_t after() const noexcept{\cf17  override}\par
176 {\cf17     }\{\par
177         {\cf17 const} {\cf17 auto} sz = std::distance(this->iter(), this->line_end());\par
178         assert(sz >= 0);\par
179         {\cf19 return} {\cf17 static_cast<}std::size_t{\cf17 >}(sz);\par
180     \}\par
181 \par
182     source_ptr {\cf17 const}& source() const& noexcept \{{\cf19 return} source_;\}\par
183     source_ptr&&      source() &&     {\cf17 noexcept} \{{\cf19 return} std::move(source_);\}\par
184 \par
185   {\cf17 private}:\par
186 \par
187     source_ptr     source_;\par
188     std::size_t    line_number_;\par
189     std::string    source_name_;\par
190     const_iterator iter_;\par
191 \};\par
192 \par
193 {\cf20 // region represents a range in a container, which contains a file content.}\par
194 {\cf20 //}\par
195 {\cf20 // it contains pointer to the file content and iterator that points the first}\par
196 {\cf20 // and last location.}\par
197 {\cf17 struct }region final : {\cf17 public} region_base\par
198 \{\par
199     {\cf17 using }const_iterator = {\cf17 typename} std::vector<char>::const_iterator;\par
200     {\cf17 using }source_ptr     = std::shared_ptr<const std::vector<char>>;\par
201 \par
202     {\cf20 // delete default constructor. source_ never be null.}\par
203     region() = {\cf17 delete};\par
204 \par
205     {\cf17 explicit} region({\cf17 const} location& loc)\par
206       : source_(loc.source()), source_name_(loc.name()),\par
207         first_(loc.iter()), last_(loc.iter())\par
208     \{\}\par
209     {\cf17 explicit} region(location&& loc)\par
210       : source_(loc.source()), source_name_(loc.name()),\par
211         first_(loc.iter()), last_(loc.iter())\par
212     \{\}\par
213 \par
214     region({\cf17 const} location& loc, const_iterator f, const_iterator l)\par
215       : source_(loc.source()), source_name_(loc.name()), first_(f), last_(l)\par
216     \{\}\par
217     region(location&& loc, const_iterator f, const_iterator l)\par
218       : source_(loc.source()), source_name_(loc.name()), first_(f), last_(l)\par
219     \{\}\par
220 \par
221     region({\cf17 const} region&) = {\cf19 default};\par
222     region(region&&)      = {\cf19 default};\par
223     region& operator=({\cf17 const} region&) = {\cf19 default};\par
224     region& operator=(region&&)      = {\cf19 default};\par
225     ~region() = {\cf19 default};\par
226 \par
227     region& operator+=({\cf17 const} region& other)\par
228     \{\par
229         {\cf20 // different regions cannot be concatenated}\par
230         assert(this->begin() == other.begin() && this->end() == other.end() &&\par
231                this->last_   == other.first_);\par
232 \par
233         this->last_ = other.last_;\par
234         {\cf19 return} *{\cf17 this};\par
235     \}\par
236 \par
237     {\cf18 bool} is_ok() const noexcept{\cf17  override }\{{\cf19 return} {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(source_);\}\par
238     {\cf18 char} front() const noexcept{\cf17  override }\{{\cf19 return} *first_;\}\par
239 \par
240     std::string str(){\cf17   const override }\{{\cf19 return} make_string(first_, last_);\}\par
241     std::string line(){\cf17  const override}\par
242 {\cf17     }\{\par
243         {\cf19 if}(this->contain_newline())\par
244         \{\par
245             {\cf19 return} make_string(this->line_begin(),\par
246                     std::find(this->line_begin(), this->last(), {\cf23 '\\n'}));\par
247         \}\par
248         {\cf19 return} make_string(this->line_begin(), this->line_end());\par
249     \}\par
250     std::string line_num(){\cf17  const override}\par
251 {\cf17     }\{\par
252         {\cf19 return} std::to_string(1 + std::count(this->begin(), this->first(), {\cf23 '\\n'}));\par
253     \}\par
254 \par
255     std::size_t size() const noexcept{\cf17  override}\par
256 {\cf17     }\{\par
257         {\cf17 const} {\cf17 auto} sz = std::distance(first_, last_);\par
258         assert(sz >= 0);\par
259         {\cf19 return} {\cf17 static_cast<}std::size_t{\cf17 >}(sz);\par
260     \}\par
261     std::size_t before() const noexcept{\cf17  override}\par
262 {\cf17     }\{\par
263         {\cf17 const} {\cf17 auto} sz = std::distance(this->line_begin(), this->first());\par
264         assert(sz >= 0);\par
265         {\cf19 return} {\cf17 static_cast<}std::size_t{\cf17 >}(sz);\par
266     \}\par
267     std::size_t after() const noexcept{\cf17  override}\par
268 {\cf17     }\{\par
269         {\cf17 const} {\cf17 auto} sz = std::distance(this->last(), this->line_end());\par
270         assert(sz >= 0);\par
271         {\cf19 return} {\cf17 static_cast<}std::size_t{\cf17 >}(sz);\par
272     \}\par
273 \par
274     {\cf18 bool} contain_newline() const noexcept\par
275     \{\par
276         {\cf19 return} std::find(this->first(), this->last(), {\cf23 '\\n'}) != this->last();\par
277     \}\par
278 \par
279     const_iterator line_begin() const noexcept\par
280     \{\par
281         {\cf17 using }reverse_iterator = std::reverse_iterator<const_iterator>;\par
282         {\cf19 return} std::find(reverse_iterator(this->first()),\par
283                          reverse_iterator(this->begin()), {\cf23 '\\n'}).base();\par
284     \}\par
285     const_iterator line_end() const noexcept\par
286     \{\par
287         {\cf19 return} std::find(this->last(), this->end(), {\cf23 '\\n'});\par
288     \}\par
289 \par
290     const_iterator begin() const noexcept \{{\cf19 return} source_->cbegin();\}\par
291     const_iterator end()   const noexcept \{{\cf19 return} source_->cend();\}\par
292     const_iterator first() const noexcept \{{\cf19 return} first_;\}\par
293     const_iterator last()  const noexcept \{{\cf19 return} last_;\}\par
294 \par
295     source_ptr {\cf17 const}& source() const& noexcept \{{\cf19 return} source_;\}\par
296     source_ptr&&      source() &&     {\cf17 noexcept} \{{\cf19 return} std::move(source_);\}\par
297 \par
298     std::string name(){\cf17  const override }\{{\cf19 return} source_name_;\}\par
299 \par
300     std::vector<std::string> comments(){\cf17  const override}\par
301 {\cf17     }\{\par
302         {\cf20 // assuming the current region (`*this`) points a value.}\par
303         {\cf20 // ```toml}\par
304         {\cf20 // a = "value"}\par
305         {\cf20 //     ^^^^^^^- this region}\par
306         {\cf20 // ```}\par
307         {\cf17 using }rev_iter = std::reverse_iterator<const_iterator>;\par
308 \par
309         std::vector<std::string> com\{\};\par
310         \{\par
311             {\cf20 // find comments just before the current region.}\par
312             {\cf20 // ```toml}\par
313             {\cf20 // # this should be collected.}\par
314             {\cf20 // # this also.}\par
315             {\cf20 // a = value # not this.}\par
316             {\cf20 // ```}\par
317 \par
318             {\cf20 // # this is a comment for `a`, not array elements.}\par
319             {\cf20 // a = [1, 2, 3, 4, 5]}\par
320             {\cf19 if}(this->first() == std::find_if(this->line_begin(), this->first(),\par
321                 []({\cf17 const} {\cf18 char} c) {\cf17 noexcept} -> {\cf18 bool} \{{\cf19 return} c == {\cf23 '['} || c == {\cf23 '\{'};\}))\par
322             \{\par
323                 {\cf17 auto} iter = this->line_begin(); {\cf20 // points the first character}\par
324                 {\cf19 while}(iter != this->begin())\par
325                 \{\par
326                     iter = std::prev(iter);\par
327 \par
328                     {\cf20 // range [line_start, iter) represents the previous line}\par
329                     {\cf17 const} {\cf17 auto} line_start   = std::find(\par
330                             rev_iter(iter), rev_iter(this->begin()), {\cf23 '\\n'}).base();\par
331                     {\cf17 const} {\cf17 auto} comment_found = std::find(line_start, iter, {\cf23 '#'});\par
332                     {\cf19 if}(comment_found == iter)\par
333                     \{\par
334                         {\cf19 break}; {\cf20 // comment not found.}\par
335                     \}\par
336 \par
337                     {\cf20 // exclude the following case.}\par
338                     {\cf20 // > a = "foo" # comment // <-- this is not a comment for b but a.}\par
339                     {\cf20 // > b = "current value"}\par
340                     {\cf19 if}(std::all_of(line_start, comment_found,\par
341                             []({\cf17 const} {\cf18 char} c) {\cf17 noexcept} -> {\cf18 bool} \{\par
342                                 {\cf19 return} c == {\cf23 ' '} || c == {\cf23 '\\t'};\par
343                             \}))\par
344                     \{\par
345                         {\cf20 // unwrap the first '#' by std::next.}\par
346                         {\cf17 auto} s = make_string(std::next(comment_found), iter);\par
347                         {\cf19 if}(!s.empty() && s.back() == {\cf23 '\\r'}) \{s.pop_back();\}\par
348                         com.push_back(std::move(s));\par
349                     \}\par
350                     {\cf19 else}\par
351                     \{\par
352                         {\cf19 break};\par
353                     \}\par
354                     iter = line_start;\par
355                 \}\par
356             \}\par
357         \}\par
358 \par
359         {\cf19 if}(com.size() > 1)\par
360         \{\par
361             std::reverse(com.begin(), com.end());\par
362         \}\par
363 \par
364         \{\par
365             {\cf20 // find comments just after the current region.}\par
366             {\cf20 // ```toml}\par
367             {\cf20 // # not this.}\par
368             {\cf20 // a = value # this one.}\par
369             {\cf20 // a = [ # not this (technically difficult)}\par
370             {\cf20 //}\par
371             {\cf20 // ] # and this.}\par
372             {\cf20 // ```}\par
373             {\cf20 // The reason why it's difficult is that it requires parsing in the}\par
374             {\cf20 // following case.}\par
375             {\cf20 // ```toml}\par
376             {\cf20 // a = [ 10 # this comment is for `10`. not for `a` but `a[0]`.}\par
377             {\cf20 // # ...}\par
378             {\cf20 // ] # this is apparently a comment for a.}\par
379             {\cf20 //}\par
380             {\cf20 // b = [}\par
381             {\cf20 // 3.14 ] # there is no way to add a comment to `3.14` currently.}\par
382             {\cf20 //}\par
383             {\cf20 // c = [}\par
384             {\cf20 //   3.14 # do this if you need a comment here.}\par
385             {\cf20 // ]}\par
386             {\cf20 // ```}\par
387             {\cf17 const} {\cf17 auto} comment_found =\par
388                 std::find(this->last(), this->line_end(), {\cf23 '#'});\par
389             {\cf19 if}(comment_found != this->line_end()) {\cf20 // '#' found}\par
390             \{\par
391                 {\cf20 // table = \{key = "value"\} # what is this for?}\par
392                 {\cf20 // the above comment is not for "value", but \{key="value"\}.}\par
393                 {\cf19 if}(comment_found == std::find_if(this->last(), comment_found,\par
394                     []({\cf17 const} {\cf18 char} c) {\cf17 noexcept} -> {\cf18 bool} \{\par
395                         {\cf19 return} !(c == {\cf23 ' '} || c == {\cf23 '\\t'} || c == {\cf23 ','});\par
396                     \}))\par
397                 \{\par
398                     {\cf20 // unwrap the first '#' by std::next.}\par
399                     {\cf17 auto} s = make_string(std::next(comment_found), this->line_end());\par
400                     {\cf19 if}(!s.empty() && s.back() == {\cf23 '\\r'}) \{s.pop_back();\}\par
401                     com.push_back(std::move(s));\par
402                 \}\par
403             \}\par
404         \}\par
405         {\cf19 return} com;\par
406     \}\par
407 \par
408   {\cf17 private}:\par
409 \par
410     source_ptr     source_;\par
411     std::string    source_name_;\par
412     const_iterator first_, last_;\par
413 \};\par
414 \par
415 \} {\cf20 // detail}\par
416 \} {\cf20 // toml}\par
417 {\cf21 #endif}{\cf20 // TOML11_REGION_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/result.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/result.hpp}
{\xe \v external/toml/result.hpp}
{\bkmkstart AAAAAAAAEB}
{\bkmkend AAAAAAAAEB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "traits.hpp"}\par
{\f2 #include <type_traits>}\par
{\f2 #include <stdexcept>}\par
{\f2 #include <utility>}\par
{\f2 #include <new>}\par
{\f2 #include <string>}\par
{\f2 #include <sstream>}\par
{\f2 #include <cassert>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::success< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::failure< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::result< T, E >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::none_t}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > success< typename std::remove_cv< typename std::remove_reference< T >::type >::type > {\b toml::ok} (T &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > failure< typename std::remove_cv< typename std::remove_reference< T >::type >::type > {\b toml::err} (T &&v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
success< std::string > {\b toml::ok} (const char *literal)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
failure< std::string > {\b toml::err} (const char *literal)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename E > void {\b toml::swap} (result< T, E > &lhs, result< T, E > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::detail::operator==} (const none_t &, const none_t &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::detail::operator!=} (const none_t &, const none_t &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::detail::operator<} (const none_t &, const none_t &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::detail::operator<=} (const none_t &, const none_t &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::detail::operator>} (const none_t &, const none_t &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::detail::operator>=} (const none_t &, const none_t &) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traitsT > std::basic_ostream< charT, traitsT > & {\b toml::detail::operator<<} (std::basic_ostream< charT, traitsT > &os, const none_t &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
failure< none_t > {\b toml::detail::none} () noexcept\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
result.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/result.hpp}
{\xe \v external/toml/result.hpp}
{\bkmkstart AAAAAAAAAS}
{\bkmkend AAAAAAAAAS}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2017.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_RESULT_HPP}\par
4 {\cf21 #define TOML11_RESULT_HPP}\par
5 {\cf21 #include "traits.hpp"}\par
6 {\cf21 #include <type_traits>}\par
7 {\cf21 #include <stdexcept>}\par
8 {\cf21 #include <utility>}\par
9 {\cf21 #include <new>}\par
10 {\cf21 #include <string>}\par
11 {\cf21 #include <sstream>}\par
12 {\cf21 #include <cassert>}\par
13 \par
14 {\cf17 namespace }toml\par
15 \{\par
16 \par
17 {\cf17 template}<{\cf17 typename} T>\par
18 {\cf17 struct }success\par
19 \{\par
20     {\cf17 using }value_type = T;\par
21     value_type value;\par
22 \par
23     {\cf17 explicit} success({\cf17 const} value_type& v)\par
24         {\cf17 noexcept}(std::is_nothrow_copy_constructible<value_type>::value)\par
25         : value(v)\par
26     \{\}\par
27     {\cf17 explicit} success(value_type&& v)\par
28         {\cf17 noexcept}(std::is_nothrow_move_constructible<value_type>::value)\par
29         : value(std::move(v))\par
30     \{\}\par
31 \par
32     {\cf17 template}<{\cf17 typename} U>\par
33     {\cf17 explicit} success(U&& v): value(std::forward<U>(v)) \{\}\par
34 \par
35     {\cf17 template}<{\cf17 typename} U>\par
36     {\cf17 explicit} success({\cf17 const} success<U>& v): value(v.value) \{\}\par
37     {\cf17 template}<{\cf17 typename} U>\par
38     {\cf17 explicit} success(success<U>&& v): value(std::move(v.value)) \{\}\par
39 \par
40     ~success() = {\cf19 default};\par
41     success({\cf17 const} success&) = {\cf19 default};\par
42     success(success&&)      = {\cf19 default};\par
43     success& operator=({\cf17 const} success&) = {\cf19 default};\par
44     success& operator=(success&&)      = {\cf19 default};\par
45 \};\par
46 \par
47 {\cf17 template}<{\cf17 typename} T>\par
48 {\cf17 struct }failure\par
49 \{\par
50     {\cf17 using }value_type = T;\par
51     value_type value;\par
52 \par
53     {\cf17 explicit} failure({\cf17 const} value_type& v)\par
54         {\cf17 noexcept}(std::is_nothrow_copy_constructible<value_type>::value)\par
55         : value(v)\par
56     \{\}\par
57     {\cf17 explicit} failure(value_type&& v)\par
58         {\cf17 noexcept}(std::is_nothrow_move_constructible<value_type>::value)\par
59         : value(std::move(v))\par
60     \{\}\par
61 \par
62     {\cf17 template}<{\cf17 typename} U>\par
63     {\cf17 explicit} failure(U&& v): value(std::forward<U>(v)) \{\}\par
64 \par
65     {\cf17 template}<{\cf17 typename} U>\par
66     {\cf17 explicit} failure({\cf17 const} failure<U>& v): value(v.value) \{\}\par
67     {\cf17 template}<{\cf17 typename} U>\par
68     {\cf17 explicit} failure(failure<U>&& v): value(std::move(v.value)) \{\}\par
69 \par
70     ~failure() = {\cf19 default};\par
71     failure({\cf17 const} failure&) = {\cf19 default};\par
72     failure(failure&&)      = {\cf19 default};\par
73     failure& operator=({\cf17 const} failure&) = {\cf19 default};\par
74     failure& operator=(failure&&)      = {\cf19 default};\par
75 \};\par
76 \par
77 {\cf17 template}<{\cf17 typename} T>\par
78 success<typename std::remove_cv<typename std::remove_reference<T>::type>::type>\par
79 ok(T&& v)\par
80 \{\par
81     {\cf19 return} success<\par
82         {\cf17 typename} std::remove_cv<typename std::remove_reference<T>::type>::type\par
83         >(std::forward<T>(v));\par
84 \}\par
85 {\cf17 template}<{\cf17 typename} T>\par
86 failure<typename std::remove_cv<typename std::remove_reference<T>::type>::type>\par
87 err(T&& v)\par
88 \{\par
89     {\cf19 return} failure<\par
90         {\cf17 typename} std::remove_cv<typename std::remove_reference<T>::type>::type\par
91         >(std::forward<T>(v));\par
92 \}\par
93 \par
94 {\cf17 inline} success<std::string> ok({\cf17 const} {\cf18 char}* literal)\par
95 \{\par
96     {\cf19 return} success<std::string>(std::string(literal));\par
97 \}\par
98 {\cf17 inline} failure<std::string> err({\cf17 const} {\cf18 char}* literal)\par
99 \{\par
100     {\cf19 return} failure<std::string>(std::string(literal));\par
101 \}\par
102 \par
103 \par
104 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} E>\par
105 {\cf17 struct }result\par
106 \{\par
107     {\cf17 using }value_type = T;\par
108     {\cf17 using }error_type = E;\par
109     {\cf17 using }success_type = success<value_type>;\par
110     {\cf17 using }failure_type = failure<error_type>;\par
111 \par
112     result({\cf17 const} success_type& s): is_ok_(true)\par
113     \{\par
114         {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(s);\par
115         assert(tmp == std::addressof(this->succ));\par
116         (void)tmp;\par
117     \}\par
118     result({\cf17 const} failure_type& f): is_ok_(false)\par
119     \{\par
120         {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(f);\par
121         assert(tmp == std::addressof(this->fail));\par
122         (void)tmp;\par
123     \}\par
124     result(success_type&& s): is_ok_(true)\par
125     \{\par
126         {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(std::move(s));\par
127         assert(tmp == std::addressof(this->succ));\par
128         (void)tmp;\par
129     \}\par
130     result(failure_type&& f): is_ok_(false)\par
131     \{\par
132         {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(std::move(f));\par
133         assert(tmp == std::addressof(this->fail));\par
134         (void)tmp;\par
135     \}\par
136 \par
137     {\cf17 template}<{\cf17 typename} U>\par
138     result({\cf17 const} success<U>& s): is_ok_(true)\par
139     \{\par
140         {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(s.value);\par
141         assert(tmp == std::addressof(this->succ));\par
142         (void)tmp;\par
143     \}\par
144     {\cf17 template}<{\cf17 typename} U>\par
145     result({\cf17 const} failure<U>& f): is_ok_(false)\par
146     \{\par
147         {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(f.value);\par
148         assert(tmp == std::addressof(this->fail));\par
149         (void)tmp;\par
150     \}\par
151     {\cf17 template}<{\cf17 typename} U>\par
152     result(success<U>&& s): is_ok_(true)\par
153     \{\par
154         {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(std::move(s.value));\par
155         assert(tmp == std::addressof(this->succ));\par
156         (void)tmp;\par
157     \}\par
158     {\cf17 template}<{\cf17 typename} U>\par
159     result(failure<U>&& f): is_ok_(false)\par
160     \{\par
161         {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(std::move(f.value));\par
162         assert(tmp == std::addressof(this->fail));\par
163         (void)tmp;\par
164     \}\par
165 \par
166     result& operator=({\cf17 const} success_type& s)\par
167     \{\par
168         this->cleanup();\par
169         this->is_ok_ = {\cf17 true};\par
170         {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(s);\par
171         assert(tmp == std::addressof(this->succ));\par
172         (void)tmp;\par
173         {\cf19 return} *{\cf17 this};\par
174     \}\par
175     result& operator=({\cf17 const} failure_type& f)\par
176     \{\par
177         this->cleanup();\par
178         this->is_ok_ = {\cf17 false};\par
179         {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(f);\par
180         assert(tmp == std::addressof(this->fail));\par
181         (void)tmp;\par
182         {\cf19 return} *{\cf17 this};\par
183     \}\par
184     result& operator=(success_type&& s)\par
185     \{\par
186         this->cleanup();\par
187         this->is_ok_ = {\cf17 true};\par
188         {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(std::move(s));\par
189         assert(tmp == std::addressof(this->succ));\par
190         (void)tmp;\par
191         {\cf19 return} *{\cf17 this};\par
192     \}\par
193     result& operator=(failure_type&& f)\par
194     \{\par
195         this->cleanup();\par
196         this->is_ok_ = {\cf17 false};\par
197         {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(std::move(f));\par
198         assert(tmp == std::addressof(this->fail));\par
199         (void)tmp;\par
200         {\cf19 return} *{\cf17 this};\par
201     \}\par
202 \par
203     {\cf17 template}<{\cf17 typename} U>\par
204     result& operator=({\cf17 const} success<U>& s)\par
205     \{\par
206         this->cleanup();\par
207         this->is_ok_ = {\cf17 true};\par
208         {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(s.value);\par
209         assert(tmp == std::addressof(this->succ));\par
210         (void)tmp;\par
211         {\cf19 return} *{\cf17 this};\par
212     \}\par
213     {\cf17 template}<{\cf17 typename} U>\par
214     result& operator=({\cf17 const} failure<U>& f)\par
215     \{\par
216         this->cleanup();\par
217         this->is_ok_ = {\cf17 false};\par
218         {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(f.value);\par
219         assert(tmp == std::addressof(this->fail));\par
220         (void)tmp;\par
221         {\cf19 return} *{\cf17 this};\par
222     \}\par
223     {\cf17 template}<{\cf17 typename} U>\par
224     result& operator=(success<U>&& s)\par
225     \{\par
226         this->cleanup();\par
227         this->is_ok_ = {\cf17 true};\par
228         {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(std::move(s.value));\par
229         assert(tmp == std::addressof(this->succ));\par
230         (void)tmp;\par
231         {\cf19 return} *{\cf17 this};\par
232     \}\par
233     {\cf17 template}<{\cf17 typename} U>\par
234     result& operator=(failure<U>&& f)\par
235     \{\par
236         this->cleanup();\par
237         this->is_ok_ = {\cf17 false};\par
238         {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(std::move(f.value));\par
239         assert(tmp == std::addressof(this->fail));\par
240         (void)tmp;\par
241         {\cf19 return} *{\cf17 this};\par
242     \}\par
243 \par
244     ~result() noexcept \{this->cleanup();\}\par
245 \par
246     result({\cf17 const} result& other): is_ok_(other.is_ok())\par
247     \{\par
248         {\cf19 if}(other.is_ok())\par
249         \{\par
250             {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(other.as_ok());\par
251             assert(tmp == std::addressof(this->succ));\par
252             (void)tmp;\par
253         \}\par
254         {\cf19 else}\par
255         \{\par
256             {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(other.as_err());\par
257             assert(tmp == std::addressof(this->fail));\par
258             (void)tmp;\par
259         \}\par
260     \}\par
261     result(result&& other): is_ok_(other.is_ok())\par
262     \{\par
263         {\cf19 if}(other.is_ok())\par
264         \{\par
265             {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(std::move(other.as_ok()));\par
266             assert(tmp == std::addressof(this->succ));\par
267             (void)tmp;\par
268         \}\par
269         {\cf19 else}\par
270         \{\par
271             {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(std::move(other.as_err()));\par
272             assert(tmp == std::addressof(this->fail));\par
273             (void)tmp;\par
274         \}\par
275     \}\par
276 \par
277     {\cf17 template}<{\cf17 typename} U, {\cf17 typename} F>\par
278     result({\cf17 const} result<U, F>& other): is_ok_(other.is_ok())\par
279     \{\par
280         {\cf19 if}(other.is_ok())\par
281         \{\par
282             {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(other.as_ok());\par
283             assert(tmp == std::addressof(this->succ));\par
284             (void)tmp;\par
285         \}\par
286         {\cf19 else}\par
287         \{\par
288             {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(other.as_err());\par
289             assert(tmp == std::addressof(this->fail));\par
290             (void)tmp;\par
291         \}\par
292     \}\par
293     {\cf17 template}<{\cf17 typename} U, {\cf17 typename} F>\par
294     result(result<U, F>&& other): is_ok_(other.is_ok())\par
295     \{\par
296         {\cf19 if}(other.is_ok())\par
297         \{\par
298             {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(std::move(other.as_ok()));\par
299             assert(tmp == std::addressof(this->succ));\par
300             (void)tmp;\par
301         \}\par
302         {\cf19 else}\par
303         \{\par
304             {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(std::move(other.as_err()));\par
305             assert(tmp == std::addressof(this->fail));\par
306             (void)tmp;\par
307         \}\par
308     \}\par
309 \par
310     result& operator=({\cf17 const} result& other)\par
311     \{\par
312         this->cleanup();\par
313         {\cf19 if}(other.is_ok())\par
314         \{\par
315             {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(other.as_ok());\par
316             assert(tmp == std::addressof(this->succ));\par
317             (void)tmp;\par
318         \}\par
319         {\cf19 else}\par
320         \{\par
321             {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(other.as_err());\par
322             assert(tmp == std::addressof(this->fail));\par
323             (void)tmp;\par
324         \}\par
325         is_ok_ = other.is_ok();\par
326         {\cf19 return} *{\cf17 this};\par
327     \}\par
328     result& operator=(result&& other)\par
329     \{\par
330         this->cleanup();\par
331         {\cf19 if}(other.is_ok())\par
332         \{\par
333             {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(std::move(other.as_ok()));\par
334             assert(tmp == std::addressof(this->succ));\par
335             (void)tmp;\par
336         \}\par
337         {\cf19 else}\par
338         \{\par
339             {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(std::move(other.as_err()));\par
340             assert(tmp == std::addressof(this->fail));\par
341             (void)tmp;\par
342         \}\par
343         is_ok_ = other.is_ok();\par
344         {\cf19 return} *{\cf17 this};\par
345     \}\par
346 \par
347     {\cf17 template}<{\cf17 typename} U, {\cf17 typename} F>\par
348     result& operator=({\cf17 const} result<U, F>& other)\par
349     \{\par
350         this->cleanup();\par
351         {\cf19 if}(other.is_ok())\par
352         \{\par
353             {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(other.as_ok());\par
354             assert(tmp == std::addressof(this->succ));\par
355             (void)tmp;\par
356         \}\par
357         {\cf19 else}\par
358         \{\par
359             {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(other.as_err());\par
360             assert(tmp == std::addressof(this->fail));\par
361             (void)tmp;\par
362         \}\par
363         is_ok_ = other.is_ok();\par
364         {\cf19 return} *{\cf17 this};\par
365     \}\par
366     {\cf17 template}<{\cf17 typename} U, {\cf17 typename} F>\par
367     result& operator=(result<U, F>&& other)\par
368     \{\par
369         this->cleanup();\par
370         {\cf19 if}(other.is_ok())\par
371         \{\par
372             {\cf17 auto} tmp = ::new(std::addressof(this->succ)) success_type(std::move(other.as_ok()));\par
373             assert(tmp == std::addressof(this->succ));\par
374             (void)tmp;\par
375         \}\par
376         {\cf19 else}\par
377         \{\par
378             {\cf17 auto} tmp = ::new(std::addressof(this->fail)) failure_type(std::move(other.as_err()));\par
379             assert(tmp == std::addressof(this->fail));\par
380             (void)tmp;\par
381         \}\par
382         is_ok_ = other.is_ok();\par
383         {\cf19 return} *{\cf17 this};\par
384     \}\par
385 \par
386     {\cf18 bool} is_ok()  const noexcept \{{\cf19 return} is_ok_;\}\par
387     {\cf18 bool} is_err() const noexcept \{{\cf19 return} !is_ok_;\}\par
388 \par
389     {\cf17 operator} bool() const noexcept \{{\cf19 return} is_ok_;\}\par
390 \par
391     value_type&       unwrap() &\par
392     \{\par
393         {\cf19 if}(is_err())\par
394         \{\par
395             {\cf19 throw} std::runtime_error({\cf22 "toml::result: bad unwrap: "} +\par
396                                      format_error(this->as_err()));\par
397         \}\par
398         {\cf19 return} this->succ.value;\par
399     \}\par
400     value_type {\cf17 const}& unwrap() const&\par
401     \{\par
402         {\cf19 if}(is_err())\par
403         \{\par
404             {\cf19 throw} std::runtime_error({\cf22 "toml::result: bad unwrap: "} +\par
405                                      format_error(this->as_err()));\par
406         \}\par
407         {\cf19 return} this->succ.value;\par
408     \}\par
409     value_type&&      unwrap() &&\par
410     \{\par
411         {\cf19 if}(is_err())\par
412         \{\par
413             {\cf19 throw} std::runtime_error({\cf22 "toml::result: bad unwrap: "} +\par
414                                      format_error(this->as_err()));\par
415         \}\par
416         {\cf19 return} std::move(this->succ.value);\par
417     \}\par
418 \par
419     value_type&       unwrap_or(value_type& opt) &\par
420     \{\par
421         {\cf19 if}(is_err()) \{{\cf19 return} opt;\}\par
422         {\cf19 return} this->succ.value;\par
423     \}\par
424     value_type {\cf17 const}& unwrap_or(value_type {\cf17 const}& opt) {\cf17 const}&\par
425     \{\par
426         {\cf19 if}(is_err()) \{{\cf19 return} opt;\}\par
427         {\cf19 return} this->succ.value;\par
428     \}\par
429     value_type        unwrap_or(value_type opt) &&\par
430     \{\par
431         {\cf19 if}(is_err()) \{{\cf19 return} opt;\}\par
432         {\cf19 return} this->succ.value;\par
433     \}\par
434 \par
435     error_type&       unwrap_err() &\par
436     \{\par
437         {\cf19 if}(is_ok()) \{{\cf19 throw} std::runtime_error({\cf22 "toml::result: bad unwrap_err"});\}\par
438         {\cf19 return} this->fail.value;\par
439     \}\par
440     error_type {\cf17 const}& unwrap_err() const&\par
441     \{\par
442         {\cf19 if}(is_ok()) \{{\cf19 throw} std::runtime_error({\cf22 "toml::result: bad unwrap_err"});\}\par
443         {\cf19 return} this->fail.value;\par
444     \}\par
445     error_type&&      unwrap_err() &&\par
446     \{\par
447         {\cf19 if}(is_ok()) \{{\cf19 throw} std::runtime_error({\cf22 "toml::result: bad unwrap_err"});\}\par
448         {\cf19 return} std::move(this->fail.value);\par
449     \}\par
450 \par
451     value_type&       as_ok() &      {\cf17 noexcept} \{{\cf19 return} this->succ.value;\}\par
452     value_type {\cf17 const}& as_ok() const& noexcept \{{\cf19 return} this->succ.value;\}\par
453     value_type&&      as_ok() &&     {\cf17 noexcept} \{{\cf19 return} std::move(this->succ.value);\}\par
454 \par
455     error_type&       as_err() &      {\cf17 noexcept} \{{\cf19 return} this->fail.value;\}\par
456     error_type {\cf17 const}& as_err() const& noexcept \{{\cf19 return} this->fail.value;\}\par
457     error_type&&      as_err() &&     {\cf17 noexcept} \{{\cf19 return} std::move(this->fail.value);\}\par
458 \par
459 \par
460     {\cf20 // prerequisities}\par
461     {\cf20 // F: T -> U}\par
462     {\cf20 // retval: result<U, E>}\par
463     {\cf17 template}<{\cf17 typename} F>\par
464     result<detail::return_type_of_t<F, value_type&>, error_type>\par
465     map(F&& f) &\par
466     \{\par
467         {\cf19 if}(this->is_ok())\{{\cf19 return} ok(f(this->as_ok()));\}\par
468         {\cf19 return} err(this->as_err());\par
469     \}\par
470     {\cf17 template}<{\cf17 typename} F>\par
471     result<detail::return_type_of_t<F, value_type const&>, error_type>\par
472     map(F&& f) {\cf17 const}&\par
473     \{\par
474         {\cf19 if}(this->is_ok())\{{\cf19 return} ok(f(this->as_ok()));\}\par
475         {\cf19 return} err(this->as_err());\par
476     \}\par
477     {\cf17 template}<{\cf17 typename} F>\par
478     result<detail::return_type_of_t<F, value_type &&>, error_type>\par
479     map(F&& f) &&\par
480     \{\par
481         {\cf19 if}(this->is_ok())\{{\cf19 return} ok(f(std::move(this->as_ok())));\}\par
482         {\cf19 return} err(std::move(this->as_err()));\par
483     \}\par
484 \par
485     {\cf20 // prerequisities}\par
486     {\cf20 // F: E -> F}\par
487     {\cf20 // retval: result<T, F>}\par
488     {\cf17 template}<{\cf17 typename} F>\par
489     result<value_type, detail::return_type_of_t<F, error_type&>>\par
490     map_err(F&& f) &\par
491     \{\par
492         {\cf19 if}(this->is_err())\{{\cf19 return} err(f(this->as_err()));\}\par
493         {\cf19 return} ok(this->as_ok());\par
494     \}\par
495     {\cf17 template}<{\cf17 typename} F>\par
496     result<value_type, detail::return_type_of_t<F, error_type const&>>\par
497     map_err(F&& f) {\cf17 const}&\par
498     \{\par
499         {\cf19 if}(this->is_err())\{{\cf19 return} err(f(this->as_err()));\}\par
500         {\cf19 return} ok(this->as_ok());\par
501     \}\par
502     {\cf17 template}<{\cf17 typename} F>\par
503     result<value_type, detail::return_type_of_t<F, error_type&&>>\par
504     map_err(F&& f) &&\par
505     \{\par
506         {\cf19 if}(this->is_err())\{{\cf19 return} err(f(std::move(this->as_err())));\}\par
507         {\cf19 return} ok(std::move(this->as_ok()));\par
508     \}\par
509 \par
510     {\cf20 // prerequisities}\par
511     {\cf20 // F: T -> U}\par
512     {\cf20 // retval: U}\par
513     {\cf17 template}<{\cf17 typename} F, {\cf17 typename} U>\par
514     detail::return_type_of_t<F, value_type&>\par
515     map_or_else(F&& f, U&& opt) &\par
516     \{\par
517         {\cf19 if}(this->is_err())\{{\cf19 return} std::forward<U>(opt);\}\par
518         {\cf19 return} f(this->as_ok());\par
519     \}\par
520     {\cf17 template}<{\cf17 typename} F, {\cf17 typename} U>\par
521     detail::return_type_of_t<F, value_type const&>\par
522     map_or_else(F&& f, U&& opt) {\cf17 const}&\par
523     \{\par
524         {\cf19 if}(this->is_err())\{{\cf19 return} std::forward<U>(opt);\}\par
525         {\cf19 return} f(this->as_ok());\par
526     \}\par
527     {\cf17 template}<{\cf17 typename} F, {\cf17 typename} U>\par
528     detail::return_type_of_t<F, value_type&&>\par
529     map_or_else(F&& f, U&& opt) &&\par
530     \{\par
531         {\cf19 if}(this->is_err())\{{\cf19 return} std::forward<U>(opt);\}\par
532         {\cf19 return} f(std::move(this->as_ok()));\par
533     \}\par
534 \par
535     {\cf20 // prerequisities}\par
536     {\cf20 // F: E -> U}\par
537     {\cf20 // retval: U}\par
538     {\cf17 template}<{\cf17 typename} F, {\cf17 typename} U>\par
539     detail::return_type_of_t<F, error_type&>\par
540     map_err_or_else(F&& f, U&& opt) &\par
541     \{\par
542         {\cf19 if}(this->is_ok())\{{\cf19 return} std::forward<U>(opt);\}\par
543         {\cf19 return} f(this->as_err());\par
544     \}\par
545     {\cf17 template}<{\cf17 typename} F, {\cf17 typename} U>\par
546     detail::return_type_of_t<F, error_type const&>\par
547     map_err_or_else(F&& f, U&& opt) {\cf17 const}&\par
548     \{\par
549         {\cf19 if}(this->is_ok())\{{\cf19 return} std::forward<U>(opt);\}\par
550         {\cf19 return} f(this->as_err());\par
551     \}\par
552     {\cf17 template}<{\cf17 typename} F, {\cf17 typename} U>\par
553     detail::return_type_of_t<F, error_type&&>\par
554     map_err_or_else(F&& f, U&& opt) &&\par
555     \{\par
556         {\cf19 if}(this->is_ok())\{{\cf19 return} std::forward<U>(opt);\}\par
557         {\cf19 return} f(std::move(this->as_err()));\par
558     \}\par
559 \par
560     {\cf20 // prerequisities:}\par
561     {\cf20 // F: func T -> U}\par
562     {\cf20 // toml::err(error_type) should be convertible to U.}\par
563     {\cf20 // normally, type U is another result<S, F> and E is convertible to F}\par
564     {\cf17 template}<{\cf17 typename} F>\par
565     detail::return_type_of_t<F, value_type&>\par
566     and_then(F&& f) &\par
567     \{\par
568         {\cf19 if}(this->is_ok())\{{\cf19 return} f(this->as_ok());\}\par
569         {\cf19 return} err(this->as_err());\par
570     \}\par
571     {\cf17 template}<{\cf17 typename} F>\par
572     detail::return_type_of_t<F, value_type const&>\par
573     and_then(F&& f) {\cf17 const}&\par
574     \{\par
575         {\cf19 if}(this->is_ok())\{{\cf19 return} f(this->as_ok());\}\par
576         {\cf19 return} err(this->as_err());\par
577     \}\par
578     {\cf17 template}<{\cf17 typename} F>\par
579     detail::return_type_of_t<F, value_type&&>\par
580     and_then(F&& f) &&\par
581     \{\par
582         {\cf19 if}(this->is_ok())\{{\cf19 return} f(std::move(this->as_ok()));\}\par
583         {\cf19 return} err(std::move(this->as_err()));\par
584     \}\par
585 \par
586     {\cf20 // prerequisities:}\par
587     {\cf20 // F: func E -> U}\par
588     {\cf20 // toml::ok(value_type) should be convertible to U.}\par
589     {\cf20 // normally, type U is another result<S, F> and T is convertible to S}\par
590     {\cf17 template}<{\cf17 typename} F>\par
591     detail::return_type_of_t<F, error_type&>\par
592     or_else(F&& f) &\par
593     \{\par
594         {\cf19 if}(this->is_err())\{{\cf19 return} f(this->as_err());\}\par
595         {\cf19 return} ok(this->as_ok());\par
596     \}\par
597     {\cf17 template}<{\cf17 typename} F>\par
598     detail::return_type_of_t<F, error_type const&>\par
599     or_else(F&& f) {\cf17 const}&\par
600     \{\par
601         {\cf19 if}(this->is_err())\{{\cf19 return} f(this->as_err());\}\par
602         {\cf19 return} ok(this->as_ok());\par
603     \}\par
604     {\cf17 template}<{\cf17 typename} F>\par
605     detail::return_type_of_t<F, error_type&&>\par
606     or_else(F&& f) &&\par
607     \{\par
608         {\cf19 if}(this->is_err())\{{\cf19 return} f(std::move(this->as_err()));\}\par
609         {\cf19 return} ok(std::move(this->as_ok()));\par
610     \}\par
611 \par
612     {\cf20 // if *this is error, returns *this. otherwise, returns other.}\par
613     result and_other({\cf17 const} result& other) {\cf17 const}&\par
614     \{\par
615         {\cf19 return} this->is_err() ? *this : other;\par
616     \}\par
617     result and_other(result&& other) &&\par
618     \{\par
619         {\cf19 return} this->is_err() ? std::move(*{\cf17 this}) : std::move(other);\par
620     \}\par
621 \par
622     {\cf20 // if *this is okay, returns *this. otherwise, returns other.}\par
623     result or_other({\cf17 const} result& other) {\cf17 const}&\par
624     \{\par
625         {\cf19 return} this->is_ok() ? *this : other;\par
626     \}\par
627     result or_other(result&& other) &&\par
628     \{\par
629         {\cf19 return} this->is_ok() ? std::move(*{\cf17 this}) : std::move(other);\par
630     \}\par
631 \par
632     {\cf18 void} swap(result<T, E>& other)\par
633     \{\par
634         result<T, E> tmp(std::move(*{\cf17 this}));\par
635         *{\cf17 this} = std::move(other);\par
636         other = std::move(tmp);\par
637         return ;\par
638     \}\par
639 \par
640   {\cf17 private}:\par
641 \par
642     {\cf17 static} std::string format_error(std::exception {\cf17 const}& excpt)\par
643     \{\par
644         {\cf19 return} std::string(excpt.what());\par
645     \}\par
646     {\cf17 template}<{\cf17 typename} U, {\cf17 typename} std::enable_if<!std::is_base_of<\par
647         std::exception, U>::value, std::nullptr_t>::type = {\cf17 nullptr}>\par
648     {\cf17 static} std::string format_error(U {\cf17 const}& others)\par
649     \{\par
650         std::ostringstream oss; oss << others;\par
651         {\cf19 return} oss.str();\par
652     \}\par
653 \par
654     {\cf18 void} cleanup() noexcept\par
655     \{\par
656         {\cf19 if}(this->is_ok_) \{this->succ.~success_type();\}\par
657         {\cf19 else}             \{this->fail.~failure_type();\}\par
658         {\cf19 return};\par
659     \}\par
660 \par
661   {\cf17 private}:\par
662 \par
663     {\cf18 bool}      is_ok_;\par
664     {\cf17 union}\par
665     \{\par
666         success_type succ;\par
667         failure_type fail;\par
668     \};\par
669 \};\par
670 \par
671 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} E>\par
672 {\cf18 void} swap(result<T, E>& lhs, result<T, E>& rhs)\par
673 \{\par
674     lhs.swap(rhs);\par
675     {\cf19 return};\par
676 \}\par
677 \par
678 {\cf20 // this might be confusing because it eagerly evaluated, while in the other}\par
679 {\cf20 // cases operator && and || are short-circuited.}\par
680 {\cf20 //}\par
681 {\cf20 // template<typename T, typename E>}\par
682 {\cf20 // inline result<T, E>}\par
683 {\cf20 // operator&&(const result<T, E>& lhs, const result<T, E>& rhs) noexcept}\par
684 {\cf20 // \{}\par
685 {\cf20 //     return lhs.is_ok() ? rhs : lhs;}\par
686 {\cf20 // \}}\par
687 {\cf20 //}\par
688 {\cf20 // template<typename T, typename E>}\par
689 {\cf20 // inline result<T, E>}\par
690 {\cf20 // operator||(const result<T, E>& lhs, const result<T, E>& rhs) noexcept}\par
691 {\cf20 // \{}\par
692 {\cf20 //     return lhs.is_ok() ? lhs : rhs;}\par
693 {\cf20 // \}}\par
694 \par
695 {\cf20 // ----------------------------------------------------------------------------}\par
696 {\cf20 // re-use result<T, E> as a optional<T> with none_t}\par
697 \par
698 {\cf17 namespace }detail\par
699 \{\par
700 {\cf17 struct }none_t \{\};\par
701 {\cf17 inline} {\cf18 bool} operator==({\cf17 const} none_t&, {\cf17 const} none_t&) {\cf17 noexcept} \{{\cf19 return} {\cf17 true};\}\par
702 {\cf17 inline} {\cf18 bool} operator!=({\cf17 const} none_t&, {\cf17 const} none_t&) {\cf17 noexcept} \{{\cf19 return} {\cf17 false};\}\par
703 {\cf17 inline} {\cf18 bool} operator< ({\cf17 const} none_t&, {\cf17 const} none_t&) {\cf17 noexcept} \{{\cf19 return} {\cf17 false};\}\par
704 {\cf17 inline} {\cf18 bool} operator<=({\cf17 const} none_t&, {\cf17 const} none_t&) {\cf17 noexcept} \{{\cf19 return} {\cf17 true};\}\par
705 {\cf17 inline} {\cf18 bool} operator> ({\cf17 const} none_t&, {\cf17 const} none_t&) {\cf17 noexcept} \{{\cf19 return} {\cf17 false};\}\par
706 {\cf17 inline} {\cf18 bool} operator>=({\cf17 const} none_t&, {\cf17 const} none_t&) {\cf17 noexcept} \{{\cf19 return} {\cf17 true};\}\par
707 {\cf17 template}<{\cf17 typename} {\cf18 char}T, {\cf17 typename} traitsT>\par
708 std::basic_ostream<charT, traitsT>&\par
709 operator<<(std::basic_ostream<charT, traitsT>& os, {\cf17 const} none_t&)\par
710 \{\par
711     os << {\cf22 "none"};\par
712     {\cf19 return} os;\par
713 \}\par
714 {\cf17 inline} failure<none_t> none() noexcept \{{\cf19 return} failure<none_t>\{none_t\{\}\};\}\par
715 \} {\cf20 // detail}\par
716 \} {\cf20 // toml11}\par
717 {\cf21 #endif}{\cf20 // TOML11_RESULT_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/serializer.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/serializer.hpp}
{\xe \v external/toml/serializer.hpp}
{\bkmkstart AAAAAAAAEC}
{\bkmkend AAAAAAAAEC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cmath>}\par
{\f2 #include <cstdio>}\par
{\f2 #include <limits>}\par
{\f2 #include "lexer.hpp"}\par
{\f2 #include "value.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::serializer< Value >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits , typename Alloc > std::basic_string< charT, traits, Alloc > {\b toml::format_key} (const std::basic_string< charT, traits, Alloc > &k)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits , typename Alloc > std::basic_string< charT, traits, Alloc > {\b toml::format_keys} (const std::vector< std::basic_string< charT, traits, Alloc > > &keys)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class M, template< typename ... > class V> std::string {\b toml::format} (const basic_value< C, M, V > &v, std::size_t w=80u, int fprec=std::numeric_limits< {\b toml::floating} >::max_digits10, bool no_comment=false, bool force_inline=false)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > int {\b toml::detail::comment_index} (std::basic_ostream< charT, traits > &)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b toml::nocomment} (std::basic_ostream< charT, traits > &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b toml::showcomment} (std::basic_ostream< charT, traits > &os)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits , typename C , template< typename ... > class M, template< typename ... > class V> std::basic_ostream< charT, traits > & {\b toml::operator<<} (std::basic_ostream< charT, traits > &os, const basic_value< C, M, V > &v)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
serializer.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/serializer.hpp}
{\xe \v external/toml/serializer.hpp}
{\bkmkstart AAAAAAAAAT}
{\bkmkend AAAAAAAAAT}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2019.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_SERIALIZER_HPP}\par
4 {\cf21 #define TOML11_SERIALIZER_HPP}\par
5 {\cf21 #include <cmath>}\par
6 {\cf21 #include <cstdio>}\par
7 \par
8 {\cf21 #include <limits>}\par
9 \par
10 {\cf21 #include "lexer.hpp"}\par
11 {\cf21 #include "value.hpp"}\par
12 \par
13 {\cf17 namespace }toml\par
14 \{\par
15 \par
16 {\cf20 // This function serialize a key. It checks a string is a bare key and}\par
17 {\cf20 // escapes special characters if the string is not compatible to a bare key.}\par
18 {\cf20 // ```cpp}\par
19 {\cf20 // std::string k("non.bare.key"); // the key itself includes `.`s.}\par
20 {\cf20 // std::string formatted = toml::format_key(k);}\par
21 {\cf20 // assert(formatted == "\\"non.bare.key\\"");}\par
22 {\cf20 // ```}\par
23 {\cf20 //}\par
24 {\cf20 // This function is exposed to make it easy to write a user-defined serializer.}\par
25 {\cf20 // Since toml restricts characters available in a bare key, generally a string}\par
26 {\cf20 // should be escaped. But checking whether a string needs to be surrounded by}\par
27 {\cf20 // a `"` and escaping some special character is boring.}\par
28 {\cf17 template}<{\cf17 typename} {\cf18 char}T, {\cf17 typename} traits, {\cf17 typename} Alloc>\par
29 std::basic_string<charT, traits, Alloc>\par
30 format_key({\cf17 const} std::basic_string<charT, traits, Alloc>& k)\par
31 \{\par
32     {\cf19 if}(k.empty())\par
33     \{\par
34         {\cf19 return} std::string({\cf22 "\\"\\""});\par
35     \}\par
36 \par
37     {\cf20 // check the key can be a bare (unquoted) key}\par
38     detail::location loc(k, std::vector<char>(k.begin(), k.end()));\par
39     detail::lex_unquoted_key::invoke(loc);\par
40     {\cf19 if}(loc.iter() == loc.end())\par
41     \{\par
42         {\cf19 return} k; {\cf20 // all the tokens are consumed. the key is unquoted-key.}\par
43     \}\par
44 \par
45     {\cf20 //if it includes special characters, then format it in a "quoted" key.}\par
46     std::basic_string<charT, traits, Alloc> serialized({\cf22 "\\""});\par
47     {\cf19 for}({\cf17 const} {\cf18 char} c : k)\par
48     \{\par
49         {\cf19 switch}(c)\par
50         \{\par
51             {\cf19 case} {\cf23 '\\\\'}: \{serialized += {\cf22 "\\\\\\\\"}; {\cf19 break};\}\par
52             {\cf19 case} {\cf23 '\\"'}: \{serialized += {\cf22 "\\\\\\""}; {\cf19 break};\}\par
53             {\cf19 case} {\cf23 '\\b'}: \{serialized += {\cf22 "\\\\b"};  {\cf19 break};\}\par
54             {\cf19 case} {\cf23 '\\t'}: \{serialized += {\cf22 "\\\\t"};  {\cf19 break};\}\par
55             {\cf19 case} {\cf23 '\\f'}: \{serialized += {\cf22 "\\\\f"};  {\cf19 break};\}\par
56             {\cf19 case} {\cf23 '\\n'}: \{serialized += {\cf22 "\\\\n"};  {\cf19 break};\}\par
57             {\cf19 case} {\cf23 '\\r'}: \{serialized += {\cf22 "\\\\r"};  {\cf19 break};\}\par
58             default  : \{serialized += c;      {\cf19 break};\}\par
59         \}\par
60     \}\par
61     serialized += {\cf22 "\\""};\par
62     {\cf19 return} serialized;\par
63 \}\par
64 \par
65 {\cf17 template}<{\cf17 typename} {\cf18 char}T, {\cf17 typename} traits, {\cf17 typename} Alloc>\par
66 std::basic_string<charT, traits, Alloc>\par
67 format_keys({\cf17 const} std::vector<std::basic_string<charT, traits, Alloc>>& keys)\par
68 \{\par
69     {\cf19 if}(keys.empty())\par
70     \{\par
71         {\cf19 return} std::string({\cf22 "\\"\\""});\par
72     \}\par
73 \par
74     std::basic_string<charT, traits, Alloc> serialized;\par
75     {\cf19 for}({\cf17 const} {\cf17 auto}& ky : keys)\par
76     \{\par
77         serialized += format_key(ky);\par
78         serialized += charT({\cf23 '.'});\par
79     \}\par
80     serialized.pop_back(); {\cf20 // remove the last dot '.'}\par
81     {\cf19 return} serialized;\par
82 \}\par
83 \par
84 {\cf17 template}<{\cf17 typename} Value>\par
85 {\cf17 struct }serializer\par
86 \{\par
87     {\cf17 static_assert}(detail::is_basic_value<Value>::value,\par
88                   {\cf22 "toml::serializer is for toml::value and its variants, "}\par
89                   {\cf22 "toml::basic_value<...>."});\par
90 \par
91     {\cf17 using }value_type           = Value;\par
92     {\cf17 using }key_type             = {\cf17 typename} value_type::key_type            ;\par
93     {\cf17 using }comment_type         = {\cf17 typename} value_type::comment_type        ;\par
94     {\cf17 using }boolean_type         = {\cf17 typename} value_type::boolean_type        ;\par
95     {\cf17 using }integer_type         = {\cf17 typename} value_type::integer_type        ;\par
96     {\cf17 using }floating_type        = {\cf17 typename} value_type::floating_type       ;\par
97     {\cf17 using }string_type          = {\cf17 typename} value_type::string_type         ;\par
98     {\cf17 using }local_time_type      = {\cf17 typename} value_type::local_time_type     ;\par
99     {\cf17 using }local_date_type      = {\cf17 typename} value_type::local_date_type     ;\par
100     {\cf17 using }local_datetime_type  = {\cf17 typename} value_type::local_datetime_type ;\par
101     {\cf17 using }offset_datetime_type = {\cf17 typename} value_type::offset_datetime_type;\par
102     {\cf17 using }array_type           = {\cf17 typename} value_type::array_type          ;\par
103     {\cf17 using }table_type           = {\cf17 typename} value_type::table_type          ;\par
104 \par
105     serializer({\cf17 const} std::size_t w              = 80u,\par
106                {\cf17 const} {\cf18 int}         float_prec     = std::numeric_limits<toml::floating>::max_digits10,\par
107                {\cf17 const} {\cf18 bool}        can_be_inlined = {\cf17 false},\par
108                {\cf17 const} {\cf18 bool}        no_comment     = {\cf17 false},\par
109                std::vector<toml::key> ks        = \{\},\par
110                {\cf17 const} {\cf18 bool}     value_has_comment = {\cf17 false})\par
111         : can_be_inlined_(can_be_inlined), no_comment_(no_comment),\par
112           value_has_comment_(value_has_comment && !no_comment),\par
113           float_prec_(float_prec), width_(w), keys_(std::move(ks))\par
114     \{\}\par
115     ~serializer() = {\cf19 default};\par
116 \par
117     std::string operator()({\cf17 const} boolean_type& b){\cf17  const}\par
118 {\cf17     }\{\par
119         {\cf19 return} b ? {\cf22 "true"} : {\cf22 "false"};\par
120     \}\par
121     std::string operator()({\cf17 const} integer_type i){\cf17  const}\par
122 {\cf17     }\{\par
123         {\cf19 return} std::to_string(i);\par
124     \}\par
125     std::string operator()({\cf17 const} floating_type f){\cf17  const}\par
126 {\cf17     }\{\par
127         {\cf19 if}(std::isnan(f))\par
128         \{\par
129             {\cf19 if}(std::signbit(f))\par
130             \{\par
131                 {\cf19 return} std::string({\cf22 "-nan"});\par
132             \}\par
133             {\cf19 else}\par
134             \{\par
135                 {\cf19 return} std::string({\cf22 "nan"});\par
136             \}\par
137         \}\par
138         {\cf19 else} {\cf19 if}(!std::isfinite(f))\par
139         \{\par
140             {\cf19 if}(std::signbit(f))\par
141             \{\par
142                 {\cf19 return} std::string({\cf22 "-inf"});\par
143             \}\par
144             {\cf19 else}\par
145             \{\par
146                 {\cf19 return} std::string({\cf22 "inf"});\par
147             \}\par
148         \}\par
149 \par
150         {\cf17 const} {\cf17 auto} fmt = {\cf22 "%.*g"};\par
151         {\cf17 const} {\cf17 auto} bsz = std::snprintf({\cf17 nullptr}, 0, fmt, this->float_prec_, f);\par
152         {\cf20 // +1 for null character(\\0)}\par
153         std::vector<char> buf({\cf17 static_cast<}std::size_t{\cf17 >}(bsz + 1), {\cf23 '\\0'});\par
154         std::snprintf(buf.data(), buf.size(), fmt, this->float_prec_, f);\par
155 \par
156         std::string token(buf.begin(), std::prev(buf.end()));\par
157         {\cf19 if}(!token.empty() && token.back() == {\cf23 '.'}) {\cf20 // 1. => 1.0}\par
158         \{\par
159             token += {\cf23 '0'};\par
160         \}\par
161 \par
162         {\cf17 const} {\cf17 auto} e = std::find_if(\par
163             token.cbegin(), token.cend(), []({\cf17 const} {\cf18 char} c) noexcept -> {\cf18 bool} \{\par
164                 return c == {\cf22 'e'} || c == {\cf22 'E'};\par
165             \});\par
166         {\cf17 const} {\cf17 auto} has_exponent = (token.cend() != e);\par
167         {\cf17 const} {\cf17 auto} has_fraction = (token.cend() != std::find(\par
168             token.cbegin(), token.cend(), {\cf23 '.'}));\par
169 \par
170         {\cf19 if}(!has_exponent && !has_fraction)\par
171         \{\par
172             {\cf20 // the resulting value does not have any float specific part!}\par
173             token += {\cf22 ".0"};\par
174         \}\par
175         {\cf19 return} token;\par
176     \}\par
177     std::string operator()({\cf17 const} string_type& s){\cf17  const}\par
178 {\cf17     }\{\par
179         {\cf19 if}(s.kind == string_t::basic)\par
180         \{\par
181             {\cf19 if}((std::find(s.str.cbegin(), s.str.cend(), {\cf23 '\\n'}) != s.str.cend() ||\par
182                 std::find(s.str.cbegin(), s.str.cend(), {\cf23 '\\"'}) != s.str.cend()) &&\par
183                this->width_ != (std::numeric_limits<std::size_t>::max)())\par
184             \{\par
185                 {\cf20 // if linefeed or double-quote is contained,}\par
186                 {\cf20 // make it multiline basic string.}\par
187                 {\cf17 const} {\cf17 auto} escaped = this->escape_ml_basic_string(s.str);\par
188                 std::string open({\cf22 "\\"\\"\\""});\par
189                 std::string close({\cf22 "\\"\\"\\""});\par
190                 {\cf19 if}(escaped.find({\cf23 '\\n'}) != std::string::npos ||\par
191                    this->width_ < escaped.size() + 6)\par
192                 \{\par
193                     {\cf20 // if the string body contains newline or is enough long,}\par
194                     {\cf20 // add newlines after and before delimiters.}\par
195                     open += {\cf22 "\\n"};\par
196                     close = std::string({\cf22 "\\\\\\n"}) + close;\par
197                 \}\par
198                 {\cf19 return} open + escaped + close;\par
199             \}\par
200 \par
201             {\cf20 // no linefeed. try to make it oneline-string.}\par
202             std::string oneline = this->escape_basic_string(s.str);\par
203             {\cf19 if}(oneline.size() + 2 < width_ || width_ < 2)\par
204             \{\par
205                 {\cf17 const} std::string quote({\cf22 "\\""});\par
206                 {\cf19 return} quote + oneline + quote;\par
207             \}\par
208 \par
209             {\cf20 // the line is too long compared to the specified width.}\par
210             {\cf20 // split it into multiple lines.}\par
211             std::string token({\cf22 "\\"\\"\\"\\n"});\par
212             {\cf19 while}(!oneline.empty())\par
213             \{\par
214                 {\cf19 if}(oneline.size() < width_)\par
215                 \{\par
216                     token += oneline;\par
217                     oneline.clear();\par
218                 \}\par
219                 {\cf19 else} {\cf19 if}(oneline.at(width_-2) == {\cf23 '\\\\'})\par
220                 \{\par
221                     token += oneline.substr(0, width_-2);\par
222                     token += {\cf22 "\\\\\\n"};\par
223                     oneline.erase(0, width_-2);\par
224                 \}\par
225                 {\cf19 else}\par
226                 \{\par
227                     token += oneline.substr(0, width_-1);\par
228                     token += {\cf22 "\\\\\\n"};\par
229                     oneline.erase(0, width_-1);\par
230                 \}\par
231             \}\par
232             {\cf19 return} token + std::string({\cf22 "\\\\\\n\\"\\"\\""});\par
233         \}\par
234         {\cf19 else} {\cf20 // the string `s` is literal-string.}\par
235         \{\par
236             {\cf19 if}(std::find(s.str.cbegin(), s.str.cend(), {\cf23 '\\n'}) != s.str.cend() ||\par
237                std::find(s.str.cbegin(), s.str.cend(), {\cf23 '\\''}) != s.str.cend() )\par
238             \{\par
239                 std::string open({\cf22 "'''"});\par
240                 {\cf19 if}(this->width_ + 6 < s.str.size())\par
241                 \{\par
242                     open += {\cf23 '\\n'}; {\cf20 // the first newline is ignored by TOML spec}\par
243                 \}\par
244                 {\cf17 const} std::string close({\cf22 "'''"});\par
245                 {\cf19 return} open + s.str + close;\par
246             \}\par
247             {\cf19 else}\par
248             \{\par
249                 {\cf17 const} std::string quote({\cf22 "'"});\par
250                 {\cf19 return} quote + s.str + quote;\par
251             \}\par
252         \}\par
253     \}\par
254 \par
255     std::string operator()({\cf17 const} local_date_type& d){\cf17  const}\par
256 {\cf17     }\{\par
257         std::ostringstream oss;\par
258         oss << d;\par
259         {\cf19 return} oss.str();\par
260     \}\par
261     std::string operator()({\cf17 const} local_time_type& t){\cf17  const}\par
262 {\cf17     }\{\par
263         std::ostringstream oss;\par
264         oss << t;\par
265         {\cf19 return} oss.str();\par
266     \}\par
267     std::string operator()({\cf17 const} local_datetime_type& dt){\cf17  const}\par
268 {\cf17     }\{\par
269         std::ostringstream oss;\par
270         oss << dt;\par
271         {\cf19 return} oss.str();\par
272     \}\par
273     std::string operator()({\cf17 const} offset_datetime_type& odt){\cf17  const}\par
274 {\cf17     }\{\par
275         std::ostringstream oss;\par
276         oss << odt;\par
277         {\cf19 return} oss.str();\par
278     \}\par
279 \par
280     std::string operator()({\cf17 const} array_type& v){\cf17  const}\par
281 {\cf17     }\{\par
282         {\cf19 if}(v.empty())\par
283         \{\par
284             {\cf19 return} std::string({\cf22 "[]"});\par
285         \}\par
286         {\cf19 if}(this->is_array_of_tables(v))\par
287         \{\par
288             {\cf19 return} make_array_of_tables(v);\par
289         \}\par
290 \par
291         {\cf20 // not an array of tables. normal array.}\par
292         {\cf20 // first, try to make it inline if none of the elements have a comment.}\par
293         {\cf19 if}( ! this->has_comment_inside(v))\par
294         \{\par
295             {\cf17 const} {\cf17 auto} inl = this->make_inline_array(v);\par
296             {\cf19 if}(inl.size() < this->width_ &&\par
297                std::find(inl.cbegin(), inl.cend(), {\cf23 '\\n'}) == inl.cend())\par
298             \{\par
299                 {\cf19 return} inl;\par
300             \}\par
301         \}\par
302 \par
303         {\cf20 // if the length exceeds this->width_, print multiline array.}\par
304         {\cf20 // key = [}\par
305         {\cf20 //   # ...}\par
306         {\cf20 //   42,}\par
307         {\cf20 //   ...}\par
308         {\cf20 // ]}\par
309         std::string token;\par
310         std::string current_line;\par
311         token += {\cf22 "[\\n"};\par
312         {\cf19 for}({\cf17 const} {\cf17 auto}& item : v)\par
313         \{\par
314             {\cf19 if}( ! item.comments().empty() && !no_comment_)\par
315             \{\par
316                 {\cf20 // if comment exists, the element must be the only element in the line.}\par
317                 {\cf20 // e.g. the following is not allowed.}\par
318                 {\cf20 // ```toml}\par
319                 {\cf20 // array = [}\par
320                 {\cf20 // # comment for what?}\par
321                 {\cf20 // 1, 2, 3, 4, 5}\par
322                 {\cf20 // ]}\par
323                 {\cf20 // ```}\par
324                 {\cf19 if}(!current_line.empty())\par
325                 \{\par
326                     {\cf19 if}(current_line.back() != {\cf23 '\\n'})\par
327                     \{\par
328                         current_line += {\cf23 '\\n'};\par
329                     \}\par
330                     token += current_line;\par
331                     current_line.clear();\par
332                 \}\par
333                 {\cf19 for}({\cf17 const} {\cf17 auto}& c : item.comments())\par
334                 \{\par
335                     token += {\cf23 '#'};\par
336                     token += c;\par
337                     token += {\cf23 '\\n'};\par
338                 \}\par
339                 token += toml::visit(*{\cf17 this}, item);\par
340                 {\cf19 if}(!token.empty() && token.back() == {\cf23 '\\n'}) \{token.pop_back();\}\par
341                 token += {\cf22 ",\\n"};\par
342                 {\cf19 continue};\par
343             \}\par
344             std::string next_elem;\par
345             {\cf19 if}(item.is_table())\par
346             \{\par
347                 serializer ser(*{\cf17 this});\par
348                 ser.can_be_inlined_ = {\cf17 true};\par
349                 ser.width_ = (std::numeric_limits<std::size_t>::max)();\par
350                 next_elem += toml::visit(ser, item);\par
351             \}\par
352             {\cf19 else}\par
353             \{\par
354                 next_elem += toml::visit(*{\cf17 this}, item);\par
355             \}\par
356 \par
357             {\cf20 // comma before newline.}\par
358             {\cf19 if}(!next_elem.empty() && next_elem.back() == {\cf23 '\\n'}) \{next_elem.pop_back();\}\par
359 \par
360             {\cf20 // if current line does not exceeds the width limit, continue.}\par
361             {\cf19 if}(current_line.size() + next_elem.size() + 1 < this->width_)\par
362             \{\par
363                 current_line += next_elem;\par
364                 current_line += {\cf23 ','};\par
365             \}\par
366             {\cf19 else} {\cf19 if}(current_line.empty())\par
367             \{\par
368                 {\cf20 // if current line was empty, force put the next_elem because}\par
369                 {\cf20 // next_elem is not splittable}\par
370                 token += next_elem;\par
371                 token += {\cf22 ",\\n"};\par
372                 {\cf20 // current_line is kept empty}\par
373             \}\par
374             {\cf19 else} {\cf20 // reset current_line}\par
375             \{\par
376                 assert(current_line.back() == {\cf23 ','});\par
377                 token += current_line;\par
378                 token += {\cf23 '\\n'};\par
379                 current_line = next_elem;\par
380                 current_line += {\cf23 ','};\par
381             \}\par
382         \}\par
383         {\cf19 if}(!current_line.empty())\par
384         \{\par
385             {\cf19 if}(!current_line.empty() && current_line.back() != {\cf23 '\\n'})\par
386             \{\par
387                 current_line += {\cf23 '\\n'};\par
388             \}\par
389             token += current_line;\par
390         \}\par
391         token += {\cf22 "]\\n"};\par
392         {\cf19 return} token;\par
393     \}\par
394 \par
395     {\cf20 // templatize for any table-like container}\par
396     std::string operator()({\cf17 const} table_type& v){\cf17  const}\par
397 {\cf17     }\{\par
398         {\cf20 // if an element has a comment, then it can't be inlined.}\par
399         {\cf20 // table = \{# how can we write a comment for this? key = "value"\}}\par
400         {\cf19 if}(this->can_be_inlined_ && !(this->has_comment_inside(v)))\par
401         \{\par
402             std::string token;\par
403             {\cf19 if}(!this->keys_.empty())\par
404             \{\par
405                 token += format_key(this->keys_.back());\par
406                 token += {\cf22 " = "};\par
407             \}\par
408             token += this->make_inline_table(v);\par
409             {\cf19 if}(token.size() < this->width_ &&\par
410                token.end() == std::find(token.begin(), token.end(), {\cf23 '\\n'}))\par
411             \{\par
412                 {\cf19 return} token;\par
413             \}\par
414         \}\par
415 \par
416         std::string token;\par
417         {\cf19 if}(!keys_.empty())\par
418         \{\par
419             token += {\cf23 '['};\par
420             token += format_keys(keys_);\par
421             token += {\cf22 "]\\n"};\par
422         \}\par
423         token += this->make_multiline_table(v);\par
424         {\cf19 return} token;\par
425     \}\par
426 \par
427   {\cf17 private}:\par
428 \par
429     std::string escape_basic_string({\cf17 const} std::string& s){\cf17  const}\par
430 {\cf17     }\{\par
431         {\cf20 //XXX assuming `s` is a valid utf-8 sequence.}\par
432         std::string retval;\par
433         {\cf19 for}({\cf17 const} {\cf18 char} c : s)\par
434         \{\par
435             {\cf19 switch}(c)\par
436             \{\par
437                 {\cf19 case} {\cf23 '\\\\'}: \{retval += {\cf22 "\\\\\\\\"}; {\cf19 break};\}\par
438                 {\cf19 case} {\cf23 '\\"'}: \{retval += {\cf22 "\\\\\\""}; {\cf19 break};\}\par
439                 {\cf19 case} {\cf23 '\\b'}: \{retval += {\cf22 "\\\\b"};  {\cf19 break};\}\par
440                 {\cf19 case} {\cf23 '\\t'}: \{retval += {\cf22 "\\\\t"};  {\cf19 break};\}\par
441                 {\cf19 case} {\cf23 '\\f'}: \{retval += {\cf22 "\\\\f"};  {\cf19 break};\}\par
442                 {\cf19 case} {\cf23 '\\n'}: \{retval += {\cf22 "\\\\n"};  {\cf19 break};\}\par
443                 {\cf19 case} {\cf23 '\\r'}: \{retval += {\cf22 "\\\\r"};  {\cf19 break};\}\par
444                 default  :\par
445                 \{\par
446                     {\cf19 if}((0x00 <= c && c <= 0x08) || (0x0A <= c && c <= 0x1F) || c == 0x7F)\par
447                     \{\par
448                         retval += {\cf22 "\\\\u00"};\par
449                         retval += char(48 + (c / 16));\par
450                         retval += char((c % 16 < 10 ? 48 : 55) + (c % 16));\par
451                     \}\par
452                     {\cf19 else}\par
453                     \{\par
454                         retval += c;\par
455                     \}\par
456                 \}\par
457             \}\par
458         \}\par
459         {\cf19 return} retval;\par
460     \}\par
461 \par
462     std::string escape_ml_basic_string({\cf17 const} std::string& s){\cf17  const}\par
463 {\cf17     }\{\par
464         std::string retval;\par
465         {\cf19 for}({\cf17 auto} i=s.cbegin(), e=s.cend(); i!=e; ++i)\par
466         \{\par
467             {\cf19 switch}(*i)\par
468             \{\par
469                 {\cf19 case} {\cf23 '\\\\'}: \{retval += {\cf22 "\\\\\\\\"}; {\cf19 break};\}\par
470                 {\cf20 // One or two consecutive "s are allowed.}\par
471                 {\cf20 // Later we will check there are no three consecutive "s.}\par
472                 {\cf20 //   case '\\"': \{retval += "\\\\\\""; break;\}}\par
473                 {\cf19 case} {\cf23 '\\b'}: \{retval += {\cf22 "\\\\b"};  {\cf19 break};\}\par
474                 {\cf19 case} {\cf23 '\\t'}: \{retval += {\cf22 "\\\\t"};  {\cf19 break};\}\par
475                 {\cf19 case} {\cf23 '\\f'}: \{retval += {\cf22 "\\\\f"};  {\cf19 break};\}\par
476                 {\cf19 case} {\cf23 '\\n'}: \{retval += {\cf22 "\\n"};   {\cf19 break};\}\par
477                 {\cf19 case} {\cf23 '\\r'}:\par
478                 \{\par
479                     {\cf19 if}(std::next(i) != e && *std::next(i) == {\cf23 '\\n'})\par
480                     \{\par
481                         retval += {\cf22 "\\r\\n"};\par
482                         ++i;\par
483                     \}\par
484                     {\cf19 else}\par
485                     \{\par
486                         retval += {\cf22 "\\\\r"};\par
487                     \}\par
488                     {\cf19 break};\par
489                 \}\par
490                 default  :\par
491                 \{\par
492                     {\cf17 const} {\cf17 auto} c = *i;\par
493                     {\cf19 if}((0x00 <= c && c <= 0x08) || (0x0A <= c && c <= 0x1F) || c == 0x7F)\par
494                     \{\par
495                         retval += {\cf22 "\\\\u00"};\par
496                         retval += char(48 + (c / 16));\par
497                         retval += char((c % 16 < 10 ? 48 : 55) + (c % 16));\par
498                     \}\par
499                     {\cf19 else}\par
500                     \{\par
501                         retval += c;\par
502                     \}\par
503                 \}\par
504 \par
505             \}\par
506         \}\par
507         {\cf20 // Only 1 or 2 consecutive `"`s are allowed in multiline basic string.}\par
508         {\cf20 // 3 consecutive `"`s are considered as a closing delimiter.}\par
509         {\cf20 // We need to check if there are 3 or more consecutive `"`s and insert}\par
510         {\cf20 // backslash to break them down into several short `"`s like the `str6`}\par
511         {\cf20 // in the following example.}\par
512         {\cf20 // ```toml}\par
513         {\cf20 // str4 = """Here are two quotation marks: "". Simple enough."""}\par
514         {\cf20 // # str5 = """Here are three quotation marks: """."""  # INVALID}\par
515         {\cf20 // str5 = """Here are three quotation marks: ""\\"."""}\par
516         {\cf20 // str6 = """Here are fifteen quotation marks: ""\\"""\\"""\\"""\\"""\\"."""}\par
517         {\cf20 // ```}\par
518         {\cf17 auto} found_3_quotes = retval.find({\cf22 "\\"\\"\\""});\par
519         {\cf19 while}(found_3_quotes != std::string::npos)\par
520         \{\par
521             retval.replace(found_3_quotes, 3, {\cf22 "\\"\\"\\\\\\""});\par
522             found_3_quotes = retval.find({\cf22 "\\"\\"\\""});\par
523         \}\par
524         {\cf19 return} retval;\par
525     \}\par
526 \par
527     {\cf20 // if an element of a table or an array has a comment, it cannot be inlined.}\par
528     {\cf18 bool} has_comment_inside({\cf17 const} array_type& a) {\cf17 const} {\cf17 noexcept}\par
529     \{\par
530         {\cf20 // if no_comment is set, comments would not be written.}\par
531         {\cf19 if}(this->no_comment_) \{{\cf19 return} {\cf17 false};\}\par
532 \par
533         {\cf19 for}({\cf17 const} {\cf17 auto}& v : a)\par
534         \{\par
535             {\cf19 if}(!v.comments().empty()) \{{\cf19 return} {\cf17 true};\}\par
536         \}\par
537         {\cf19 return} {\cf17 false};\par
538     \}\par
539     {\cf18 bool} has_comment_inside({\cf17 const} table_type& t) {\cf17 const} {\cf17 noexcept}\par
540     \{\par
541         {\cf20 // if no_comment is set, comments would not be written.}\par
542         {\cf19 if}(this->no_comment_) \{{\cf19 return} {\cf17 false};\}\par
543 \par
544         {\cf19 for}({\cf17 const} {\cf17 auto}& kv : t)\par
545         \{\par
546             {\cf19 if}(!kv.second.comments().empty()) \{{\cf19 return} {\cf17 true};\}\par
547         \}\par
548         {\cf19 return} {\cf17 false};\par
549     \}\par
550 \par
551     std::string make_inline_array({\cf17 const} array_type& v){\cf17  const}\par
552 {\cf17     }\{\par
553         assert(!has_comment_inside(v));\par
554         std::string token;\par
555         token += {\cf23 '['};\par
556         {\cf18 bool} is_first = {\cf17 true};\par
557         {\cf19 for}({\cf17 const} {\cf17 auto}& item : v)\par
558         \{\par
559             {\cf19 if}(is_first) \{is_first = {\cf17 false};\} {\cf19 else} \{token += {\cf23 ','};\}\par
560             token += visit(serializer(\par
561                 (std::numeric_limits<std::size_t>::max)(), this->float_prec_,\par
562                 {\cf20 /* inlined */} {\cf17 true}, {\cf20 /*no comment*/} {\cf17 false}, {\cf20 /*keys*/} \{\},\par
563                 {\cf20 /*has_comment*/} !item.comments().empty()), item);\par
564         \}\par
565         token += {\cf23 ']'};\par
566         {\cf19 return} token;\par
567     \}\par
568 \par
569     std::string make_inline_table({\cf17 const} table_type& v){\cf17  const}\par
570 {\cf17     }\{\par
571         assert(!has_comment_inside(v));\par
572         assert(this->can_be_inlined_);\par
573         std::string token;\par
574         token += {\cf23 '\{'};\par
575         {\cf18 bool} is_first = {\cf17 true};\par
576         {\cf19 for}({\cf17 const} {\cf17 auto}& kv : v)\par
577         \{\par
578             {\cf20 // in inline tables, trailing comma is not allowed (toml-lang #569).}\par
579             {\cf19 if}(is_first) \{is_first = {\cf17 false};\} {\cf19 else} \{token += {\cf23 ','};\}\par
580             token += format_key(kv.first);\par
581             token += {\cf23 '='};\par
582             token += visit(serializer(\par
583                 (std::numeric_limits<std::size_t>::max)(), this->float_prec_,\par
584                 {\cf20 /* inlined */} {\cf17 true}, {\cf20 /*no comment*/} {\cf17 false}, {\cf20 /*keys*/} \{\},\par
585                 {\cf20 /*has_comment*/} !kv.second.comments().empty()), kv.second);\par
586         \}\par
587         token += {\cf23 '\}'};\par
588         {\cf19 return} token;\par
589     \}\par
590 \par
591     std::string make_multiline_table({\cf17 const} table_type& v){\cf17  const}\par
592 {\cf17     }\{\par
593         std::string token;\par
594 \par
595         {\cf20 // print non-table elements first.}\par
596         {\cf20 // ```toml}\par
597         {\cf20 // [foo]         # a table we're writing now here}\par
598         {\cf20 // key = "value" # <- non-table element, "key"}\par
599         {\cf20 // # ...}\par
600         {\cf20 // [foo.bar] # <- table element, "bar"}\par
601         {\cf20 // ```}\par
602         {\cf20 // because after printing [foo.bar], the remaining non-table values will}\par
603         {\cf20 // be assigned into [foo.bar], not [foo]. Those values should be printed}\par
604         {\cf20 // earlier.}\par
605         {\cf19 for}({\cf17 const} {\cf17 auto}& kv : v)\par
606         \{\par
607             {\cf19 if}(kv.second.is_table() || is_array_of_tables(kv.second))\par
608             \{\par
609                 {\cf19 continue};\par
610             \}\par
611 \par
612             token += write_comments(kv.second);\par
613 \par
614             {\cf17 const} {\cf17 auto} key_and_sep    = format_key(kv.first) + {\cf22 " = "};\par
615             {\cf17 const} {\cf17 auto} residual_width = (this->width_ > key_and_sep.size()) ?\par
616                                         this->width_ - key_and_sep.size() : 0;\par
617             token += key_and_sep;\par
618             token += visit(serializer(residual_width, this->float_prec_,\par
619                 {\cf20 /*can be inlined*/} {\cf17 true}, {\cf20 /*no comment*/} {\cf17 false}, {\cf20 /*keys*/} \{\},\par
620                 {\cf20 /*has_comment*/} !kv.second.comments().empty()), kv.second);\par
621 \par
622             {\cf19 if}(token.back() != {\cf23 '\\n'})\par
623             \{\par
624                 token += {\cf23 '\\n'};\par
625             \}\par
626         \}\par
627 \par
628         {\cf20 // normal tables / array of tables}\par
629 \par
630         {\cf20 // after multiline table appeared, the other tables cannot be inline}\par
631         {\cf20 // because the table would be assigned into the table.}\par
632         {\cf20 // [foo]}\par
633         {\cf20 // ...}\par
634         {\cf20 // bar = \{...\} # <- bar will be a member of [foo].}\par
635         {\cf18 bool} multiline_table_printed = {\cf17 false};\par
636         {\cf19 for}({\cf17 const} {\cf17 auto}& kv : v)\par
637         \{\par
638             {\cf19 if}(!kv.second.is_table() && !is_array_of_tables(kv.second))\par
639             \{\par
640                 {\cf19 continue}; {\cf20 // other stuff are already serialized. skip them.}\par
641             \}\par
642 \par
643             std::vector<toml::key> ks(this->keys_);\par
644             ks.push_back(kv.first);\par
645 \par
646             {\cf17 auto} tmp = visit(serializer(this->width_, this->float_prec_,\par
647                 !multiline_table_printed, this->no_comment_, ks,\par
648                 {\cf20 /*has_comment*/} !kv.second.comments().empty()), kv.second);\par
649 \par
650             {\cf20 // If it is the first time to print a multi-line table, it would be}\par
651             {\cf20 // helpful to separate normal key-value pair and subtables by a}\par
652             {\cf20 // newline.}\par
653             {\cf20 // (this checks if the current key-value pair contains newlines.}\par
654             {\cf20 //  but it is not perfect because multi-line string can also contain}\par
655             {\cf20 //  a newline. in such a case, an empty line will be written) TODO}\par
656             {\cf19 if}((!multiline_table_printed) &&\par
657                std::find(tmp.cbegin(), tmp.cend(), {\cf23 '\\n'}) != tmp.cend())\par
658             \{\par
659                 multiline_table_printed = {\cf17 true};\par
660                 token += {\cf23 '\\n'}; {\cf20 // separate key-value pairs and subtables}\par
661 \par
662                 token += write_comments(kv.second);\par
663                 token += tmp;\par
664 \par
665                 {\cf20 // care about recursive tables (all tables in each level prints}\par
666                 {\cf20 // newline and there will be a full of newlines)}\par
667                 {\cf19 if}(tmp.substr(tmp.size() - 2, 2) != {\cf22 "\\n\\n"} &&\par
668                    tmp.substr(tmp.size() - 4, 4) != {\cf22 "\\r\\n\\r\\n"} )\par
669                 \{\par
670                     token += {\cf23 '\\n'};\par
671                 \}\par
672             \}\par
673             {\cf19 else}\par
674             \{\par
675                 token += write_comments(kv.second);\par
676                 token += tmp;\par
677                 token += {\cf23 '\\n'};\par
678             \}\par
679         \}\par
680         {\cf19 return} token;\par
681     \}\par
682 \par
683     std::string make_array_of_tables({\cf17 const} array_type& v){\cf17  const}\par
684 {\cf17     }\{\par
685         {\cf20 // if it's not inlined, we need to add `[[table.key]]`.}\par
686         {\cf20 // but if it can be inlined, we can format it as the following.}\par
687         {\cf20 // ```}\par
688         {\cf20 // table.key = [}\par
689         {\cf20 //   \{...\},}\par
690         {\cf20 //   # comment}\par
691         {\cf20 //   \{...\},}\par
692         {\cf20 // ]}\par
693         {\cf20 // ```}\par
694         {\cf20 // This function checks if inlinization is possible or not, and then}\par
695         {\cf20 // format the array-of-tables in a proper way.}\par
696         {\cf20 //}\par
697         {\cf20 // Note about comments:}\par
698         {\cf20 //}\par
699         {\cf20 // If the array itself has a comment (value_has_comment_ == true), we}\par
700         {\cf20 // should try to make it inline.}\par
701         {\cf20 // ```toml}\par
702         {\cf20 // # comment about array}\par
703         {\cf20 // array = [}\par
704         {\cf20 //   # comment about table element}\par
705         {\cf20 //   \{of = "table"\}}\par
706         {\cf20 // ]}\par
707         {\cf20 // ```}\par
708         {\cf20 // If it is formatted as a multiline table, the two comments becomes}\par
709         {\cf20 // indistinguishable.}\par
710         {\cf20 // ```toml}\par
711         {\cf20 // # comment about array}\par
712         {\cf20 // # comment about table element}\par
713         {\cf20 // [[array]]}\par
714         {\cf20 // of = "table"}\par
715         {\cf20 // ```}\par
716         {\cf20 // So we need to try to make it inline, and it force-inlines regardless}\par
717         {\cf20 // of the line width limit.}\par
718         {\cf20 //     It may fail if the element of a table has comment. In that case,}\par
719         {\cf20 // the array-of-tables will be formatted as a multiline table.}\par
720         {\cf19 if}(this->can_be_inlined_ || this->value_has_comment_)\par
721         \{\par
722             std::string token;\par
723             {\cf19 if}(!keys_.empty())\par
724             \{\par
725                 token += format_key(keys_.back());\par
726                 token += {\cf22 " = "};\par
727             \}\par
728 \par
729             {\cf18 bool} failed = {\cf17 false};\par
730             token += {\cf22 "[\\n"};\par
731             {\cf19 for}({\cf17 const} {\cf17 auto}& item : v)\par
732             \{\par
733                 {\cf20 // if an element of the table has a comment, the table}\par
734                 {\cf20 // cannot be inlined.}\par
735                 {\cf19 if}(this->has_comment_inside(item.as_table()))\par
736                 \{\par
737                     failed = {\cf17 true};\par
738                     {\cf19 break};\par
739                 \}\par
740                 {\cf20 // write comments for the table itself}\par
741                 token += write_comments(item);\par
742 \par
743                 {\cf17 const} {\cf17 auto} t = this->make_inline_table(item.as_table());\par
744 \par
745                 {\cf19 if}(t.size() + 1 > width_ || {\cf20 // +1 for the last comma \{...\},}\par
746                    std::find(t.cbegin(), t.cend(), {\cf23 '\\n'}) != t.cend())\par
747                 \{\par
748                     {\cf20 // if the value itself has a comment, ignore the line width limit}\par
749                     {\cf19 if}( ! this->value_has_comment_)\par
750                     \{\par
751                         failed = {\cf17 true};\par
752                         {\cf19 break};\par
753                     \}\par
754                 \}\par
755                 token += t;\par
756                 token += {\cf22 ",\\n"};\par
757             \}\par
758 \par
759             {\cf19 if}( ! failed)\par
760             \{\par
761                 token += {\cf22 "]\\n"};\par
762                 {\cf19 return} token;\par
763             \}\par
764             {\cf20 // if failed, serialize them as [[array.of.tables]].}\par
765         \}\par
766 \par
767         std::string token;\par
768         {\cf19 for}({\cf17 const} {\cf17 auto}& item : v)\par
769         \{\par
770             token += write_comments(item);\par
771             token += {\cf22 "[["};\par
772             token += format_keys(keys_);\par
773             token += {\cf22 "]]\\n"};\par
774             token += this->make_multiline_table(item.as_table());\par
775         \}\par
776         {\cf19 return} token;\par
777     \}\par
778 \par
779     std::string write_comments({\cf17 const} value_type& v){\cf17  const}\par
780 {\cf17     }\{\par
781         std::string retval;\par
782         {\cf19 if}(this->no_comment_) \{{\cf19 return} retval;\}\par
783 \par
784         {\cf19 for}({\cf17 const} {\cf17 auto}& c : v.comments())\par
785         \{\par
786             retval += {\cf23 '#'};\par
787             retval += c;\par
788             retval += {\cf23 '\\n'};\par
789         \}\par
790         {\cf19 return} retval;\par
791     \}\par
792 \par
793     {\cf18 bool} is_array_of_tables({\cf17 const} value_type& v){\cf17  const}\par
794 {\cf17     }\{\par
795         {\cf19 if}(!v.is_array() || v.as_array().empty()) \{{\cf19 return} {\cf17 false};\}\par
796         {\cf19 return} is_array_of_tables(v.as_array());\par
797     \}\par
798     {\cf18 bool} is_array_of_tables({\cf17 const} array_type& v){\cf17  const}\par
799 {\cf17     }\{\par
800         {\cf20 // Since TOML v0.5.0, heterogeneous arrays are allowed. So we need to}\par
801         {\cf20 // check all the element in an array to check if the array is an array}\par
802         {\cf20 // of tables.}\par
803         {\cf19 return} std::all_of(v.begin(), v.end(), []({\cf17 const} value_type& elem) \{\par
804                 return elem.is_table();\par
805             \});\par
806     \}\par
807 \par
808   {\cf17 private}:\par
809 \par
810     {\cf18 bool}        can_be_inlined_;\par
811     {\cf18 bool}        no_comment_;\par
812     {\cf18 bool}        value_has_comment_;\par
813     {\cf18 int}         float_prec_;\par
814     std::size_t width_;\par
815     std::vector<toml::key> keys_;\par
816 \};\par
817 \par
818 {\cf17 template}<{\cf17 typename} C,\par
819          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
820 std::string\par
821 format({\cf17 const} basic_value<C, M, V>& v, std::size_t w = 80u,\par
822        {\cf18 int} fprec = std::numeric_limits<toml::floating>::max_digits10,\par
823        {\cf18 bool} no_comment = {\cf17 false}, {\cf18 bool} force_inline = {\cf17 false})\par
824 \{\par
825     {\cf17 using }value_type = basic_value<C, M, V>;\par
826     {\cf20 // if value is a table, it is considered to be a root object.}\par
827     {\cf20 // the root object can't be an inline table.}\par
828     {\cf19 if}(v.is_table())\par
829     \{\par
830         std::ostringstream oss;\par
831         {\cf19 if}(!v.comments().empty())\par
832         \{\par
833             oss << v.comments();\par
834             oss << {\cf23 '\\n'}; {\cf20 // to split the file comment from the first element}\par
835         \}\par
836         {\cf17 const} {\cf17 auto} serialized = visit(serializer<value_type>(w, fprec, {\cf17 false}, no_comment), v);\par
837         oss << serialized;\par
838         {\cf19 return} oss.str();\par
839     \}\par
840     {\cf19 return} visit(serializer<value_type>(w, fprec, force_inline), v);\par
841 \}\par
842 \par
843 {\cf17 namespace }detail\par
844 \{\par
845 {\cf17 template}<{\cf17 typename} {\cf18 char}T, {\cf17 typename} traits>\par
846 {\cf18 int} comment_index(std::basic_ostream<charT, traits>&)\par
847 \{\par
848     {\cf17 static} {\cf17 const} {\cf18 int} index = std::ios_base::xalloc();\par
849     {\cf19 return} index;\par
850 \}\par
851 \} {\cf20 // detail}\par
852 \par
853 {\cf17 template}<{\cf17 typename} {\cf18 char}T, {\cf17 typename} traits>\par
854 std::basic_ostream<charT, traits>&\par
855 nocomment(std::basic_ostream<charT, traits>& os)\par
856 \{\par
857     {\cf20 // by default, it is zero. and by default, it shows comments.}\par
858     os.iword(detail::comment_index(os)) = 1;\par
859     {\cf19 return} os;\par
860 \}\par
861 \par
862 {\cf17 template}<{\cf17 typename} {\cf18 char}T, {\cf17 typename} traits>\par
863 std::basic_ostream<charT, traits>&\par
864 showcomment(std::basic_ostream<charT, traits>& os)\par
865 \{\par
866     {\cf20 // by default, it is zero. and by default, it shows comments.}\par
867     os.iword(detail::comment_index(os)) = 0;\par
868     {\cf19 return} os;\par
869 \}\par
870 \par
871 {\cf17 template}<{\cf17 typename} charT, {\cf17 typename} traits, {\cf17 typename} C,\par
872          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
873 std::basic_ostream<charT, traits>&\par
874 operator<<(std::basic_ostream<charT, traits>& os, {\cf17 const} basic_value<C, M, V>& v)\par
875 \{\par
876     {\cf17 using }value_type = basic_value<C, M, V>;\par
877 \par
878     {\cf20 // get status of std::setw().}\par
879     {\cf17 const} {\cf17 auto} w     = {\cf17 static_cast<}std::size_t{\cf17 >}(os.width());\par
880     {\cf17 const} {\cf18 int}  fprec = {\cf17 static_cast<}{\cf18 int}{\cf17 >}(os.precision());\par
881     os.width(0);\par
882 \par
883     {\cf20 // by default, iword is initialized by 0. And by default, toml11 outputs}\par
884     {\cf20 // comments. So `0` means showcomment. 1 means nocommnet.}\par
885     {\cf17 const} {\cf18 bool} no_comment = (1 == os.iword(detail::comment_index(os)));\par
886 \par
887     {\cf19 if}(!no_comment && v.is_table() && !v.comments().empty())\par
888     \{\par
889         os << v.comments();\par
890         os << {\cf23 '\\n'}; {\cf20 // to split the file comment from the first element}\par
891     \}\par
892     {\cf20 // the root object can't be an inline table. so pass `false`.}\par
893     {\cf17 const} {\cf17 auto} serialized = visit(serializer<value_type>(w, fprec, no_comment, {\cf17 false}), v);\par
894     os << serialized;\par
895 \par
896     {\cf20 // if v is a non-table value, and has only one comment, then}\par
897     {\cf20 // put a comment just after a value. in the following way.}\par
898     {\cf20 //}\par
899     {\cf20 // ```toml}\par
900     {\cf20 // key = "value" # comment.}\par
901     {\cf20 // ```}\par
902     {\cf20 //}\par
903     {\cf20 // Since the top-level toml object is a table, one who want to put a}\par
904     {\cf20 // non-table toml value must use this in a following way.}\par
905     {\cf20 //}\par
906     {\cf20 // ```cpp}\par
907     {\cf20 // toml::value v;}\par
908     {\cf20 // std::cout << "user-defined-key = " << v << std::endl;}\par
909     {\cf20 // ```}\par
910     {\cf20 //}\par
911     {\cf20 // In this case, it is impossible to put comments before key-value pair.}\par
912     {\cf20 // The only way to preserve comments is to put all of them after a value.}\par
913     {\cf19 if}(!no_comment && !v.is_table() && !v.comments().empty())\par
914     \{\par
915         os << {\cf22 " #"};\par
916         {\cf19 for}({\cf17 const} {\cf17 auto}& c : v.comments()) \{os << c;\}\par
917     \}\par
918     {\cf19 return} os;\par
919 \}\par
920 \par
921 \} {\cf20 // toml}\par
922 {\cf21 #endif}{\cf20 // TOML11_SERIALIZER_HPP}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/source_location.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/source_location.hpp}
{\xe \v external/toml/source_location.hpp}
{\bkmkstart AAAAAAAAED}
{\bkmkend AAAAAAAAED}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cstdint>}\par
{\f2 #include <sstream>}\par
{\f2 #include "region.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::source_location}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toml::detail::format_underline} (const std::string &message, const std::vector< std::pair< source_location, std::string > > &loc_com, const std::vector< std::string > &helps=\{\}, const bool colorize={\b TOML11_ERROR_MESSAGE_COLORIZED})\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
source_location.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/source_location.hpp}
{\xe \v external/toml/source_location.hpp}
{\bkmkstart AAAAAAAAAU}
{\bkmkend AAAAAAAAAU}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2019.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_SOURCE_LOCATION_HPP}\par
4 {\cf21 #define TOML11_SOURCE_LOCATION_HPP}\par
5 {\cf21 #include <cstdint>}\par
6 {\cf21 #include <sstream>}\par
7 \par
8 {\cf21 #include "region.hpp"}\par
9 \par
10 {\cf17 namespace }toml\par
11 \{\par
12 \par
13 {\cf20 // A struct to contain location in a toml file.}\par
14 {\cf20 // The interface imitates std::experimental::source_location,}\par
15 {\cf20 // but not completely the same.}\par
16 {\cf20 //}\par
17 {\cf20 // It would be constructed by toml::value. It can be used to generate}\par
18 {\cf20 // user-defined error messages.}\par
19 {\cf20 //}\par
20 {\cf20 // - std::uint_least32_t line() const noexcept}\par
21 {\cf20 //   - returns the line number where the region is on.}\par
22 {\cf20 // - std::uint_least32_t column() const noexcept}\par
23 {\cf20 //   - returns the column number where the region starts.}\par
24 {\cf20 // - std::uint_least32_t region() const noexcept}\par
25 {\cf20 //   - returns the size of the region.}\par
26 {\cf20 //}\par
27 {\cf20 // +-- line()       +-- region of interest (region() == 9)}\par
28 {\cf20 // v            .---+---.}\par
29 {\cf20 // 12 | value = "foo bar"}\par
30 {\cf20 //              ^}\par
31 {\cf20 //              +-- column()}\par
32 {\cf20 //}\par
33 {\cf20 // - std::string const& file_name() const noexcept;}\par
34 {\cf20 //   - name of the file.}\par
35 {\cf20 // - std::string const& line_str() const noexcept;}\par
36 {\cf20 //   - the whole line that contains the region of interest.}\par
37 {\cf20 //}\par
38 {\cf17 struct }source_location\par
39 \{\par
40   {\cf17 public}:\par
41 \par
42     source_location()\par
43         : line_num_(1), column_num_(1), region_size_(1),\par
44           file_name_({\cf22 "unknown file"}), line_str_({\cf22 ""})\par
45     \{\}\par
46 \par
47     {\cf17 explicit} source_location({\cf17 const} detail::region_base* reg)\par
48         : line_num_(1), column_num_(1), region_size_(1),\par
49           file_name_({\cf22 "unknown file"}), line_str_({\cf22 ""})\par
50     \{\par
51         {\cf19 if}(reg)\par
52         \{\par
53             {\cf19 if}(reg->line_num() != detail::region_base().line_num())\par
54             \{\par
55                 line_num_ = {\cf17 static_cast<}std::uint_least32_t{\cf17 >}(\par
56                         std::stoul(reg->line_num()));\par
57             \}\par
58             column_num_  = {\cf17 static_cast<}std::uint_least32_t{\cf17 >}(reg->before() + 1);\par
59             region_size_ = {\cf17 static_cast<}std::uint_least32_t{\cf17 >}(reg->size());\par
60             file_name_   = reg->name();\par
61             line_str_    = reg->line();\par
62         \}\par
63     \}\par
64 \par
65     {\cf17 explicit} source_location({\cf17 const} detail::region& reg)\par
66         : line_num_(static_cast<std::uint_least32_t>(std::stoul(reg.line_num()))),\par
67           column_num_(static_cast<std::uint_least32_t>(reg.before() + 1)),\par
68           region_size_(static_cast<std::uint_least32_t>(reg.size())),\par
69           file_name_(reg.name()),\par
70           line_str_ (reg.line())\par
71     \{\}\par
72     {\cf17 explicit} source_location({\cf17 const} detail::location& loc)\par
73         : line_num_(static_cast<std::uint_least32_t>(std::stoul(loc.line_num()))),\par
74           column_num_(static_cast<std::uint_least32_t>(loc.before() + 1)),\par
75           region_size_(static_cast<std::uint_least32_t>(loc.size())),\par
76           file_name_(loc.name()),\par
77           line_str_ (loc.line())\par
78     \{\}\par
79 \par
80     ~source_location() = {\cf19 default};\par
81     source_location(source_location {\cf17 const}&) = {\cf19 default};\par
82     source_location(source_location &&)     = {\cf19 default};\par
83     source_location& operator=(source_location {\cf17 const}&) = {\cf19 default};\par
84     source_location& operator=(source_location &&)     = {\cf19 default};\par
85 \par
86     std::uint_least32_t line()      const noexcept \{{\cf19 return} line_num_;\}\par
87     std::uint_least32_t column()    const noexcept \{{\cf19 return} column_num_;\}\par
88     std::uint_least32_t region()    const noexcept \{{\cf19 return} region_size_;\}\par
89 \par
90     std::string {\cf17 const}&  file_name() const noexcept \{{\cf19 return} file_name_;\}\par
91     std::string {\cf17 const}&  line_str()  const noexcept \{{\cf19 return} line_str_;\}\par
92 \par
93   {\cf17 private}:\par
94 \par
95     std::uint_least32_t line_num_;\par
96     std::uint_least32_t column_num_;\par
97     std::uint_least32_t region_size_;\par
98     std::string         file_name_;\par
99     std::string         line_str_;\par
100 \};\par
101 \par
102 {\cf17 namespace }detail\par
103 \{\par
104 \par
105 {\cf20 // internal error message generation.}\par
106 {\cf17 inline} std::string format_underline({\cf17 const} std::string& message,\par
107         {\cf17 const} std::vector<std::pair<source_location, std::string>>& loc_com,\par
108         {\cf17 const} std::vector<std::string>& helps = \{\},\par
109         {\cf17 const} {\cf18 bool} colorize = TOML11_ERROR_MESSAGE_COLORIZED)\par
110 \{\par
111     std::size_t line_num_width = 0;\par
112     {\cf19 for}({\cf17 const} {\cf17 auto}& lc : loc_com)\par
113     \{\par
114         std::uint_least32_t line = lc.first.line();\par
115         std::size_t        digit = 0;\par
116         {\cf19 while}(line != 0)\par
117         \{\par
118             line  /= 10;\par
119             digit +=  1;\par
120         \}\par
121         line_num_width = (std::max)(line_num_width, digit);\par
122     \}\par
123     {\cf20 // 1 is the minimum width}\par
124     line_num_width = std::max<std::size_t>(line_num_width, 1);\par
125 \par
126     std::ostringstream retval;\par
127 \par
128     {\cf19 if}(colorize)\par
129     \{\par
130         retval << color::colorize; {\cf20 // turn on ANSI color}\par
131     \}\par
132 \par
133     {\cf20 // XXX}\par
134     {\cf20 // Here, before `colorize` support, it does not output `[error]` prefix}\par
135     {\cf20 // automatically. So some user may output it manually and this change may}\par
136     {\cf20 // duplicate the prefix. To avoid it, check the first 7 characters and}\par
137     {\cf20 // if it is "[error]", it removes that part from the message shown.}\par
138     {\cf19 if}(message.size() > 7 && message.substr(0, 7) == {\cf22 "[error]"})\par
139     \{\par
140         retval << color::bold << color::red << {\cf22 "[error]"} << color::reset\par
141                << color::bold << message.substr(7) << color::reset << {\cf23 '\\n'};\par
142     \}\par
143     {\cf19 else}\par
144     \{\par
145         retval << color::bold << color::red << {\cf22 "[error] "} << color::reset\par
146                << color::bold << message << color::reset << {\cf23 '\\n'};\par
147     \}\par
148 \par
149     {\cf17 const} {\cf17 auto} format_one_location = [line_num_width]\par
150         (std::ostringstream& oss,\par
151          {\cf17 const} source_location& loc, {\cf17 const} std::string& comment) -> {\cf18 void}\par
152         \{\par
153             oss << {\cf23 ' '} << color::bold << color::blue\par
154                 << std::setw({\cf17 static_cast<}{\cf18 int}{\cf17 >}(line_num_width))\par
155                 << std::right << loc.line() << {\cf22 " | "}  << color::reset\par
156                 << loc.line_str() << {\cf23 '\\n'};\par
157 \par
158             oss << make_string(line_num_width + 1, {\cf23 ' '})\par
159                 << color::bold << color::blue << {\cf22 " | "} << color::reset\par
160                 << make_string(loc.column()-1 {\cf20 /*1-origin*/}, {\cf23 ' '});\par
161 \par
162             {\cf19 if}(loc.region() == 1)\par
163             \{\par
164                 {\cf20 // invalid}\par
165                 {\cf20 // ^------}\par
166                 oss << color::bold << color::red << {\cf22 "^---"} << color::reset;\par
167             \}\par
168             {\cf19 else}\par
169             \{\par
170                 {\cf20 // invalid}\par
171                 {\cf20 // ~~~~~~~}\par
172                 {\cf17 const} {\cf17 auto} underline_len = (std::min)(\par
173                     {\cf17 static_cast<}std::size_t{\cf17 >}(loc.region()), loc.line_str().size());\par
174                 oss << color::bold << color::red\par
175                     << make_string(underline_len, {\cf23 '~'}) << color::reset;\par
176             \}\par
177             oss << {\cf23 ' '};\par
178             oss << comment;\par
179             {\cf19 return};\par
180         \};\par
181 \par
182     assert(!loc_com.empty());\par
183 \par
184     {\cf20 // --> example.toml}\par
185     {\cf20 //   |}\par
186     retval << color::bold << color::blue << {\cf22 " --> "} << color::reset\par
187            << loc_com.front().first.file_name() << {\cf23 '\\n'};\par
188     retval << make_string(line_num_width + 1, {\cf23 ' '})\par
189            << color::bold << color::blue << {\cf22 " |\\n"}  << color::reset;\par
190     {\cf20 // 1 | key value}\par
191     {\cf20 //   |    ^--- missing =}\par
192     format_one_location(retval, loc_com.front().first, loc_com.front().second);\par
193 \par
194     {\cf20 // process the rest of the locations}\par
195     {\cf19 for}(std::size_t i=1; i<loc_com.size(); ++i)\par
196     \{\par
197         {\cf17 const} {\cf17 auto}& prev = loc_com.at(i-1);\par
198         {\cf17 const} {\cf17 auto}& curr = loc_com.at(i);\par
199 \par
200         retval << {\cf23 '\\n'};\par
201         {\cf20 // if the filenames are the same, print "..."}\par
202         {\cf19 if}(prev.first.file_name() == curr.first.file_name())\par
203         \{\par
204             retval << color::bold << color::blue << {\cf22 " ...\\n"} << color::reset;\par
205         \}\par
206         {\cf19 else} {\cf20 // if filename differs, print " --> filename.toml" again}\par
207         \{\par
208             retval << color::bold << color::blue << {\cf22 " --> "} << color::reset\par
209                    << curr.first.file_name() << {\cf23 '\\n'};\par
210             retval << make_string(line_num_width + 1, {\cf23 ' '})\par
211                    << color::bold << color::blue << {\cf22 " |\\n"}  << color::reset;\par
212         \}\par
213 \par
214         format_one_location(retval, curr.first, curr.second);\par
215     \}\par
216 \par
217     {\cf19 if}(!helps.empty())\par
218     \{\par
219         retval << {\cf23 '\\n'};\par
220         retval << make_string(line_num_width + 1, {\cf23 ' '});\par
221         retval << color::bold << color::blue << {\cf22 " |"} << color::reset;\par
222         {\cf19 for}({\cf17 const} {\cf17 auto}& help : helps)\par
223         \{\par
224             retval << color::bold << {\cf22 "\\nHint: "} << color::reset;\par
225             retval << help;\par
226         \}\par
227     \}\par
228     {\cf19 return} retval.str();\par
229 \}\par
230 \par
231 \} {\cf20 // detail}\par
232 \} {\cf20 // toml}\par
233 {\cf21 #endif}{\cf20 // TOML11_SOURCE_LOCATION_HPP}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/storage.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/storage.hpp}
{\xe \v external/toml/storage.hpp}
{\bkmkstart AAAAAAAAEE}
{\bkmkend AAAAAAAAEE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "utility.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::storage< T >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::detail}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
storage.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/storage.hpp}
{\xe \v external/toml/storage.hpp}
{\bkmkstart AAAAAAAAAV}
{\bkmkend AAAAAAAAAV}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2017.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_STORAGE_HPP}\par
4 {\cf21 #define TOML11_STORAGE_HPP}\par
5 {\cf21 #include "utility.hpp"}\par
6 \par
7 {\cf17 namespace }toml\par
8 \{\par
9 {\cf17 namespace }detail\par
10 \{\par
11 \par
12 {\cf20 // this contains pointer and deep-copy the content if copied.}\par
13 {\cf20 // to avoid recursive pointer.}\par
14 {\cf17 template}<{\cf17 typename} T>\par
15 {\cf17 struct }storage\par
16 \{\par
17     {\cf17 using }value_type = T;\par
18 \par
19     {\cf17 explicit} storage(value_type {\cf17 const}& v): ptr(toml::make_unique<T>(v)) \{\}\par
20     {\cf17 explicit} storage(value_type&&      v): ptr(toml::make_unique<T>(std::move(v))) \{\}\par
21     ~storage() = {\cf19 default};\par
22     storage({\cf17 const} storage& rhs): ptr(toml::make_unique<T>(*rhs.ptr)) \{\}\par
23     storage& operator=({\cf17 const} storage& rhs)\par
24     \{\par
25         this->ptr = toml::make_unique<T>(*rhs.ptr);\par
26         {\cf19 return} *{\cf17 this};\par
27     \}\par
28     storage(storage&&) = {\cf19 default};\par
29     storage& operator=(storage&&) = {\cf19 default};\par
30 \par
31     {\cf18 bool} is_ok() const noexcept \{{\cf19 return} {\cf17 static_cast<}{\cf18 bool}{\cf17 >}(ptr);\}\par
32 \par
33     value_type&       value() &      {\cf17 noexcept} \{{\cf19 return} *ptr;\}\par
34     value_type {\cf17 const}& value() const& noexcept \{{\cf19 return} *ptr;\}\par
35     value_type&&      value() &&     {\cf17 noexcept} \{{\cf19 return} std::move(*ptr);\}\par
36 \par
37   {\cf17 private}:\par
38     std::unique_ptr<value_type> ptr;\par
39 \};\par
40 \par
41 \} {\cf20 // detail}\par
42 \} {\cf20 // toml}\par
43 {\cf21 #endif}{\cf20 // TOML11_STORAGE_HPP}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/string.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/string.hpp}
{\xe \v external/toml/string.hpp}
{\bkmkstart AAAAAAAAEF}
{\bkmkend AAAAAAAAEF}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "version.hpp"}\par
{\f2 #include <cstdint>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <string>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::string}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b toml::string_t} : std::uint8_t \{ {\b toml::basic} = 0
, {\b toml::literal} = 1
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator==} (const string &lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator!=} (const string &lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<} (const string &lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>} (const string &lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<=} (const string &lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>=} (const string &lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator==} (const string &lhs, const std::string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator!=} (const string &lhs, const std::string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<} (const string &lhs, const std::string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>} (const string &lhs, const std::string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<=} (const string &lhs, const std::string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>=} (const string &lhs, const std::string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator==} (const std::string &lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator!=} (const std::string &lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<} (const std::string &lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>} (const std::string &lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<=} (const std::string &lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>=} (const std::string &lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator==} (const string &lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator!=} (const string &lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<} (const string &lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>} (const string &lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<=} (const string &lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>=} (const string &lhs, const char *rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator==} (const char *lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator!=} (const char *lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<} (const char *lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>} (const char *lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator<=} (const char *lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b toml::operator>=} (const char *lhs, const string &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b toml::operator<<} (std::basic_ostream< charT, traits > &os, const string &s)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
string.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/string.hpp}
{\xe \v external/toml/string.hpp}
{\bkmkstart AAAAAAAAAW}
{\bkmkend AAAAAAAAAW}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2017.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_STRING_HPP}\par
4 {\cf21 #define TOML11_STRING_HPP}\par
5 \par
6 {\cf21 #include "version.hpp"}\par
7 \par
8 {\cf21 #include <cstdint>}\par
9 \par
10 {\cf21 #include <algorithm>}\par
11 {\cf21 #include <string>}\par
12 \par
13 {\cf21 #if TOML11_CPLUSPLUS_STANDARD_VERSION >= 201703L}\par
14 {\cf21 #if __has_include(<string_view>)}\par
15 {\cf21 #define TOML11_USING_STRING_VIEW 1}\par
16 {\cf21 #include <string_view>}\par
17 {\cf21 #endif}\par
18 {\cf21 #endif}\par
19 \par
20 {\cf17 namespace }toml\par
21 \{\par
22 \par
23 {\cf17 enum class} string_t : std::uint8_t\par
24 \{\par
25     basic   = 0,\par
26     literal = 1,\par
27 \};\par
28 \par
29 {\cf17 struct }string\par
30 \{\par
31     string()  = {\cf19 default};\par
32     ~string() = {\cf19 default};\par
33     string({\cf17 const} {\cf18 string}& s) = {\cf19 default};\par
34     string({\cf18 string}&& s)      = {\cf19 default};\par
35     {\cf18 string}& operator=({\cf17 const} {\cf18 string}& s) = {\cf19 default};\par
36     {\cf18 string}& operator=({\cf18 string}&& s)      = {\cf19 default};\par
37 \par
38     string({\cf17 const} std::string& s): kind(string_t::basic), str(s)\{\}\par
39     string({\cf17 const} std::string& s, string_t k):   kind(k), str(s)\{\}\par
40     string({\cf17 const} {\cf18 char}* s):        kind(string_t::basic), str(s)\{\}\par
41     string({\cf17 const} {\cf18 char}* s,        string_t k):   kind(k), str(s)\{\}\par
42 \par
43     string(std::string&& s): kind(string_t::basic), str(std::move(s))\{\}\par
44     string(std::string&& s, string_t k):   kind(k), str(std::move(s))\{\}\par
45 \par
46     {\cf18 string}& operator=({\cf17 const} std::string& s)\par
47     \{kind = string_t::basic; str = s; {\cf19 return} *{\cf17 this};\}\par
48     {\cf18 string}& operator=(std::string&& s)\par
49     \{kind = string_t::basic; str = std::move(s); {\cf19 return} *{\cf17 this};\}\par
50 \par
51     {\cf17 operator} std::string&       () &      {\cf17 noexcept} \{{\cf19 return} str;\}\par
52     {\cf17 operator} std::string {\cf17 const}& () {\cf17 const}& {\cf17 noexcept} \{{\cf19 return} str;\}\par
53     {\cf17 operator} std::string&&      () &&     {\cf17 noexcept} \{{\cf19 return} std::move(str);\}\par
54 \par
55     {\cf18 string}& operator+=({\cf17 const} {\cf18 char}*        rhs) \{str += rhs; {\cf19 return} *{\cf17 this};\}\par
56     {\cf18 string}& operator+=({\cf17 const} {\cf18 char}         rhs) \{str += rhs; {\cf19 return} *{\cf17 this};\}\par
57     {\cf18 string}& operator+=({\cf17 const} std::string& rhs) \{str += rhs; {\cf19 return} *{\cf17 this};\}\par
58     {\cf18 string}& operator+=({\cf17 const} {\cf18 string}&      rhs) \{str += rhs.str; {\cf19 return} *{\cf17 this};\}\par
59 \par
60 {\cf21 #if defined(TOML11_USING_STRING_VIEW) && TOML11_USING_STRING_VIEW>0}\par
61     {\cf17 explicit} string(std::string_view s): kind(string_t::basic), str(s)\{\}\par
62     string(std::string_view s, string_t k): kind(k), str(s)\{\}\par
63 \par
64     {\cf18 string}& operator=(std::string_view s)\par
65     \{kind = string_t::basic; str = s; {\cf19 return} *{\cf17 this};\}\par
66 \par
67     {\cf17 explicit} {\cf17 operator} std::string_view() const noexcept\par
68     \{{\cf19 return} std::string_view(str);\}\par
69 \par
70     {\cf18 string}& operator+=({\cf17 const} std::string_view& rhs) \{str += rhs; {\cf19 return} *{\cf17 this};\}\par
71 {\cf21 #endif}\par
72 \par
73     string_t    kind;\par
74     std::string str;\par
75 \};\par
76 \par
77 {\cf17 inline} {\cf18 bool} operator==({\cf17 const} {\cf18 string}& lhs, {\cf17 const} {\cf18 string}& rhs)\par
78 \{\par
79     {\cf19 return} lhs.kind == rhs.kind && lhs.str == rhs.str;\par
80 \}\par
81 {\cf17 inline} {\cf18 bool} operator!=({\cf17 const} {\cf18 string}& lhs, {\cf17 const} {\cf18 string}& rhs)\par
82 \{\par
83     {\cf19 return} !(lhs == rhs);\par
84 \}\par
85 {\cf17 inline} {\cf18 bool} operator<({\cf17 const} {\cf18 string}& lhs, {\cf17 const} {\cf18 string}& rhs)\par
86 \{\par
87     {\cf19 return} (lhs.kind == rhs.kind) ? (lhs.str < rhs.str) : (lhs.kind < rhs.kind);\par
88 \}\par
89 {\cf17 inline} {\cf18 bool} operator>({\cf17 const} {\cf18 string}& lhs, {\cf17 const} {\cf18 string}& rhs)\par
90 \{\par
91     {\cf19 return} rhs < lhs;\par
92 \}\par
93 {\cf17 inline} {\cf18 bool} operator<=({\cf17 const} {\cf18 string}& lhs, {\cf17 const} {\cf18 string}& rhs)\par
94 \{\par
95     {\cf19 return} !(rhs < lhs);\par
96 \}\par
97 {\cf17 inline} {\cf18 bool} operator>=({\cf17 const} {\cf18 string}& lhs, {\cf17 const} {\cf18 string}& rhs)\par
98 \{\par
99     {\cf19 return} !(lhs < rhs);\par
100 \}\par
101 \par
102 {\cf17 inline} {\cf18 bool}\par
103 operator==({\cf17 const} {\cf18 string}& lhs, {\cf17 const} std::string& rhs) \{{\cf19 return} lhs.str == rhs;\}\par
104 {\cf17 inline} {\cf18 bool}\par
105 operator!=({\cf17 const} {\cf18 string}& lhs, {\cf17 const} std::string& rhs) \{{\cf19 return} lhs.str != rhs;\}\par
106 {\cf17 inline} {\cf18 bool}\par
107 operator< ({\cf17 const} {\cf18 string}& lhs, {\cf17 const} std::string& rhs) \{{\cf19 return} lhs.str <  rhs;\}\par
108 {\cf17 inline} {\cf18 bool}\par
109 operator> ({\cf17 const} {\cf18 string}& lhs, {\cf17 const} std::string& rhs) \{{\cf19 return} lhs.str >  rhs;\}\par
110 {\cf17 inline} {\cf18 bool}\par
111 operator<=({\cf17 const} {\cf18 string}& lhs, {\cf17 const} std::string& rhs) \{{\cf19 return} lhs.str <= rhs;\}\par
112 {\cf17 inline} {\cf18 bool}\par
113 operator>=({\cf17 const} {\cf18 string}& lhs, {\cf17 const} std::string& rhs) \{{\cf19 return} lhs.str >= rhs;\}\par
114 \par
115 {\cf17 inline} {\cf18 bool}\par
116 operator==({\cf17 const} std::string& lhs, {\cf17 const} {\cf18 string}& rhs) \{{\cf19 return} lhs == rhs.str;\}\par
117 {\cf17 inline} {\cf18 bool}\par
118 operator!=({\cf17 const} std::string& lhs, {\cf17 const} {\cf18 string}& rhs) \{{\cf19 return} lhs != rhs.str;\}\par
119 {\cf17 inline} {\cf18 bool}\par
120 operator< ({\cf17 const} std::string& lhs, {\cf17 const} {\cf18 string}& rhs) \{{\cf19 return} lhs <  rhs.str;\}\par
121 {\cf17 inline} {\cf18 bool}\par
122 operator> ({\cf17 const} std::string& lhs, {\cf17 const} {\cf18 string}& rhs) \{{\cf19 return} lhs >  rhs.str;\}\par
123 {\cf17 inline} {\cf18 bool}\par
124 operator<=({\cf17 const} std::string& lhs, {\cf17 const} {\cf18 string}& rhs) \{{\cf19 return} lhs <= rhs.str;\}\par
125 {\cf17 inline} {\cf18 bool}\par
126 operator>=({\cf17 const} std::string& lhs, {\cf17 const} {\cf18 string}& rhs) \{{\cf19 return} lhs >= rhs.str;\}\par
127 \par
128 {\cf17 inline} {\cf18 bool}\par
129 operator==({\cf17 const} {\cf18 string}& lhs, {\cf17 const} {\cf18 char}* rhs) \{{\cf19 return} lhs.str == std::string(rhs);\}\par
130 {\cf17 inline} {\cf18 bool}\par
131 operator!=({\cf17 const} {\cf18 string}& lhs, {\cf17 const} {\cf18 char}* rhs) \{{\cf19 return} lhs.str != std::string(rhs);\}\par
132 {\cf17 inline} {\cf18 bool}\par
133 operator< ({\cf17 const} {\cf18 string}& lhs, {\cf17 const} {\cf18 char}* rhs) \{{\cf19 return} lhs.str <  std::string(rhs);\}\par
134 {\cf17 inline} {\cf18 bool}\par
135 operator> ({\cf17 const} {\cf18 string}& lhs, {\cf17 const} {\cf18 char}* rhs) \{{\cf19 return} lhs.str >  std::string(rhs);\}\par
136 {\cf17 inline} {\cf18 bool}\par
137 operator<=({\cf17 const} {\cf18 string}& lhs, {\cf17 const} {\cf18 char}* rhs) \{{\cf19 return} lhs.str <= std::string(rhs);\}\par
138 {\cf17 inline} {\cf18 bool}\par
139 operator>=({\cf17 const} {\cf18 string}& lhs, {\cf17 const} {\cf18 char}* rhs) \{{\cf19 return} lhs.str >= std::string(rhs);\}\par
140 \par
141 {\cf17 inline} {\cf18 bool}\par
142 operator==({\cf17 const} {\cf18 char}* lhs, {\cf17 const} {\cf18 string}& rhs) \{{\cf19 return} std::string(lhs) == rhs.str;\}\par
143 {\cf17 inline} {\cf18 bool}\par
144 operator!=({\cf17 const} {\cf18 char}* lhs, {\cf17 const} {\cf18 string}& rhs) \{{\cf19 return} std::string(lhs) != rhs.str;\}\par
145 {\cf17 inline} {\cf18 bool}\par
146 operator< ({\cf17 const} {\cf18 char}* lhs, {\cf17 const} {\cf18 string}& rhs) \{{\cf19 return} std::string(lhs) <  rhs.str;\}\par
147 {\cf17 inline} {\cf18 bool}\par
148 operator> ({\cf17 const} {\cf18 char}* lhs, {\cf17 const} {\cf18 string}& rhs) \{{\cf19 return} std::string(lhs) >  rhs.str;\}\par
149 {\cf17 inline} {\cf18 bool}\par
150 operator<=({\cf17 const} {\cf18 char}* lhs, {\cf17 const} {\cf18 string}& rhs) \{{\cf19 return} std::string(lhs) <= rhs.str;\}\par
151 {\cf17 inline} {\cf18 bool}\par
152 operator>=({\cf17 const} {\cf18 char}* lhs, {\cf17 const} {\cf18 string}& rhs) \{{\cf19 return} std::string(lhs) >= rhs.str;\}\par
153 \par
154 {\cf17 template}<{\cf17 typename} {\cf18 char}T, {\cf17 typename} traits>\par
155 std::basic_ostream<charT, traits>&\par
156 operator<<(std::basic_ostream<charT, traits>& os, {\cf17 const} {\cf18 string}& s)\par
157 \{\par
158     {\cf19 if}(s.kind == string_t::basic)\par
159     \{\par
160         {\cf19 if}(std::find(s.str.cbegin(), s.str.cend(), {\cf23 '\\n'}) != s.str.cend())\par
161         \{\par
162             {\cf20 // it contains newline. make it multiline string.}\par
163             os << {\cf22 "\\"\\"\\"\\n"};\par
164             {\cf19 for}({\cf17 auto} i=s.str.cbegin(), e=s.str.cend(); i!=e; ++i)\par
165             \{\par
166                 {\cf19 switch}(*i)\par
167                 \{\par
168                     {\cf19 case} {\cf23 '\\\\'}: \{os << {\cf22 "\\\\\\\\"}; {\cf19 break};\}\par
169                     {\cf19 case} {\cf23 '\\"'}: \{os << {\cf22 "\\\\\\""}; {\cf19 break};\}\par
170                     {\cf19 case} {\cf23 '\\b'}: \{os << {\cf22 "\\\\b"};  {\cf19 break};\}\par
171                     {\cf19 case} {\cf23 '\\t'}: \{os << {\cf22 "\\\\t"};  {\cf19 break};\}\par
172                     {\cf19 case} {\cf23 '\\f'}: \{os << {\cf22 "\\\\f"};  {\cf19 break};\}\par
173                     {\cf19 case} {\cf23 '\\n'}: \{os << {\cf23 '\\n'};   {\cf19 break};\}\par
174                     {\cf19 case} {\cf23 '\\r'}:\par
175                     \{\par
176                         {\cf20 // since it is a multiline string,}\par
177                         {\cf20 // CRLF is not needed to be escaped.}\par
178                         {\cf19 if}(std::next(i) != e && *std::next(i) == {\cf23 '\\n'})\par
179                         \{\par
180                             os << {\cf22 "\\r\\n"};\par
181                             ++i;\par
182                         \}\par
183                         {\cf19 else}\par
184                         \{\par
185                             os << {\cf22 "\\\\r"};\par
186                         \}\par
187                         {\cf19 break};\par
188                     \}\par
189                     {\cf19 default}: \{os << *i; {\cf19 break};\}\par
190                 \}\par
191             \}\par
192             os << {\cf22 "\\\\\\n\\"\\"\\""};\par
193             {\cf19 return} os;\par
194         \}\par
195         {\cf20 // no newline. make it inline.}\par
196         os << {\cf22 "\\""};\par
197         {\cf19 for}({\cf17 const} {\cf17 auto} c : s.str)\par
198         \{\par
199             {\cf19 switch}(c)\par
200             \{\par
201                 {\cf19 case} {\cf23 '\\\\'}: \{os << {\cf22 "\\\\\\\\"}; {\cf19 break};\}\par
202                 {\cf19 case} {\cf23 '\\"'}: \{os << {\cf22 "\\\\\\""}; {\cf19 break};\}\par
203                 {\cf19 case} {\cf23 '\\b'}: \{os << {\cf22 "\\\\b"};  {\cf19 break};\}\par
204                 {\cf19 case} {\cf23 '\\t'}: \{os << {\cf22 "\\\\t"};  {\cf19 break};\}\par
205                 {\cf19 case} {\cf23 '\\f'}: \{os << {\cf22 "\\\\f"};  {\cf19 break};\}\par
206                 {\cf19 case} {\cf23 '\\n'}: \{os << {\cf22 "\\\\n"};  {\cf19 break};\}\par
207                 {\cf19 case} {\cf23 '\\r'}: \{os << {\cf22 "\\\\r"};  {\cf19 break};\}\par
208                 default  : \{os << c;      {\cf19 break};\}\par
209             \}\par
210         \}\par
211         os << {\cf22 "\\""};\par
212         {\cf19 return} os;\par
213     \}\par
214     {\cf20 // the string `s` is literal-string.}\par
215     {\cf19 if}(std::find(s.str.cbegin(), s.str.cend(), {\cf23 '\\n'}) != s.str.cend() ||\par
216        std::find(s.str.cbegin(), s.str.cend(), {\cf23 '\\''}) != s.str.cend() )\par
217     \{\par
218         {\cf20 // contains newline or single quote. make it multiline.}\par
219         os << {\cf22 "'''\\n"} << s.str << {\cf22 "'''"};\par
220         {\cf19 return} os;\par
221     \}\par
222     {\cf20 // normal literal string}\par
223     os << {\cf23 '\\''} << s.str << {\cf23 '\\''};\par
224     {\cf19 return} os;\par
225 \}\par
226 \par
227 \} {\cf20 // toml}\par
228 {\cf21 #endif}{\cf20 // TOML11_STRING_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/traits.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/traits.hpp}
{\xe \v external/toml/traits.hpp}
{\bkmkstart AAAAAAAAEG}
{\bkmkend AAAAAAAAEG}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "from.hpp"}\par
{\f2 #include "into.hpp"}\par
{\f2 #include "version.hpp"}\par
{\f2 #include <chrono>}\par
{\f2 #include <forward_list>}\par
{\f2 #include <string>}\par
{\f2 #include <tuple>}\par
{\f2 #include <type_traits>}\par
{\f2 #include <utility>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_iterator_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_value_type_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_key_type_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_mapped_type_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_reserve_method_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_push_back_method_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_comparable_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_from_toml_method_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_into_toml_method_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_specialized_from_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_specialized_into_impl}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_iterator< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_value_type< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_key_type< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_mapped_type< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_reserve_method< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_push_back_method< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_comparable< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_from_toml_method< T, C, Tb, A >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_into_toml_method< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_specialized_from< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::has_specialized_into< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::conjunction<... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::conjunction< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::conjunction< T, Ts... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::disjunction<... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::disjunction< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::disjunction< T, Ts... >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::negation< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_std_pair< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_std_pair< std::pair< T1, T2 > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_std_tuple< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_std_tuple< std::tuple< Ts... > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_std_forward_list< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_std_forward_list< std::forward_list< T > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_chrono_duration< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_chrono_duration< std::chrono::duration< Rep, Period > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_map< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_map< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_map< T const & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_map< T volatile & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_map< T const volatile & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_container< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_container< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_container< T const & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_container< T volatile & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_container< T const volatile & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_basic_value< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_basic_value< T & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_basic_value< T const & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_basic_value< T volatile & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_basic_value< T const volatile & >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_basic_value<::toml::basic_value< C, M, V > >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::index_sequence< Ns >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::push_back_index_sequence< IS, N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::push_back_index_sequence< index_sequence< Ns... >, N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::index_sequence_maker< N >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::index_sequence_maker< 0 >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_string_literal< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::remove_cvref< T >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<std::size_t N> using {\b toml::detail::make_index_sequence} = typename index_sequence_maker< N-1 >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<bool B, typename T > using {\b toml::detail::enable_if_t} = typename std::enable_if< B, T >::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename F , typename ... Args> using {\b toml::detail::return_type_of_t} = typename std::result_of< F(Args...)>::type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > using {\b toml::detail::remove_cvref_t} = typename remove_cvref< T >::type\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
traits.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/traits.hpp}
{\xe \v external/toml/traits.hpp}
{\bkmkstart AAAAAAAAAX}
{\bkmkend AAAAAAAAAX}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2017.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_TRAITS_HPP}\par
4 {\cf21 #define TOML11_TRAITS_HPP}\par
5 \par
6 {\cf21 #include "from.hpp"}\par
7 {\cf21 #include "into.hpp"}\par
8 {\cf21 #include "version.hpp"}\par
9 \par
10 {\cf21 #include <chrono>}\par
11 {\cf21 #include <forward_list>}\par
12 {\cf21 #include <string>}\par
13 {\cf21 #include <tuple>}\par
14 {\cf21 #include <type_traits>}\par
15 {\cf21 #include <utility>}\par
16 \par
17 {\cf21 #if TOML11_CPLUSPLUS_STANDARD_VERSION >= 201703L}\par
18 {\cf21 #if __has_include(<string_view>)}\par
19 {\cf21 #include <string_view>}\par
20 {\cf21 #endif }{\cf20 // has_include(<string_view>)}\par
21 {\cf21 #endif }{\cf20 // cplusplus   >= C++17}\par
22 \par
23 {\cf17 namespace }toml\par
24 \{\par
25 {\cf17 template}<{\cf17 typename} C, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
26 {\cf17 class }basic_value;\par
27 \par
28 {\cf17 namespace }detail\par
29 \{\par
30 {\cf20 // ---------------------------------------------------------------------------}\par
31 {\cf20 // check whether type T is a kind of container/map class}\par
32 \par
33 {\cf17 struct }has_iterator_impl\par
34 \{\par
35     {\cf17 template}<{\cf17 typename} T> {\cf17 static} std::true_type  check({\cf17 typename} T::iterator*);\par
36     {\cf17 template}<{\cf17 typename} T> {\cf17 static} std::false_type check(...);\par
37 \};\par
38 {\cf17 struct }has_value_type_impl\par
39 \{\par
40     {\cf17 template}<{\cf17 typename} T> {\cf17 static} std::true_type  check({\cf17 typename} T::value_type*);\par
41     {\cf17 template}<{\cf17 typename} T> {\cf17 static} std::false_type check(...);\par
42 \};\par
43 {\cf17 struct }has_key_type_impl\par
44 \{\par
45     {\cf17 template}<{\cf17 typename} T> {\cf17 static} std::true_type  check({\cf17 typename} T::key_type*);\par
46     {\cf17 template}<{\cf17 typename} T> {\cf17 static} std::false_type check(...);\par
47 \};\par
48 {\cf17 struct }has_mapped_type_impl\par
49 \{\par
50     {\cf17 template}<{\cf17 typename} T> {\cf17 static} std::true_type  check({\cf17 typename} T::mapped_type*);\par
51     {\cf17 template}<{\cf17 typename} T> {\cf17 static} std::false_type check(...);\par
52 \};\par
53 {\cf17 struct }has_reserve_method_impl\par
54 \{\par
55     {\cf17 template}<{\cf17 typename} T> {\cf17 static} std::false_type check(...);\par
56     {\cf17 template}<{\cf17 typename} T> {\cf17 static} std::true_type  check(\par
57         {\cf17 decltype}(std::declval<T>().reserve(std::declval<std::size_t>()))*);\par
58 \};\par
59 {\cf17 struct }has_push_back_method_impl\par
60 \{\par
61     {\cf17 template}<{\cf17 typename} T> {\cf17 static} std::false_type check(...);\par
62     {\cf17 template}<{\cf17 typename} T> {\cf17 static} std::true_type  check(\par
63         {\cf17 decltype}(std::declval<T>().push_back(std::declval<typename T::value_type>()))*);\par
64 \};\par
65 {\cf17 struct }is_comparable_impl\par
66 \{\par
67     {\cf17 template}<{\cf17 typename} T> {\cf17 static} std::false_type check(...);\par
68     {\cf17 template}<{\cf17 typename} T> {\cf17 static} std::true_type  check(\par
69         {\cf17 decltype}(std::declval<T>() < std::declval<T>())*);\par
70 \};\par
71 \par
72 {\cf17 struct }has_from_toml_method_impl\par
73 \{\par
74     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
75              {\cf17 template}<{\cf17 typename} ...> {\cf17 class }Tb, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
76     {\cf17 static} std::true_type  check(\par
77         {\cf17 decltype}(std::declval<T>().from_toml(\par
78                 std::declval<::toml::basic_value<C, Tb, A>>()))*);\par
79 \par
80     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
81              {\cf17 template}<{\cf17 typename} ...> {\cf17 class }Tb, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
82     {\cf17 static} std::false_type check(...);\par
83 \};\par
84 {\cf17 struct }has_into_toml_method_impl\par
85 \{\par
86     {\cf17 template}<{\cf17 typename} T>\par
87     {\cf17 static} std::true_type  check({\cf17 decltype}(std::declval<T>().into_toml())*);\par
88     {\cf17 template}<{\cf17 typename} T>\par
89     {\cf17 static} std::false_type check(...);\par
90 \};\par
91 \par
92 {\cf17 struct }has_specialized_from_impl\par
93 \{\par
94     {\cf17 template}<{\cf17 typename} T>\par
95     {\cf17 static} std::false_type check(...);\par
96     {\cf17 template}<{\cf17 typename} T, std::{\cf18 size_t} S = sizeof(::toml::from<T>)>\par
97     {\cf17 static} std::true_type check(::toml::from<T>*);\par
98 \};\par
99 {\cf17 struct }has_specialized_into_impl\par
100 \{\par
101     {\cf17 template}<{\cf17 typename} T>\par
102     {\cf17 static} std::false_type check(...);\par
103     {\cf17 template}<{\cf17 typename} T, std::{\cf18 size_t} S = sizeof(::toml::{\cf18 int}o<T>)>\par
104     {\cf17 static} std::true_type check(::toml::from<T>*);\par
105 \};\par
106 \par
107 \par
110 {\cf21 #ifdef __INTEL_COMPILER}\par
111 {\cf21 #define decltype(...) std::enable_if<true, decltype(__VA_ARGS__)>::type}\par
112 {\cf21 #endif}\par
113 \par
114 {\cf17 template}<{\cf17 typename} T>\par
115 {\cf17 struct }has_iterator    : decltype(has_iterator_impl::check<T>(nullptr))\{\};\par
116 {\cf17 template}<{\cf17 typename} T>\par
117 {\cf17 struct }has_value_type  : decltype(has_value_type_impl::check<T>(nullptr))\{\};\par
118 {\cf17 template}<{\cf17 typename} T>\par
119 {\cf17 struct }has_key_type    : decltype(has_key_type_impl::check<T>(nullptr))\{\};\par
120 {\cf17 template}<{\cf17 typename} T>\par
121 {\cf17 struct }has_mapped_type : decltype(has_mapped_type_impl::check<T>(nullptr))\{\};\par
122 {\cf17 template}<{\cf17 typename} T>\par
123 {\cf17 struct }has_reserve_method : decltype(has_reserve_method_impl::check<T>(nullptr))\{\};\par
124 {\cf17 template}<{\cf17 typename} T>\par
125 {\cf17 struct }has_push_back_method : decltype(has_push_back_method_impl::check<T>(nullptr))\{\};\par
126 {\cf17 template}<{\cf17 typename} T>\par
127 {\cf17 struct }is_comparable : decltype(is_comparable_impl::check<T>(nullptr))\{\};\par
128 \par
129 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} C,\par
130          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }Tb, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
131 {\cf17 struct }has_from_toml_method\par
132 : decltype(has_from_toml_method_impl::check<T, C, Tb, A>(nullptr))\{\};\par
133 \par
134 {\cf17 template}<{\cf17 typename} T>\par
135 {\cf17 struct }has_into_toml_method\par
136 : decltype(has_into_toml_method_impl::check<T>(nullptr))\{\};\par
137 \par
138 {\cf17 template}<{\cf17 typename} T>\par
139 {\cf17 struct }has_specialized_from : decltype(has_specialized_from_impl::check<T>(nullptr))\{\};\par
140 {\cf17 template}<{\cf17 typename} T>\par
141 {\cf17 struct }has_specialized_into : decltype(has_specialized_into_impl::check<T>(nullptr))\{\};\par
142 \par
143 {\cf21 #ifdef __INTEL_COMPILER}\par
144 {\cf21 #undef decltype}\par
145 {\cf21 #endif}\par
146 \par
147 {\cf20 // ---------------------------------------------------------------------------}\par
148 {\cf20 // C++17 and/or/not}\par
149 \par
150 {\cf21 #if TOML11_CPLUSPLUS_STANDARD_VERSION >= 201703L}\par
151 \par
152 {\cf17 using }std::conjunction;\par
153 {\cf17 using }std::disjunction;\par
154 {\cf17 using }std::negation;\par
155 \par
156 {\cf21 #else}\par
157 \par
158 {\cf17 template}<{\cf17 typename} ...> {\cf17 struct }conjunction : std::true_type\{\};\par
159 {\cf17 template}<{\cf17 typename} T>   {\cf17 struct }conjunction<T> : T\{\};\par
160 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} ... Ts>\par
161 {\cf17 struct }conjunction<T, Ts...> :\par
162     std::conditional<static_cast<bool>(T::value), conjunction<Ts...>, T>::type\par
163 \{\};\par
164 \par
165 {\cf17 template}<{\cf17 typename} ...> {\cf17 struct }disjunction : std::false_type\{\};\par
166 {\cf17 template}<{\cf17 typename} T>   {\cf17 struct }disjunction<T> : T \{\};\par
167 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} ... Ts>\par
168 {\cf17 struct }disjunction<T, Ts...> :\par
169     std::conditional<static_cast<bool>(T::value), T, disjunction<Ts...>>::type\par
170 \{\};\par
171 \par
172 {\cf17 template}<{\cf17 typename} T>\par
173 {\cf17 struct }negation : std::integral_constant<bool, !static_cast<bool>(T::value)>\{\};\par
174 \par
175 {\cf21 #endif}\par
176 \par
177 {\cf20 // ---------------------------------------------------------------------------}\par
178 {\cf20 // type checkers}\par
179 \par
180 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_std_pair : std::false_type\{\};\par
181 {\cf17 template}<{\cf17 typename} T1, {\cf17 typename} T2>\par
182 {\cf17 struct }is_std_pair<std::pair<T1, T2>> : std::true_type\{\};\par
183 \par
184 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_std_tuple : std::false_type\{\};\par
185 {\cf17 template}<{\cf17 typename} ... Ts>\par
186 {\cf17 struct }is_std_tuple<std::tuple<Ts...>> : std::true_type\{\};\par
187 \par
188 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_std_forward_list : std::false_type\{\};\par
189 {\cf17 template}<{\cf17 typename} T>\par
190 {\cf17 struct }is_std_forward_list<std::forward_list<T>> : std::true_type\{\};\par
191 \par
192 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_chrono_duration: std::false_type\{\};\par
193 {\cf17 template}<{\cf17 typename} Rep, {\cf17 typename} Period>\par
194 {\cf17 struct }is_chrono_duration<std::chrono::duration<Rep, Period>>: std::true_type\{\};\par
195 \par
196 {\cf17 template}<{\cf17 typename} T>\par
197 {\cf17 struct }is_map : conjunction< {\cf20 // map satisfies all the following conditions}\par
198     has_iterator<T>,         {\cf20 // has T::iterator}\par
199     has_value_type<T>,       {\cf20 // has T::value_type}\par
200     has_key_type<T>,         {\cf20 // has T::key_type}\par
201     has_mapped_type<T>       {\cf20 // has T::mapped_type}\par
202     >\{\};\par
203 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_map<T&>                : is_map<T>\{\};\par
204 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_map<T const&>          : is_map<T>\{\};\par
205 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_map<T volatile&>       : is_map<T>\{\};\par
206 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_map<T const volatile&> : is_map<T>\{\};\par
207 \par
208 {\cf17 template}<{\cf17 typename} T>\par
209 {\cf17 struct }is_container : conjunction<\par
210     negation<is_map<T>>,                         {\cf20 // not a map}\par
211     negation<std::is_same<T, std::string>>,      {\cf20 // not a std::string}\par
212 #if TOML11_CPLUSPLUS_STANDARD_VERSION >= 201703L\par
213 {\cf21 #if __has_include(<string_view>)}\par
214     negation<std::is_same<T, std::string_view>>, {\cf20 // not a std::string_view}\par
215 {\cf21 #endif }{\cf20 // has_include(<string_view>)}\par
216 {\cf21 #endif}\par
217     has_iterator<T>,                             {\cf20 // has T::iterator}\par
218     has_value_type<T>                            {\cf20 // has T::value_type}\par
219     >\{\};\par
220 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_container<T&>                : is_container<T>\{\};\par
221 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_container<T const&>          : is_container<T>\{\};\par
222 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_container<T volatile&>       : is_container<T>\{\};\par
223 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_container<T const volatile&> : is_container<T>\{\};\par
224 \par
225 {\cf17 template}<{\cf17 typename} T>\par
226 {\cf17 struct }is_basic_value: std::false_type\{\};\par
227 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_basic_value<T&>                : is_basic_value<T>\{\};\par
228 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_basic_value<T const&>          : is_basic_value<T>\{\};\par
229 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_basic_value<T volatile&>       : is_basic_value<T>\{\};\par
230 {\cf17 template}<{\cf17 typename} T> {\cf17 struct }is_basic_value<T const volatile&> : is_basic_value<T>\{\};\par
231 {\cf17 template}<{\cf17 typename} C, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }M, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }V>\par
232 {\cf17 struct }is_basic_value<::toml::basic_value<C, M, V>>: std::true_type\{\};\par
233 \par
234 {\cf20 // ---------------------------------------------------------------------------}\par
235 {\cf20 // C++14 index_sequence}\par
236 \par
237 {\cf21 #if TOML11_CPLUSPLUS_STANDARD_VERSION >= 201402L}\par
238 \par
239 {\cf17 using }std::index_sequence;\par
240 {\cf17 using }std::make_index_sequence;\par
241 \par
242 {\cf21 #else}\par
243 \par
244 {\cf17 template}<std::size_t ... Ns> {\cf17 struct }index_sequence\{\};\par
245 \par
246 {\cf17 template}<{\cf17 typename} IS, std::{\cf18 size_t} N> {\cf17 struct }push_back_index_sequence\{\};\par
247 {\cf17 template}<std::size_t N, std::size_t ... Ns>\par
248 {\cf17 struct }push_back_index_sequence<index_sequence<Ns...>, N>\par
249 \{\par
250     {\cf17 typedef} index_sequence<Ns..., N> type;\par
251 \};\par
252 \par
253 {\cf17 template}<std::{\cf18 size_t} N>\par
254 {\cf17 struct }index_sequence_maker\par
255 \{\par
256     {\cf17 typedef} {\cf17 typename} push_back_index_sequence<\par
257         {\cf17 typename} index_sequence_maker<N-1>::type, N>::type type;\par
258 \};\par
259 {\cf17 template}<>\par
260 {\cf17 struct }index_sequence_maker<0>\par
261 \{\par
262     {\cf17 typedef} index_sequence<0> type;\par
263 \};\par
264 {\cf17 template}<std::{\cf18 size_t} N>\par
265 {\cf17 using }make_index_sequence = {\cf17 typename} index_sequence_maker<N-1>::type;\par
266 \par
267 {\cf21 #endif }{\cf20 // cplusplus >= 2014}\par
268 \par
269 {\cf20 // ---------------------------------------------------------------------------}\par
270 {\cf20 // C++14 enable_if_t}\par
271 \par
272 {\cf21 #if TOML11_CPLUSPLUS_STANDARD_VERSION >= 201402L}\par
273 \par
274 {\cf17 using }std::enable_if_t;\par
275 \par
276 {\cf21 #else}\par
277 \par
278 {\cf17 template}<{\cf18 bool} B, {\cf17 typename} T>\par
279 {\cf17 using }enable_if_t = {\cf17 typename} std::enable_if<B, T>::type;\par
280 \par
281 {\cf21 #endif }{\cf20 // cplusplus >= 2014}\par
282 \par
283 {\cf20 // ---------------------------------------------------------------------------}\par
284 {\cf20 // return_type_of_t}\par
285 \par
286 {\cf21 #if TOML11_CPLUSPLUS_STANDARD_VERSION >= 201703L && defined(__cpp_lib_is_invocable) && __cpp_lib_is_invocable>=201703}\par
287 \par
288 {\cf17 template}<{\cf17 typename} F, {\cf17 typename} ... Args>\par
289 {\cf17 using }return_type_of_t = std::invoke_result_t<F, Args...>;\par
290 \par
291 {\cf21 #else}\par
292 {\cf20 // result_of is deprecated after C++17}\par
293 {\cf17 template}<{\cf17 typename} F, {\cf17 typename} ... Args>\par
294 {\cf17 using }return_type_of_t = {\cf17 typename} std::result_of<F(Args...)>::type;\par
295 \par
296 {\cf21 #endif}\par
297 \par
298 {\cf20 // ---------------------------------------------------------------------------}\par
299 {\cf20 // is_string_literal}\par
300 {\cf20 //}\par
301 {\cf20 // to use this, pass `typename remove_reference<T>::type` to T.}\par
302 \par
303 {\cf17 template}<{\cf17 typename} T>\par
304 {\cf17 struct }is_string_literal:\par
305 disjunction<\par
306     std::is_same<const char*, T>,\par
307     conjunction<\par
308         std::is_array<T>,\par
309         std::is_same<const char, typename std::remove_extent<T>::type>\par
310         >\par
311     >\{\};\par
312 \par
313 {\cf20 // ---------------------------------------------------------------------------}\par
314 {\cf20 // C++20 remove_cvref_t}\par
315 \par
316 {\cf17 template}<{\cf17 typename} T>\par
317 {\cf17 struct }remove_cvref\par
318 \{\par
319     {\cf17 using }type = {\cf17 typename} std::remove_cv<\par
320         {\cf17 typename} std::remove_reference<T>::type>::type;\par
321 \};\par
322 \par
323 {\cf17 template}<{\cf17 typename} T>\par
324 {\cf17 using }remove_cvref_t = {\cf17 typename} remove_cvref<T>::type;\par
325 \par
326 \}{\cf20 // detail}\par
327 \}{\cf20 //toml}\par
328 {\cf21 #endif }{\cf20 // TOML_TRAITS}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/types.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/types.hpp}
{\xe \v external/toml/types.hpp}
{\bkmkstart AAAAAAAAEH}
{\bkmkend AAAAAAAAEH}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <unordered_map>}\par
{\f2 #include <vector>}\par
{\f2 #include "comments.hpp"}\par
{\f2 #include "datetime.hpp"}\par
{\f2 #include "string.hpp"}\par
{\f2 #include "traits.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::enum_to_type< t, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::enum_to_type< value_t::empty, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::enum_to_type< value_t::boolean, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::enum_to_type< value_t::integer, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::enum_to_type< value_t::floating, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::enum_to_type< value_t::string, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::enum_to_type< value_t::offset_datetime, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::enum_to_type< value_t::local_datetime, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::enum_to_type< value_t::local_date, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::enum_to_type< value_t::local_time, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::enum_to_type< value_t::array, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::enum_to_type< value_t::table, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::type_to_enum< T, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::type_to_enum< boolean, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::type_to_enum< integer, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::type_to_enum< floating, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::type_to_enum< string, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::type_to_enum< offset_datetime, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::type_to_enum< local_datetime, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::type_to_enum< local_date, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::type_to_enum< local_time, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_exact_toml_type< T, Value >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_exact_toml_type< T &, V >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_exact_toml_type< T const &, V >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_exact_toml_type< T volatile &, V >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::is_exact_toml_type< T const volatile &, V >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::character} = char\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::key} = std::string\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::boolean} = bool\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::integer} = std::int64_t\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::floating} = double\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<value_t V> using {\b toml::detail::value_t_constant} = std::integral_constant< value_t, V >\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum class {\b toml::value_t} : std::uint8_t \{ {\b toml::empty} = 0
, {\b toml::boolean} = 1
, {\b toml::integer} = 2
, {\b toml::floating} = 3
, {\b toml::string} = 4
, {\b toml::offset_datetime} = 5
, {\b toml::local_datetime} = 6
, {\b toml::local_date} = 7
, {\b toml::local_time} = 8
, {\b toml::array} = 9
, {\b toml::table} = 10
 \}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT , typename traits > std::basic_ostream< charT, traits > & {\b toml::operator<<} (std::basic_ostream< charT, traits > &os, value_t t)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename charT  = char, typename traits  = std::char_traits<charT>, typename alloc  = std::allocator<charT>> std::basic_string< charT, traits, alloc > {\b toml::stringize} (value_t t)\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
types.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/types.hpp}
{\xe \v external/toml/types.hpp}
{\bkmkstart AAAAAAAAAY}
{\bkmkend AAAAAAAAAY}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2017.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_TYPES_HPP}\par
4 {\cf21 #define TOML11_TYPES_HPP}\par
5 {\cf21 #include <unordered_map>}\par
6 {\cf21 #include <vector>}\par
7 \par
8 {\cf21 #include "comments.hpp"}\par
9 {\cf21 #include "datetime.hpp"}\par
10 {\cf21 #include "string.hpp"}\par
11 {\cf21 #include "traits.hpp"}\par
12 \par
13 {\cf17 namespace }toml\par
14 \{\par
15 \par
16 {\cf17 template}<{\cf17 typename} Comment, {\cf20 // discard/preserve_comment}\par
17          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }Table, {\cf20 // map-like class}\par
18          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }Array> {\cf20 // vector-like class}\par
19 {\cf17 class }basic_value;\par
20 \par
21 {\cf17 using }character = char;\par
22 {\cf17 using }key = std::string;\par
23 \par
24 {\cf21 #if !defined(__clang__) && defined(__GNUC__) && __GNUC__ <= 4}\par
25 {\cf21 #  pragma GCC diagnostic push}\par
26 {\cf21 #  pragma GCC diagnostic ignored "-Wshadow"}\par
27 {\cf21 #endif}\par
28 \par
29 {\cf17 using }boolean        = bool;\par
30 {\cf17 using }integer        = std::int64_t;\par
31 {\cf17 using }floating       = double; {\cf20 // "float" is a keyword, cannot use it here.}\par
32 {\cf20 // the following stuffs are structs defined here, so aliases are not needed.}\par
33 {\cf20 // - string}\par
34 {\cf20 // - offset_datetime}\par
35 {\cf20 // - offset_datetime}\par
36 {\cf20 // - local_datetime}\par
37 {\cf20 // - local_date}\par
38 {\cf20 // - local_time}\par
39 \par
40 {\cf21 #if defined(__GNUC__) && !defined(__clang__)}\par
41 {\cf21 #  pragma GCC diagnostic pop}\par
42 {\cf21 #endif}\par
43 \par
44 {\cf20 // default toml::value and default array/table. these are defined after defining}\par
45 {\cf20 // basic_value itself.}\par
46 {\cf20 // using value = basic_value<discard_comments, std::unordered_map, std::vector>;}\par
47 {\cf20 // using array = typename value::array_type;}\par
48 {\cf20 // using table = typename value::table_type;}\par
49 \par
50 {\cf20 // to avoid warnings about `value_t::integer` is "shadowing" toml::integer in}\par
51 {\cf20 // GCC -Wshadow=global.}\par
52 {\cf21 #if defined(__GNUC__) && !defined(__clang__)}\par
53 {\cf21 #  pragma GCC diagnostic push}\par
54 {\cf21 #  if 7 <= __GNUC__}\par
55 {\cf21 #    pragma GCC diagnostic ignored "-Wshadow=global"}\par
56 {\cf21 #  else }{\cf20 // gcc-6 or older}\par
57 {\cf21 #    pragma GCC diagnostic ignored "-Wshadow"}\par
58 {\cf21 #  endif}\par
59 {\cf21 #endif}\par
60 {\cf17 enum class} value_t : std::uint8_t\par
61 \{\par
62     empty           =  0,\par
63     {\cf18 boolean}         =  1,\par
64     integer         =  2,\par
65     floating        =  3,\par
66     {\cf18 string}          =  4,\par
67     offset_datetime =  5,\par
68     local_datetime  =  6,\par
69     local_date      =  7,\par
70     local_time      =  8,\par
71     array           =  9,\par
72     table           = 10,\par
73 \};\par
74 {\cf21 #if defined(__GNUC__) && !defined(__clang__)}\par
75 {\cf21 #  pragma GCC diagnostic pop}\par
76 {\cf21 #endif}\par
77 \par
78 {\cf17 template}<{\cf17 typename} {\cf18 char}T, {\cf17 typename} traits>\par
79 {\cf17 inline} std::basic_ostream<charT, traits>&\par
80 operator<<(std::basic_ostream<charT, traits>& os, value_t t)\par
81 \{\par
82     {\cf19 switch}(t)\par
83     \{\par
84         {\cf19 case} value_t::boolean         : os << {\cf22 "boolean"};         {\cf19 return} os;\par
85         {\cf19 case} value_t::integer         : os << {\cf22 "integer"};         {\cf19 return} os;\par
86         {\cf19 case} value_t::floating        : os << {\cf22 "floating"};        {\cf19 return} os;\par
87         {\cf19 case} value_t::string          : os << {\cf22 "string"};          {\cf19 return} os;\par
88         {\cf19 case} value_t::offset_datetime : os << {\cf22 "offset_datetime"}; {\cf19 return} os;\par
89         {\cf19 case} value_t::local_datetime  : os << {\cf22 "local_datetime"};  {\cf19 return} os;\par
90         {\cf19 case} value_t::local_date      : os << {\cf22 "local_date"};      {\cf19 return} os;\par
91         {\cf19 case} value_t::local_time      : os << {\cf22 "local_time"};      {\cf19 return} os;\par
92         {\cf19 case} value_t::array           : os << {\cf22 "array"};           {\cf19 return} os;\par
93         {\cf19 case} value_t::table           : os << {\cf22 "table"};           {\cf19 return} os;\par
94         {\cf19 case} value_t::empty           : os << {\cf22 "empty"};           {\cf19 return} os;\par
95         default                       : os << {\cf22 "unknown"};         {\cf19 return} os;\par
96     \}\par
97 \}\par
98 \par
99 {\cf17 template}<{\cf17 typename} charT = char,\par
100          {\cf17 typename} traits = std::char_traits<charT>,\par
101          {\cf17 typename} alloc = std::allocator<charT>>\par
102 {\cf17 inline} std::basic_string<charT, traits, alloc> stringize(value_t t)\par
103 \{\par
104     std::basic_ostringstream<charT, traits, alloc> oss;\par
105     oss << t;\par
106     {\cf19 return} oss.str();\par
107 \}\par
108 \par
109 {\cf17 namespace }detail\par
110 \{\par
111 \par
112 {\cf20 // helper to define a type that represents a value_t value.}\par
113 {\cf17 template}<value_t V>\par
114 {\cf17 using }value_t_constant = std::integral_constant<value_t, V>;\par
115 \par
116 {\cf20 // meta-function that convertes from value_t to the exact toml type that corresponds to.}\par
117 {\cf20 // It takes toml::basic_value type because array and table types depend on it.}\par
118 {\cf17 template}<value_t t, {\cf17 typename} Value> {\cf17 struct }enum_to_type                      \{{\cf17 using }type = void                      ;\};\par
119 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }enum_to_type<value_t::empty          , Value>\{{\cf17 using }type = void                      ;\};\par
120 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }enum_to_type<value_t::boolean        , Value>\{{\cf17 using }type = boolean                   ;\};\par
121 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }enum_to_type<value_t::integer        , Value>\{{\cf17 using }type = integer                   ;\};\par
122 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }enum_to_type<value_t::floating       , Value>\{{\cf17 using }type = floating                  ;\};\par
123 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }enum_to_type<value_t::string         , Value>\{{\cf17 using }type = string                    ;\};\par
124 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }enum_to_type<value_t::offset_datetime, Value>\{{\cf17 using }type = offset_datetime           ;\};\par
125 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }enum_to_type<value_t::local_datetime , Value>\{{\cf17 using }type = local_datetime            ;\};\par
126 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }enum_to_type<value_t::local_date     , Value>\{{\cf17 using }type = local_date                ;\};\par
127 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }enum_to_type<value_t::local_time     , Value>\{{\cf17 using }type = local_time                ;\};\par
128 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }enum_to_type<value_t::array          , Value>\{{\cf17 using }type = {\cf17 typename} Value::array_type;\};\par
129 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }enum_to_type<value_t::table          , Value>\{{\cf17 using }type = {\cf17 typename} Value::table_type;\};\par
130 \par
131 {\cf20 // meta-function that converts from an exact toml type to the enum that corresponds to.}\par
132 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} Value>\par
133 {\cf17 struct }type_to_enum : std::conditional<\par
134     std::is_same<T, typename Value::array_type>::value, {\cf20 // if T == array_type,}\par
135     value_t_constant<value_t::array>,                   {\cf20 // then value_t::array}\par
136     typename std::conditional<                          {\cf20 // else...}\par
137         std::is_same<T, typename Value::table_type>::value, {\cf20 // if T == table_type}\par
138         value_t_constant<value_t::table>,               {\cf20 // then value_t::table}\par
139         value_t_constant<value_t::empty>                {\cf20 // else value_t::empty}\par
140         >::type\par
141     >::type \{\};\par
142 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }type_to_enum<boolean        , Value>: value_t_constant<value_t::boolean        > \{\};\par
143 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }type_to_enum<integer        , Value>: value_t_constant<value_t::integer        > \{\};\par
144 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }type_to_enum<floating       , Value>: value_t_constant<value_t::floating       > \{\};\par
145 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }type_to_enum<string         , Value>: value_t_constant<value_t::string         > \{\};\par
146 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }type_to_enum<offset_datetime, Value>: value_t_constant<value_t::offset_datetime> \{\};\par
147 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }type_to_enum<local_datetime , Value>: value_t_constant<value_t::local_datetime > \{\};\par
148 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }type_to_enum<local_date     , Value>: value_t_constant<value_t::local_date     > \{\};\par
149 {\cf17 template}<{\cf17 typename} Value> {\cf17 struct }type_to_enum<local_time     , Value>: value_t_constant<value_t::local_time     > \{\};\par
150 \par
151 {\cf20 // meta-function that checks the type T is the same as one of the toml::* types.}\par
152 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} Value>\par
153 {\cf17 struct }is_exact_toml_type : disjunction<\par
154     std::is_same<T, boolean        >,\par
155     std::is_same<T, integer        >,\par
156     std::is_same<T, floating       >,\par
157     std::is_same<T, string         >,\par
158     std::is_same<T, offset_datetime>,\par
159     std::is_same<T, local_datetime >,\par
160     std::is_same<T, local_date     >,\par
161     std::is_same<T, local_time     >,\par
162     std::is_same<T, typename Value::array_type>,\par
163     std::is_same<T, typename Value::table_type>\par
164     >\{\};\par
165 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} V> {\cf17 struct }is_exact_toml_type<T&, V>               : is_exact_toml_type<T, V>\{\};\par
166 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} V> {\cf17 struct }is_exact_toml_type<T const&, V>         : is_exact_toml_type<T, V>\{\};\par
167 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} V> {\cf17 struct }is_exact_toml_type<T volatile&, V>      : is_exact_toml_type<T, V>\{\};\par
168 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} V> {\cf17 struct }is_exact_toml_type<T const volatile&, V>: is_exact_toml_type<T, V>\{\};\par
169 \par
170 \} {\cf20 // detail}\par
171 \} {\cf20 // toml}\par
172 \par
173 {\cf21 #endif}{\cf20 // TOML11_TYPES_H}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/utility.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/utility.hpp}
{\xe \v external/toml/utility.hpp}
{\bkmkstart AAAAAAAAEI}
{\bkmkend AAAAAAAAEI}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <memory>}\par
{\f2 #include <sstream>}\par
{\f2 #include <utility>}\par
{\f2 #include "traits.hpp"}\par
{\f2 #include "version.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::last_one_in_pack< T, Ts >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::last_one_in_pack< T >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_MARK_AS_DEPRECATED}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ts> using {\b toml::detail::last_one_in_pack_t} = typename last_one_in_pack< Ts... >::type\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename ... Ts> std::unique_ptr< T > {\b toml::make_unique} (Ts &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Container > void {\b toml::detail::try_reserve_impl} (Container &container, std::size_t N, std::true_type)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Container > void {\b toml::detail::try_reserve_impl} (Container &, std::size_t, std::false_type) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Container > void {\b toml::try_reserve} (Container &container, std::size_t N)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b toml::detail::concat_to_string_impl} (std::ostringstream &oss)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename ... Ts> std::string {\b toml::detail::concat_to_string_impl} (std::ostringstream &oss, T &&head, Ts &&... tail)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename ... Ts> std::string {\b toml::concat_to_string} (Ts &&... args)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > T {\b toml::from_string} (const std::string &str, T opt)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T > T && {\b toml::detail::last_one} (T &&tail) noexcept\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename T , typename ... Ts> enable_if_t<(sizeof...(Ts) > 0), last_one_in_pack_t< Ts &&... > > {\b toml::detail::last_one} (T &&, Ts &&... tail)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v TOML11_MARK_AS_DEPRECATED\:utility.hpp}
{\xe \v utility.hpp\:TOML11_MARK_AS_DEPRECATED}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_MARK_AS_DEPRECATED}}
\par
{\bkmkstart AAAAAAAAEJ}
{\bkmkend AAAAAAAAEJ}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
utility.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/utility.hpp}
{\xe \v external/toml/utility.hpp}
{\bkmkstart AAAAAAAAAZ}
{\bkmkend AAAAAAAAAZ}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2017.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_UTILITY_HPP}\par
4 {\cf21 #define TOML11_UTILITY_HPP}\par
5 {\cf21 #include <memory>}\par
6 {\cf21 #include <sstream>}\par
7 {\cf21 #include <utility>}\par
8 \par
9 {\cf21 #include "traits.hpp"}\par
10 {\cf21 #include "version.hpp"}\par
11 \par
12 {\cf21 #if TOML11_CPLUSPLUS_STANDARD_VERSION >= 201402L}\par
13 {\cf21 #  define TOML11_MARK_AS_DEPRECATED(msg) [[deprecated(msg)]]}\par
14 {\cf21 #elif defined(__GNUC__)}\par
15 {\cf21 #  define TOML11_MARK_AS_DEPRECATED(msg) __attribute__((deprecated(msg)))}\par
16 {\cf21 #elif defined(_MSC_VER)}\par
17 {\cf21 #  define TOML11_MARK_AS_DEPRECATED(msg) __declspec(deprecated(msg))}\par
18 {\cf21 #else}\par
19 {\cf21 #  define TOML11_MARK_AS_DEPRECATED}\par
20 {\cf21 #endif}\par
21 \par
22 {\cf17 namespace }toml\par
23 \{\par
24 \par
25 {\cf21 #if TOML11_CPLUSPLUS_STANDARD_VERSION >= 201402L}\par
26 \par
27 {\cf17 using }std::make_unique;\par
28 \par
29 {\cf21 #else}\par
30 \par
31 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} ... Ts>\par
32 {\cf17 inline} std::unique_ptr<T> make_unique(Ts&& ... args)\par
33 \{\par
34     {\cf19 return} std::unique_ptr<T>({\cf17 new} T(std::forward<Ts>(args)...));\par
35 \}\par
36 \par
37 {\cf21 #endif }{\cf20 // TOML11_CPLUSPLUS_STANDARD_VERSION >= 2014}\par
38 \par
39 {\cf17 namespace }detail\par
40 \{\par
41 {\cf17 template}<{\cf17 typename} Container>\par
42 {\cf18 void} try_reserve_impl(Container& container, std::size_t N, std::true_type)\par
43 \{\par
44     container.reserve(N);\par
45     {\cf19 return};\par
46 \}\par
47 {\cf17 template}<{\cf17 typename} Container>\par
48 {\cf18 void} try_reserve_impl(Container&, std::size_t, std::false_type) {\cf17 noexcept}\par
49 \{\par
50     {\cf19 return};\par
51 \}\par
52 \} {\cf20 // detail}\par
53 \par
54 {\cf17 template}<{\cf17 typename} Container>\par
55 {\cf18 void} try_reserve(Container& container, std::size_t N)\par
56 \{\par
57     {\cf19 if}(N <= container.size()) \{{\cf19 return};\}\par
58     detail::try_reserve_impl(container, N, detail::has_reserve_method<Container>\{\});\par
59     {\cf19 return};\par
60 \}\par
61 \par
62 {\cf17 namespace }detail\par
63 \{\par
64 {\cf17 inline} std::string concat_to_string_impl(std::ostringstream& oss)\par
65 \{\par
66     {\cf19 return} oss.str();\par
67 \}\par
68 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} ... Ts>\par
69 std::string concat_to_string_impl(std::ostringstream& oss, T&& head, Ts&& ... tail)\par
70 \{\par
71     oss << std::forward<T>(head);\par
72     {\cf19 return} concat_to_string_impl(oss, std::forward<Ts>(tail) ... );\par
73 \}\par
74 \} {\cf20 // detail}\par
75 \par
76 {\cf17 template}<{\cf17 typename} ... Ts>\par
77 std::string concat_to_string(Ts&& ... args)\par
78 \{\par
79     std::ostringstream oss;\par
80     oss << std::boolalpha << std::fixed;\par
81     {\cf19 return} detail::concat_to_string_impl(oss, std::forward<Ts>(args) ...);\par
82 \}\par
83 \par
84 {\cf17 template}<{\cf17 typename} T>\par
85 T from_string({\cf17 const} std::string& str, T opt)\par
86 \{\par
87     T v(opt);\par
88     std::istringstream iss(str);\par
89     iss >> v;\par
90     {\cf19 return} v;\par
91 \}\par
92 \par
93 {\cf17 namespace }detail\par
94 \{\par
95 {\cf21 #if TOML11_CPLUSPLUS_STANDARD_VERSION >= 201402L}\par
96 {\cf17 template}<{\cf17 typename} T>\par
97 {\cf17 decltype}({\cf17 auto}) last_one(T&& tail) {\cf17 noexcept}\par
98 \{\par
99     {\cf19 return} std::forward<T>(tail);\par
100 \}\par
101 \par
102 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} ... Ts>\par
103 {\cf17 decltype}({\cf17 auto}) last_one(T&& {\cf20 /*head*/}, Ts&& ... tail) {\cf17 noexcept}\par
104 \{\par
105     {\cf19 return} last_one(std::forward<Ts>(tail)...);\par
106 \}\par
107 {\cf21 #else }{\cf20 // C++11}\par
108 {\cf20 // The following code}\par
109 {\cf20 // ```cpp}\par
110 {\cf20 //  1 | template<typename T, typename ... Ts>}\par
111 {\cf20 //  2 | auto last_one(T&& /*head*/, Ts&& ... tail)}\par
112 {\cf20 //  3 |  -> decltype(last_one(std::forward<Ts>(tail)...))}\par
113 {\cf20 //  4 | \{}\par
114 {\cf20 //  5 |     return last_one(std::forward<Ts>(tail)...);}\par
115 {\cf20 //  6 | \}}\par
116 {\cf20 // ```}\par
117 {\cf20 // does not work because the function `last_one(...)` is not yet defined at}\par
118 {\cf20 // line #3, so `decltype()` cannot deduce the type returned from `last_one`.}\par
119 {\cf20 // So we need to determine return type in a different way, like a meta func.}\par
120 \par
121 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} ... Ts>\par
122 {\cf17 struct }last_one_in_pack\par
123 \{\par
124     {\cf17 using }type = {\cf17 typename} last_one_in_pack<Ts...>::type;\par
125 \};\par
126 {\cf17 template}<{\cf17 typename} T>\par
127 {\cf17 struct }last_one_in_pack<T>\par
128 \{\par
129     {\cf17 using }type = T;\par
130 \};\par
131 {\cf17 template}<{\cf17 typename} ... Ts>\par
132 {\cf17 using }last_one_in_pack_t = {\cf17 typename} last_one_in_pack<Ts...>::type;\par
133 \par
134 {\cf17 template}<{\cf17 typename} T>\par
135 T&& last_one(T&& tail) {\cf17 noexcept}\par
136 \{\par
137     {\cf19 return} std::forward<T>(tail);\par
138 \}\par
139 {\cf17 template}<{\cf17 typename} T, {\cf17 typename} ... Ts>\par
140 enable_if_t<({\cf17 sizeof}...(Ts) > 0), last_one_in_pack_t<Ts&& ...>>\par
141 last_one(T&& {\cf20 /*head*/}, Ts&& ... tail)\par
142 \{\par
143     {\cf19 return} last_one(std::forward<Ts>(tail)...);\par
144 \}\par
145 \par
146 {\cf21 #endif}\par
147 \} {\cf20 // detail}\par
148 \par
149 \}{\cf20 // toml}\par
150 {\cf21 #endif }{\cf20 // TOML11_UTILITY}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/value.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/value.hpp}
{\xe \v external/toml/value.hpp}
{\bkmkstart AAAAAAAAEK}
{\bkmkend AAAAAAAAEK}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <cassert>}\par
{\f2 #include "comments.hpp"}\par
{\f2 #include "exception.hpp"}\par
{\f2 #include "into.hpp"}\par
{\f2 #include "region.hpp"}\par
{\f2 #include "source_location.hpp"}\par
{\f2 #include "storage.hpp"}\par
{\f2 #include "traits.hpp"}\par
{\f2 #include "types.hpp"}\par
{\f2 #include "utility.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b toml::detail::switch_cast< T >}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b toml::basic_value< Comment, Table, Array >}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml}\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b toml::detail}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_GENERATE_SWITCH_CASTER}(TYPE)\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::value} = basic_value< {\b TOML11_DEFAULT_COMMENT_STRATEGY}, std::unordered_map, std::vector >\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::array} = typename value::array_type\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
using {\b toml::table} = typename value::table_type\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > region_base const * {\b toml::detail::get_region} (const Value &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > void {\b toml::detail::change_region} (Value &v, region reg)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<value_t Expected, typename Value > void {\b toml::detail::throw_bad_cast} (const std::string &funcname, value_t actual, const Value &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Value > void {\b toml::detail::throw_key_not_found_error} (const Value &v, const key &ky)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> bool {\b toml::operator==} (const basic_value< C, T, A > &lhs, const basic_value< C, T, A > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> bool {\b toml::operator!=} (const basic_value< C, T, A > &lhs, const basic_value< C, T, A > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::enable_if< detail::conjunction< detail::is_comparable< typenamebasic_value< C, T, A >::array_type >, detail::is_comparable< typenamebasic_value< C, T, A >::table_type > >::value, bool >::type {\b toml::operator<} (const basic_value< C, T, A > &lhs, const basic_value< C, T, A > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::enable_if< detail::conjunction< detail::is_comparable< typenamebasic_value< C, T, A >::array_type >, detail::is_comparable< typenamebasic_value< C, T, A >::table_type > >::value, bool >::type {\b toml::operator<=} (const basic_value< C, T, A > &lhs, const basic_value< C, T, A > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::enable_if< detail::conjunction< detail::is_comparable< typenamebasic_value< C, T, A >::array_type >, detail::is_comparable< typenamebasic_value< C, T, A >::table_type > >::value, bool >::type {\b toml::operator>} (const basic_value< C, T, A > &lhs, const basic_value< C, T, A > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::enable_if< detail::conjunction< detail::is_comparable< typenamebasic_value< C, T, A >::array_type >, detail::is_comparable< typenamebasic_value< C, T, A >::table_type > >::value, bool >::type {\b toml::operator>=} (const basic_value< C, T, A > &lhs, const basic_value< C, T, A > &rhs)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::string {\b toml::format_error} (const std::string &err_msg, const basic_value< C, T, A > &v, const std::string &comment, std::vector< std::string > hints=\{\}, const bool colorize={\b TOML11_ERROR_MESSAGE_COLORIZED})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::string {\b toml::format_error} (const std::string &err_msg, const {\b toml::basic_value}< C, T, A > &v1, const std::string &comment1, const {\b toml::basic_value}< C, T, A > &v2, const std::string &comment2, std::vector< std::string > hints=\{\}, const bool colorize={\b TOML11_ERROR_MESSAGE_COLORIZED})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename C , template< typename ... > class T, template< typename ... > class A> std::string {\b toml::format_error} (const std::string &err_msg, const {\b toml::basic_value}< C, T, A > &v1, const std::string &comment1, const {\b toml::basic_value}< C, T, A > &v2, const std::string &comment2, const {\b toml::basic_value}< C, T, A > &v3, const std::string &comment3, std::vector< std::string > hints=\{\}, const bool colorize={\b TOML11_ERROR_MESSAGE_COLORIZED})\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Visitor , typename C , template< typename ... > class T, template< typename ... > class A> detail::return_type_of_t< Visitor, const {\b toml::boolean} & > {\b toml::visit} (Visitor &&visitor, const {\b toml::basic_value}< C, T, A > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Visitor , typename C , template< typename ... > class T, template< typename ... > class A> detail::return_type_of_t< Visitor, {\b toml::boolean} & > {\b toml::visit} (Visitor &&visitor, {\b toml::basic_value}< C, T, A > &v)\par
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename Visitor , typename C , template< typename ... > class T, template< typename ... > class A> detail::return_type_of_t< Visitor, {\b toml::boolean} && > {\b toml::visit} (Visitor &&visitor, {\b toml::basic_value}< C, T, A > &&v)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v TOML11_GENERATE_SWITCH_CASTER\:value.hpp}
{\xe \v value.hpp\:TOML11_GENERATE_SWITCH_CASTER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_GENERATE_SWITCH_CASTER( TYPE)}}
\par
{\bkmkstart AAAAAAAAEL}
{\bkmkend AAAAAAAAEL}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Value:}{
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid     {\cf17 template}<>                                                           \\\par
    struct switch_cast<value_t::TYPE>                                    \\\par
    \{                                                                    \\\par
        template<typename Value>                                         \\\par
        static {\cf17 typename} Value::TYPE##_type& invoke(Value& v)             \\\par
        \{                                                                \\\par
            return v.as_##TYPE();                                        \\\par
        \}                                                                \\\par
        template<typename Value>                                         \\\par
        static {\cf17 typename} Value::TYPE##_type {\cf17 const}& invoke({\cf17 const} Value& v) \\\par
        \{                                                                \\\par
            return v.as_##TYPE();                                        \\\par
        \}                                                                \\\par
        template<typename Value>                                         \\\par
        static {\cf17 typename} Value::TYPE##_type&& invoke(Value&& v)           \\\par
        \{                                                                \\\par
            return std::move(v).as_##TYPE();                             \\\par
        \}                                                                \\\par
    \};                                                                   \\\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
value.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/value.hpp}
{\xe \v external/toml/value.hpp}
{\bkmkstart AAAAAAAABA}
{\bkmkend AAAAAAAABA}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf20 //     Copyright Toru Niina 2017.}\par
2 {\cf20 // Distributed under the MIT License.}\par
3 {\cf21 #ifndef TOML11_VALUE_HPP}\par
4 {\cf21 #define TOML11_VALUE_HPP}\par
5 {\cf21 #include <cassert>}\par
6 \par
7 {\cf21 #include "comments.hpp"}\par
8 {\cf21 #include "exception.hpp"}\par
9 {\cf21 #include "into.hpp"}\par
10 {\cf21 #include "region.hpp"}\par
11 {\cf21 #include "source_location.hpp"}\par
12 {\cf21 #include "storage.hpp"}\par
13 {\cf21 #include "traits.hpp"}\par
14 {\cf21 #include "types.hpp"}\par
15 {\cf21 #include "utility.hpp"}\par
16 \par
17 {\cf17 namespace }toml\par
18 \{\par
19 \par
20 {\cf17 namespace }detail\par
21 \{\par
22 \par
23 {\cf20 // to show error messages. not recommended for users.}\par
24 {\cf17 template}<{\cf17 typename} Value>\par
25 {\cf17 inline} region_base {\cf17 const}* get_region({\cf17 const} Value& v)\par
26 \{\par
27     {\cf19 return} v.region_info_.get();\par
28 \}\par
29 \par
30 {\cf17 template}<{\cf17 typename} Value>\par
31 {\cf18 void} change_region(Value& v, region reg)\par
32 \{\par
33     v.region_info_ = std::make_shared<region>(std::move(reg));\par
34     {\cf19 return};\par
35 \}\par
36 \par
37 {\cf17 template}<value_t Expected, {\cf17 typename} Value>\par
38 [[noreturn]] {\cf17 inline} {\cf18 void}\par
39 throw_bad_cast({\cf17 const} std::string& funcname, value_t actual, {\cf17 const} Value& v)\par
40 \{\par
41     {\cf19 throw} type_error(detail::format_underline(\par
42         concat_to_string(funcname, {\cf22 "bad_cast to "}, Expected), \{\par
43             \{v.location(), concat_to_string({\cf22 "the actual type is "}, actual)\}\par
44         \}), v.location());\par
45 \}\par
46 \par
47 {\cf20 // Throw `out_of_range` from `toml::value::at()` and `toml::find()`}\par
48 {\cf20 // after generating an error message.}\par
49 {\cf20 //}\par
50 {\cf20 // The implementation is a bit complicated and there are many edge-cases.}\par
51 {\cf20 // If you are not interested in the error message generation, just skip this.}\par
52 {\cf17 template}<{\cf17 typename} Value>\par
53 [[noreturn]] {\cf18 void}\par
54 throw_key_not_found_error({\cf17 const} Value& v, {\cf17 const} key& ky)\par
55 \{\par
56     {\cf20 // The top-level table has its region at the first character of the file.}\par
57     {\cf20 // That means that, in the case when a key is not found in the top-level}\par
58     {\cf20 // table, the error message points to the first character. If the file has}\par
59     {\cf20 // its first table at the first line, the error message would be like this.}\par
60     {\cf20 // ```console}\par
61     {\cf20 // [error] key "a" not found}\par
62     {\cf20 //  --> example.toml}\par
63     {\cf20 //    |}\par
64     {\cf20 //  1 | [table]}\par
65     {\cf20 //    | ^------ in this table}\par
66     {\cf20 // ```}\par
67     {\cf20 // It actually points to the top-level table at the first character,}\par
68     {\cf20 // not `[table]`. But it is too confusing. To avoid the confusion, the error}\par
69     {\cf20 // message should explicitly say "key not found in the top-level table",}\par
70     {\cf20 // or "the parsed file is empty" if there is no content at all (0 bytes in file).}\par
71     {\cf17 const} {\cf17 auto} loc = v.location();\par
72     {\cf19 if}(loc.line() == 1 && loc.region() == 0)\par
73     \{\par
74         {\cf20 // First line with a zero-length region means "empty file".}\par
75         {\cf20 // The region will be generated at `parse_toml_file` function}\par
76         {\cf20 // if the file contains no bytes.}\par
77         {\cf19 throw} std::out_of_range(format_underline(concat_to_string(\par
78             {\cf22 "key \\""}, ky, {\cf22 "\\" not found in the top-level table"}), \{\par
79                 \{loc, {\cf22 "the parsed file is empty"}\}\par
80             \}));\par
81     \}\par
82     {\cf19 else} {\cf19 if}(loc.line() == 1 && loc.region() == 1)\par
83     \{\par
84         {\cf20 // Here it assumes that top-level table starts at the first character.}\par
85         {\cf20 // The region corresponds to the top-level table will be generated at}\par
86         {\cf20 // `parse_toml_file` function.}\par
87         {\cf20 //     It also assumes that the top-level table size is just one and}\par
88         {\cf20 // the line number is `1`. It is always satisfied. And those conditions}\par
89         {\cf20 // are satisfied only if the table is the top-level table.}\par
90         {\cf20 //}\par
91         {\cf20 // 1. one-character dot-key at the first line}\par
92         {\cf20 // ```toml}\par
93         {\cf20 // a.b = "c"}\par
94         {\cf20 // ```}\par
95         {\cf20 // toml11 counts whole key as the table key. Here, `a.b` is the region}\par
96         {\cf20 // of the table "a". It could be counter intuitive, but it works.}\par
97         {\cf20 // The size of the region is 3, not 1. The above example is the shortest}\par
98         {\cf20 // dot-key example. The size cannot be 1.}\par
99         {\cf20 //}\par
100         {\cf20 // 2. one-character inline-table at the first line}\par
101         {\cf20 // ```toml}\par
102         {\cf20 // a = \{b = "c"\}}\par
103         {\cf20 // ```}\par
104         {\cf20 // toml11 considers the inline table body as the table region. Here,}\par
105         {\cf20 // `\{b = "c"\}` is the region of the table "a". The size of the region}\par
106         {\cf20 // is 9, not 1. The shotest inline table still has two characters, `\{`}\par
107         {\cf20 // and `\}`. The size cannot be 1.}\par
108         {\cf20 //}\par
109         {\cf20 // 3. one-character table declaration at the first line}\par
110         {\cf20 // ```toml}\par
111         {\cf20 // [a]}\par
112         {\cf20 // ```}\par
113         {\cf20 // toml11 considers the whole table key as the table region. Here,}\par
114         {\cf20 // `[a]` is the table region. The size is 3, not 1.}\par
115         {\cf20 //}\par
116         {\cf19 throw} std::out_of_range(format_underline(concat_to_string(\par
117             {\cf22 "key \\""}, ky, {\cf22 "\\" not found in the top-level table"}), \{\par
118                 \{loc, {\cf22 "the top-level table starts here"}\}\par
119             \}));\par
120     \}\par
121     {\cf19 else}\par
122     \{\par
123         {\cf20 // normal table.}\par
124         {\cf19 throw} std::out_of_range(format_underline(concat_to_string(\par
125             {\cf22 "key \\""}, ky, {\cf22 "\\" not found"}), \{ \{loc, {\cf22 "in this table"}\} \}));\par
126     \}\par
127 \}\par
128 \par
129 {\cf20 // switch by `value_t` at the compile time.}\par
130 {\cf17 template}<value_t T>\par
131 {\cf17 struct }switch_cast \{\};\par
132 {\cf21 #define TOML11_GENERATE_SWITCH_CASTER(TYPE) \\}\par
133 {\cf21     template<>                                                           \\}\par
134 {\cf21     struct switch_cast<value_t::TYPE>                                    \\}\par
135 {\cf21     \{                                                                    \\}\par
136 {\cf21         template<typename Value>                                         \\}\par
137 {\cf21         static typename Value::TYPE##_type& invoke(Value& v)             \\}\par
138 {\cf21         \{                                                                \\}\par
139 {\cf21             return v.as_##TYPE();                                        \\}\par
140 {\cf21         \}                                                                \\}\par
141 {\cf21         template<typename Value>                                         \\}\par
142 {\cf21         static typename Value::TYPE##_type const& invoke(const Value& v) \\}\par
143 {\cf21         \{                                                                \\}\par
144 {\cf21             return v.as_##TYPE();                                        \\}\par
145 {\cf21         \}                                                                \\}\par
146 {\cf21         template<typename Value>                                         \\}\par
147 {\cf21         static typename Value::TYPE##_type&& invoke(Value&& v)           \\}\par
148 {\cf21         \{                                                                \\}\par
149 {\cf21             return std::move(v).as_##TYPE();                             \\}\par
150 {\cf21         \}                                                                \\}\par
151 {\cf21     \};                                                                   \\}\par
152 {\cf21     }\par
153 TOML11_GENERATE_SWITCH_CASTER({\cf18 boolean})\par
154 TOML11_GENERATE_SWITCH_CASTER(integer)\par
155 TOML11_GENERATE_SWITCH_CASTER(floating)\par
156 TOML11_GENERATE_SWITCH_CASTER({\cf18 string})\par
157 TOML11_GENERATE_SWITCH_CASTER(offset_datetime)\par
158 TOML11_GENERATE_SWITCH_CASTER(local_datetime)\par
159 TOML11_GENERATE_SWITCH_CASTER(local_date)\par
160 TOML11_GENERATE_SWITCH_CASTER(local_time)\par
161 TOML11_GENERATE_SWITCH_CASTER(array)\par
162 TOML11_GENERATE_SWITCH_CASTER(table)\par
163 \par
164 {\cf21 #undef TOML11_GENERATE_SWITCH_CASTER}\par
165 \par
166 \}{\cf20 // detail}\par
167 \par
168 {\cf17 template}<{\cf17 typename} Comment, {\cf20 // discard/preserve_comment}\par
169          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }Table = std::unordered_map,\par
170          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }Array = std::vector>\par
171 {\cf17 class }basic_value\par
172 \{\par
173     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} U>\par
174     {\cf17 static} {\cf18 void} assigner(T& dst, U&& v)\par
175     \{\par
176         {\cf17 const} {\cf17 auto} tmp = ::new(std::addressof(dst)) T(std::forward<U>(v));\par
177         assert(tmp == std::addressof(dst));\par
178         (void)tmp;\par
179     \}\par
180 \par
181     {\cf17 using }region_base = detail::region_base;\par
182 \par
183     {\cf17 template}<{\cf17 typename} C, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T,\par
184              {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
185     {\cf17 friend} {\cf17 class }basic_value;\par
186 \par
187   {\cf17 public}:\par
188 \par
189     {\cf17 using }comment_type         = Comment;\par
190     {\cf17 using }key_type             = ::toml::key;\par
191     {\cf17 using }value_type           = basic_value<comment_type, Table, Array>;\par
192     {\cf17 using }boolean_type         = ::toml::boolean;\par
193     {\cf17 using }integer_type         = ::toml::integer;\par
194     {\cf17 using }floating_type        = ::toml::floating;\par
195     {\cf17 using }string_type          = ::toml::string;\par
196     {\cf17 using }local_time_type      = ::toml::local_time;\par
197     {\cf17 using }local_date_type      = ::toml::local_date;\par
198     {\cf17 using }local_datetime_type  = ::toml::local_datetime;\par
199     {\cf17 using }offset_datetime_type = ::toml::offset_datetime;\par
200     {\cf17 using }array_type           = Array<value_type>;\par
201     {\cf17 using }table_type           = Table<key_type, value_type>;\par
202 \par
203   {\cf17 public}:\par
204 \par
205     basic_value() noexcept\par
206         : type_(value_t::empty),\par
207           region_info_(std::make_shared<region_base>(region_base\{\}))\par
208     \{\}\par
209     ~basic_value() noexcept \{this->cleanup();\}\par
210 \par
211     basic_value({\cf17 const} basic_value& v)\par
212         : type_(v.type()), region_info_(v.region_info_), comments_(v.comments_)\par
213     \{\par
214         {\cf19 switch}(v.type())\par
215         \{\par
216             {\cf19 case} value_t::boolean        : assigner(boolean_        , v.boolean_        ); {\cf19 break};\par
217             {\cf19 case} value_t::integer        : assigner(integer_        , v.integer_        ); {\cf19 break};\par
218             {\cf19 case} value_t::floating       : assigner(floating_       , v.floating_       ); {\cf19 break};\par
219             {\cf19 case} value_t::string         : assigner(string_         , v.string_         ); {\cf19 break};\par
220             {\cf19 case} value_t::offset_datetime: assigner(offset_datetime_, v.offset_datetime_); {\cf19 break};\par
221             {\cf19 case} value_t::local_datetime : assigner(local_datetime_ , v.local_datetime_ ); {\cf19 break};\par
222             {\cf19 case} value_t::local_date     : assigner(local_date_     , v.local_date_     ); {\cf19 break};\par
223             {\cf19 case} value_t::local_time     : assigner(local_time_     , v.local_time_     ); {\cf19 break};\par
224             {\cf19 case} value_t::array          : assigner(array_          , v.array_          ); {\cf19 break};\par
225             {\cf19 case} value_t::table          : assigner(table_          , v.table_          ); {\cf19 break};\par
226             {\cf19 default}: {\cf19 break};\par
227         \}\par
228     \}\par
229     basic_value(basic_value&& v)\par
230         : type_(v.type()), region_info_(std::move(v.region_info_)),\par
231           comments_(std::move(v.comments_))\par
232     \{\par
233         {\cf19 switch}(this->type_) {\cf20 // here this->type_ is already initialized}\par
234         \{\par
235             {\cf19 case} value_t::boolean        : assigner(boolean_        , std::move(v.boolean_        )); {\cf19 break};\par
236             {\cf19 case} value_t::integer        : assigner(integer_        , std::move(v.integer_        )); {\cf19 break};\par
237             {\cf19 case} value_t::floating       : assigner(floating_       , std::move(v.floating_       )); {\cf19 break};\par
238             {\cf19 case} value_t::string         : assigner(string_         , std::move(v.string_         )); {\cf19 break};\par
239             {\cf19 case} value_t::offset_datetime: assigner(offset_datetime_, std::move(v.offset_datetime_)); {\cf19 break};\par
240             {\cf19 case} value_t::local_datetime : assigner(local_datetime_ , std::move(v.local_datetime_ )); {\cf19 break};\par
241             {\cf19 case} value_t::local_date     : assigner(local_date_     , std::move(v.local_date_     )); {\cf19 break};\par
242             {\cf19 case} value_t::local_time     : assigner(local_time_     , std::move(v.local_time_     )); {\cf19 break};\par
243             {\cf19 case} value_t::array          : assigner(array_          , std::move(v.array_          )); {\cf19 break};\par
244             {\cf19 case} value_t::table          : assigner(table_          , std::move(v.table_          )); {\cf19 break};\par
245             {\cf19 default}: {\cf19 break};\par
246         \}\par
247     \}\par
248     basic_value& operator=({\cf17 const} basic_value& v)\par
249     \{\par
250         this->cleanup();\par
251         this->region_info_ = v.region_info_;\par
252         this->comments_ = v.comments_;\par
253         this->type_ = v.type();\par
254         {\cf19 switch}(this->type_)\par
255         \{\par
256             {\cf19 case} value_t::boolean        : assigner(boolean_        , v.boolean_        ); {\cf19 break};\par
257             {\cf19 case} value_t::integer        : assigner(integer_        , v.integer_        ); {\cf19 break};\par
258             {\cf19 case} value_t::floating       : assigner(floating_       , v.floating_       ); {\cf19 break};\par
259             {\cf19 case} value_t::string         : assigner(string_         , v.string_         ); {\cf19 break};\par
260             {\cf19 case} value_t::offset_datetime: assigner(offset_datetime_, v.offset_datetime_); {\cf19 break};\par
261             {\cf19 case} value_t::local_datetime : assigner(local_datetime_ , v.local_datetime_ ); {\cf19 break};\par
262             {\cf19 case} value_t::local_date     : assigner(local_date_     , v.local_date_     ); {\cf19 break};\par
263             {\cf19 case} value_t::local_time     : assigner(local_time_     , v.local_time_     ); {\cf19 break};\par
264             {\cf19 case} value_t::array          : assigner(array_          , v.array_          ); {\cf19 break};\par
265             {\cf19 case} value_t::table          : assigner(table_          , v.table_          ); {\cf19 break};\par
266             {\cf19 default}: {\cf19 break};\par
267         \}\par
268         {\cf19 return} *{\cf17 this};\par
269     \}\par
270     basic_value& operator=(basic_value&& v)\par
271     \{\par
272         this->cleanup();\par
273         this->region_info_ = std::move(v.region_info_);\par
274         this->comments_ = std::move(v.comments_);\par
275         this->type_ = v.type();\par
276         {\cf19 switch}(this->type_)\par
277         \{\par
278             {\cf19 case} value_t::boolean        : assigner(boolean_        , std::move(v.boolean_        )); {\cf19 break};\par
279             {\cf19 case} value_t::integer        : assigner(integer_        , std::move(v.integer_        )); {\cf19 break};\par
280             {\cf19 case} value_t::floating       : assigner(floating_       , std::move(v.floating_       )); {\cf19 break};\par
281             {\cf19 case} value_t::string         : assigner(string_         , std::move(v.string_         )); {\cf19 break};\par
282             {\cf19 case} value_t::offset_datetime: assigner(offset_datetime_, std::move(v.offset_datetime_)); {\cf19 break};\par
283             {\cf19 case} value_t::local_datetime : assigner(local_datetime_ , std::move(v.local_datetime_ )); {\cf19 break};\par
284             {\cf19 case} value_t::local_date     : assigner(local_date_     , std::move(v.local_date_     )); {\cf19 break};\par
285             {\cf19 case} value_t::local_time     : assigner(local_time_     , std::move(v.local_time_     )); {\cf19 break};\par
286             {\cf19 case} value_t::array          : assigner(array_          , std::move(v.array_          )); {\cf19 break};\par
287             {\cf19 case} value_t::table          : assigner(table_          , std::move(v.table_          )); {\cf19 break};\par
288             {\cf19 default}: {\cf19 break};\par
289         \}\par
290         {\cf19 return} *{\cf17 this};\par
291     \}\par
292 \par
293     {\cf20 // overwrite comments ----------------------------------------------------}\par
294 \par
295     basic_value({\cf17 const} basic_value& v, std::vector<std::string> com)\par
296         : type_(v.type()), region_info_(v.region_info_),\par
297           comments_(std::move(com))\par
298     \{\par
299         {\cf19 switch}(v.type())\par
300         \{\par
301             {\cf19 case} value_t::boolean        : assigner(boolean_        , v.boolean_        ); {\cf19 break};\par
302             {\cf19 case} value_t::integer        : assigner(integer_        , v.integer_        ); {\cf19 break};\par
303             {\cf19 case} value_t::floating       : assigner(floating_       , v.floating_       ); {\cf19 break};\par
304             {\cf19 case} value_t::string         : assigner(string_         , v.string_         ); {\cf19 break};\par
305             {\cf19 case} value_t::offset_datetime: assigner(offset_datetime_, v.offset_datetime_); {\cf19 break};\par
306             {\cf19 case} value_t::local_datetime : assigner(local_datetime_ , v.local_datetime_ ); {\cf19 break};\par
307             {\cf19 case} value_t::local_date     : assigner(local_date_     , v.local_date_     ); {\cf19 break};\par
308             {\cf19 case} value_t::local_time     : assigner(local_time_     , v.local_time_     ); {\cf19 break};\par
309             {\cf19 case} value_t::array          : assigner(array_          , v.array_          ); {\cf19 break};\par
310             {\cf19 case} value_t::table          : assigner(table_          , v.table_          ); {\cf19 break};\par
311             {\cf19 default}: {\cf19 break};\par
312         \}\par
313     \}\par
314 \par
315     basic_value(basic_value&& v, std::vector<std::string> com)\par
316         : type_(v.type()), region_info_(std::move(v.region_info_)),\par
317           comments_(std::move(com))\par
318     \{\par
319         {\cf19 switch}(this->type_) {\cf20 // here this->type_ is already initialized}\par
320         \{\par
321             {\cf19 case} value_t::boolean        : assigner(boolean_        , std::move(v.boolean_        )); {\cf19 break};\par
322             {\cf19 case} value_t::integer        : assigner(integer_        , std::move(v.integer_        )); {\cf19 break};\par
323             {\cf19 case} value_t::floating       : assigner(floating_       , std::move(v.floating_       )); {\cf19 break};\par
324             {\cf19 case} value_t::string         : assigner(string_         , std::move(v.string_         )); {\cf19 break};\par
325             {\cf19 case} value_t::offset_datetime: assigner(offset_datetime_, std::move(v.offset_datetime_)); {\cf19 break};\par
326             {\cf19 case} value_t::local_datetime : assigner(local_datetime_ , std::move(v.local_datetime_ )); {\cf19 break};\par
327             {\cf19 case} value_t::local_date     : assigner(local_date_     , std::move(v.local_date_     )); {\cf19 break};\par
328             {\cf19 case} value_t::local_time     : assigner(local_time_     , std::move(v.local_time_     )); {\cf19 break};\par
329             {\cf19 case} value_t::array          : assigner(array_          , std::move(v.array_          )); {\cf19 break};\par
330             {\cf19 case} value_t::table          : assigner(table_          , std::move(v.table_          )); {\cf19 break};\par
331             {\cf19 default}: {\cf19 break};\par
332         \}\par
333     \}\par
334 \par
335     {\cf20 // -----------------------------------------------------------------------}\par
336     {\cf20 // conversion between different basic_values.}\par
337     {\cf17 template}<{\cf17 typename} C,\par
338              {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T,\par
339              {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
340     basic_value({\cf17 const} basic_value<C, T, A>& v)\par
341         : type_(v.type()), region_info_(v.region_info_), comments_(v.comments())\par
342     \{\par
343         {\cf19 switch}(v.type())\par
344         \{\par
345             {\cf19 case} value_t::boolean        : assigner(boolean_        , v.boolean_        ); {\cf19 break};\par
346             {\cf19 case} value_t::integer        : assigner(integer_        , v.integer_        ); {\cf19 break};\par
347             {\cf19 case} value_t::floating       : assigner(floating_       , v.floating_       ); {\cf19 break};\par
348             {\cf19 case} value_t::string         : assigner(string_         , v.string_         ); {\cf19 break};\par
349             {\cf19 case} value_t::offset_datetime: assigner(offset_datetime_, v.offset_datetime_); {\cf19 break};\par
350             {\cf19 case} value_t::local_datetime : assigner(local_datetime_ , v.local_datetime_ ); {\cf19 break};\par
351             {\cf19 case} value_t::local_date     : assigner(local_date_     , v.local_date_     ); {\cf19 break};\par
352             {\cf19 case} value_t::local_time     : assigner(local_time_     , v.local_time_     ); {\cf19 break};\par
353             {\cf19 case} value_t::array          :\par
354             \{\par
355                 array_type tmp(v.as_array(std::nothrow).begin(),\par
356                                v.as_array(std::nothrow).end());\par
357                 assigner(array_, std::move(tmp));\par
358                 {\cf19 break};\par
359             \}\par
360             {\cf19 case} value_t::table          :\par
361             \{\par
362                 table_type tmp(v.as_table(std::nothrow).begin(),\par
363                                v.as_table(std::nothrow).end());\par
364                 assigner(table_, std::move(tmp));\par
365                 {\cf19 break};\par
366             \}\par
367             {\cf19 default}: {\cf19 break};\par
368         \}\par
369     \}\par
370     {\cf17 template}<{\cf17 typename} C,\par
371              {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T,\par
372              {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
373     basic_value({\cf17 const} basic_value<C, T, A>& v, std::vector<std::string> com)\par
374         : type_(v.type()), region_info_(v.region_info_),\par
375           comments_(std::move(com))\par
376     \{\par
377         {\cf19 switch}(v.type())\par
378         \{\par
379             {\cf19 case} value_t::boolean        : assigner(boolean_        , v.boolean_        ); {\cf19 break};\par
380             {\cf19 case} value_t::integer        : assigner(integer_        , v.integer_        ); {\cf19 break};\par
381             {\cf19 case} value_t::floating       : assigner(floating_       , v.floating_       ); {\cf19 break};\par
382             {\cf19 case} value_t::string         : assigner(string_         , v.string_         ); {\cf19 break};\par
383             {\cf19 case} value_t::offset_datetime: assigner(offset_datetime_, v.offset_datetime_); {\cf19 break};\par
384             {\cf19 case} value_t::local_datetime : assigner(local_datetime_ , v.local_datetime_ ); {\cf19 break};\par
385             {\cf19 case} value_t::local_date     : assigner(local_date_     , v.local_date_     ); {\cf19 break};\par
386             {\cf19 case} value_t::local_time     : assigner(local_time_     , v.local_time_     ); {\cf19 break};\par
387             {\cf19 case} value_t::array          :\par
388             \{\par
389                 array_type tmp(v.as_array(std::nothrow).begin(),\par
390                                v.as_array(std::nothrow).end());\par
391                 assigner(array_, std::move(tmp));\par
392                 {\cf19 break};\par
393             \}\par
394             {\cf19 case} value_t::table          :\par
395             \{\par
396                 table_type tmp(v.as_table(std::nothrow).begin(),\par
397                                v.as_table(std::nothrow).end());\par
398                 assigner(table_, std::move(tmp));\par
399                 {\cf19 break};\par
400             \}\par
401             {\cf19 default}: {\cf19 break};\par
402         \}\par
403     \}\par
404     {\cf17 template}<{\cf17 typename} C,\par
405              {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T,\par
406              {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
407     basic_value& operator=({\cf17 const} basic_value<C, T, A>& v)\par
408     \{\par
409         this->region_info_ = v.region_info_;\par
410         this->comments_    = comment_type(v.comments());\par
411         this->type_        = v.type();\par
412         {\cf19 switch}(v.type())\par
413         \{\par
414             {\cf19 case} value_t::boolean        : assigner(boolean_        , v.boolean_        ); {\cf19 break};\par
415             {\cf19 case} value_t::integer        : assigner(integer_        , v.integer_        ); {\cf19 break};\par
416             {\cf19 case} value_t::floating       : assigner(floating_       , v.floating_       ); {\cf19 break};\par
417             {\cf19 case} value_t::string         : assigner(string_         , v.string_         ); {\cf19 break};\par
418             {\cf19 case} value_t::offset_datetime: assigner(offset_datetime_, v.offset_datetime_); {\cf19 break};\par
419             {\cf19 case} value_t::local_datetime : assigner(local_datetime_ , v.local_datetime_ ); {\cf19 break};\par
420             {\cf19 case} value_t::local_date     : assigner(local_date_     , v.local_date_     ); {\cf19 break};\par
421             {\cf19 case} value_t::local_time     : assigner(local_time_     , v.local_time_     ); {\cf19 break};\par
422             {\cf19 case} value_t::array          :\par
423             \{\par
424                 array_type tmp(v.as_array(std::nothrow).begin(),\par
425                                v.as_array(std::nothrow).end());\par
426                 assigner(array_, std::move(tmp));\par
427                 {\cf19 break};\par
428             \}\par
429             {\cf19 case} value_t::table          :\par
430             \{\par
431                 table_type tmp(v.as_table(std::nothrow).begin(),\par
432                                v.as_table(std::nothrow).end());\par
433                 assigner(table_, std::move(tmp));\par
434                 {\cf19 break};\par
435             \}\par
436             {\cf19 default}: {\cf19 break};\par
437         \}\par
438         {\cf19 return} *{\cf17 this};\par
439     \}\par
440 \par
441     {\cf20 // boolean ==============================================================}\par
442 \par
443     basic_value({\cf18 boolean} b)\par
444         : type_(value_t::boolean),\par
445           region_info_(std::make_shared<region_base>(region_base\{\}))\par
446     \{\par
447         assigner(this->boolean_, b);\par
448     \}\par
449     basic_value& operator=({\cf18 boolean} b)\par
450     \{\par
451         this->cleanup();\par
452         this->type_ = value_t::boolean;\par
453         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
454         assigner(this->boolean_, b);\par
455         {\cf19 return} *{\cf17 this};\par
456     \}\par
457     basic_value({\cf18 boolean} b, std::vector<std::string> com)\par
458         : type_(value_t::boolean),\par
459           region_info_(std::make_shared<region_base>(region_base\{\})),\par
460           comments_(std::move(com))\par
461     \{\par
462         assigner(this->boolean_, b);\par
463     \}\par
464 \par
465     {\cf20 // integer ==============================================================}\par
466 \par
467     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<detail::conjunction<\par
468         std::is_integral<T>, detail::negation<std::is_same<T, boolean>>>::value,\par
469         std::nullptr_t>::type = {\cf17 nullptr}>\par
470     basic_value(T i)\par
471         : type_(value_t::integer),\par
472           region_info_(std::make_shared<region_base>(region_base\{\}))\par
473     \{\par
474         assigner(this->integer_, {\cf17 static_cast<}integer{\cf17 >}(i));\par
475     \}\par
476 \par
477     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<detail::conjunction<\par
478         std::is_integral<T>, detail::negation<std::is_same<T, boolean>>>::value,\par
479         std::nullptr_t>::type = {\cf17 nullptr}>\par
480     basic_value& operator=(T i)\par
481     \{\par
482         this->cleanup();\par
483         this->type_ = value_t::integer;\par
484         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
485         assigner(this->integer_, {\cf17 static_cast<}integer{\cf17 >}(i));\par
486         {\cf19 return} *{\cf17 this};\par
487     \}\par
488 \par
489     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<detail::conjunction<\par
490         std::is_integral<T>, detail::negation<std::is_same<T, boolean>>>::value,\par
491         std::nullptr_t>::type = {\cf17 nullptr}>\par
492     basic_value(T i, std::vector<std::string> com)\par
493         : type_(value_t::integer),\par
494           region_info_(std::make_shared<region_base>(region_base\{\})),\par
495           comments_(std::move(com))\par
496     \{\par
497         assigner(this->integer_, {\cf17 static_cast<}integer{\cf17 >}(i));\par
498     \}\par
499 \par
500     {\cf20 // floating =============================================================}\par
501 \par
502     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<\par
503         std::is_floating_point<T>::value, std::nullptr_t>::type = {\cf17 nullptr}>\par
504     basic_value(T f)\par
505         : type_(value_t::floating),\par
506           region_info_(std::make_shared<region_base>(region_base\{\}))\par
507     \{\par
508         assigner(this->floating_, {\cf17 static_cast<}floating{\cf17 >}(f));\par
509     \}\par
510 \par
511 \par
512     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<\par
513         std::is_floating_point<T>::value, std::nullptr_t>::type = {\cf17 nullptr}>\par
514     basic_value& operator=(T f)\par
515     \{\par
516         this->cleanup();\par
517         this->type_ = value_t::floating;\par
518         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
519         assigner(this->floating_, {\cf17 static_cast<}floating{\cf17 >}(f));\par
520         {\cf19 return} *{\cf17 this};\par
521     \}\par
522 \par
523     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<\par
524         std::is_floating_point<T>::value, std::nullptr_t>::type = {\cf17 nullptr}>\par
525     basic_value(T f, std::vector<std::string> com)\par
526         : type_(value_t::floating),\par
527           region_info_(std::make_shared<region_base>(region_base\{\})),\par
528           comments_(std::move(com))\par
529     \{\par
530         assigner(this->floating_, f);\par
531     \}\par
532 \par
533     {\cf20 // string ===============================================================}\par
534 \par
535     basic_value(toml::string s)\par
536         : type_(value_t::string),\par
537           region_info_(std::make_shared<region_base>(region_base\{\}))\par
538     \{\par
539         assigner(this->string_, std::move(s));\par
540     \}\par
541     basic_value& operator=(toml::string s)\par
542     \{\par
543         this->cleanup();\par
544         this->type_ = value_t::string ;\par
545         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
546         assigner(this->string_, s);\par
547         {\cf19 return} *{\cf17 this};\par
548     \}\par
549     basic_value(toml::string s, std::vector<std::string> com)\par
550         : type_(value_t::string),\par
551           region_info_(std::make_shared<region_base>(region_base\{\})),\par
552           comments_(std::move(com))\par
553     \{\par
554         assigner(this->string_, std::move(s));\par
555     \}\par
556 \par
557     basic_value(std::string s)\par
558         : type_(value_t::string),\par
559           region_info_(std::make_shared<region_base>(region_base\{\}))\par
560     \{\par
561         assigner(this->string_, toml::string(std::move(s)));\par
562     \}\par
563     basic_value& operator=(std::string s)\par
564     \{\par
565         this->cleanup();\par
566         this->type_ = value_t::string ;\par
567         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
568         assigner(this->string_, toml::string(std::move(s)));\par
569         {\cf19 return} *{\cf17 this};\par
570     \}\par
571     basic_value(std::string s, string_t kind)\par
572         : type_(value_t::string),\par
573           region_info_(std::make_shared<region_base>(region_base\{\}))\par
574     \{\par
575         assigner(this->string_, toml::string(std::move(s), kind));\par
576     \}\par
577     basic_value(std::string s, std::vector<std::string> com)\par
578         : type_(value_t::string),\par
579           region_info_(std::make_shared<region_base>(region_base\{\})),\par
580           comments_(std::move(com))\par
581     \{\par
582         assigner(this->string_, toml::string(std::move(s)));\par
583     \}\par
584     basic_value(std::string s, string_t kind, std::vector<std::string> com)\par
585         : type_(value_t::string),\par
586           region_info_(std::make_shared<region_base>(region_base\{\})),\par
587           comments_(std::move(com))\par
588     \{\par
589         assigner(this->string_, toml::string(std::move(s), kind));\par
590     \}\par
591 \par
592     basic_value({\cf17 const} {\cf18 char}* s)\par
593         : type_(value_t::string),\par
594           region_info_(std::make_shared<region_base>(region_base\{\}))\par
595     \{\par
596         assigner(this->string_, toml::string(std::string(s)));\par
597     \}\par
598     basic_value& operator=({\cf17 const} {\cf18 char}* s)\par
599     \{\par
600         this->cleanup();\par
601         this->type_ = value_t::string ;\par
602         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
603         assigner(this->string_, toml::string(std::string(s)));\par
604         {\cf19 return} *{\cf17 this};\par
605     \}\par
606     basic_value({\cf17 const} {\cf18 char}* s, string_t kind)\par
607         : type_(value_t::string),\par
608           region_info_(std::make_shared<region_base>(region_base\{\}))\par
609     \{\par
610         assigner(this->string_, toml::string(std::string(s), kind));\par
611     \}\par
612     basic_value({\cf17 const} {\cf18 char}* s, std::vector<std::string> com)\par
613         : type_(value_t::string),\par
614           region_info_(std::make_shared<region_base>(region_base\{\})),\par
615           comments_(std::move(com))\par
616     \{\par
617         assigner(this->string_, toml::string(std::string(s)));\par
618     \}\par
619     basic_value({\cf17 const} {\cf18 char}* s, string_t kind, std::vector<std::string> com)\par
620         : type_(value_t::string),\par
621           region_info_(std::make_shared<region_base>(region_base\{\})),\par
622           comments_(std::move(com))\par
623     \{\par
624         assigner(this->string_, toml::string(std::string(s), kind));\par
625     \}\par
626 \par
627 {\cf21 #if defined(TOML11_USING_STRING_VIEW) && TOML11_USING_STRING_VIEW>0}\par
628     basic_value(std::string_view s)\par
629         : type_(value_t::string),\par
630           region_info_(std::make_shared<region_base>(region_base\{\}))\par
631     \{\par
632         assigner(this->string_, toml::string(s));\par
633     \}\par
634     basic_value& operator=(std::string_view s)\par
635     \{\par
636         this->cleanup();\par
637         this->type_ = value_t::string ;\par
638         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
639         assigner(this->string_, toml::string(s));\par
640         {\cf19 return} *{\cf17 this};\par
641     \}\par
642     basic_value(std::string_view s, std::vector<std::string> com)\par
643         : type_(value_t::string),\par
644           region_info_(std::make_shared<region_base>(region_base\{\})),\par
645           comments_(std::move(com))\par
646     \{\par
647         assigner(this->string_, toml::string(s));\par
648     \}\par
649     basic_value(std::string_view s, string_t kind)\par
650         : type_(value_t::string),\par
651           region_info_(std::make_shared<region_base>(region_base\{\}))\par
652     \{\par
653         assigner(this->string_, toml::string(s, kind));\par
654     \}\par
655     basic_value(std::string_view s, string_t kind, std::vector<std::string> com)\par
656         : type_(value_t::string),\par
657           region_info_(std::make_shared<region_base>(region_base\{\})),\par
658           comments_(std::move(com))\par
659     \{\par
660         assigner(this->string_, toml::string(s, kind));\par
661     \}\par
662 {\cf21 #endif}\par
663 \par
664     {\cf20 // local date ===========================================================}\par
665 \par
666     basic_value({\cf17 const} local_date& ld)\par
667         : type_(value_t::local_date),\par
668           region_info_(std::make_shared<region_base>(region_base\{\}))\par
669     \{\par
670         assigner(this->local_date_, ld);\par
671     \}\par
672     basic_value& operator=({\cf17 const} local_date& ld)\par
673     \{\par
674         this->cleanup();\par
675         this->type_ = value_t::local_date;\par
676         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
677         assigner(this->local_date_, ld);\par
678         {\cf19 return} *{\cf17 this};\par
679     \}\par
680     basic_value({\cf17 const} local_date& ld, std::vector<std::string> com)\par
681         : type_(value_t::local_date),\par
682           region_info_(std::make_shared<region_base>(region_base\{\})),\par
683           comments_(std::move(com))\par
684     \{\par
685         assigner(this->local_date_, ld);\par
686     \}\par
687 \par
688     {\cf20 // local time ===========================================================}\par
689 \par
690     basic_value({\cf17 const} local_time& lt)\par
691         : type_(value_t::local_time),\par
692           region_info_(std::make_shared<region_base>(region_base\{\}))\par
693     \{\par
694         assigner(this->local_time_, lt);\par
695     \}\par
696     basic_value({\cf17 const} local_time& lt, std::vector<std::string> com)\par
697         : type_(value_t::local_time),\par
698           region_info_(std::make_shared<region_base>(region_base\{\})),\par
699           comments_(std::move(com))\par
700     \{\par
701         assigner(this->local_time_, lt);\par
702     \}\par
703     basic_value& operator=({\cf17 const} local_time& lt)\par
704     \{\par
705         this->cleanup();\par
706         this->type_ = value_t::local_time;\par
707         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
708         assigner(this->local_time_, lt);\par
709         {\cf19 return} *{\cf17 this};\par
710     \}\par
711 \par
712     {\cf17 template}<{\cf17 typename} Rep, {\cf17 typename} Period>\par
713     basic_value({\cf17 const} std::chrono::duration<Rep, Period>& dur)\par
714         : type_(value_t::local_time),\par
715           region_info_(std::make_shared<region_base>(region_base\{\}))\par
716     \{\par
717         assigner(this->local_time_, local_time(dur));\par
718     \}\par
719     {\cf17 template}<{\cf17 typename} Rep, {\cf17 typename} Period>\par
720     basic_value({\cf17 const} std::chrono::duration<Rep, Period>& dur,\par
721                 std::vector<std::string> com)\par
722         : type_(value_t::local_time),\par
723           region_info_(std::make_shared<region_base>(region_base\{\})),\par
724           comments_(std::move(com))\par
725     \{\par
726         assigner(this->local_time_, local_time(dur));\par
727     \}\par
728     {\cf17 template}<{\cf17 typename} Rep, {\cf17 typename} Period>\par
729     basic_value& operator=({\cf17 const} std::chrono::duration<Rep, Period>& dur)\par
730     \{\par
731         this->cleanup();\par
732         this->type_ = value_t::local_time;\par
733         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
734         assigner(this->local_time_, local_time(dur));\par
735         {\cf19 return} *{\cf17 this};\par
736     \}\par
737 \par
738     {\cf20 // local datetime =======================================================}\par
739 \par
740     basic_value({\cf17 const} local_datetime& ldt)\par
741         : type_(value_t::local_datetime),\par
742           region_info_(std::make_shared<region_base>(region_base\{\}))\par
743     \{\par
744         assigner(this->local_datetime_, ldt);\par
745     \}\par
746     basic_value({\cf17 const} local_datetime& ldt, std::vector<std::string> com)\par
747         : type_(value_t::local_datetime),\par
748           region_info_(std::make_shared<region_base>(region_base\{\})),\par
749           comments_(std::move(com))\par
750     \{\par
751         assigner(this->local_datetime_, ldt);\par
752     \}\par
753     basic_value& operator=({\cf17 const} local_datetime& ldt)\par
754     \{\par
755         this->cleanup();\par
756         this->type_ = value_t::local_datetime;\par
757         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
758         assigner(this->local_datetime_, ldt);\par
759         {\cf19 return} *{\cf17 this};\par
760     \}\par
761 \par
762     {\cf20 // offset datetime ======================================================}\par
763 \par
764     basic_value({\cf17 const} offset_datetime& odt)\par
765         : type_(value_t::offset_datetime),\par
766           region_info_(std::make_shared<region_base>(region_base\{\}))\par
767     \{\par
768         assigner(this->offset_datetime_, odt);\par
769     \}\par
770     basic_value({\cf17 const} offset_datetime& odt, std::vector<std::string> com)\par
771         : type_(value_t::offset_datetime),\par
772           region_info_(std::make_shared<region_base>(region_base\{\})),\par
773           comments_(std::move(com))\par
774     \{\par
775         assigner(this->offset_datetime_, odt);\par
776     \}\par
777     basic_value& operator=({\cf17 const} offset_datetime& odt)\par
778     \{\par
779         this->cleanup();\par
780         this->type_ = value_t::offset_datetime;\par
781         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
782         assigner(this->offset_datetime_, odt);\par
783         {\cf19 return} *{\cf17 this};\par
784     \}\par
785     basic_value({\cf17 const} std::chrono::system_clock::time_point& tp)\par
786         : type_(value_t::offset_datetime),\par
787           region_info_(std::make_shared<region_base>(region_base\{\}))\par
788     \{\par
789         assigner(this->offset_datetime_, offset_datetime(tp));\par
790     \}\par
791     basic_value({\cf17 const} std::chrono::system_clock::time_point& tp,\par
792                 std::vector<std::string> com)\par
793         : type_(value_t::offset_datetime),\par
794           region_info_(std::make_shared<region_base>(region_base\{\})),\par
795           comments_(std::move(com))\par
796     \{\par
797         assigner(this->offset_datetime_, offset_datetime(tp));\par
798     \}\par
799     basic_value& operator=({\cf17 const} std::chrono::system_clock::time_point& tp)\par
800     \{\par
801         this->cleanup();\par
802         this->type_ = value_t::offset_datetime;\par
803         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
804         assigner(this->offset_datetime_, offset_datetime(tp));\par
805         {\cf19 return} *{\cf17 this};\par
806     \}\par
807 \par
808     {\cf20 // array ================================================================}\par
809 \par
810     basic_value({\cf17 const} array_type& ary)\par
811         : type_(value_t::array),\par
812           region_info_(std::make_shared<region_base>(region_base\{\}))\par
813     \{\par
814         assigner(this->array_, ary);\par
815     \}\par
816     basic_value({\cf17 const} array_type& ary, std::vector<std::string> com)\par
817         : type_(value_t::array),\par
818           region_info_(std::make_shared<region_base>(region_base\{\})),\par
819           comments_(std::move(com))\par
820     \{\par
821         assigner(this->array_, ary);\par
822     \}\par
823     basic_value& operator=({\cf17 const} array_type& ary)\par
824     \{\par
825         this->cleanup();\par
826         this->type_ = value_t::array ;\par
827         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
828         assigner(this->array_, ary);\par
829         {\cf19 return} *{\cf17 this};\par
830     \}\par
831 \par
832     {\cf20 // array (initializer_list) ----------------------------------------------}\par
833 \par
834     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<\par
835             std::is_convertible<T, value_type>::value,\par
836         std::nullptr_t>::type = {\cf17 nullptr}>\par
837     basic_value(std::initializer_list<T> list)\par
838         : type_(value_t::array),\par
839           region_info_(std::make_shared<region_base>(region_base\{\}))\par
840     \{\par
841         array_type ary(list.begin(), list.end());\par
842         assigner(this->array_, std::move(ary));\par
843     \}\par
844     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<\par
845             std::is_convertible<T, value_type>::value,\par
846         std::nullptr_t>::type = {\cf17 nullptr}>\par
847     basic_value(std::initializer_list<T> list, std::vector<std::string> com)\par
848         : type_(value_t::array),\par
849           region_info_(std::make_shared<region_base>(region_base\{\})),\par
850           comments_(std::move(com))\par
851     \{\par
852         array_type ary(list.begin(), list.end());\par
853         assigner(this->array_, std::move(ary));\par
854     \}\par
855     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<\par
856             std::is_convertible<T, value_type>::value,\par
857         std::nullptr_t>::type = {\cf17 nullptr}>\par
858     basic_value& operator=(std::initializer_list<T> list)\par
859     \{\par
860         this->cleanup();\par
861         this->type_ = value_t::array;\par
862         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
863 \par
864         array_type ary(list.begin(), list.end());\par
865         assigner(this->array_, std::move(ary));\par
866         {\cf19 return} *{\cf17 this};\par
867     \}\par
868 \par
869     {\cf20 // array (STL Containers) ------------------------------------------------}\par
870 \par
871     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<detail::conjunction<\par
872             detail::negation<std::is_same<T, array_type>>,\par
873             detail::is_container<T>\par
874         >::value, std::nullptr_t>::type = {\cf17 nullptr}>\par
875     basic_value({\cf17 const} T& list)\par
876         : type_(value_t::array),\par
877           region_info_(std::make_shared<region_base>(region_base\{\}))\par
878     \{\par
879         {\cf17 static_assert}(std::is_convertible<typename T::value_type, value_type>::value,\par
880             {\cf22 "elements of a container should be convertible to toml::value"});\par
881 \par
882         array_type ary(list.size());\par
883         std::copy(list.begin(), list.end(), ary.begin());\par
884         assigner(this->array_, std::move(ary));\par
885     \}\par
886     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<detail::conjunction<\par
887             detail::negation<std::is_same<T, array_type>>,\par
888             detail::is_container<T>\par
889         >::value, std::nullptr_t>::type = {\cf17 nullptr}>\par
890     basic_value({\cf17 const} T& list, std::vector<std::string> com)\par
891         : type_(value_t::array),\par
892           region_info_(std::make_shared<region_base>(region_base\{\})),\par
893           comments_(std::move(com))\par
894     \{\par
895         {\cf17 static_assert}(std::is_convertible<typename T::value_type, value_type>::value,\par
896             {\cf22 "elements of a container should be convertible to toml::value"});\par
897 \par
898         array_type ary(list.size());\par
899         std::copy(list.begin(), list.end(), ary.begin());\par
900         assigner(this->array_, std::move(ary));\par
901     \}\par
902     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<detail::conjunction<\par
903             detail::negation<std::is_same<T, array_type>>,\par
904             detail::is_container<T>\par
905         >::value, std::nullptr_t>::type = {\cf17 nullptr}>\par
906     basic_value& operator=({\cf17 const} T& list)\par
907     \{\par
908         {\cf17 static_assert}(std::is_convertible<typename T::value_type, value_type>::value,\par
909             {\cf22 "elements of a container should be convertible to toml::value"});\par
910 \par
911         this->cleanup();\par
912         this->type_ = value_t::array;\par
913         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
914 \par
915         array_type ary(list.size());\par
916         std::copy(list.begin(), list.end(), ary.begin());\par
917         assigner(this->array_, std::move(ary));\par
918         {\cf19 return} *{\cf17 this};\par
919     \}\par
920 \par
921     {\cf20 // table ================================================================}\par
922 \par
923     basic_value({\cf17 const} table_type& tab)\par
924         : type_(value_t::table),\par
925           region_info_(std::make_shared<region_base>(region_base\{\}))\par
926     \{\par
927         assigner(this->table_, tab);\par
928     \}\par
929     basic_value({\cf17 const} table_type& tab, std::vector<std::string> com)\par
930         : type_(value_t::table),\par
931           region_info_(std::make_shared<region_base>(region_base\{\})),\par
932           comments_(std::move(com))\par
933     \{\par
934         assigner(this->table_, tab);\par
935     \}\par
936     basic_value& operator=({\cf17 const} table_type& tab)\par
937     \{\par
938         this->cleanup();\par
939         this->type_ = value_t::table;\par
940         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
941         assigner(this->table_, tab);\par
942         {\cf19 return} *{\cf17 this};\par
943     \}\par
944 \par
945     {\cf20 // initializer-list ------------------------------------------------------}\par
946 \par
947     basic_value(std::initializer_list<std::pair<key, basic_value>> list)\par
948         : type_(value_t::table),\par
949           region_info_(std::make_shared<region_base>(region_base\{\}))\par
950     \{\par
951         table_type tab;\par
952         {\cf19 for}({\cf17 const} {\cf17 auto}& elem : list) \{tab[elem.first] = elem.second;\}\par
953         assigner(this->table_, std::move(tab));\par
954     \}\par
955 \par
956     basic_value(std::initializer_list<std::pair<key, basic_value>> list,\par
957                 std::vector<std::string> com)\par
958         : type_(value_t::table),\par
959           region_info_(std::make_shared<region_base>(region_base\{\})),\par
960           comments_(std::move(com))\par
961     \{\par
962         table_type tab;\par
963         {\cf19 for}({\cf17 const} {\cf17 auto}& elem : list) \{tab[elem.first] = elem.second;\}\par
964         assigner(this->table_, std::move(tab));\par
965     \}\par
966     basic_value& operator=(std::initializer_list<std::pair<key, basic_value>> list)\par
967     \{\par
968         this->cleanup();\par
969         this->type_ = value_t::table;\par
970         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
971 \par
972         table_type tab;\par
973         {\cf19 for}({\cf17 const} {\cf17 auto}& elem : list) \{tab[elem.first] = elem.second;\}\par
974         assigner(this->table_, std::move(tab));\par
975         {\cf19 return} *{\cf17 this};\par
976     \}\par
977 \par
978     {\cf20 // other table-like -----------------------------------------------------}\par
979 \par
980     {\cf17 template}<{\cf17 typename} Map, {\cf17 typename} std::enable_if<detail::conjunction<\par
981             detail::negation<std::is_same<Map, table_type>>,\par
982             detail::is_map<Map>\par
983         >::value, std::nullptr_t>::type = {\cf17 nullptr}>\par
984     basic_value({\cf17 const} Map& mp)\par
985         : type_(value_t::table),\par
986           region_info_(std::make_shared<region_base>(region_base\{\}))\par
987     \{\par
988         table_type tab;\par
989         {\cf19 for}({\cf17 const} {\cf17 auto}& elem : mp) \{tab[elem.first] = elem.second;\}\par
990         assigner(this->table_, std::move(tab));\par
991     \}\par
992     {\cf17 template}<{\cf17 typename} Map, {\cf17 typename} std::enable_if<detail::conjunction<\par
993             detail::negation<std::is_same<Map, table_type>>,\par
994             detail::is_map<Map>\par
995         >::value, std::nullptr_t>::type = {\cf17 nullptr}>\par
996     basic_value({\cf17 const} Map& mp, std::vector<std::string> com)\par
997         : type_(value_t::table),\par
998           region_info_(std::make_shared<region_base>(region_base\{\})),\par
999           comments_(std::move(com))\par
1000     \{\par
1001         table_type tab;\par
1002         {\cf19 for}({\cf17 const} {\cf17 auto}& elem : mp) \{tab[elem.first] = elem.second;\}\par
1003         assigner(this->table_, std::move(tab));\par
1004     \}\par
1005     {\cf17 template}<{\cf17 typename} Map, {\cf17 typename} std::enable_if<detail::conjunction<\par
1006             detail::negation<std::is_same<Map, table_type>>,\par
1007             detail::is_map<Map>\par
1008         >::value, std::nullptr_t>::type = {\cf17 nullptr}>\par
1009     basic_value& operator=({\cf17 const} Map& mp)\par
1010     \{\par
1011         this->cleanup();\par
1012         this->type_ = value_t::table;\par
1013         this->region_info_ = std::make_shared<region_base>(region_base\{\});\par
1014 \par
1015         table_type tab;\par
1016         {\cf19 for}({\cf17 const} {\cf17 auto}& elem : mp) \{tab[elem.first] = elem.second;\}\par
1017         assigner(this->table_, std::move(tab));\par
1018         {\cf19 return} *{\cf17 this};\par
1019     \}\par
1020 \par
1021     {\cf20 // user-defined =========================================================}\par
1022 \par
1023     {\cf20 // convert using into_toml() method -------------------------------------}\par
1024 \par
1025     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<\par
1026         detail::has_into_toml_method<T>::value, std::nullptr_t>::type = {\cf17 nullptr}>\par
1027     basic_value({\cf17 const} T& ud): basic_value(ud.into_toml()) \{\}\par
1028 \par
1029     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<\par
1030         detail::has_into_toml_method<T>::value, std::nullptr_t>::type = {\cf17 nullptr}>\par
1031     basic_value({\cf17 const} T& ud, std::vector<std::string> com)\par
1032         : basic_value(ud.into_toml(), std::move(com))\par
1033     \{\}\par
1034     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<\par
1035         detail::has_into_toml_method<T>::value, std::nullptr_t>::type = {\cf17 nullptr}>\par
1036     basic_value& operator=({\cf17 const} T& ud)\par
1037     \{\par
1038         *{\cf17 this} = ud.into_toml();\par
1039         {\cf19 return} *{\cf17 this};\par
1040     \}\par
1041 \par
1042     {\cf20 // convert using into<T> struct -----------------------------------------}\par
1043 \par
1044     {\cf17 template}<{\cf17 typename} T, std::{\cf18 size_t} S = sizeof(::toml::{\cf18 int}o<T>)>\par
1045     basic_value({\cf17 const} T& ud): basic_value(::toml::into<T>::into_toml(ud)) \{\}\par
1046     {\cf17 template}<{\cf17 typename} T, std::{\cf18 size_t} S = sizeof(::toml::{\cf18 int}o<T>)>\par
1047     basic_value({\cf17 const} T& ud, std::vector<std::string> com)\par
1048         : basic_value(::toml::into<T>::into_toml(ud), std::move(com))\par
1049     \{\}\par
1050     {\cf17 template}<{\cf17 typename} T, std::{\cf18 size_t} S = sizeof(::toml::{\cf18 int}o<T>)>\par
1051     basic_value& operator=({\cf17 const} T& ud)\par
1052     \{\par
1053         *{\cf17 this} = ::toml::into<T>::into_toml(ud);\par
1054         {\cf19 return} *{\cf17 this};\par
1055     \}\par
1056 \par
1057     {\cf20 // for internal use ------------------------------------------------------}\par
1058     {\cf20 //}\par
1059     {\cf20 // Those constructors take detail::region that contains parse result.}\par
1060 \par
1061     basic_value({\cf18 boolean} b, detail::region reg, std::vector<std::string> cm)\par
1062         : type_(value_t::boolean),\par
1063           region_info_(std::make_shared<detail::region>(std::move(reg))),\par
1064           comments_(std::move(cm))\par
1065     \{\par
1066         assigner(this->boolean_, b);\par
1067     \}\par
1068     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<\par
1069         detail::conjunction<\par
1070             std::is_integral<T>, detail::negation<std::is_same<T, boolean>>\par
1071         >::value, std::nullptr_t>::type = {\cf17 nullptr}>\par
1072     basic_value(T i, detail::region reg, std::vector<std::string> cm)\par
1073         : type_(value_t::integer),\par
1074           region_info_(std::make_shared<detail::region>(std::move(reg))),\par
1075           comments_(std::move(cm))\par
1076     \{\par
1077         assigner(this->integer_, {\cf17 static_cast<}integer{\cf17 >}(i));\par
1078     \}\par
1079     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<\par
1080         std::is_floating_point<T>::value, std::nullptr_t>::type = {\cf17 nullptr}>\par
1081     basic_value(T f, detail::region reg, std::vector<std::string> cm)\par
1082         : type_(value_t::floating),\par
1083           region_info_(std::make_shared<detail::region>(std::move(reg))),\par
1084           comments_(std::move(cm))\par
1085     \{\par
1086         assigner(this->floating_, {\cf17 static_cast<}floating{\cf17 >}(f));\par
1087     \}\par
1088     basic_value(toml::string s, detail::region reg,\par
1089                 std::vector<std::string> cm)\par
1090         : type_(value_t::string),\par
1091           region_info_(std::make_shared<detail::region>(std::move(reg))),\par
1092           comments_(std::move(cm))\par
1093     \{\par
1094         assigner(this->string_, std::move(s));\par
1095     \}\par
1096     basic_value({\cf17 const} local_date& ld, detail::region reg,\par
1097                 std::vector<std::string> cm)\par
1098         : type_(value_t::local_date),\par
1099           region_info_(std::make_shared<detail::region>(std::move(reg))),\par
1100           comments_(std::move(cm))\par
1101     \{\par
1102         assigner(this->local_date_, ld);\par
1103     \}\par
1104     basic_value({\cf17 const} local_time& lt, detail::region reg,\par
1105                 std::vector<std::string> cm)\par
1106         : type_(value_t::local_time),\par
1107           region_info_(std::make_shared<detail::region>(std::move(reg))),\par
1108           comments_(std::move(cm))\par
1109     \{\par
1110         assigner(this->local_time_, lt);\par
1111     \}\par
1112     basic_value({\cf17 const} local_datetime& ldt, detail::region reg,\par
1113                 std::vector<std::string> cm)\par
1114         : type_(value_t::local_datetime),\par
1115           region_info_(std::make_shared<detail::region>(std::move(reg))),\par
1116           comments_(std::move(cm))\par
1117     \{\par
1118         assigner(this->local_datetime_, ldt);\par
1119     \}\par
1120     basic_value({\cf17 const} offset_datetime& odt, detail::region reg,\par
1121                 std::vector<std::string> cm)\par
1122         : type_(value_t::offset_datetime),\par
1123           region_info_(std::make_shared<detail::region>(std::move(reg))),\par
1124           comments_(std::move(cm))\par
1125     \{\par
1126         assigner(this->offset_datetime_, odt);\par
1127     \}\par
1128     basic_value({\cf17 const} array_type& ary, detail::region reg,\par
1129                 std::vector<std::string> cm)\par
1130         : type_(value_t::array),\par
1131           region_info_(std::make_shared<detail::region>(std::move(reg))),\par
1132           comments_(std::move(cm))\par
1133     \{\par
1134         assigner(this->array_, ary);\par
1135     \}\par
1136     basic_value({\cf17 const} table_type& tab, detail::region reg,\par
1137                 std::vector<std::string> cm)\par
1138         : type_(value_t::table),\par
1139           region_info_(std::make_shared<detail::region>(std::move(reg))),\par
1140           comments_(std::move(cm))\par
1141     \{\par
1142         assigner(this->table_, tab);\par
1143     \}\par
1144 \par
1145     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<\par
1146         detail::is_exact_toml_type<T, value_type>::value,\par
1147         std::nullptr_t>::type = {\cf17 nullptr}>\par
1148     basic_value(std::pair<T, detail::region> parse_result, std::vector<std::string> com)\par
1149         : basic_value(std::move(parse_result.first),\par
1150                       std::move(parse_result.second),\par
1151                       std::move(com))\par
1152     \{\}\par
1153 \par
1154     {\cf20 // type checking and casting ============================================}\par
1155 \par
1156     {\cf17 template}<{\cf17 typename} T, {\cf17 typename} std::enable_if<\par
1157         detail::is_exact_toml_type<T, value_type>::value,\par
1158         std::nullptr_t>::type = {\cf17 nullptr}>\par
1159     {\cf18 bool} is() const noexcept\par
1160     \{\par
1161         {\cf19 return} detail::type_to_enum<T, value_type>::value == this->type_;\par
1162     \}\par
1163     {\cf18 bool} is(value_t t) {\cf17 const} {\cf17 noexcept} \{{\cf19 return} t == this->type_;\}\par
1164 \par
1165     {\cf18 bool} is_uninitialized()   const noexcept \{{\cf19 return} this->is(value_t::empty          );\}\par
1166     {\cf18 bool} is_boolean()         const noexcept \{{\cf19 return} this->is(value_t::boolean        );\}\par
1167     {\cf18 bool} is_integer()         const noexcept \{{\cf19 return} this->is(value_t::integer        );\}\par
1168     {\cf18 bool} is_floating()        const noexcept \{{\cf19 return} this->is(value_t::floating       );\}\par
1169     {\cf18 bool} is_string()          const noexcept \{{\cf19 return} this->is(value_t::string         );\}\par
1170     {\cf18 bool} is_offset_datetime() const noexcept \{{\cf19 return} this->is(value_t::offset_datetime);\}\par
1171     {\cf18 bool} is_local_datetime()  const noexcept \{{\cf19 return} this->is(value_t::local_datetime );\}\par
1172     {\cf18 bool} is_local_date()      const noexcept \{{\cf19 return} this->is(value_t::local_date     );\}\par
1173     {\cf18 bool} is_local_time()      const noexcept \{{\cf19 return} this->is(value_t::local_time     );\}\par
1174     {\cf18 bool} is_array()           const noexcept \{{\cf19 return} this->is(value_t::array          );\}\par
1175     {\cf18 bool} is_table()           const noexcept \{{\cf19 return} this->is(value_t::table          );\}\par
1176 \par
1177     value_t type() const noexcept \{{\cf19 return} type_;\}\par
1178 \par
1179     {\cf17 template}<value_t T>\par
1180     {\cf17 typename} detail::enum_to_type<T, value_type>::type&       cast() &\par
1181     \{\par
1182         {\cf19 if}(this->type_ != T)\par
1183         \{\par
1184             detail::throw_bad_cast<T>({\cf22 "toml::value::cast: "}, this->type_, *{\cf17 this});\par
1185         \}\par
1186         {\cf19 return} detail::switch_cast<T>::invoke(*{\cf17 this});\par
1187     \}\par
1188     {\cf17 template}<value_t T>\par
1189     {\cf17 typename} detail::enum_to_type<T, value_type>::type {\cf17 const}& cast() const&\par
1190     \{\par
1191         {\cf19 if}(this->type_ != T)\par
1192         \{\par
1193             detail::throw_bad_cast<T>({\cf22 "toml::value::cast: "}, this->type_, *{\cf17 this});\par
1194         \}\par
1195         {\cf19 return} detail::switch_cast<T>::invoke(*{\cf17 this});\par
1196     \}\par
1197     {\cf17 template}<value_t T>\par
1198     {\cf17 typename} detail::enum_to_type<T, value_type>::type&&      cast() &&\par
1199     \{\par
1200         {\cf19 if}(this->type_ != T)\par
1201         \{\par
1202             detail::throw_bad_cast<T>({\cf22 "toml::value::cast: "}, this->type_, *{\cf17 this});\par
1203         \}\par
1204         {\cf19 return} detail::switch_cast<T>::invoke(std::move(*{\cf17 this}));\par
1205     \}\par
1206 \par
1207     {\cf20 // ------------------------------------------------------------------------}\par
1208     {\cf20 // nothrow version}\par
1209 \par
1210     {\cf18 boolean}         {\cf17 const}& as_boolean        ({\cf17 const} std::nothrow_t&) {\cf17 const}& {\cf17 noexcept} \{{\cf19 return} this->boolean_;\}\par
1211     integer         {\cf17 const}& as_integer        ({\cf17 const} std::nothrow_t&) {\cf17 const}& {\cf17 noexcept} \{{\cf19 return} this->integer_;\}\par
1212     floating        {\cf17 const}& as_floating       ({\cf17 const} std::nothrow_t&) {\cf17 const}& {\cf17 noexcept} \{{\cf19 return} this->floating_;\}\par
1213     {\cf18 string}          {\cf17 const}& as_string         ({\cf17 const} std::nothrow_t&) {\cf17 const}& {\cf17 noexcept} \{{\cf19 return} this->string_;\}\par
1214     offset_datetime {\cf17 const}& as_offset_datetime({\cf17 const} std::nothrow_t&) {\cf17 const}& {\cf17 noexcept} \{{\cf19 return} this->offset_datetime_;\}\par
1215     local_datetime  {\cf17 const}& as_local_datetime ({\cf17 const} std::nothrow_t&) {\cf17 const}& {\cf17 noexcept} \{{\cf19 return} this->local_datetime_;\}\par
1216     local_date      {\cf17 const}& as_local_date     ({\cf17 const} std::nothrow_t&) {\cf17 const}& {\cf17 noexcept} \{{\cf19 return} this->local_date_;\}\par
1217     local_time      {\cf17 const}& as_local_time     ({\cf17 const} std::nothrow_t&) {\cf17 const}& {\cf17 noexcept} \{{\cf19 return} this->local_time_;\}\par
1218     array_type      {\cf17 const}& as_array          ({\cf17 const} std::nothrow_t&) {\cf17 const}& {\cf17 noexcept} \{{\cf19 return} this->array_.value();\}\par
1219     table_type      {\cf17 const}& as_table          ({\cf17 const} std::nothrow_t&) {\cf17 const}& {\cf17 noexcept} \{{\cf19 return} this->table_.value();\}\par
1220 \par
1221     {\cf18 boolean}        & as_boolean        ({\cf17 const} std::nothrow_t&) & {\cf17 noexcept} \{{\cf19 return} this->boolean_;\}\par
1222     integer        & as_integer        ({\cf17 const} std::nothrow_t&) & {\cf17 noexcept} \{{\cf19 return} this->integer_;\}\par
1223     floating       & as_floating       ({\cf17 const} std::nothrow_t&) & {\cf17 noexcept} \{{\cf19 return} this->floating_;\}\par
1224     {\cf18 string}         & as_string         ({\cf17 const} std::nothrow_t&) & {\cf17 noexcept} \{{\cf19 return} this->string_;\}\par
1225     offset_datetime& as_offset_datetime({\cf17 const} std::nothrow_t&) & {\cf17 noexcept} \{{\cf19 return} this->offset_datetime_;\}\par
1226     local_datetime & as_local_datetime ({\cf17 const} std::nothrow_t&) & {\cf17 noexcept} \{{\cf19 return} this->local_datetime_;\}\par
1227     local_date     & as_local_date     ({\cf17 const} std::nothrow_t&) & {\cf17 noexcept} \{{\cf19 return} this->local_date_;\}\par
1228     local_time     & as_local_time     ({\cf17 const} std::nothrow_t&) & {\cf17 noexcept} \{{\cf19 return} this->local_time_;\}\par
1229     array_type     & as_array          ({\cf17 const} std::nothrow_t&) & {\cf17 noexcept} \{{\cf19 return} this->array_.value();\}\par
1230     table_type     & as_table          ({\cf17 const} std::nothrow_t&) & {\cf17 noexcept} \{{\cf19 return} this->table_.value();\}\par
1231 \par
1232     {\cf18 boolean}        && as_boolean        ({\cf17 const} std::nothrow_t&) && {\cf17 noexcept} \{{\cf19 return} std::move(this->boolean_);\}\par
1233     integer        && as_integer        ({\cf17 const} std::nothrow_t&) && {\cf17 noexcept} \{{\cf19 return} std::move(this->integer_);\}\par
1234     floating       && as_floating       ({\cf17 const} std::nothrow_t&) && {\cf17 noexcept} \{{\cf19 return} std::move(this->floating_);\}\par
1235     {\cf18 string}         && as_string         ({\cf17 const} std::nothrow_t&) && {\cf17 noexcept} \{{\cf19 return} std::move(this->string_);\}\par
1236     offset_datetime&& as_offset_datetime({\cf17 const} std::nothrow_t&) && {\cf17 noexcept} \{{\cf19 return} std::move(this->offset_datetime_);\}\par
1237     local_datetime && as_local_datetime ({\cf17 const} std::nothrow_t&) && {\cf17 noexcept} \{{\cf19 return} std::move(this->local_datetime_);\}\par
1238     local_date     && as_local_date     ({\cf17 const} std::nothrow_t&) && {\cf17 noexcept} \{{\cf19 return} std::move(this->local_date_);\}\par
1239     local_time     && as_local_time     ({\cf17 const} std::nothrow_t&) && {\cf17 noexcept} \{{\cf19 return} std::move(this->local_time_);\}\par
1240     array_type     && as_array          ({\cf17 const} std::nothrow_t&) && {\cf17 noexcept} \{{\cf19 return} std::move(this->array_.value());\}\par
1241     table_type     && as_table          ({\cf17 const} std::nothrow_t&) && {\cf17 noexcept} \{{\cf19 return} std::move(this->table_.value());\}\par
1242 \par
1243     {\cf20 // ========================================================================}\par
1244     {\cf20 // throw version}\par
1245     {\cf20 // ------------------------------------------------------------------------}\par
1246     {\cf20 // const reference \{\{\{}\par
1247 \par
1248     {\cf18 boolean} {\cf17 const}& as_boolean() const&\par
1249     \{\par
1250         {\cf19 if}(this->type_ != value_t::boolean)\par
1251         \{\par
1252             detail::throw_bad_cast<value_t::boolean>(\par
1253                     {\cf22 "toml::value::as_boolean(): "}, this->type_, *{\cf17 this});\par
1254         \}\par
1255         {\cf19 return} this->boolean_;\par
1256     \}\par
1257     integer {\cf17 const}& as_integer() const&\par
1258     \{\par
1259         {\cf19 if}(this->type_ != value_t::integer)\par
1260         \{\par
1261             detail::throw_bad_cast<value_t::integer>(\par
1262                     {\cf22 "toml::value::as_integer(): "}, this->type_, *{\cf17 this});\par
1263         \}\par
1264         {\cf19 return} this->integer_;\par
1265     \}\par
1266     floating {\cf17 const}& as_floating() const&\par
1267     \{\par
1268         {\cf19 if}(this->type_ != value_t::floating)\par
1269         \{\par
1270             detail::throw_bad_cast<value_t::floating>(\par
1271                     {\cf22 "toml::value::as_floating(): "}, this->type_, *{\cf17 this});\par
1272         \}\par
1273         {\cf19 return} this->floating_;\par
1274     \}\par
1275     {\cf18 string} {\cf17 const}& as_string() const&\par
1276     \{\par
1277         {\cf19 if}(this->type_ != value_t::string)\par
1278         \{\par
1279             detail::throw_bad_cast<value_t::string>(\par
1280                     {\cf22 "toml::value::as_string(): "}, this->type_, *{\cf17 this});\par
1281         \}\par
1282         {\cf19 return} this->string_;\par
1283     \}\par
1284     offset_datetime {\cf17 const}& as_offset_datetime() const&\par
1285     \{\par
1286         {\cf19 if}(this->type_ != value_t::offset_datetime)\par
1287         \{\par
1288             detail::throw_bad_cast<value_t::offset_datetime>(\par
1289                     {\cf22 "toml::value::as_offset_datetime(): "}, this->type_, *{\cf17 this});\par
1290         \}\par
1291         {\cf19 return} this->offset_datetime_;\par
1292     \}\par
1293     local_datetime {\cf17 const}& as_local_datetime() const&\par
1294     \{\par
1295         {\cf19 if}(this->type_ != value_t::local_datetime)\par
1296         \{\par
1297             detail::throw_bad_cast<value_t::local_datetime>(\par
1298                     {\cf22 "toml::value::as_local_datetime(): "}, this->type_, *{\cf17 this});\par
1299         \}\par
1300         {\cf19 return} this->local_datetime_;\par
1301     \}\par
1302     local_date {\cf17 const}& as_local_date() const&\par
1303     \{\par
1304         {\cf19 if}(this->type_ != value_t::local_date)\par
1305         \{\par
1306             detail::throw_bad_cast<value_t::local_date>(\par
1307                     {\cf22 "toml::value::as_local_date(): "}, this->type_, *{\cf17 this});\par
1308         \}\par
1309         {\cf19 return} this->local_date_;\par
1310     \}\par
1311     local_time {\cf17 const}& as_local_time() const&\par
1312     \{\par
1313         {\cf19 if}(this->type_ != value_t::local_time)\par
1314         \{\par
1315             detail::throw_bad_cast<value_t::local_time>(\par
1316                     {\cf22 "toml::value::as_local_time(): "}, this->type_, *{\cf17 this});\par
1317         \}\par
1318         {\cf19 return} this->local_time_;\par
1319     \}\par
1320     array_type {\cf17 const}& as_array() const&\par
1321     \{\par
1322         {\cf19 if}(this->type_ != value_t::array)\par
1323         \{\par
1324             detail::throw_bad_cast<value_t::array>(\par
1325                     {\cf22 "toml::value::as_array(): "}, this->type_, *{\cf17 this});\par
1326         \}\par
1327         {\cf19 return} this->array_.value();\par
1328     \}\par
1329     table_type {\cf17 const}& as_table() const&\par
1330     \{\par
1331         {\cf19 if}(this->type_ != value_t::table)\par
1332         \{\par
1333             detail::throw_bad_cast<value_t::table>(\par
1334                     {\cf22 "toml::value::as_table(): "}, this->type_, *{\cf17 this});\par
1335         \}\par
1336         {\cf19 return} this->table_.value();\par
1337     \}\par
1338     {\cf20 // \}\}\}}\par
1339     {\cf20 // ------------------------------------------------------------------------}\par
1340     {\cf20 // nonconst reference \{\{\{}\par
1341 \par
1342     {\cf18 boolean} & as_boolean() &\par
1343     \{\par
1344         {\cf19 if}(this->type_ != value_t::boolean)\par
1345         \{\par
1346             detail::throw_bad_cast<value_t::boolean>(\par
1347                     {\cf22 "toml::value::as_boolean(): "}, this->type_, *{\cf17 this});\par
1348         \}\par
1349         {\cf19 return} this->boolean_;\par
1350     \}\par
1351     integer & as_integer() &\par
1352     \{\par
1353         {\cf19 if}(this->type_ != value_t::integer)\par
1354         \{\par
1355             detail::throw_bad_cast<value_t::integer>(\par
1356                     {\cf22 "toml::value::as_integer(): "}, this->type_, *{\cf17 this});\par
1357         \}\par
1358         {\cf19 return} this->integer_;\par
1359     \}\par
1360     floating & as_floating() &\par
1361     \{\par
1362         {\cf19 if}(this->type_ != value_t::floating)\par
1363         \{\par
1364             detail::throw_bad_cast<value_t::floating>(\par
1365                     {\cf22 "toml::value::as_floating(): "}, this->type_, *{\cf17 this});\par
1366         \}\par
1367         {\cf19 return} this->floating_;\par
1368     \}\par
1369     {\cf18 string} & as_string() &\par
1370     \{\par
1371         {\cf19 if}(this->type_ != value_t::string)\par
1372         \{\par
1373             detail::throw_bad_cast<value_t::string>(\par
1374                     {\cf22 "toml::value::as_string(): "}, this->type_, *{\cf17 this});\par
1375         \}\par
1376         {\cf19 return} this->string_;\par
1377     \}\par
1378     offset_datetime & as_offset_datetime() &\par
1379     \{\par
1380         {\cf19 if}(this->type_ != value_t::offset_datetime)\par
1381         \{\par
1382             detail::throw_bad_cast<value_t::offset_datetime>(\par
1383                     {\cf22 "toml::value::as_offset_datetime(): "}, this->type_, *{\cf17 this});\par
1384         \}\par
1385         {\cf19 return} this->offset_datetime_;\par
1386     \}\par
1387     local_datetime & as_local_datetime() &\par
1388     \{\par
1389         {\cf19 if}(this->type_ != value_t::local_datetime)\par
1390         \{\par
1391             detail::throw_bad_cast<value_t::local_datetime>(\par
1392                     {\cf22 "toml::value::as_local_datetime(): "}, this->type_, *{\cf17 this});\par
1393         \}\par
1394         {\cf19 return} this->local_datetime_;\par
1395     \}\par
1396     local_date & as_local_date() &\par
1397     \{\par
1398         {\cf19 if}(this->type_ != value_t::local_date)\par
1399         \{\par
1400             detail::throw_bad_cast<value_t::local_date>(\par
1401                     {\cf22 "toml::value::as_local_date(): "}, this->type_, *{\cf17 this});\par
1402         \}\par
1403         {\cf19 return} this->local_date_;\par
1404     \}\par
1405     local_time & as_local_time() &\par
1406     \{\par
1407         {\cf19 if}(this->type_ != value_t::local_time)\par
1408         \{\par
1409             detail::throw_bad_cast<value_t::local_time>(\par
1410                     {\cf22 "toml::value::as_local_time(): "}, this->type_, *{\cf17 this});\par
1411         \}\par
1412         {\cf19 return} this->local_time_;\par
1413     \}\par
1414     array_type & as_array() &\par
1415     \{\par
1416         {\cf19 if}(this->type_ != value_t::array)\par
1417         \{\par
1418             detail::throw_bad_cast<value_t::array>(\par
1419                     {\cf22 "toml::value::as_array(): "}, this->type_, *{\cf17 this});\par
1420         \}\par
1421         {\cf19 return} this->array_.value();\par
1422     \}\par
1423     table_type & as_table() &\par
1424     \{\par
1425         {\cf19 if}(this->type_ != value_t::table)\par
1426         \{\par
1427             detail::throw_bad_cast<value_t::table>(\par
1428                     {\cf22 "toml::value::as_table(): "}, this->type_, *{\cf17 this});\par
1429         \}\par
1430         {\cf19 return} this->table_.value();\par
1431     \}\par
1432 \par
1433     {\cf20 // \}\}\}}\par
1434     {\cf20 // ------------------------------------------------------------------------}\par
1435     {\cf20 // rvalue reference \{\{\{}\par
1436 \par
1437     {\cf18 boolean} && as_boolean() &&\par
1438     \{\par
1439         {\cf19 if}(this->type_ != value_t::boolean)\par
1440         \{\par
1441             detail::throw_bad_cast<value_t::boolean>(\par
1442                     {\cf22 "toml::value::as_boolean(): "}, this->type_, *{\cf17 this});\par
1443         \}\par
1444         {\cf19 return} std::move(this->boolean_);\par
1445     \}\par
1446     integer && as_integer() &&\par
1447     \{\par
1448         {\cf19 if}(this->type_ != value_t::integer)\par
1449         \{\par
1450             detail::throw_bad_cast<value_t::integer>(\par
1451                     {\cf22 "toml::value::as_integer(): "}, this->type_, *{\cf17 this});\par
1452         \}\par
1453         {\cf19 return} std::move(this->integer_);\par
1454     \}\par
1455     floating && as_floating() &&\par
1456     \{\par
1457         {\cf19 if}(this->type_ != value_t::floating)\par
1458         \{\par
1459             detail::throw_bad_cast<value_t::floating>(\par
1460                     {\cf22 "toml::value::as_floating(): "}, this->type_, *{\cf17 this});\par
1461         \}\par
1462         {\cf19 return} std::move(this->floating_);\par
1463     \}\par
1464     {\cf18 string} && as_string() &&\par
1465     \{\par
1466         {\cf19 if}(this->type_ != value_t::string)\par
1467         \{\par
1468             detail::throw_bad_cast<value_t::string>(\par
1469                     {\cf22 "toml::value::as_string(): "}, this->type_, *{\cf17 this});\par
1470         \}\par
1471         {\cf19 return} std::move(this->string_);\par
1472     \}\par
1473     offset_datetime && as_offset_datetime() &&\par
1474     \{\par
1475         {\cf19 if}(this->type_ != value_t::offset_datetime)\par
1476         \{\par
1477             detail::throw_bad_cast<value_t::offset_datetime>(\par
1478                     {\cf22 "toml::value::as_offset_datetime(): "}, this->type_, *{\cf17 this});\par
1479         \}\par
1480         {\cf19 return} std::move(this->offset_datetime_);\par
1481     \}\par
1482     local_datetime && as_local_datetime() &&\par
1483     \{\par
1484         {\cf19 if}(this->type_ != value_t::local_datetime)\par
1485         \{\par
1486             detail::throw_bad_cast<value_t::local_datetime>(\par
1487                     {\cf22 "toml::value::as_local_datetime(): "}, this->type_, *{\cf17 this});\par
1488         \}\par
1489         {\cf19 return} std::move(this->local_datetime_);\par
1490     \}\par
1491     local_date && as_local_date() &&\par
1492     \{\par
1493         {\cf19 if}(this->type_ != value_t::local_date)\par
1494         \{\par
1495             detail::throw_bad_cast<value_t::local_date>(\par
1496                     {\cf22 "toml::value::as_local_date(): "}, this->type_, *{\cf17 this});\par
1497         \}\par
1498         {\cf19 return} std::move(this->local_date_);\par
1499     \}\par
1500     local_time && as_local_time() &&\par
1501     \{\par
1502         {\cf19 if}(this->type_ != value_t::local_time)\par
1503         \{\par
1504             detail::throw_bad_cast<value_t::local_time>(\par
1505                     {\cf22 "toml::value::as_local_time(): "}, this->type_, *{\cf17 this});\par
1506         \}\par
1507         {\cf19 return} std::move(this->local_time_);\par
1508     \}\par
1509     array_type && as_array() &&\par
1510     \{\par
1511         {\cf19 if}(this->type_ != value_t::array)\par
1512         \{\par
1513             detail::throw_bad_cast<value_t::array>(\par
1514                     {\cf22 "toml::value::as_array(): "}, this->type_, *{\cf17 this});\par
1515         \}\par
1516         {\cf19 return} std::move(this->array_.value());\par
1517     \}\par
1518     table_type && as_table() &&\par
1519     \{\par
1520         {\cf19 if}(this->type_ != value_t::table)\par
1521         \{\par
1522             detail::throw_bad_cast<value_t::table>(\par
1523                     {\cf22 "toml::value::as_table(): "}, this->type_, *{\cf17 this});\par
1524         \}\par
1525         {\cf19 return} std::move(this->table_.value());\par
1526     \}\par
1527     {\cf20 // \}\}\}}\par
1528 \par
1529     {\cf20 // accessors =============================================================}\par
1530     {\cf20 //}\par
1531     {\cf20 // may throw type_error or out_of_range}\par
1532     {\cf20 //}\par
1533     value_type&       at({\cf17 const} key& k)\par
1534     \{\par
1535         {\cf19 if}(!this->is_table())\par
1536         \{\par
1537             detail::throw_bad_cast<value_t::table>(\par
1538                 {\cf22 "toml::value::at(key): "}, this->type_, *{\cf17 this});\par
1539         \}\par
1540         {\cf19 if}(this->as_table(std::nothrow).count(k) == 0)\par
1541         \{\par
1542             detail::throw_key_not_found_error(*{\cf17 this}, k);\par
1543         \}\par
1544         {\cf19 return} this->as_table(std::nothrow).at(k);\par
1545     \}\par
1546     value_type {\cf17 const}& at({\cf17 const} key& k){\cf17  const}\par
1547 {\cf17     }\{\par
1548         {\cf19 if}(!this->is_table())\par
1549         \{\par
1550             detail::throw_bad_cast<value_t::table>(\par
1551                 {\cf22 "toml::value::at(key): "}, this->type_, *{\cf17 this});\par
1552         \}\par
1553         {\cf19 if}(this->as_table(std::nothrow).count(k) == 0)\par
1554         \{\par
1555             detail::throw_key_not_found_error(*{\cf17 this}, k);\par
1556         \}\par
1557         {\cf19 return} this->as_table(std::nothrow).at(k);\par
1558     \}\par
1559     value_type&       operator[]({\cf17 const} key& k)\par
1560     \{\par
1561         {\cf19 if}(this->is_uninitialized())\par
1562         \{\par
1563             *{\cf17 this} = table_type\{\};\par
1564         \}\par
1565         {\cf19 else} {\cf19 if}(!this->is_table()) {\cf20 // initialized, but not a table}\par
1566         \{\par
1567             detail::throw_bad_cast<value_t::table>(\par
1568                 {\cf22 "toml::value::operator[](key): "}, this->type_, *{\cf17 this});\par
1569         \}\par
1570         {\cf19 return} this->as_table(std::nothrow)[k];\par
1571     \}\par
1572 \par
1573     value_type&       at({\cf17 const} std::size_t idx)\par
1574     \{\par
1575         {\cf19 if}(!this->is_array())\par
1576         \{\par
1577             detail::throw_bad_cast<value_t::array>(\par
1578                 {\cf22 "toml::value::at(idx): "}, this->type_, *{\cf17 this});\par
1579         \}\par
1580         {\cf19 if}(this->as_array(std::nothrow).size() <= idx)\par
1581         \{\par
1582             {\cf19 throw} std::out_of_range(detail::format_underline(\par
1583                 {\cf22 "toml::value::at(idx): no element corresponding to the index"}, \{\par
1584                     \{this->location(), concat_to_string({\cf22 "the length is "},\par
1585                         this->as_array(std::nothrow).size(),\par
1586                         {\cf22 ", and the specified index is "}, idx)\}\par
1587                 \}));\par
1588         \}\par
1589         {\cf19 return} this->as_array().at(idx);\par
1590     \}\par
1591     value_type {\cf17 const}& at({\cf17 const} std::size_t idx){\cf17  const}\par
1592 {\cf17     }\{\par
1593         {\cf19 if}(!this->is_array())\par
1594         \{\par
1595             detail::throw_bad_cast<value_t::array>(\par
1596                 {\cf22 "toml::value::at(idx): "}, this->type_, *{\cf17 this});\par
1597         \}\par
1598         {\cf19 if}(this->as_array(std::nothrow).size() <= idx)\par
1599         \{\par
1600             {\cf19 throw} std::out_of_range(detail::format_underline(\par
1601                 {\cf22 "toml::value::at(idx): no element corresponding to the index"}, \{\par
1602                     \{this->location(), concat_to_string({\cf22 "the length is "},\par
1603                         this->as_array(std::nothrow).size(),\par
1604                         {\cf22 ", and the specified index is "}, idx)\}\par
1605                 \}));\par
1606         \}\par
1607         {\cf19 return} this->as_array(std::nothrow).at(idx);\par
1608     \}\par
1609 \par
1610     value_type&       operator[]({\cf17 const} std::size_t idx) {\cf17 noexcept}\par
1611     \{\par
1612         {\cf20 // no check...}\par
1613         {\cf19 return} this->as_array(std::nothrow)[idx];\par
1614     \}\par
1615     value_type {\cf17 const}& operator[]({\cf17 const} std::size_t idx) {\cf17 const} {\cf17 noexcept}\par
1616     \{\par
1617         {\cf20 // no check...}\par
1618         {\cf19 return} this->as_array(std::nothrow)[idx];\par
1619     \}\par
1620 \par
1621     {\cf18 void} push_back({\cf17 const} value_type& x)\par
1622     \{\par
1623         {\cf19 if}(!this->is_array())\par
1624         \{\par
1625             detail::throw_bad_cast<value_t::array>(\par
1626                 {\cf22 "toml::value::push_back(value): "}, this->type_, *{\cf17 this});\par
1627         \}\par
1628         this->as_array(std::nothrow).push_back(x);\par
1629         {\cf19 return};\par
1630     \}\par
1631     {\cf18 void} push_back(value_type&& x)\par
1632     \{\par
1633         {\cf19 if}(!this->is_array())\par
1634         \{\par
1635             detail::throw_bad_cast<value_t::array>(\par
1636                 {\cf22 "toml::value::push_back(value): "}, this->type_, *{\cf17 this});\par
1637         \}\par
1638         this->as_array(std::nothrow).push_back(std::move(x));\par
1639         {\cf19 return};\par
1640     \}\par
1641 \par
1642     {\cf17 template}<{\cf17 typename} ... Ts>\par
1643     value_type& emplace_back(Ts&& ... args)\par
1644     \{\par
1645         {\cf19 if}(!this->is_array())\par
1646         \{\par
1647             detail::throw_bad_cast<value_t::array>(\par
1648                 {\cf22 "toml::value::emplace_back(...): "}, this->type_, *{\cf17 this});\par
1649         \}\par
1650         this->as_array(std::nothrow).emplace_back(std::forward<Ts>(args) ...);\par
1651         {\cf19 return} this->as_array(std::nothrow).back();\par
1652     \}\par
1653 \par
1654     std::size_t size(){\cf17  const}\par
1655 {\cf17     }\{\par
1656         {\cf19 switch}(this->type_)\par
1657         \{\par
1658             {\cf19 case} value_t::array:\par
1659             \{\par
1660                 {\cf19 return} this->as_array(std::nothrow).size();\par
1661             \}\par
1662             {\cf19 case} value_t::table:\par
1663             \{\par
1664                 {\cf19 return} this->as_table(std::nothrow).size();\par
1665             \}\par
1666             {\cf19 case} value_t::string:\par
1667             \{\par
1668                 {\cf19 return} this->as_string(std::nothrow).str.size();\par
1669             \}\par
1670             {\cf19 default}:\par
1671             \{\par
1672                 {\cf19 throw} type_error(detail::format_underline(\par
1673                     {\cf22 "toml::value::size(): bad_cast to container types"}, \{\par
1674                         \{this->location(),\par
1675                          concat_to_string({\cf22 "the actual type is "}, this->type_)\}\par
1676                     \}), this->location());\par
1677             \}\par
1678         \}\par
1679     \}\par
1680 \par
1681     std::size_t count({\cf17 const} key_type& k){\cf17  const}\par
1682 {\cf17     }\{\par
1683         {\cf19 if}(!this->is_table())\par
1684         \{\par
1685             detail::throw_bad_cast<value_t::table>(\par
1686                 {\cf22 "toml::value::count(key): "}, this->type_, *{\cf17 this});\par
1687         \}\par
1688         {\cf19 return} this->as_table(std::nothrow).count(k);\par
1689     \}\par
1690 \par
1691     {\cf18 bool} contains({\cf17 const} key_type& k){\cf17  const}\par
1692 {\cf17     }\{\par
1693         {\cf19 if}(!this->is_table())\par
1694         \{\par
1695             detail::throw_bad_cast<value_t::table>(\par
1696                 {\cf22 "toml::value::contains(key): "}, this->type_, *{\cf17 this});\par
1697         \}\par
1698         {\cf19 return} (this->as_table(std::nothrow).count(k) != 0);\par
1699     \}\par
1700 \par
1701     source_location location(){\cf17  const}\par
1702 {\cf17     }\{\par
1703         {\cf19 return} source_location(this->region_info_.get());\par
1704     \}\par
1705 \par
1706     comment_type {\cf17 const}& comments() const noexcept \{{\cf19 return} this->comments_;\}\par
1707     comment_type&       comments()       noexcept \{{\cf19 return} this->comments_;\}\par
1708 \par
1709   {\cf17 private}:\par
1710 \par
1711     {\cf18 void} cleanup() noexcept\par
1712     \{\par
1713         {\cf19 switch}(this->type_)\par
1714         \{\par
1715             {\cf19 case} value_t::string  : \{string_.~string();       {\cf19 return};\}\par
1716             {\cf19 case} value_t::array   : \{array_.~array_storage(); {\cf19 return};\}\par
1717             {\cf19 case} value_t::table   : \{table_.~table_storage(); {\cf19 return};\}\par
1718             default              : {\cf19 return};\par
1719         \}\par
1720     \}\par
1721 \par
1722     {\cf20 // for error messages}\par
1723     {\cf17 template}<{\cf17 typename} Value>\par
1724     {\cf17 friend} region_base {\cf17 const}* detail::get_region({\cf17 const} Value& v);\par
1725 \par
1726     {\cf17 template}<{\cf17 typename} Value>\par
1727     {\cf17 friend} {\cf18 void} detail::change_region(Value& v, detail::region reg);\par
1728 \par
1729   {\cf17 private}:\par
1730 \par
1731     {\cf17 using }array_storage = detail::storage<array_type>;\par
1732     {\cf17 using }table_storage = detail::storage<table_type>;\par
1733 \par
1734     value_t type_;\par
1735     {\cf17 union}\par
1736     \{\par
1737         {\cf18 boolean}         boolean_;\par
1738         integer         integer_;\par
1739         floating        floating_;\par
1740         {\cf18 string}          string_;\par
1741         offset_datetime offset_datetime_;\par
1742         local_datetime  local_datetime_;\par
1743         local_date      local_date_;\par
1744         local_time      local_time_;\par
1745         array_storage   array_;\par
1746         table_storage   table_;\par
1747     \};\par
1748     std::shared_ptr<region_base> region_info_;\par
1749     comment_type                 comments_;\par
1750 \};\par
1751 \par
1752 {\cf20 // default toml::value and default array/table.}\par
1753 {\cf20 // TOML11_DEFAULT_COMMENT_STRATEGY is defined in comments.hpp}\par
1754 {\cf17 using }value = basic_value<TOML11_DEFAULT_COMMENT_STRATEGY, std::unordered_map, std::vector>;\par
1755 {\cf17 using }array = {\cf17 typename} value::array_type;\par
1756 {\cf17 using }table = {\cf17 typename} value::table_type;\par
1757 \par
1758 {\cf17 template}<{\cf17 typename} C, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
1759 {\cf17 inline} {\cf18 bool}\par
1760 operator==({\cf17 const} basic_value<C, T, A>& lhs, {\cf17 const} basic_value<C, T, A>& rhs)\par
1761 \{\par
1762     {\cf19 if}(lhs.type()     != rhs.type())     \{{\cf19 return} {\cf17 false};\}\par
1763     {\cf19 if}(lhs.comments() != rhs.comments()) \{{\cf19 return} {\cf17 false};\}\par
1764 \par
1765     {\cf19 switch}(lhs.type())\par
1766     \{\par
1767         {\cf19 case} value_t::boolean  :\par
1768         \{\par
1769             {\cf19 return} lhs.as_boolean() == rhs.as_boolean();\par
1770         \}\par
1771         {\cf19 case} value_t::integer  :\par
1772         \{\par
1773             {\cf19 return} lhs.as_integer() == rhs.as_integer();\par
1774         \}\par
1775         {\cf19 case} value_t::floating :\par
1776         \{\par
1777             {\cf19 return} lhs.as_floating() == rhs.as_floating();\par
1778         \}\par
1779         {\cf19 case} value_t::string   :\par
1780         \{\par
1781             {\cf19 return} lhs.as_string() == rhs.as_string();\par
1782         \}\par
1783         {\cf19 case} value_t::offset_datetime:\par
1784         \{\par
1785             {\cf19 return} lhs.as_offset_datetime() == rhs.as_offset_datetime();\par
1786         \}\par
1787         {\cf19 case} value_t::local_datetime:\par
1788         \{\par
1789             {\cf19 return} lhs.as_local_datetime() == rhs.as_local_datetime();\par
1790         \}\par
1791         {\cf19 case} value_t::local_date:\par
1792         \{\par
1793             {\cf19 return} lhs.as_local_date() == rhs.as_local_date();\par
1794         \}\par
1795         {\cf19 case} value_t::local_time:\par
1796         \{\par
1797             {\cf19 return} lhs.as_local_time() == rhs.as_local_time();\par
1798         \}\par
1799         {\cf19 case} value_t::array    :\par
1800         \{\par
1801             {\cf19 return} lhs.as_array() == rhs.as_array();\par
1802         \}\par
1803         {\cf19 case} value_t::table    :\par
1804         \{\par
1805             {\cf19 return} lhs.as_table() == rhs.as_table();\par
1806         \}\par
1807         {\cf19 case} value_t::empty    : \{{\cf19 return} {\cf17 true}; \}\par
1808         {\cf19 default}:                 \{{\cf19 return} {\cf17 false};\}\par
1809     \}\par
1810 \}\par
1811 \par
1812 {\cf17 template}<{\cf17 typename} C, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
1813 {\cf17 inline} {\cf18 bool} operator!=({\cf17 const} basic_value<C, T, A>& lhs, {\cf17 const} basic_value<C, T, A>& rhs)\par
1814 \{\par
1815     {\cf19 return} !(lhs == rhs);\par
1816 \}\par
1817 \par
1818 {\cf17 template}<{\cf17 typename} C, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
1819 {\cf17 typename} std::enable_if<detail::conjunction<\par
1820     detail::is_comparable<typename basic_value<C, T, A>::array_type>,\par
1821     detail::is_comparable<typename basic_value<C, T, A>::table_type>\par
1822     >::value, {\cf18 bool}>::type\par
1823 operator<({\cf17 const} basic_value<C, T, A>& lhs, {\cf17 const} basic_value<C, T, A>& rhs)\par
1824 \{\par
1825     {\cf19 if}(lhs.type() != rhs.type())\{{\cf19 return} (lhs.type() < rhs.type());\}\par
1826     {\cf19 switch}(lhs.type())\par
1827     \{\par
1828         {\cf19 case} value_t::boolean  :\par
1829         \{\par
1830             {\cf19 return} lhs.as_boolean() <  rhs.as_boolean() ||\par
1831                   (lhs.as_boolean() == rhs.as_boolean() &&\par
1832                    lhs.comments() < rhs.comments());\par
1833         \}\par
1834         {\cf19 case} value_t::integer  :\par
1835         \{\par
1836             {\cf19 return} lhs.as_integer() <  rhs.as_integer() ||\par
1837                   (lhs.as_integer() == rhs.as_integer() &&\par
1838                    lhs.comments() < rhs.comments());\par
1839         \}\par
1840         {\cf19 case} value_t::floating :\par
1841         \{\par
1842             {\cf19 return} lhs.as_floating() <  rhs.as_floating() ||\par
1843                   (lhs.as_floating() == rhs.as_floating() &&\par
1844                    lhs.comments() < rhs.comments());\par
1845         \}\par
1846         {\cf19 case} value_t::string   :\par
1847         \{\par
1848             {\cf19 return} lhs.as_string() <  rhs.as_string() ||\par
1849                   (lhs.as_string() == rhs.as_string() &&\par
1850                    lhs.comments() < rhs.comments());\par
1851         \}\par
1852         {\cf19 case} value_t::offset_datetime:\par
1853         \{\par
1854             {\cf19 return} lhs.as_offset_datetime() <  rhs.as_offset_datetime() ||\par
1855                   (lhs.as_offset_datetime() == rhs.as_offset_datetime() &&\par
1856                    lhs.comments() < rhs.comments());\par
1857         \}\par
1858         {\cf19 case} value_t::local_datetime:\par
1859         \{\par
1860             {\cf19 return} lhs.as_local_datetime() <  rhs.as_local_datetime() ||\par
1861                   (lhs.as_local_datetime() == rhs.as_local_datetime() &&\par
1862                    lhs.comments() < rhs.comments());\par
1863         \}\par
1864         {\cf19 case} value_t::local_date:\par
1865         \{\par
1866             {\cf19 return} lhs.as_local_date() <  rhs.as_local_date() ||\par
1867                   (lhs.as_local_date() == rhs.as_local_date() &&\par
1868                    lhs.comments() < rhs.comments());\par
1869         \}\par
1870         {\cf19 case} value_t::local_time:\par
1871         \{\par
1872             {\cf19 return} lhs.as_local_time() <  rhs.as_local_time() ||\par
1873                   (lhs.as_local_time() == rhs.as_local_time() &&\par
1874                    lhs.comments() < rhs.comments());\par
1875         \}\par
1876         {\cf19 case} value_t::array    :\par
1877         \{\par
1878             {\cf19 return} lhs.as_array() <  rhs.as_array() ||\par
1879                   (lhs.as_array() == rhs.as_array() &&\par
1880                    lhs.comments() < rhs.comments());\par
1881         \}\par
1882         {\cf19 case} value_t::table    :\par
1883         \{\par
1884             {\cf19 return} lhs.as_table() <  rhs.as_table() ||\par
1885                   (lhs.as_table() == rhs.as_table() &&\par
1886                    lhs.comments() < rhs.comments());\par
1887         \}\par
1888         {\cf19 case} value_t::empty    :\par
1889         \{\par
1890             {\cf19 return} lhs.comments() < rhs.comments();\par
1891         \}\par
1892         {\cf19 default}:\par
1893         \{\par
1894             {\cf19 return} lhs.comments() < rhs.comments();\par
1895         \}\par
1896     \}\par
1897 \}\par
1898 \par
1899 {\cf17 template}<{\cf17 typename} C, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
1900 {\cf17 typename} std::enable_if<detail::conjunction<\par
1901     detail::is_comparable<typename basic_value<C, T, A>::array_type>,\par
1902     detail::is_comparable<typename basic_value<C, T, A>::table_type>\par
1903     >::value, {\cf18 bool}>::type\par
1904 operator<=({\cf17 const} basic_value<C, T, A>& lhs, {\cf17 const} basic_value<C, T, A>& rhs)\par
1905 \{\par
1906     {\cf19 return} (lhs < rhs) || (lhs == rhs);\par
1907 \}\par
1908 {\cf17 template}<{\cf17 typename} C, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
1909 {\cf17 typename} std::enable_if<detail::conjunction<\par
1910     detail::is_comparable<typename basic_value<C, T, A>::array_type>,\par
1911     detail::is_comparable<typename basic_value<C, T, A>::table_type>\par
1912     >::value, {\cf18 bool}>::type\par
1913 operator>({\cf17 const} basic_value<C, T, A>& lhs, {\cf17 const} basic_value<C, T, A>& rhs)\par
1914 \{\par
1915     {\cf19 return} !(lhs <= rhs);\par
1916 \}\par
1917 {\cf17 template}<{\cf17 typename} C, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
1918 {\cf17 typename} std::enable_if<detail::conjunction<\par
1919     detail::is_comparable<typename basic_value<C, T, A>::array_type>,\par
1920     detail::is_comparable<typename basic_value<C, T, A>::table_type>\par
1921     >::value, {\cf18 bool}>::type\par
1922 operator>=({\cf17 const} basic_value<C, T, A>& lhs, {\cf17 const} basic_value<C, T, A>& rhs)\par
1923 \{\par
1924     {\cf19 return} !(lhs < rhs);\par
1925 \}\par
1926 \par
1927 {\cf17 template}<{\cf17 typename} C, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
1928 {\cf17 inline} std::string format_error({\cf17 const} std::string& err_msg,\par
1929         {\cf17 const} basic_value<C, T, A>& v, {\cf17 const} std::string& comment,\par
1930         std::vector<std::string> hints = \{\},\par
1931         {\cf17 const} {\cf18 bool} colorize = TOML11_ERROR_MESSAGE_COLORIZED)\par
1932 \{\par
1933     {\cf19 return} detail::format_underline(err_msg, \{\{v.location(), comment\}\},\par
1934                                     std::move(hints), colorize);\par
1935 \}\par
1936 \par
1937 {\cf17 template}<{\cf17 typename} C, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
1938 {\cf17 inline} std::string format_error({\cf17 const} std::string& err_msg,\par
1939         {\cf17 const} toml::basic_value<C, T, A>& v1, {\cf17 const} std::string& comment1,\par
1940         {\cf17 const} toml::basic_value<C, T, A>& v2, {\cf17 const} std::string& comment2,\par
1941         std::vector<std::string> hints = \{\},\par
1942         {\cf17 const} {\cf18 bool} colorize = TOML11_ERROR_MESSAGE_COLORIZED)\par
1943 \{\par
1944     {\cf19 return} detail::format_underline(err_msg, \{\par
1945             \{v1.location(), comment1\}, \{v2.location(), comment2\}\par
1946         \}, std::move(hints), colorize);\par
1947 \}\par
1948 \par
1949 {\cf17 template}<{\cf17 typename} C, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
1950 {\cf17 inline} std::string format_error({\cf17 const} std::string& err_msg,\par
1951         {\cf17 const} toml::basic_value<C, T, A>& v1, {\cf17 const} std::string& comment1,\par
1952         {\cf17 const} toml::basic_value<C, T, A>& v2, {\cf17 const} std::string& comment2,\par
1953         {\cf17 const} toml::basic_value<C, T, A>& v3, {\cf17 const} std::string& comment3,\par
1954         std::vector<std::string> hints = \{\},\par
1955         {\cf17 const} {\cf18 bool} colorize = TOML11_ERROR_MESSAGE_COLORIZED)\par
1956 \{\par
1957     {\cf19 return} detail::format_underline(err_msg, \{\{v1.location(), comment1\},\par
1958             \{v2.location(), comment2\}, \{v3.location(), comment3\}\par
1959         \}, std::move(hints), colorize);\par
1960 \}\par
1961 \par
1962 {\cf17 template}<{\cf17 typename} Visitor, {\cf17 typename} C,\par
1963          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
1964 detail::return_type_of_t<Visitor, const toml::boolean&>\par
1965 visit(Visitor&& visitor, {\cf17 const} toml::basic_value<C, T, A>& v)\par
1966 \{\par
1967     {\cf19 switch}(v.type())\par
1968     \{\par
1969         {\cf19 case} value_t::boolean        : \{{\cf19 return} visitor(v.as_boolean        ());\}\par
1970         {\cf19 case} value_t::integer        : \{{\cf19 return} visitor(v.as_integer        ());\}\par
1971         {\cf19 case} value_t::floating       : \{{\cf19 return} visitor(v.as_floating       ());\}\par
1972         {\cf19 case} value_t::string         : \{{\cf19 return} visitor(v.as_string         ());\}\par
1973         {\cf19 case} value_t::offset_datetime: \{{\cf19 return} visitor(v.as_offset_datetime());\}\par
1974         {\cf19 case} value_t::local_datetime : \{{\cf19 return} visitor(v.as_local_datetime ());\}\par
1975         {\cf19 case} value_t::local_date     : \{{\cf19 return} visitor(v.as_local_date     ());\}\par
1976         {\cf19 case} value_t::local_time     : \{{\cf19 return} visitor(v.as_local_time     ());\}\par
1977         {\cf19 case} value_t::array          : \{{\cf19 return} visitor(v.as_array          ());\}\par
1978         {\cf19 case} value_t::table          : \{{\cf19 return} visitor(v.as_table          ());\}\par
1979         {\cf19 case} value_t::empty          : {\cf19 break};\par
1980         {\cf19 default}: {\cf19 break};\par
1981     \}\par
1982     {\cf19 throw} std::runtime_error(format_error({\cf22 "[error] toml::visit: toml::basic_value "}\par
1983             {\cf22 "does not have any valid basic_value."}, v, {\cf22 "here"}));\par
1984 \}\par
1985 \par
1986 {\cf17 template}<{\cf17 typename} Visitor, {\cf17 typename} C,\par
1987          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
1988 detail::return_type_of_t<Visitor, toml::boolean&>\par
1989 visit(Visitor&& visitor, toml::basic_value<C, T, A>& v)\par
1990 \{\par
1991     {\cf19 switch}(v.type())\par
1992     \{\par
1993         {\cf19 case} value_t::boolean        : \{{\cf19 return} visitor(v.as_boolean        ());\}\par
1994         {\cf19 case} value_t::integer        : \{{\cf19 return} visitor(v.as_integer        ());\}\par
1995         {\cf19 case} value_t::floating       : \{{\cf19 return} visitor(v.as_floating       ());\}\par
1996         {\cf19 case} value_t::string         : \{{\cf19 return} visitor(v.as_string         ());\}\par
1997         {\cf19 case} value_t::offset_datetime: \{{\cf19 return} visitor(v.as_offset_datetime());\}\par
1998         {\cf19 case} value_t::local_datetime : \{{\cf19 return} visitor(v.as_local_datetime ());\}\par
1999         {\cf19 case} value_t::local_date     : \{{\cf19 return} visitor(v.as_local_date     ());\}\par
2000         {\cf19 case} value_t::local_time     : \{{\cf19 return} visitor(v.as_local_time     ());\}\par
2001         {\cf19 case} value_t::array          : \{{\cf19 return} visitor(v.as_array          ());\}\par
2002         {\cf19 case} value_t::table          : \{{\cf19 return} visitor(v.as_table          ());\}\par
2003         {\cf19 case} value_t::empty          : {\cf19 break};\par
2004         {\cf19 default}: {\cf19 break};\par
2005     \}\par
2006     {\cf19 throw} std::runtime_error(format_error({\cf22 "[error] toml::visit: toml::basic_value "}\par
2007             {\cf22 "does not have any valid basic_value."}, v, {\cf22 "here"}));\par
2008 \}\par
2009 \par
2010 {\cf17 template}<{\cf17 typename} Visitor, {\cf17 typename} C,\par
2011          {\cf17 template}<{\cf17 typename} ...> {\cf17 class }T, {\cf17 template}<{\cf17 typename} ...> {\cf17 class }A>\par
2012 detail::return_type_of_t<Visitor, toml::boolean&&>\par
2013 visit(Visitor&& visitor, toml::basic_value<C, T, A>&& v)\par
2014 \{\par
2015     {\cf19 switch}(v.type())\par
2016     \{\par
2017         {\cf19 case} value_t::boolean        : \{{\cf19 return} visitor(std::move(v.as_boolean        ()));\}\par
2018         {\cf19 case} value_t::integer        : \{{\cf19 return} visitor(std::move(v.as_integer        ()));\}\par
2019         {\cf19 case} value_t::floating       : \{{\cf19 return} visitor(std::move(v.as_floating       ()));\}\par
2020         {\cf19 case} value_t::string         : \{{\cf19 return} visitor(std::move(v.as_string         ()));\}\par
2021         {\cf19 case} value_t::offset_datetime: \{{\cf19 return} visitor(std::move(v.as_offset_datetime()));\}\par
2022         {\cf19 case} value_t::local_datetime : \{{\cf19 return} visitor(std::move(v.as_local_datetime ()));\}\par
2023         {\cf19 case} value_t::local_date     : \{{\cf19 return} visitor(std::move(v.as_local_date     ()));\}\par
2024         {\cf19 case} value_t::local_time     : \{{\cf19 return} visitor(std::move(v.as_local_time     ()));\}\par
2025         {\cf19 case} value_t::array          : \{{\cf19 return} visitor(std::move(v.as_array          ()));\}\par
2026         {\cf19 case} value_t::table          : \{{\cf19 return} visitor(std::move(v.as_table          ()));\}\par
2027         {\cf19 case} value_t::empty          : {\cf19 break};\par
2028         {\cf19 default}: {\cf19 break};\par
2029     \}\par
2030     {\cf19 throw} std::runtime_error(format_error({\cf22 "[error] toml::visit: toml::basic_value "}\par
2031             {\cf22 "does not have any valid basic_value."}, v, {\cf22 "here"}));\par
2032 \}\par
2033 \par
2034 \}{\cf20 // toml}\par
2035 {\cf21 #endif}{\cf20 // TOML11_VALUE}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
external/toml/version.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v external/toml/version.hpp}
{\xe \v external/toml/version.hpp}
{\bkmkstart AAAAAAAAEM}
{\bkmkend AAAAAAAAEM}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macros\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TOML11_CPLUSPLUS_STANDARD_VERSION}\~ __cplusplus\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Macro Definition Documentation\par
\pard\plain 
{\xe \v TOML11_CPLUSPLUS_STANDARD_VERSION\:version.hpp}
{\xe \v version.hpp\:TOML11_CPLUSPLUS_STANDARD_VERSION}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TOML11_CPLUSPLUS_STANDARD_VERSION\~ __cplusplus}}
\par
{\bkmkstart AAAAAAAAEN}
{\bkmkend AAAAAAAAEN}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
version.hpp\par \pard\plain 
{\tc\tcl2 \v external/toml/version.hpp}
{\xe \v external/toml/version.hpp}
{\bkmkstart AAAAAAAABB}
{\bkmkend AAAAAAAABB}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #ifndef TOML11_VERSION_HPP}\par
2 {\cf21 #define TOML11_VERSION_HPP}\par
3 \par
4 {\cf20 // This file checks C++ version.}\par
5 \par
6 {\cf21 #ifndef __cplusplus}\par
7 {\cf21 #    error "__cplusplus is not defined"}\par
8 {\cf21 #endif}\par
9 \par
10 {\cf20 // Since MSVC does not define `__cplusplus` correctly unless you pass}\par
11 {\cf20 // `/Zc:__cplusplus` when compiling, the workaround macros are added.}\par
12 {\cf20 // Those enables you to define version manually or to use MSVC specific}\par
13 {\cf20 // version macro automatically.}\par
14 {\cf20 //}\par
15 {\cf20 // The value of `__cplusplus` macro is defined in the C++ standard spec, but}\par
16 {\cf20 // MSVC ignores the value, maybe because of backward compatibility. Instead,}\par
17 {\cf20 // MSVC defines _MSVC_LANG that has the same value as __cplusplus defined in}\par
18 {\cf20 // the C++ standard. First we check the manual version definition, and then}\par
19 {\cf20 // we check if _MSVC_LANG is defined. If neither, use normal `__cplusplus`.}\par
20 {\cf20 //}\par
21 {\cf20 // FYI: https://docs.microsoft.com/en-us/cpp/build/reference/zc-cplusplus?view=msvc-170}\par
22 {\cf20 //      https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170}\par
23 {\cf20 //}\par
24 {\cf21 #if   defined(TOML11_ENFORCE_CXX11)}\par
25 {\cf21 #  define TOML11_CPLUSPLUS_STANDARD_VERSION 201103L}\par
26 {\cf21 #elif defined(TOML11_ENFORCE_CXX14)}\par
27 {\cf21 #  define TOML11_CPLUSPLUS_STANDARD_VERSION 201402L}\par
28 {\cf21 #elif defined(TOML11_ENFORCE_CXX17)}\par
29 {\cf21 #  define TOML11_CPLUSPLUS_STANDARD_VERSION 201703L}\par
30 {\cf21 #elif defined(TOML11_ENFORCE_CXX20)}\par
31 {\cf21 #  define TOML11_CPLUSPLUS_STANDARD_VERSION 202002L}\par
32 {\cf21 #elif defined(_MSVC_LANG) && defined(_MSC_VER) && 1910 <= _MSC_VER}\par
33 {\cf21 #  define TOML11_CPLUSPLUS_STANDARD_VERSION _MSVC_LANG}\par
34 {\cf21 #else}\par
35 {\cf21 #  define TOML11_CPLUSPLUS_STANDARD_VERSION __cplusplus}\par
36 {\cf21 #endif}\par
37 \par
38 {\cf21 #if TOML11_CPLUSPLUS_STANDARD_VERSION < 201103L && _MSC_VER < 1900}\par
39 {\cf21 #    error "toml11 requires C++11 or later."}\par
40 {\cf21 #endif}\par
41 \par
42 {\cf21 #endif}{\cf20 // TOML11_VERSION_HPP}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Game/Game.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Game/Game.cpp}
{\xe \v Game/Game.cpp}
{\bkmkstart AAAAAAAAEO}
{\bkmkend AAAAAAAAEO}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Game.hpp"}\par
{\f2 #include "cmath"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Game/Game.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v Game/Game.hpp}
{\xe \v Game/Game.hpp}
{\bkmkstart AAAAAAAAEP}
{\bkmkend AAAAAAAAEP}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Audio.hpp>}\par
{\f2 #include <SFML/Graphics.hpp>}\par
{\f2 #include <algorithm>}\par
{\f2 #include <iostream>}\par
{\f2 #include "../Bullet/Bullet.hpp"}\par
{\f2 #include "../Enemies/EyeEnemy.hpp"}\par
{\f2 #include "../GameObject/GameObject.hpp"}\par
{\f2 #include "../Player/Player.hpp"}\par
{\f2 #include "../SettingsManager/SettingsManager.hpp"}\par
{\f2 #include "../SpriteContoller/SpriteController.hpp"}\par
{\f2 #include "../TileMap/TileMap.hpp"}\par
{\f2 #include "../external/SimplexNoise/SimplexNoise.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Game}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Game.hpp\par \pard\plain 
{\tc\tcl2 \v Game/Game.hpp}
{\xe \v Game/Game.hpp}
{\bkmkstart AAAAAAAABC}
{\bkmkend AAAAAAAABC}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #pragma once}\par
2 {\cf21 #include <SFML/Audio.hpp>}\par
3 {\cf21 #include <SFML/Graphics.hpp>}\par
4 {\cf21 #include <algorithm>}\par
5 {\cf21 #include <iostream>}\par
6 \par
7 {\cf21 #include "../Bullet/Bullet.hpp"}\par
8 {\cf21 #include "../Enemies/EyeEnemy.hpp"}\par
9 {\cf21 #include "../GameObject/GameObject.hpp"}\par
10 {\cf21 #include "../Player/Player.hpp"}\par
11 {\cf21 #include "../SettingsManager/SettingsManager.hpp"}\par
12 {\cf21 #include "../SpriteContoller/SpriteController.hpp"}\par
13 {\cf21 #include "../TileMap/TileMap.hpp"}\par
14 {\cf21 #include "../external/SimplexNoise/SimplexNoise.hpp"}\par
15 \par
16 {\cf17 class }Game \{\par
17   {\cf17 private}:\par
18     {\cf18 unsigned} {\cf18 int} WINDOW_SIZE_H;\par
19     {\cf18 unsigned} {\cf18 int} WINDOW_SIZE_W;\par
20     uint8_t FPS;\par
21     {\cf18 bool} paused;\par
22 \par
23     sf::RenderWindow window;\par
24 \par
25     SpriteController spriteController;\par
26     SettingsManager settingsManager;\par
27 \par
28     Player player;\par
29     sf::Vector2i previousPlayerPosition;\par
30     sf::View camera;\par
31     sf::View map;\par
32 \par
33     std::vector<GameObject> drawLayer;\par
34     std::vector<Bullet> bulletLayer;\par
35 \par
36     {\cf20 // TEMP}\par
37     std::vector<EyeEnemy> enemies;\par
38     {\cf18 unsigned} {\cf18 int} difficulty;\par
39 \par
44     {\cf18 void} ProcessEvents();\par
45 \par
51     {\cf18 void} update(sf::Time deltatime);\par
52 \par
58     {\cf18 void} updateAnimations(sf::Time deltatime);\par
59 \par
65     {\cf18 void} draw(sf::Time deltaTime);\par
66 \par
72     {\cf18 void} draw_world(std::vector<sf::Sprite> sprites);\par
73 \par
79     {\cf18 void} draw_test_room(std::vector<sf::Sprite> sprites);\par
80 \par
88     {\cf18 void} draw_animated_player(std::vector<sf::Sprite> sprites, {\cf18 float} x,\par
89                               {\cf18 float} y);\par
90 \par
95     {\cf18 void} new_wave();\par
96 \par
97     {\cf20 //\'D0\'9C\'D0\'B5\'D1\'85\'D0\'B0\'D0\'BD\'D0\'B8\'D0\'BA\'D0\'B8}\par
103 {\cf20 }    {\cf18 void} shootBullet(sf::Vector2f velocity);\par
104 \par
105   {\cf17 public}:\par
112     Game({\cf18 unsigned} {\cf18 int} h = 600U, {\cf18 unsigned} {\cf18 int} w = 800U);\par
113 \par
118     {\cf18 void} run();\par
119 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GameObject/GameObject.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v GameObject/GameObject.cpp}
{\xe \v GameObject/GameObject.cpp}
{\bkmkstart AAAAAAAAEQ}
{\bkmkend AAAAAAAAEQ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "GameObject.hpp"}\par
{\f2 #include "../Utils/debug.hpp"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GameObject/GameObject.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v GameObject/GameObject.hpp}
{\xe \v GameObject/GameObject.hpp}
{\bkmkstart AAAAAAAAER}
{\bkmkend AAAAAAAAER}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Graphics.hpp>}\par
{\f2 #include <vector>}\par
{\f2 #include "GameObject.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b GameObject}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
GameObject.hpp\par \pard\plain 
{\tc\tcl2 \v GameObject/GameObject.hpp}
{\xe \v GameObject/GameObject.hpp}
{\bkmkstart AAAAAAAABD}
{\bkmkend AAAAAAAABD}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #pragma once}\par
2 {\cf21 #include <SFML/Graphics.hpp>}\par
3 {\cf21 #include <vector>}\par
4 \par
5 {\cf21 #include "GameObject.hpp"}\par
10 {\cf17 class }GameObject : {\cf17 public} sf::Drawable, {\cf17 public} sf::Transformable \{\par
11   {\cf17 private}:\par
12     sf::Vector2f m_cordinates;\par
13     sf::Vector2f m_boxCollider;\par
14 \par
15     {\cf18 int} animation_state;\par
16     {\cf18 bool} m_isCollider;\par
17     {\cf18 bool} isAnimated = {\cf17 false};\par
18     {\cf18 bool} isFinished = {\cf17 false};\par
19 \par
20   {\cf17 public}:\par
21     {\cf18 float} m_scale;\par
22     {\cf18 bool} stopAtEnd = {\cf17 false};\par
23 \par
24     std::vector<sf::Sprite> m_sprites_array;\par
25     sf::Sprite m_sprite;\par
26 \par
27     GameObject();\par
37     GameObject({\cf17 const} sf::Vector2f &cordinates,\par
38                std::vector<sf::Sprite> &sprites_array, {\cf18 bool} isCollider = {\cf17 false},\par
39                {\cf18 float} scale = 1, sf::Vector2f boxCollider = \{0, 0\});\par
40 \par
50     GameObject({\cf17 const} sf::Vector2f &cordinates, {\cf17 const} sf::Sprite &sprite,\par
51                {\cf18 bool} isCollider = {\cf17 false}, {\cf18 float} scale = 1,\par
52                sf::Vector2f boxCollider = \{0, 0\});\par
53 \par
54     {\cf17 virtual} {\cf18 void} draw(sf::RenderTarget &surface, sf::RenderStates states) {\cf17 const};\par
55 \par
59     {\cf18 void} nextState();\par
60 \par
66     {\cf18 bool} isCollider() {\cf17 const};\par
67 \par
71     {\cf18 void} resetAnimation();\par
72 \par
80     {\cf18 bool} check_collision(GameObject &other) {\cf17 const};\par
81 \par
89     {\cf18 bool} check_collision(sf::FloatRect &otherFloatRect) {\cf17 const};\par
90 \par
96     sf::FloatRect getGameObjectRect() {\cf17 const};\par
97 \par
105     {\cf18 bool} isLastAnimationState() {\cf17 const};\par
106 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
main.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v main.cpp}
{\xe \v main.cpp}
{\bkmkstart AAAAAAAAES}
{\bkmkend AAAAAAAAES}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Game/Game.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:main.cpp}
{\xe \v main.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}}
\par
{\bkmkstart AAAAAAAAET}
{\bkmkend AAAAAAAAET}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Player/Player.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Player/Player.cpp}
{\xe \v Player/Player.cpp}
{\bkmkstart AAAAAAAAEU}
{\bkmkend AAAAAAAAEU}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Player.hpp"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Player/Player.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v Player/Player.hpp}
{\xe \v Player/Player.hpp}
{\bkmkstart AAAAAAAAEV}
{\bkmkend AAAAAAAAEV}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Audio.hpp>}\par
{\f2 #include <SFML/Graphics.hpp>}\par
{\f2 #include "../GameObject/GameObject.hpp"}\par
{\f2 #include "../SpriteContoller/SpriteController.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Player}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Player.hpp\par \pard\plain 
{\tc\tcl2 \v Player/Player.hpp}
{\xe \v Player/Player.hpp}
{\bkmkstart AAAAAAAABE}
{\bkmkend AAAAAAAABE}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #pragma once}\par
2 {\cf21 #include <SFML/Audio.hpp>}\par
3 {\cf21 #include <SFML/Graphics.hpp>}\par
4 \par
5 {\cf21 #include "../GameObject/GameObject.hpp"}\par
6 {\cf21 #include "../SpriteContoller/SpriteController.hpp"}\par
7 \par
8 {\cf17 class }Player : {\cf17 public} sf::Drawable, {\cf17 public} sf::Transformable \{\par
9     {\cf17 using }spritesMap = std::map<std::string, std::vector<sf::Sprite>>;\par
10 \par
11     sf::Vector2f m_velocity;\par
12     sf::Vector2f m_position;\par
13 \par
14     std::map<std::string, std::vector<sf::Sprite>> m_playerSprites;\par
15 \par
16     std::vector<sf::Sprite> m_current_state;\par
17 \par
18     sf::SoundBuffer m_sbuffer;\par
19     sf::Sound m_footstepsSound;\par
20 \par
21     {\cf17 mutable} GameObject m_playerObject;\par
22     {\cf18 float} m_speed;\par
23     {\cf18 bool} isLookRight;\par
24     {\cf18 bool} isMoveHorizontal = {\cf17 false};\par
25     {\cf18 bool} isMoveVertical = {\cf17 false};\par
26     {\cf18 bool} isStepping = {\cf17 false};\par
27     {\cf18 int} health;\par
28     {\cf18 int} initial_health;\par
29     {\cf17 mutable} {\cf18 bool} getting_hit;\par
30 \par
31   {\cf17 public}:\par
32     {\cf17 enum} HorizontalDirection \{ Left, Right \};\par
33     {\cf17 enum} VerticalDirection \{ Top, Down \};\par
34     Player() = {\cf19 default};\par
35 \par
46     Player(sf::Vector2f startPosition, sf::Vector2f velocity,\par
47            spritesMap playerSprites, std::string footsteps_path,\par
48            {\cf18 float} speed = 100, {\cf18 int} health = 100);\par
49 \par
55     {\cf18 void} changeXDirection(HorizontalDirection direction);\par
56 \par
62     {\cf18 void} changeYDirection(VerticalDirection direction);\par
63 \par
67     {\cf18 void} resetHorizontalVelocity();\par
68 \par
72     {\cf18 void} resetVerticalVelocity();\par
73 \par
78     {\cf18 void} movePlayer(sf::Time deltaTime);\par
79 \par
84     {\cf18 void} setSpeed({\cf18 float} speed);\par
85 \par
92     {\cf18 bool} isDead() {\cf17 const};\par
93 \par
97     {\cf18 void} resetHealth();\par
98 \par
103     sf::Vector2f getPlayerPosition() {\cf17 const};\par
104 \par
109     sf::Vector2f getPlayerVelocity() {\cf17 const};\par
110 \par
117     sf::FloatRect getNextPosition(sf::Time deltaTime) {\cf17 const};\par
118 \par
125     {\cf17 virtual} {\cf18 void} draw(sf::RenderTarget &surface, sf::RenderStates states) {\cf17 const};\par
126 \par
136     GameObject &get_playerObject();\par
137 \par
143     {\cf18 void} getHit({\cf18 int} hp);\par
144 \par
148     {\cf18 void} nextState();\par
149 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SettingsManager/SettingsManager.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v SettingsManager/SettingsManager.cpp}
{\xe \v SettingsManager/SettingsManager.cpp}
{\bkmkstart AAAAAAAAEW}
{\bkmkend AAAAAAAAEW}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "SettingsManager.hpp"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SettingsManager/SettingsManager.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v SettingsManager/SettingsManager.hpp}
{\xe \v SettingsManager/SettingsManager.hpp}
{\bkmkstart AAAAAAAAEX}
{\bkmkend AAAAAAAAEX}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
{\f2 #include "../external/toml.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SettingsManager}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SettingsManager.hpp\par \pard\plain 
{\tc\tcl2 \v SettingsManager/SettingsManager.hpp}
{\xe \v SettingsManager/SettingsManager.hpp}
{\bkmkstart AAAAAAAABF}
{\bkmkend AAAAAAAABF}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #pragma once}\par
2 {\cf21 #include <string>}\par
3 \par
4 {\cf21 #include "../external/toml.hpp"}\par
5 \par
6 {\cf17 struct }SettingsManager \{\par
7 \par
12     SettingsManager(std::string settingsPath = {\cf22 "../src/settings.toml"});\par
13     toml::value PlayerSettings;\par
14     toml::value PlayerSpritesSettings;\par
15     toml::value SpriteSettings;\par
16     toml::value TileIndexes;\par
17     toml::value TileMapSettings;\par
18     toml::value SoundSettings;\par
19     toml::value WorldGenSettings;\par
20     toml::value EnemySettings;\par
21 \par
28     {\cf17 template} <{\cf17 typename} T> T get(toml::value settingsType, std::string key) \{\par
29         {\cf19 return} toml::find<T>(settingsType, key);\par
30     \}\par
31 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SpriteContoller/SpriteController.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v SpriteContoller/SpriteController.cpp}
{\xe \v SpriteContoller/SpriteController.cpp}
{\bkmkstart AAAAAAAAEY}
{\bkmkend AAAAAAAAEY}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "SpriteController.hpp"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SpriteContoller/SpriteController.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v SpriteContoller/SpriteController.hpp}
{\xe \v SpriteContoller/SpriteController.hpp}
{\bkmkstart AAAAAAAAEZ}
{\bkmkend AAAAAAAAEZ}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Graphics.hpp>}\par
{\f2 #include <map>}\par
{\f2 #include <string>}\par
{\f2 #include <vector>}\par
{\f2 #include "../SettingsManager/SettingsManager.hpp"}\par
{\f2 #include "../TileMap/TileMap.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b SpriteController}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SpriteController.hpp\par \pard\plain 
{\tc\tcl2 \v SpriteContoller/SpriteController.hpp}
{\xe \v SpriteContoller/SpriteController.hpp}
{\bkmkstart AAAAAAAABG}
{\bkmkend AAAAAAAABG}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #pragma once}\par
2 {\cf21 #include <SFML/Graphics.hpp>}\par
3 {\cf21 #include <map>}\par
4 {\cf21 #include <string>}\par
5 {\cf21 #include <vector>}\par
6 \par
7 {\cf21 #include "../SettingsManager/SettingsManager.hpp"}\par
8 {\cf21 #include "../TileMap/TileMap.hpp"}\par
9 \par
10 {\cf17 struct }SpriteController \{\par
11     std::map<std::string, sf::Texture> textures;\par
12     std::map<std::string, std::vector<sf::Sprite>> spriteArrays;\par
13     std::map<std::string, sf::Sprite> spriteObjects;\par
14     std::map<std::string, std::vector<sf::Sprite>> playerSprites;\par
15 \par
16     std::pair<int, int> tilemap_size;\par
17 \par
18     SpriteController() = {\cf19 default};\par
19 \par
24     SpriteController(SettingsManager &settingsManager);\par
25 \par
31     {\cf18 void} processSettings(toml::table &table, {\cf18 bool} isPlayerSettings = {\cf17 false});\par
32 \par
38     {\cf18 void} load_textures(std::string name, std::string path);\par
39 \par
46     {\cf18 void} load_player_sprites(std::string name, std::string path,\par
47                              sf::Vector2u tilesize);\par
54     {\cf18 void} load_sprites(std::string name, std::string path,\par
55                       sf::Vector2u tilesize);\par
61     std::vector<sf::Sprite> make_sprite(sf::Texture &texture,\par
62                                         sf::Vector2u tilesize);\par
63 \par
70     {\cf18 void} configureSprites(toml::value TileIndexSettings);\par
71 \par
75     {\cf18 int} indexesToindex({\cf18 int} i, {\cf18 int} j);\par
76 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TileMap/TileMap.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TileMap/TileMap.cpp}
{\xe \v TileMap/TileMap.cpp}
{\bkmkstart AAAAAAAAFA}
{\bkmkend AAAAAAAAFA}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TileMap.hpp"}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TileMap/TileMap.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v TileMap/TileMap.hpp}
{\xe \v TileMap/TileMap.hpp}
{\bkmkstart AAAAAAAAFB}
{\bkmkend AAAAAAAAFB}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Graphics.hpp>}\par
{\f2 #include <vector>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Classes\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TileMap}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TileMap.hpp\par \pard\plain 
{\tc\tcl2 \v TileMap/TileMap.hpp}
{\xe \v TileMap/TileMap.hpp}
{\bkmkstart AAAAAAAABH}
{\bkmkend AAAAAAAABH}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #pragma once}\par
2 {\cf21 #include <SFML/Graphics.hpp>}\par
3 {\cf21 #include <vector>}\par
4 \par
5 {\cf17 class }TileMap \{\par
6     sf::Texture &m_tileset;\par
7     sf::Vector2u m_tile_size;\par
8     std::vector<sf::Sprite> m_sprites;\par
9 \par
10   {\cf17 public}:\par
16     TileMap(sf::Texture &tileset, {\cf17 const} sf::Vector2u &tile_size);\par
17 \par
21     std::vector<sf::Sprite> get_sprites();\par
22 \};\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Utils/debug.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v Utils/debug.cpp}
{\xe \v Utils/debug.cpp}
{\bkmkstart AAAAAAAAFC}
{\bkmkend AAAAAAAAFC}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "debug.hpp"}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::RectangleShape {\b debugRectangle} (sf::FloatRect rect)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v debugRectangle\:debug.cpp}
{\xe \v debug.cpp\:debugRectangle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::RectangleShape debugRectangle (sf::FloatRect  {\i rect})}}
\par
{\bkmkstart AAAAAAAAFD}
{\bkmkend AAAAAAAAFD}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Utils/debug.hpp File Reference\par \pard\plain 
{\tc\tcl2 \v Utils/debug.hpp}
{\xe \v Utils/debug.hpp}
{\bkmkstart AAAAAAAAFE}
{\bkmkend AAAAAAAAFE}
{
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <SFML/Graphics.hpp>}\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s120\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
sf::RectangleShape {\b debugRectangle} (sf::FloatRect rect)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v debugRectangle\:debug.hpp}
{\xe \v debug.hpp\:debugRectangle}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
sf::RectangleShape debugRectangle (sf::FloatRect  {\i rect})}}
\par
{\bkmkstart AAAAAAAAFF}
{\bkmkend AAAAAAAAFF}
{
\pard\plain \s61\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
debug.hpp\par \pard\plain 
{\tc\tcl2 \v Utils/debug.hpp}
{\xe \v Utils/debug.hpp}
{\bkmkstart AAAAAAAABI}
{\bkmkend AAAAAAAABI}
Go to the documentation of this file.{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid 1 {\cf21 #pragma once}\par
2 \par
3 {\cf21 #include <SFML/Graphics.hpp>}\par
4 \par
5 sf::RectangleShape debugRectangle(sf::FloatRect rect);\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}
