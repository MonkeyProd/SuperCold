\hypertarget{parser_8hpp_source}{}\doxysection{parser.\+hpp}
\label{parser_8hpp_source}\index{external/toml/parser.hpp@{external/toml/parser.hpp}}
\mbox{\hyperlink{parser_8hpp}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{//     Copyright Toru Niina 2017.}}
\DoxyCodeLine{2 \textcolor{comment}{// Distributed under the MIT License.}}
\DoxyCodeLine{3 \textcolor{preprocessor}{\#ifndef TOML11\_PARSER\_HPP}}
\DoxyCodeLine{4 \textcolor{preprocessor}{\#define TOML11\_PARSER\_HPP}}
\DoxyCodeLine{5 \textcolor{preprocessor}{\#include <cstring>}}
\DoxyCodeLine{6 \textcolor{preprocessor}{\#include <fstream>}}
\DoxyCodeLine{7 \textcolor{preprocessor}{\#include <sstream>}}
\DoxyCodeLine{8 }
\DoxyCodeLine{9 \textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{combinator_8hpp}{combinator.hpp}}"{}}}
\DoxyCodeLine{10 \textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{lexer_8hpp}{lexer.hpp}}"{}}}
\DoxyCodeLine{11 \textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{region_8hpp}{region.hpp}}"{}}}
\DoxyCodeLine{12 \textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{result_8hpp}{result.hpp}}"{}}}
\DoxyCodeLine{13 \textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{types_8hpp}{types.hpp}}"{}}}
\DoxyCodeLine{14 \textcolor{preprocessor}{\#include "{}\mbox{\hyperlink{value_8hpp}{value.hpp}}"{}}}
\DoxyCodeLine{15 }
\DoxyCodeLine{16 \textcolor{preprocessor}{\#ifndef TOML11\_DISABLE\_STD\_FILESYSTEM}}
\DoxyCodeLine{17 \textcolor{preprocessor}{\#ifdef \_\_cpp\_lib\_filesystem}}
\DoxyCodeLine{18 \textcolor{preprocessor}{\#if \_\_has\_include(<filesystem>)}}
\DoxyCodeLine{19 \textcolor{preprocessor}{\#define TOML11\_HAS\_STD\_FILESYSTEM}}
\DoxyCodeLine{20 \textcolor{preprocessor}{\#include <filesystem>}}
\DoxyCodeLine{21 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// has\_include(<string\_view>)}}
\DoxyCodeLine{22 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// \_\_cpp\_lib\_filesystem}}
\DoxyCodeLine{23 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// TOML11\_DISABLE\_STD\_FILESYSTEM}}
\DoxyCodeLine{24 }
\DoxyCodeLine{25 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacetoml}{toml}}}
\DoxyCodeLine{26 \{}
\DoxyCodeLine{27 \textcolor{keyword}{namespace }detail}
\DoxyCodeLine{28 \{}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{keyword}{inline} result<std::pair<boolean, region>, std::string>}
\DoxyCodeLine{31 \mbox{\hyperlink{namespacetoml_1_1detail_a79439bcaa95b2d9f009b131f4fe0503d}{parse\_boolean}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{32 \{}
\DoxyCodeLine{33     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{34     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_boolean::invoke(loc))}
\DoxyCodeLine{35     \{}
\DoxyCodeLine{36         \textcolor{keyword}{const} \textcolor{keyword}{auto} reg = token.unwrap();}
\DoxyCodeLine{37         \textcolor{keywordflow}{if}     (reg.str() == \textcolor{stringliteral}{"{}true"{}})  \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(\textcolor{keyword}{true},  reg));\}}
\DoxyCodeLine{38         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(reg.str() == \textcolor{stringliteral}{"{}false"{}}) \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(\textcolor{keyword}{false}, reg));\}}
\DoxyCodeLine{39         \textcolor{keywordflow}{else} \textcolor{comment}{// internal error.}}
\DoxyCodeLine{40         \{}
\DoxyCodeLine{41             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{42                 \textcolor{stringliteral}{"{}toml::parse\_boolean: internal error"{}},}
\DoxyCodeLine{43                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(reg), \textcolor{stringliteral}{"{}invalid token"{}}\}\}),}
\DoxyCodeLine{44                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(reg));}
\DoxyCodeLine{45         \}}
\DoxyCodeLine{46     \}}
\DoxyCodeLine{47     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first); \textcolor{comment}{//rollback}}
\DoxyCodeLine{48     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_boolean: "{}},}
\DoxyCodeLine{49                \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}the next token is not a boolean"{}}\}\}));}
\DoxyCodeLine{50 \}}
\DoxyCodeLine{51 }
\DoxyCodeLine{52 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<integer, region>}}, std::string>}
\DoxyCodeLine{53 \mbox{\hyperlink{namespacetoml_1_1detail_a28e381c53888f17cfb8fc98ee21bc968}{parse\_binary\_integer}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{54 \{}
\DoxyCodeLine{55     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{56     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_bin\_int::invoke(loc))}
\DoxyCodeLine{57     \{}
\DoxyCodeLine{58         \textcolor{keyword}{auto} str = token.unwrap().str();}
\DoxyCodeLine{59         assert(str.size() > 2); \textcolor{comment}{// minimum -\/> 0b1}}
\DoxyCodeLine{60         \mbox{\hyperlink{namespacetoml_ad9642acd2a70ea10c7c6c1b53a3caac9}{integer}} retval(0), base(1);}
\DoxyCodeLine{61         \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} i(str.rbegin()), e(str.rend() -\/ 2); i!=e; ++i)}
\DoxyCodeLine{62         \{}
\DoxyCodeLine{63             \textcolor{keywordflow}{if}     (*i == \textcolor{charliteral}{'1'})\{retval += base; base *= 2;\}}
\DoxyCodeLine{64             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*i == \textcolor{charliteral}{'0'})\{base *= 2;\}}
\DoxyCodeLine{65             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*i == \textcolor{charliteral}{'\_'})\{\textcolor{comment}{/* do nothing. */}\}}
\DoxyCodeLine{66             \textcolor{keywordflow}{else} \textcolor{comment}{// internal error.}}
\DoxyCodeLine{67             \{}
\DoxyCodeLine{68                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{69                     \textcolor{stringliteral}{"{}toml::parse\_integer: internal error"{}},}
\DoxyCodeLine{70                     \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(token.unwrap()), \textcolor{stringliteral}{"{}invalid token"{}}\}\}),}
\DoxyCodeLine{71                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{72             \}}
\DoxyCodeLine{73         \}}
\DoxyCodeLine{74         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(retval, token.unwrap()));}
\DoxyCodeLine{75     \}}
\DoxyCodeLine{76     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{77     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_binary\_integer:"{}},}
\DoxyCodeLine{78                \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}the next token is not an integer"{}}\}\}));}
\DoxyCodeLine{79 \}}
\DoxyCodeLine{80 }
\DoxyCodeLine{81 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<integer, region>}}, std::string>}
\DoxyCodeLine{82 \mbox{\hyperlink{namespacetoml_1_1detail_aaf03d2dd08ab0ee4741933f97cb776aa}{parse\_octal\_integer}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{83 \{}
\DoxyCodeLine{84     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{85     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_oct\_int::invoke(loc))}
\DoxyCodeLine{86     \{}
\DoxyCodeLine{87         \textcolor{keyword}{auto} str = token.unwrap().str();}
\DoxyCodeLine{88         str.erase(std::remove(str.begin(), str.end(), \textcolor{charliteral}{'\_'}), str.end());}
\DoxyCodeLine{89         str.erase(str.begin()); str.erase(str.begin()); \textcolor{comment}{// remove `0o` prefix}}
\DoxyCodeLine{90 }
\DoxyCodeLine{91         std::istringstream iss(str);}
\DoxyCodeLine{92         \mbox{\hyperlink{namespacetoml_ad9642acd2a70ea10c7c6c1b53a3caac9}{integer}} retval(0);}
\DoxyCodeLine{93         iss >> std::oct >> retval;}
\DoxyCodeLine{94         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(retval, token.unwrap()));}
\DoxyCodeLine{95     \}}
\DoxyCodeLine{96     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{97     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_octal\_integer:"{}},}
\DoxyCodeLine{98                \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}the next token is not an integer"{}}\}\}));}
\DoxyCodeLine{99 \}}
\DoxyCodeLine{100 }
\DoxyCodeLine{101 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<integer, region>}}, std::string>}
\DoxyCodeLine{102 \mbox{\hyperlink{namespacetoml_1_1detail_a8b05aa4b8682386670bfe2e4536aaf31}{parse\_hexadecimal\_integer}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{103 \{}
\DoxyCodeLine{104     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{105     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_hex\_int::invoke(loc))}
\DoxyCodeLine{106     \{}
\DoxyCodeLine{107         \textcolor{keyword}{auto} str = token.unwrap().str();}
\DoxyCodeLine{108         str.erase(std::remove(str.begin(), str.end(), \textcolor{charliteral}{'\_'}), str.end());}
\DoxyCodeLine{109         str.erase(str.begin()); str.erase(str.begin()); \textcolor{comment}{// remove `0x` prefix}}
\DoxyCodeLine{110 }
\DoxyCodeLine{111         std::istringstream iss(str);}
\DoxyCodeLine{112         \mbox{\hyperlink{namespacetoml_ad9642acd2a70ea10c7c6c1b53a3caac9}{integer}} retval(0);}
\DoxyCodeLine{113         iss >> std::hex >> retval;}
\DoxyCodeLine{114         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(retval, token.unwrap()));}
\DoxyCodeLine{115     \}}
\DoxyCodeLine{116     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{117     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_hexadecimal\_integer"{}},}
\DoxyCodeLine{118                \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}the next token is not an integer"{}}\}\}));}
\DoxyCodeLine{119 \}}
\DoxyCodeLine{120 }
\DoxyCodeLine{121 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<integer, region>}}, std::string>}
\DoxyCodeLine{122 \mbox{\hyperlink{namespacetoml_1_1detail_af3ce8ca50647de2d35f9e7fedf4e3c84}{parse\_integer}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{123 \{}
\DoxyCodeLine{124     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{125     \textcolor{keywordflow}{if}(first != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& *first == \textcolor{charliteral}{'0'})}
\DoxyCodeLine{126     \{}
\DoxyCodeLine{127         \textcolor{keyword}{const} \textcolor{keyword}{auto} second = std::next(first);}
\DoxyCodeLine{128         \textcolor{keywordflow}{if}(second == loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}()) \textcolor{comment}{// the token is just zero.}}
\DoxyCodeLine{129         \{}
\DoxyCodeLine{130             loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}();}
\DoxyCodeLine{131             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(0, \mbox{\hyperlink{structtoml_1_1detail_1_1region}{region}}(loc, first, second)));}
\DoxyCodeLine{132         \}}
\DoxyCodeLine{133 }
\DoxyCodeLine{134         \textcolor{keywordflow}{if}(*second == \textcolor{charliteral}{'b'}) \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_1_1detail_a28e381c53888f17cfb8fc98ee21bc968}{parse\_binary\_integer}}     (loc);\} \textcolor{comment}{// 0b1100}}
\DoxyCodeLine{135         \textcolor{keywordflow}{if}(*second == \textcolor{charliteral}{'o'}) \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_1_1detail_aaf03d2dd08ab0ee4741933f97cb776aa}{parse\_octal\_integer}}      (loc);\} \textcolor{comment}{// 0o775}}
\DoxyCodeLine{136         \textcolor{keywordflow}{if}(*second == \textcolor{charliteral}{'x'}) \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_1_1detail_a8b05aa4b8682386670bfe2e4536aaf31}{parse\_hexadecimal\_integer}}(loc);\} \textcolor{comment}{// 0xC0FFEE}}
\DoxyCodeLine{137 }
\DoxyCodeLine{138         \textcolor{keywordflow}{if}(std::isdigit(*second))}
\DoxyCodeLine{139         \{}
\DoxyCodeLine{140             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_integer: "{}}}
\DoxyCodeLine{141                 \textcolor{stringliteral}{"{}leading zero in an Integer is not allowed."{}},}
\DoxyCodeLine{142                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}leading zero"{}}\}\}));}
\DoxyCodeLine{143         \}}
\DoxyCodeLine{144         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(std::isalpha(*second))}
\DoxyCodeLine{145         \{}
\DoxyCodeLine{146              \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_integer: "{}}}
\DoxyCodeLine{147                 \textcolor{stringliteral}{"{}unknown integer prefix appeared."{}},}
\DoxyCodeLine{148                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}none of 0x, 0o, 0b"{}}\}\}));}
\DoxyCodeLine{149         \}}
\DoxyCodeLine{150     \}}
\DoxyCodeLine{151 }
\DoxyCodeLine{152     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_dec\_int::invoke(loc))}
\DoxyCodeLine{153     \{}
\DoxyCodeLine{154         \textcolor{keyword}{auto} str = token.unwrap().str();}
\DoxyCodeLine{155         str.erase(std::remove(str.begin(), str.end(), \textcolor{charliteral}{'\_'}), str.end());}
\DoxyCodeLine{156 }
\DoxyCodeLine{157         std::istringstream iss(str);}
\DoxyCodeLine{158         \mbox{\hyperlink{namespacetoml_ad9642acd2a70ea10c7c6c1b53a3caac9}{integer}} retval(0);}
\DoxyCodeLine{159         iss >> retval;}
\DoxyCodeLine{160         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(retval, token.unwrap()));}
\DoxyCodeLine{161     \}}
\DoxyCodeLine{162     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{163     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_integer: "{}},}
\DoxyCodeLine{164                \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}the next token is not an integer"{}}\}\}));}
\DoxyCodeLine{165 \}}
\DoxyCodeLine{166 }
\DoxyCodeLine{167 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<floating, region>}}, std::string>}
\DoxyCodeLine{168 \mbox{\hyperlink{namespacetoml_1_1detail_a570077e5697415b2bc98a3a3c1d083a4}{parse\_floating}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{169 \{}
\DoxyCodeLine{170     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{171     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_float::invoke(loc))}
\DoxyCodeLine{172     \{}
\DoxyCodeLine{173         \textcolor{keyword}{auto} str = token.unwrap().str();}
\DoxyCodeLine{174         \textcolor{keywordflow}{if}(str == \textcolor{stringliteral}{"{}inf"{}} || str == \textcolor{stringliteral}{"{}+inf"{}})}
\DoxyCodeLine{175         \{}
\DoxyCodeLine{176             \textcolor{keywordflow}{if}(std::numeric\_limits<floating>::has\_infinity)}
\DoxyCodeLine{177             \{}
\DoxyCodeLine{178                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(}
\DoxyCodeLine{179                     std::numeric\_limits<floating>::infinity(), token.unwrap()));}
\DoxyCodeLine{180             \}}
\DoxyCodeLine{181             \textcolor{keywordflow}{else}}
\DoxyCodeLine{182             \{}
\DoxyCodeLine{183                 \textcolor{keywordflow}{throw} std::domain\_error(\textcolor{stringliteral}{"{}toml::parse\_floating: inf value found"{}}}
\DoxyCodeLine{184                     \textcolor{stringliteral}{"{} but the current environment does not support inf. Please"{}}}
\DoxyCodeLine{185                     \textcolor{stringliteral}{"{} make sure that the floating-\/point implementation conforms"{}}}
\DoxyCodeLine{186                     \textcolor{stringliteral}{"{} IEEE 754/ISO 60559 international standard."{}});}
\DoxyCodeLine{187             \}}
\DoxyCodeLine{188         \}}
\DoxyCodeLine{189         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(str == \textcolor{stringliteral}{"{}-\/inf"{}})}
\DoxyCodeLine{190         \{}
\DoxyCodeLine{191             \textcolor{keywordflow}{if}(std::numeric\_limits<floating>::has\_infinity)}
\DoxyCodeLine{192             \{}
\DoxyCodeLine{193                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(}
\DoxyCodeLine{194                     -\/std::numeric\_limits<floating>::infinity(), token.unwrap()));}
\DoxyCodeLine{195             \}}
\DoxyCodeLine{196             \textcolor{keywordflow}{else}}
\DoxyCodeLine{197             \{}
\DoxyCodeLine{198                 \textcolor{keywordflow}{throw} std::domain\_error(\textcolor{stringliteral}{"{}toml::parse\_floating: inf value found"{}}}
\DoxyCodeLine{199                     \textcolor{stringliteral}{"{} but the current environment does not support inf. Please"{}}}
\DoxyCodeLine{200                     \textcolor{stringliteral}{"{} make sure that the floating-\/point implementation conforms"{}}}
\DoxyCodeLine{201                     \textcolor{stringliteral}{"{} IEEE 754/ISO 60559 international standard."{}});}
\DoxyCodeLine{202             \}}
\DoxyCodeLine{203         \}}
\DoxyCodeLine{204         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(str == \textcolor{stringliteral}{"{}nan"{}} || str == \textcolor{stringliteral}{"{}+nan"{}})}
\DoxyCodeLine{205         \{}
\DoxyCodeLine{206             \textcolor{keywordflow}{if}(std::numeric\_limits<floating>::has\_quiet\_NaN)}
\DoxyCodeLine{207             \{}
\DoxyCodeLine{208                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(}
\DoxyCodeLine{209                     std::numeric\_limits<floating>::quiet\_NaN(), token.unwrap()));}
\DoxyCodeLine{210             \}}
\DoxyCodeLine{211             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(std::numeric\_limits<floating>::has\_signaling\_NaN)}
\DoxyCodeLine{212             \{}
\DoxyCodeLine{213                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(}
\DoxyCodeLine{214                     std::numeric\_limits<floating>::signaling\_NaN(), token.unwrap()));}
\DoxyCodeLine{215             \}}
\DoxyCodeLine{216             \textcolor{keywordflow}{else}}
\DoxyCodeLine{217             \{}
\DoxyCodeLine{218                 \textcolor{keywordflow}{throw} std::domain\_error(\textcolor{stringliteral}{"{}toml::parse\_floating: NaN value found"{}}}
\DoxyCodeLine{219                     \textcolor{stringliteral}{"{} but the current environment does not support NaN. Please"{}}}
\DoxyCodeLine{220                     \textcolor{stringliteral}{"{} make sure that the floating-\/point implementation conforms"{}}}
\DoxyCodeLine{221                     \textcolor{stringliteral}{"{} IEEE 754/ISO 60559 international standard."{}});}
\DoxyCodeLine{222             \}}
\DoxyCodeLine{223         \}}
\DoxyCodeLine{224         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(str == \textcolor{stringliteral}{"{}-\/nan"{}})}
\DoxyCodeLine{225         \{}
\DoxyCodeLine{226             \textcolor{keywordflow}{if}(std::numeric\_limits<floating>::has\_quiet\_NaN)}
\DoxyCodeLine{227             \{}
\DoxyCodeLine{228                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(}
\DoxyCodeLine{229                     -\/std::numeric\_limits<floating>::quiet\_NaN(), token.unwrap()));}
\DoxyCodeLine{230             \}}
\DoxyCodeLine{231             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(std::numeric\_limits<floating>::has\_signaling\_NaN)}
\DoxyCodeLine{232             \{}
\DoxyCodeLine{233                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(}
\DoxyCodeLine{234                     -\/std::numeric\_limits<floating>::signaling\_NaN(), token.unwrap()));}
\DoxyCodeLine{235             \}}
\DoxyCodeLine{236             \textcolor{keywordflow}{else}}
\DoxyCodeLine{237             \{}
\DoxyCodeLine{238                 \textcolor{keywordflow}{throw} std::domain\_error(\textcolor{stringliteral}{"{}toml::parse\_floating: NaN value found"{}}}
\DoxyCodeLine{239                     \textcolor{stringliteral}{"{} but the current environment does not support NaN. Please"{}}}
\DoxyCodeLine{240                     \textcolor{stringliteral}{"{} make sure that the floating-\/point implementation conforms"{}}}
\DoxyCodeLine{241                     \textcolor{stringliteral}{"{} IEEE 754/ISO 60559 international standard."{}});}
\DoxyCodeLine{242             \}}
\DoxyCodeLine{243         \}}
\DoxyCodeLine{244         str.erase(std::remove(str.begin(), str.end(), \textcolor{charliteral}{'\_'}), str.end());}
\DoxyCodeLine{245         std::istringstream iss(str);}
\DoxyCodeLine{246         \mbox{\hyperlink{namespacetoml_a54f4b85eab8f0d6e6f0149c5ba338f6a}{floating}} v(0.0);}
\DoxyCodeLine{247         iss >> v;}
\DoxyCodeLine{248         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(v, token.unwrap()));}
\DoxyCodeLine{249     \}}
\DoxyCodeLine{250     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{251     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_floating: "{}},}
\DoxyCodeLine{252                \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}the next token is not a float"{}}\}\}));}
\DoxyCodeLine{253 \}}
\DoxyCodeLine{254 }
\DoxyCodeLine{255 \textcolor{keyword}{inline} std::string \mbox{\hyperlink{namespacetoml_1_1detail_af51fa4863a69805aee614744ec7830de}{read\_utf8\_codepoint}}(\textcolor{keyword}{const} \mbox{\hyperlink{structtoml_1_1detail_1_1region}{region}}\& reg, \textcolor{keyword}{const} \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{256 \{}
\DoxyCodeLine{257     \textcolor{keyword}{const} \textcolor{keyword}{auto} str = reg.\mbox{\hyperlink{structtoml_1_1detail_1_1region_ab29b9569c262fd0d1068501c05f49ea7}{str}}().substr(1);}
\DoxyCodeLine{258     std::uint\_least32\_t codepoint;}
\DoxyCodeLine{259     std::istringstream iss(str);}
\DoxyCodeLine{260     iss >> std::hex >> codepoint;}
\DoxyCodeLine{261 }
\DoxyCodeLine{262     \textcolor{keyword}{const} \textcolor{keyword}{auto} to\_char = [](\textcolor{keyword}{const} std::uint\_least32\_t i) \textcolor{keyword}{noexcept} -\/> \textcolor{keywordtype}{char} \{}
\DoxyCodeLine{263         \textcolor{keyword}{const} \textcolor{keyword}{auto} uc = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(i);}
\DoxyCodeLine{264         \textcolor{keywordflow}{return} *\textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const }\textcolor{keywordtype}{char}*\textcolor{keyword}{>}(std::addressof(uc));}
\DoxyCodeLine{265     \};}
\DoxyCodeLine{266 }
\DoxyCodeLine{267     std::string \mbox{\hyperlink{namespacetoml_a8f6621cf10ba95c9069e3b248eb9c01d}{character}};}
\DoxyCodeLine{268     \textcolor{keywordflow}{if}(codepoint < 0x80) \textcolor{comment}{// U+0000 ... U+0079 ; just an ASCII.}}
\DoxyCodeLine{269     \{}
\DoxyCodeLine{270         \mbox{\hyperlink{structtoml_1_1detail_1_1character}{character}} += \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{char}\textcolor{keyword}{>}(codepoint);}
\DoxyCodeLine{271     \}}
\DoxyCodeLine{272     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(codepoint < 0x800) \textcolor{comment}{//U+0080 ... U+07FF}}
\DoxyCodeLine{273     \{}
\DoxyCodeLine{274         \textcolor{comment}{// 110yyyyx 10xxxxxx; 0x3f == 0b0011'1111}}
\DoxyCodeLine{275         \mbox{\hyperlink{structtoml_1_1detail_1_1character}{character}} += to\_char(0xC0| codepoint >> 6);}
\DoxyCodeLine{276         \mbox{\hyperlink{structtoml_1_1detail_1_1character}{character}} += to\_char(0x80|(codepoint \& 0x3F));}
\DoxyCodeLine{277     \}}
\DoxyCodeLine{278     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(codepoint < 0x10000) \textcolor{comment}{// U+0800...U+FFFF}}
\DoxyCodeLine{279     \{}
\DoxyCodeLine{280         \textcolor{keywordflow}{if}(0xD800 <= codepoint \&\& codepoint <= 0xDFFF)}
\DoxyCodeLine{281         \{}
\DoxyCodeLine{282             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{283                 \textcolor{stringliteral}{"{}toml::read\_utf8\_codepoint: codepoints in the range "{}}}
\DoxyCodeLine{284                 \textcolor{stringliteral}{"{}[0xD800, 0xDFFF] are not valid UTF-\/8."{}}, \{\{}
\DoxyCodeLine{285                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}not a valid UTF-\/8 codepoint"{}}}
\DoxyCodeLine{286                 \}\}), \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{287         \}}
\DoxyCodeLine{288         assert(codepoint < 0xD800 || 0xDFFF < codepoint);}
\DoxyCodeLine{289         \textcolor{comment}{// 1110yyyy 10yxxxxx 10xxxxxx}}
\DoxyCodeLine{290         \mbox{\hyperlink{structtoml_1_1detail_1_1character}{character}} += to\_char(0xE0| codepoint >> 12);}
\DoxyCodeLine{291         \mbox{\hyperlink{structtoml_1_1detail_1_1character}{character}} += to\_char(0x80|(codepoint >> 6 \& 0x3F));}
\DoxyCodeLine{292         \mbox{\hyperlink{structtoml_1_1detail_1_1character}{character}} += to\_char(0x80|(codepoint      \& 0x3F));}
\DoxyCodeLine{293     \}}
\DoxyCodeLine{294     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(codepoint < 0x110000) \textcolor{comment}{// U+010000 ... U+10FFFF}}
\DoxyCodeLine{295     \{}
\DoxyCodeLine{296         \textcolor{comment}{// 11110yyy 10yyxxxx 10xxxxxx 10xxxxxx}}
\DoxyCodeLine{297         \mbox{\hyperlink{structtoml_1_1detail_1_1character}{character}} += to\_char(0xF0| codepoint >> 18);}
\DoxyCodeLine{298         \mbox{\hyperlink{structtoml_1_1detail_1_1character}{character}} += to\_char(0x80|(codepoint >> 12 \& 0x3F));}
\DoxyCodeLine{299         \mbox{\hyperlink{structtoml_1_1detail_1_1character}{character}} += to\_char(0x80|(codepoint >> 6  \& 0x3F));}
\DoxyCodeLine{300         \mbox{\hyperlink{structtoml_1_1detail_1_1character}{character}} += to\_char(0x80|(codepoint       \& 0x3F));}
\DoxyCodeLine{301     \}}
\DoxyCodeLine{302     \textcolor{keywordflow}{else} \textcolor{comment}{// out of UTF-\/8 region}}
\DoxyCodeLine{303     \{}
\DoxyCodeLine{304         \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::read\_utf8\_codepoint:"{}}}
\DoxyCodeLine{305             \textcolor{stringliteral}{"{} input codepoint is too large."{}},}
\DoxyCodeLine{306             \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}should be in [0x00..0x10FFFF]"{}}\}\}),}
\DoxyCodeLine{307             \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{308     \}}
\DoxyCodeLine{309     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a8f6621cf10ba95c9069e3b248eb9c01d}{character}};}
\DoxyCodeLine{310 \}}
\DoxyCodeLine{311 }
\DoxyCodeLine{312 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::string, std::string>}} \mbox{\hyperlink{namespacetoml_1_1detail_a9e2d963ae5654a0f0f3bca2ffcbb15c0}{parse\_escape\_sequence}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{313 \{}
\DoxyCodeLine{314     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{315     \textcolor{keywordflow}{if}(first == loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() || *first != \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'})}
\DoxyCodeLine{316     \{}
\DoxyCodeLine{317         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_escape\_sequence: "{}}, \{\{}
\DoxyCodeLine{318             \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}the next token is not a backslash \(\backslash\)"{}\(\backslash\)\(\backslash\)\(\backslash\)"{}"{}}\}\}));}
\DoxyCodeLine{319     \}}
\DoxyCodeLine{320     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}();}
\DoxyCodeLine{321     \textcolor{keywordflow}{switch}(*loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}())}
\DoxyCodeLine{322     \{}
\DoxyCodeLine{323         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}:\{loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}(); \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::string(\textcolor{stringliteral}{"{}\(\backslash\)\(\backslash\)"{}}));\}}
\DoxyCodeLine{324         \textcolor{keywordflow}{case} \textcolor{charliteral}{'"{}'} :\{loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}(); \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::string(\textcolor{stringliteral}{"{}\(\backslash\)"{}"{}}));\}}
\DoxyCodeLine{325         \textcolor{keywordflow}{case} \textcolor{charliteral}{'b'} :\{loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}(); \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::string(\textcolor{stringliteral}{"{}\(\backslash\)b"{}}));\}}
\DoxyCodeLine{326         \textcolor{keywordflow}{case} \textcolor{charliteral}{'t'} :\{loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}(); \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::string(\textcolor{stringliteral}{"{}\(\backslash\)t"{}}));\}}
\DoxyCodeLine{327         \textcolor{keywordflow}{case} \textcolor{charliteral}{'n'} :\{loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}(); \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::string(\textcolor{stringliteral}{"{}\(\backslash\)n"{}}));\}}
\DoxyCodeLine{328         \textcolor{keywordflow}{case} \textcolor{charliteral}{'f'} :\{loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}(); \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::string(\textcolor{stringliteral}{"{}\(\backslash\)f"{}}));\}}
\DoxyCodeLine{329         \textcolor{keywordflow}{case} \textcolor{charliteral}{'r'} :\{loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}(); \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::string(\textcolor{stringliteral}{"{}\(\backslash\)r"{}}));\}}
\DoxyCodeLine{330         \textcolor{keywordflow}{case} \textcolor{charliteral}{'u'} :}
\DoxyCodeLine{331         \{}
\DoxyCodeLine{332             \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_escape\_unicode\_short::invoke(loc))}
\DoxyCodeLine{333             \{}
\DoxyCodeLine{334                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_1_1detail_af51fa4863a69805aee614744ec7830de}{read\_utf8\_codepoint}}(token.unwrap(), loc));}
\DoxyCodeLine{335             \}}
\DoxyCodeLine{336             \textcolor{keywordflow}{else}}
\DoxyCodeLine{337             \{}
\DoxyCodeLine{338                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}parse\_escape\_sequence: "{}}}
\DoxyCodeLine{339                            \textcolor{stringliteral}{"{}invalid token found in UTF-\/8 codepoint uXXXX."{}},}
\DoxyCodeLine{340                            \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}here"{}}\}\}));}
\DoxyCodeLine{341             \}}
\DoxyCodeLine{342         \}}
\DoxyCodeLine{343         \textcolor{keywordflow}{case} \textcolor{charliteral}{'U'}:}
\DoxyCodeLine{344         \{}
\DoxyCodeLine{345             \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_escape\_unicode\_long::invoke(loc))}
\DoxyCodeLine{346             \{}
\DoxyCodeLine{347                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_1_1detail_af51fa4863a69805aee614744ec7830de}{read\_utf8\_codepoint}}(token.unwrap(), loc));}
\DoxyCodeLine{348             \}}
\DoxyCodeLine{349             \textcolor{keywordflow}{else}}
\DoxyCodeLine{350             \{}
\DoxyCodeLine{351                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}parse\_escape\_sequence: "{}}}
\DoxyCodeLine{352                            \textcolor{stringliteral}{"{}invalid token found in UTF-\/8 codepoint Uxxxxxxxx"{}},}
\DoxyCodeLine{353                            \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}here"{}}\}\}));}
\DoxyCodeLine{354             \}}
\DoxyCodeLine{355         \}}
\DoxyCodeLine{356     \}}
\DoxyCodeLine{357 }
\DoxyCodeLine{358     \textcolor{keyword}{const} \textcolor{keyword}{auto} msg = \mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}parse\_escape\_sequence: "{}}}
\DoxyCodeLine{359            \textcolor{stringliteral}{"{}unknown escape sequence appeared."{}}, \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc),}
\DoxyCodeLine{360            \textcolor{stringliteral}{"{}escape sequence is one of \(\backslash\)\(\backslash\), \(\backslash\)"{}, b, t, n, f, r, uxxxx, Uxxxxxxxx"{}}\}\},}
\DoxyCodeLine{361            \textcolor{comment}{/* Hints = */}\{\textcolor{stringliteral}{"{}if you want to write backslash as just one backslash, "{}}}
\DoxyCodeLine{362            \textcolor{stringliteral}{"{}use literal string like: regex    = '<\(\backslash\)\(\backslash\)i\(\backslash\)\(\backslash\)c*\(\backslash\)\(\backslash\)s*>'"{}}\});}
\DoxyCodeLine{363     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{364     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(msg);}
\DoxyCodeLine{365 \}}
\DoxyCodeLine{366 }
\DoxyCodeLine{367 \textcolor{keyword}{inline} std::ptrdiff\_t \mbox{\hyperlink{namespacetoml_1_1detail_aceb66a1f4d3206c2f0217c276dc7aff8}{check\_utf8\_validity}}(\textcolor{keyword}{const} std::string\& reg)}
\DoxyCodeLine{368 \{}
\DoxyCodeLine{369     \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}} loc(\textcolor{stringliteral}{"{}tmp"{}}, reg);}
\DoxyCodeLine{370     \textcolor{keyword}{const} \textcolor{keyword}{auto} u8 = \mbox{\hyperlink{structtoml_1_1detail_1_1repeat}{repeat<lex\_utf8\_code, unlimited>::invoke}}(loc);}
\DoxyCodeLine{371     \textcolor{keywordflow}{if}(!u8 || loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{372     \{}
\DoxyCodeLine{373         \textcolor{keyword}{const} \textcolor{keyword}{auto} error\_location = std::distance(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a4b1ba9aeab640d375f97b09efce3dab8}{begin}}(), loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}());}
\DoxyCodeLine{374         assert(0 <= error\_location);}
\DoxyCodeLine{375         \textcolor{keywordflow}{return} error\_location;}
\DoxyCodeLine{376     \}}
\DoxyCodeLine{377     \textcolor{keywordflow}{return} -\/1;}
\DoxyCodeLine{378 \}}
\DoxyCodeLine{379 }
\DoxyCodeLine{380 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<toml::string, region>}}, std::string>}
\DoxyCodeLine{381 \mbox{\hyperlink{namespacetoml_1_1detail_a448070e1dfbe69f2967d9b9e7f84d7ba}{parse\_ml\_basic\_string}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{382 \{}
\DoxyCodeLine{383     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{384     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_ml\_basic\_string::invoke(loc))}
\DoxyCodeLine{385     \{}
\DoxyCodeLine{386         \textcolor{keyword}{auto} inner\_loc = loc;}
\DoxyCodeLine{387         inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{388 }
\DoxyCodeLine{389         std::string retval;}
\DoxyCodeLine{390         retval.reserve(token.unwrap().size());}
\DoxyCodeLine{391 }
\DoxyCodeLine{392         \textcolor{keyword}{auto} delim = lex\_ml\_basic\_string\_open::invoke(inner\_loc);}
\DoxyCodeLine{393         \textcolor{keywordflow}{if}(!delim)}
\DoxyCodeLine{394         \{}
\DoxyCodeLine{395             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{396                 \textcolor{stringliteral}{"{}parse\_ml\_basic\_string: invalid token"{}},}
\DoxyCodeLine{397                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be \(\backslash\)"{}\(\backslash\)"{}\(\backslash\)"{}"{}}\}\}),}
\DoxyCodeLine{398                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{399         \}}
\DoxyCodeLine{400         \textcolor{comment}{// immediate newline is ignored (if exists)}}
\DoxyCodeLine{401         \textcolor{comment}{/* discard return value */} lex\_newline::invoke(inner\_loc);}
\DoxyCodeLine{402 }
\DoxyCodeLine{403         delim = \mbox{\hyperlink{namespacetoml_1_1detail_af16c59120242cf5708a3d4763ef84fda}{none}}();}
\DoxyCodeLine{404         \textcolor{keywordflow}{while}(!delim)}
\DoxyCodeLine{405         \{}
\DoxyCodeLine{406             \textcolor{keyword}{using }lex\_unescaped\_seq = \mbox{\hyperlink{structtoml_1_1detail_1_1repeat}{repeat}}<}
\DoxyCodeLine{407                 \mbox{\hyperlink{structtoml_1_1detail_1_1either}{either<lex\_ml\_basic\_unescaped, lex\_newline>}}, \mbox{\hyperlink{structtoml_1_1detail_1_1unlimited}{unlimited}}>;}
\DoxyCodeLine{408             \textcolor{keywordflow}{if}(\textcolor{keyword}{auto} unescaped = lex\_unescaped\_seq::invoke(inner\_loc))}
\DoxyCodeLine{409             \{}
\DoxyCodeLine{410                 retval += unescaped.unwrap().str();}
\DoxyCodeLine{411             \}}
\DoxyCodeLine{412             \textcolor{keywordflow}{if}(\textcolor{keyword}{auto} escaped = \mbox{\hyperlink{namespacetoml_1_1detail_a9e2d963ae5654a0f0f3bca2ffcbb15c0}{parse\_escape\_sequence}}(inner\_loc))}
\DoxyCodeLine{413             \{}
\DoxyCodeLine{414                 retval += escaped.unwrap();}
\DoxyCodeLine{415             \}}
\DoxyCodeLine{416             \textcolor{keywordflow}{if}(\textcolor{keyword}{auto} esc\_nl = lex\_ml\_basic\_escaped\_newline::invoke(inner\_loc))}
\DoxyCodeLine{417             \{}
\DoxyCodeLine{418                 \textcolor{comment}{// ignore newline after escape until next non-\/ws char}}
\DoxyCodeLine{419             \}}
\DoxyCodeLine{420             \textcolor{keywordflow}{if}(inner\_loc.iter() == inner\_loc.end())}
\DoxyCodeLine{421             \{}
\DoxyCodeLine{422                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{423                     \textcolor{stringliteral}{"{}parse\_ml\_basic\_string: unexpected end of region"{}},}
\DoxyCodeLine{424                     \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}not sufficient token"{}}\}\}),}
\DoxyCodeLine{425                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{426             \}}
\DoxyCodeLine{427             delim = lex\_ml\_basic\_string\_close::invoke(inner\_loc);}
\DoxyCodeLine{428         \}}
\DoxyCodeLine{429         \textcolor{comment}{// `lex\_ml\_basic\_string\_close` allows 3 to 5 `"{}`s to allow 1 or 2 `"{}`s}}
\DoxyCodeLine{430         \textcolor{comment}{// at just before the delimiter. Here, we need to attach `"{}`s at the}}
\DoxyCodeLine{431         \textcolor{comment}{// end of the string body, if it exists.}}
\DoxyCodeLine{432         \textcolor{comment}{// For detail, see the definition of `lex\_ml\_basic\_string\_close`.}}
\DoxyCodeLine{433         assert(std::all\_of(delim.unwrap().first(), delim.unwrap().last(),}
\DoxyCodeLine{434                            [](\textcolor{keyword}{const} \textcolor{keywordtype}{char} c) \textcolor{keyword}{noexcept} \{return c == \textcolor{stringliteral}{'\(\backslash\)"{}'};\}));}
\DoxyCodeLine{435         \textcolor{keywordflow}{switch}(delim.unwrap().size())}
\DoxyCodeLine{436         \{}
\DoxyCodeLine{437             \textcolor{keywordflow}{case} 3: \{\textcolor{keywordflow}{break};\}}
\DoxyCodeLine{438             \textcolor{keywordflow}{case} 4: \{retval += \textcolor{stringliteral}{"{}\(\backslash\)"{}"{}};  \textcolor{keywordflow}{break};\}}
\DoxyCodeLine{439             \textcolor{keywordflow}{case} 5: \{retval += \textcolor{stringliteral}{"{}\(\backslash\)"{}\(\backslash\)"{}"{}}; \textcolor{keywordflow}{break};\}}
\DoxyCodeLine{440             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{441             \{}
\DoxyCodeLine{442                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{443                     \textcolor{stringliteral}{"{}parse\_ml\_basic\_string: closing delimiter has invalid length"{}},}
\DoxyCodeLine{444                     \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}end of this"{}}\}\}),}
\DoxyCodeLine{445                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{446             \}}
\DoxyCodeLine{447         \}}
\DoxyCodeLine{448 }
\DoxyCodeLine{449         \textcolor{keyword}{const} \textcolor{keyword}{auto} err\_loc = \mbox{\hyperlink{namespacetoml_1_1detail_aceb66a1f4d3206c2f0217c276dc7aff8}{check\_utf8\_validity}}(token.unwrap().str());}
\DoxyCodeLine{450         \textcolor{keywordflow}{if}(err\_loc == -\/1)}
\DoxyCodeLine{451         \{}
\DoxyCodeLine{452             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(\mbox{\hyperlink{structtoml_1_1string}{toml::string}}(retval), token.unwrap()));}
\DoxyCodeLine{453         \}}
\DoxyCodeLine{454         \textcolor{keywordflow}{else}}
\DoxyCodeLine{455         \{}
\DoxyCodeLine{456             inner\_loc.reset(first);}
\DoxyCodeLine{457             inner\_loc.advance(err\_loc);}
\DoxyCodeLine{458             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{459                 \textcolor{stringliteral}{"{}parse\_ml\_basic\_string: invalid utf8 sequence found"{}},}
\DoxyCodeLine{460                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}here"{}}\}\}),}
\DoxyCodeLine{461                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{462         \}}
\DoxyCodeLine{463     \}}
\DoxyCodeLine{464     \textcolor{keywordflow}{else}}
\DoxyCodeLine{465     \{}
\DoxyCodeLine{466         loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{467         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_ml\_basic\_string: "{}}}
\DoxyCodeLine{468                    \textcolor{stringliteral}{"{}the next token is not a valid multiline string"{}},}
\DoxyCodeLine{469                    \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}here"{}}\}\}));}
\DoxyCodeLine{470     \}}
\DoxyCodeLine{471 \}}
\DoxyCodeLine{472 }
\DoxyCodeLine{473 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<toml::string, region>}}, std::string>}
\DoxyCodeLine{474 \mbox{\hyperlink{namespacetoml_1_1detail_a75c63a1eba5062b48bca39c3169b9246}{parse\_basic\_string}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{475 \{}
\DoxyCodeLine{476     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{477     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_basic\_string::invoke(loc))}
\DoxyCodeLine{478     \{}
\DoxyCodeLine{479         \textcolor{keyword}{auto} inner\_loc = loc;}
\DoxyCodeLine{480         inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{481 }
\DoxyCodeLine{482         \textcolor{keyword}{auto} quot = \mbox{\hyperlink{structtoml_1_1detail_1_1character_a324e051eb839e526a72e657478a65135}{lex\_quotation\_mark::invoke}}(inner\_loc);}
\DoxyCodeLine{483         \textcolor{keywordflow}{if}(!quot)}
\DoxyCodeLine{484         \{}
\DoxyCodeLine{485             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}parse\_basic\_string: "{}}}
\DoxyCodeLine{486                 \textcolor{stringliteral}{"{}invalid token"{}}, \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be \(\backslash\)"{}"{}}\}\}),}
\DoxyCodeLine{487                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{488         \}}
\DoxyCodeLine{489 }
\DoxyCodeLine{490         std::string retval;}
\DoxyCodeLine{491         retval.reserve(token.unwrap().size());}
\DoxyCodeLine{492 }
\DoxyCodeLine{493         quot = \mbox{\hyperlink{namespacetoml_1_1detail_af16c59120242cf5708a3d4763ef84fda}{none}}();}
\DoxyCodeLine{494         \textcolor{keywordflow}{while}(!quot)}
\DoxyCodeLine{495         \{}
\DoxyCodeLine{496             \textcolor{keyword}{using }lex\_unescaped\_seq = \mbox{\hyperlink{structtoml_1_1detail_1_1repeat}{repeat<lex\_basic\_unescaped, unlimited>}};}
\DoxyCodeLine{497             \textcolor{keywordflow}{if}(\textcolor{keyword}{auto} unescaped = lex\_unescaped\_seq::invoke(inner\_loc))}
\DoxyCodeLine{498             \{}
\DoxyCodeLine{499                 retval += unescaped.unwrap().str();}
\DoxyCodeLine{500             \}}
\DoxyCodeLine{501             \textcolor{keywordflow}{if}(\textcolor{keyword}{auto} escaped = \mbox{\hyperlink{namespacetoml_1_1detail_a9e2d963ae5654a0f0f3bca2ffcbb15c0}{parse\_escape\_sequence}}(inner\_loc))}
\DoxyCodeLine{502             \{}
\DoxyCodeLine{503                 retval += escaped.unwrap();}
\DoxyCodeLine{504             \}}
\DoxyCodeLine{505             \textcolor{keywordflow}{if}(inner\_loc.iter() == inner\_loc.end())}
\DoxyCodeLine{506             \{}
\DoxyCodeLine{507                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{508                     \textcolor{stringliteral}{"{}parse\_basic\_string: unexpected end of region"{}},}
\DoxyCodeLine{509                     \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}not sufficient token"{}}\}\}),}
\DoxyCodeLine{510                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{511             \}}
\DoxyCodeLine{512             quot = \mbox{\hyperlink{structtoml_1_1detail_1_1character_a324e051eb839e526a72e657478a65135}{lex\_quotation\_mark::invoke}}(inner\_loc);}
\DoxyCodeLine{513         \}}
\DoxyCodeLine{514 }
\DoxyCodeLine{515         \textcolor{keyword}{const} \textcolor{keyword}{auto} err\_loc = \mbox{\hyperlink{namespacetoml_1_1detail_aceb66a1f4d3206c2f0217c276dc7aff8}{check\_utf8\_validity}}(token.unwrap().str());}
\DoxyCodeLine{516         \textcolor{keywordflow}{if}(err\_loc == -\/1)}
\DoxyCodeLine{517         \{}
\DoxyCodeLine{518             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(\mbox{\hyperlink{structtoml_1_1string}{toml::string}}(retval), token.unwrap()));}
\DoxyCodeLine{519         \}}
\DoxyCodeLine{520         \textcolor{keywordflow}{else}}
\DoxyCodeLine{521         \{}
\DoxyCodeLine{522             inner\_loc.reset(first);}
\DoxyCodeLine{523             inner\_loc.advance(err\_loc);}
\DoxyCodeLine{524             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{525                 \textcolor{stringliteral}{"{}parse\_ml\_basic\_string: invalid utf8 sequence found"{}},}
\DoxyCodeLine{526                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}here"{}}\}\}),}
\DoxyCodeLine{527                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{528         \}}
\DoxyCodeLine{529     \}}
\DoxyCodeLine{530     \textcolor{keywordflow}{else}}
\DoxyCodeLine{531     \{}
\DoxyCodeLine{532         loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first); \textcolor{comment}{// rollback}}
\DoxyCodeLine{533         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_basic\_string: "{}}}
\DoxyCodeLine{534                    \textcolor{stringliteral}{"{}the next token is not a valid string"{}},}
\DoxyCodeLine{535                    \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}here"{}}\}\}));}
\DoxyCodeLine{536     \}}
\DoxyCodeLine{537 \}}
\DoxyCodeLine{538 }
\DoxyCodeLine{539 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<toml::string, region>}}, std::string>}
\DoxyCodeLine{540 \mbox{\hyperlink{namespacetoml_1_1detail_abb616874d86ad2e81f740a5661773003}{parse\_ml\_literal\_string}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{541 \{}
\DoxyCodeLine{542     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{543     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_ml\_literal\_string::invoke(loc))}
\DoxyCodeLine{544     \{}
\DoxyCodeLine{545         \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}} inner\_loc(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad6a386a1bb61633d7dc51025ee4bd6be}{name}}(), token.unwrap().str());}
\DoxyCodeLine{546 }
\DoxyCodeLine{547         \textcolor{keyword}{const} \textcolor{keyword}{auto} open = lex\_ml\_literal\_string\_open::invoke(inner\_loc);}
\DoxyCodeLine{548         \textcolor{keywordflow}{if}(!open)}
\DoxyCodeLine{549         \{}
\DoxyCodeLine{550             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{551                 \textcolor{stringliteral}{"{}parse\_ml\_literal\_string: invalid token"{}},}
\DoxyCodeLine{552                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be '''"{}}\}\}),}
\DoxyCodeLine{553                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{554         \}}
\DoxyCodeLine{555         \textcolor{comment}{// immediate newline is ignored (if exists)}}
\DoxyCodeLine{556         \textcolor{comment}{/* discard return value */} lex\_newline::invoke(inner\_loc);}
\DoxyCodeLine{557 }
\DoxyCodeLine{558         \textcolor{keyword}{const} \textcolor{keyword}{auto} body = lex\_ml\_literal\_body::invoke(inner\_loc);}
\DoxyCodeLine{559 }
\DoxyCodeLine{560         \textcolor{keyword}{const} \textcolor{keyword}{auto} close = lex\_ml\_literal\_string\_close::invoke(inner\_loc);}
\DoxyCodeLine{561         \textcolor{keywordflow}{if}(!close)}
\DoxyCodeLine{562         \{}
\DoxyCodeLine{563             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{564                 \textcolor{stringliteral}{"{}parse\_ml\_literal\_string: invalid token"{}},}
\DoxyCodeLine{565                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be '''"{}}\}\}),}
\DoxyCodeLine{566                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{567         \}}
\DoxyCodeLine{568         \textcolor{comment}{// `lex\_ml\_literal\_string\_close` allows 3 to 5 `'`s to allow 1 or 2 `'`s}}
\DoxyCodeLine{569         \textcolor{comment}{// at just before the delimiter. Here, we need to attach `'`s at the}}
\DoxyCodeLine{570         \textcolor{comment}{// end of the string body, if it exists.}}
\DoxyCodeLine{571         \textcolor{comment}{// For detail, see the definition of `lex\_ml\_basic\_string\_close`.}}
\DoxyCodeLine{572 }
\DoxyCodeLine{573         std::string retval = body.unwrap().str();}
\DoxyCodeLine{574         assert(std::all\_of(close.unwrap().first(), close.unwrap().last(),}
\DoxyCodeLine{575                            [](\textcolor{keyword}{const} \textcolor{keywordtype}{char} c) \textcolor{keyword}{noexcept} \{return c == \textcolor{stringliteral}{'\(\backslash\)''};\}));}
\DoxyCodeLine{576         \textcolor{keywordflow}{switch}(close.unwrap().size())}
\DoxyCodeLine{577         \{}
\DoxyCodeLine{578             \textcolor{keywordflow}{case} 3: \{\textcolor{keywordflow}{break};\}}
\DoxyCodeLine{579             \textcolor{keywordflow}{case} 4: \{retval += \textcolor{stringliteral}{"{}'"{}};  \textcolor{keywordflow}{break};\}}
\DoxyCodeLine{580             \textcolor{keywordflow}{case} 5: \{retval += \textcolor{stringliteral}{"{}''"{}}; \textcolor{keywordflow}{break};\}}
\DoxyCodeLine{581             \textcolor{keywordflow}{default}:}
\DoxyCodeLine{582             \{}
\DoxyCodeLine{583                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{584                     \textcolor{stringliteral}{"{}parse\_ml\_literal\_string: closing delimiter has invalid length"{}},}
\DoxyCodeLine{585                     \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}end of this"{}}\}\}),}
\DoxyCodeLine{586                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{587             \}}
\DoxyCodeLine{588         \}}
\DoxyCodeLine{589 }
\DoxyCodeLine{590         \textcolor{keyword}{const} \textcolor{keyword}{auto} err\_loc = \mbox{\hyperlink{namespacetoml_1_1detail_aceb66a1f4d3206c2f0217c276dc7aff8}{check\_utf8\_validity}}(token.unwrap().str());}
\DoxyCodeLine{591         \textcolor{keywordflow}{if}(err\_loc == -\/1)}
\DoxyCodeLine{592         \{}
\DoxyCodeLine{593             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(\mbox{\hyperlink{structtoml_1_1string}{toml::string}}(retval, \mbox{\hyperlink{namespacetoml_a54c05bb4b385f96d45e3807a92c1d19aaf0d674f1e0ed4292267f149c5983db02}{toml::string\_t::literal}}),}
\DoxyCodeLine{594                                      token.unwrap()));}
\DoxyCodeLine{595         \}}
\DoxyCodeLine{596         \textcolor{keywordflow}{else}}
\DoxyCodeLine{597         \{}
\DoxyCodeLine{598             inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{599             inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}(err\_loc);}
\DoxyCodeLine{600             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{601                 \textcolor{stringliteral}{"{}parse\_ml\_basic\_string: invalid utf8 sequence found"{}},}
\DoxyCodeLine{602                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}here"{}}\}\}),}
\DoxyCodeLine{603                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{604         \}}
\DoxyCodeLine{605     \}}
\DoxyCodeLine{606     \textcolor{keywordflow}{else}}
\DoxyCodeLine{607     \{}
\DoxyCodeLine{608         loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first); \textcolor{comment}{// rollback}}
\DoxyCodeLine{609         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_ml\_literal\_string: "{}}}
\DoxyCodeLine{610                    \textcolor{stringliteral}{"{}the next token is not a valid multiline literal string"{}},}
\DoxyCodeLine{611                    \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}here"{}}\}\}));}
\DoxyCodeLine{612     \}}
\DoxyCodeLine{613 \}}
\DoxyCodeLine{614 }
\DoxyCodeLine{615 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<toml::string, region>}}, std::string>}
\DoxyCodeLine{616 \mbox{\hyperlink{namespacetoml_1_1detail_ae5a8856bc82b3291e074fe4a6ace1ac9}{parse\_literal\_string}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{617 \{}
\DoxyCodeLine{618     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{619     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_literal\_string::invoke(loc))}
\DoxyCodeLine{620     \{}
\DoxyCodeLine{621         \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}} inner\_loc(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad6a386a1bb61633d7dc51025ee4bd6be}{name}}(), token.unwrap().str());}
\DoxyCodeLine{622 }
\DoxyCodeLine{623         \textcolor{keyword}{const} \textcolor{keyword}{auto} open = \mbox{\hyperlink{structtoml_1_1detail_1_1character_a324e051eb839e526a72e657478a65135}{lex\_apostrophe::invoke}}(inner\_loc);}
\DoxyCodeLine{624         \textcolor{keywordflow}{if}(!open)}
\DoxyCodeLine{625         \{}
\DoxyCodeLine{626             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{627                 \textcolor{stringliteral}{"{}parse\_literal\_string: invalid token"{}},}
\DoxyCodeLine{628                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be '"{}}\}\}),}
\DoxyCodeLine{629                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{630         \}}
\DoxyCodeLine{631 }
\DoxyCodeLine{632         \textcolor{keyword}{const} \textcolor{keyword}{auto} body = \mbox{\hyperlink{structtoml_1_1detail_1_1repeat}{repeat<lex\_literal\_char, unlimited>::invoke}}(inner\_loc);}
\DoxyCodeLine{633 }
\DoxyCodeLine{634         \textcolor{keyword}{const} \textcolor{keyword}{auto} close = \mbox{\hyperlink{structtoml_1_1detail_1_1character_a324e051eb839e526a72e657478a65135}{lex\_apostrophe::invoke}}(inner\_loc);}
\DoxyCodeLine{635         \textcolor{keywordflow}{if}(!close)}
\DoxyCodeLine{636         \{}
\DoxyCodeLine{637             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{638                 \textcolor{stringliteral}{"{}parse\_literal\_string: invalid token"{}},}
\DoxyCodeLine{639                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be '"{}}\}\}),}
\DoxyCodeLine{640                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{641         \}}
\DoxyCodeLine{642 }
\DoxyCodeLine{643         \textcolor{keyword}{const} \textcolor{keyword}{auto} err\_loc = \mbox{\hyperlink{namespacetoml_1_1detail_aceb66a1f4d3206c2f0217c276dc7aff8}{check\_utf8\_validity}}(token.unwrap().str());}
\DoxyCodeLine{644         \textcolor{keywordflow}{if}(err\_loc == -\/1)}
\DoxyCodeLine{645         \{}
\DoxyCodeLine{646             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(}
\DoxyCodeLine{647                       \mbox{\hyperlink{structtoml_1_1string}{toml::string}}(body.unwrap().str(), \mbox{\hyperlink{namespacetoml_a54c05bb4b385f96d45e3807a92c1d19aaf0d674f1e0ed4292267f149c5983db02}{toml::string\_t::literal}}),}
\DoxyCodeLine{648                       token.unwrap()));}
\DoxyCodeLine{649         \}}
\DoxyCodeLine{650         \textcolor{keywordflow}{else}}
\DoxyCodeLine{651         \{}
\DoxyCodeLine{652             inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{653             inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}(err\_loc);}
\DoxyCodeLine{654             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{655                 \textcolor{stringliteral}{"{}parse\_ml\_basic\_string: invalid utf8 sequence found"{}},}
\DoxyCodeLine{656                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}here"{}}\}\}),}
\DoxyCodeLine{657                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{658         \}}
\DoxyCodeLine{659     \}}
\DoxyCodeLine{660     \textcolor{keywordflow}{else}}
\DoxyCodeLine{661     \{}
\DoxyCodeLine{662         loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first); \textcolor{comment}{// rollback}}
\DoxyCodeLine{663         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_literal\_string: "{}}}
\DoxyCodeLine{664                    \textcolor{stringliteral}{"{}the next token is not a valid literal string"{}},}
\DoxyCodeLine{665                    \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}here"{}}\}\}));}
\DoxyCodeLine{666     \}}
\DoxyCodeLine{667 \}}
\DoxyCodeLine{668 }
\DoxyCodeLine{669 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<toml::string, region>}}, std::string>}
\DoxyCodeLine{670 \mbox{\hyperlink{namespacetoml_1_1detail_acc4dcb02c7028634b40e03687ba238de}{parse\_string}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{671 \{}
\DoxyCodeLine{672     \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& *(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}()) == \textcolor{charliteral}{'"{}'})}
\DoxyCodeLine{673     \{}
\DoxyCodeLine{674         \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() + 1 != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& *(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() + 1) == \textcolor{charliteral}{'"{}'} \&\&}
\DoxyCodeLine{675            loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() + 2 != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& *(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() + 2) == \textcolor{charliteral}{'"{}'})}
\DoxyCodeLine{676         \{}
\DoxyCodeLine{677             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_1_1detail_a448070e1dfbe69f2967d9b9e7f84d7ba}{parse\_ml\_basic\_string}}(loc);}
\DoxyCodeLine{678         \}}
\DoxyCodeLine{679         \textcolor{keywordflow}{else}}
\DoxyCodeLine{680         \{}
\DoxyCodeLine{681             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_1_1detail_a75c63a1eba5062b48bca39c3169b9246}{parse\_basic\_string}}(loc);}
\DoxyCodeLine{682         \}}
\DoxyCodeLine{683     \}}
\DoxyCodeLine{684     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& *(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}()) == \textcolor{charliteral}{'\(\backslash\)''})}
\DoxyCodeLine{685     \{}
\DoxyCodeLine{686         \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() + 1 != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& *(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() + 1) == \textcolor{charliteral}{'\(\backslash\)''} \&\&}
\DoxyCodeLine{687            loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() + 2 != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& *(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() + 2) == \textcolor{charliteral}{'\(\backslash\)''})}
\DoxyCodeLine{688         \{}
\DoxyCodeLine{689             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_1_1detail_abb616874d86ad2e81f740a5661773003}{parse\_ml\_literal\_string}}(loc);}
\DoxyCodeLine{690         \}}
\DoxyCodeLine{691         \textcolor{keywordflow}{else}}
\DoxyCodeLine{692         \{}
\DoxyCodeLine{693             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_1_1detail_ae5a8856bc82b3291e074fe4a6ace1ac9}{parse\_literal\_string}}(loc);}
\DoxyCodeLine{694         \}}
\DoxyCodeLine{695     \}}
\DoxyCodeLine{696     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_string: "{}},}
\DoxyCodeLine{697                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}the next token is not a string"{}}\}\}));}
\DoxyCodeLine{698 \}}
\DoxyCodeLine{699 }
\DoxyCodeLine{700 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<local\_date, region>}}, std::string>}
\DoxyCodeLine{701 \mbox{\hyperlink{namespacetoml_1_1detail_a086e87691ec78a9985f043905237335e}{parse\_local\_date}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{702 \{}
\DoxyCodeLine{703     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{704     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_local\_date::invoke(loc))}
\DoxyCodeLine{705     \{}
\DoxyCodeLine{706         \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}} inner\_loc(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad6a386a1bb61633d7dc51025ee4bd6be}{name}}(), token.unwrap().str());}
\DoxyCodeLine{707 }
\DoxyCodeLine{708         \textcolor{keyword}{const} \textcolor{keyword}{auto} y = lex\_date\_fullyear::invoke(inner\_loc);}
\DoxyCodeLine{709         \textcolor{keywordflow}{if}(!y || inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() || *inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != \textcolor{charliteral}{'-\/'})}
\DoxyCodeLine{710         \{}
\DoxyCodeLine{711             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{712                 \textcolor{stringliteral}{"{}toml::parse\_inner\_local\_date: invalid year format"{}},}
\DoxyCodeLine{713                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be `-\/`"{}}\}\}),}
\DoxyCodeLine{714                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{715         \}}
\DoxyCodeLine{716         inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}();}
\DoxyCodeLine{717         \textcolor{keyword}{const} \textcolor{keyword}{auto} m = lex\_date\_month::invoke(inner\_loc);}
\DoxyCodeLine{718         \textcolor{keywordflow}{if}(!m || inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() || *inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != \textcolor{charliteral}{'-\/'})}
\DoxyCodeLine{719         \{}
\DoxyCodeLine{720             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{721                 \textcolor{stringliteral}{"{}toml::parse\_local\_date: invalid month format"{}},}
\DoxyCodeLine{722                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be `-\/`"{}}\}\}),}
\DoxyCodeLine{723                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{724         \}}
\DoxyCodeLine{725         inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}();}
\DoxyCodeLine{726         \textcolor{keyword}{const} \textcolor{keyword}{auto} d = lex\_date\_mday::invoke(inner\_loc);}
\DoxyCodeLine{727         \textcolor{keywordflow}{if}(!d)}
\DoxyCodeLine{728         \{}
\DoxyCodeLine{729             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{730                 \textcolor{stringliteral}{"{}toml::parse\_local\_date: invalid day format"{}},}
\DoxyCodeLine{731                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}here"{}}\}\}),}
\DoxyCodeLine{732                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{733         \}}
\DoxyCodeLine{734 }
\DoxyCodeLine{735         \textcolor{keyword}{const} \textcolor{keyword}{auto} year  = \textcolor{keyword}{static\_cast<}std::int16\_t\textcolor{keyword}{>}(from\_string<int>(y.unwrap().str(), 0));}
\DoxyCodeLine{736         \textcolor{keyword}{const} \textcolor{keyword}{auto} month = \textcolor{keyword}{static\_cast<}std::int8\_t \textcolor{keyword}{>}(from\_string<int>(m.unwrap().str(), 0));}
\DoxyCodeLine{737         \textcolor{keyword}{const} \textcolor{keyword}{auto} day   = \textcolor{keyword}{static\_cast<}std::int8\_t \textcolor{keyword}{>}(from\_string<int>(d.unwrap().str(), 0));}
\DoxyCodeLine{738 }
\DoxyCodeLine{739         \textcolor{comment}{// We briefly check whether the input date is valid or not. But here, we}}
\DoxyCodeLine{740         \textcolor{comment}{// only check if the RFC3339 compliance.}}
\DoxyCodeLine{741         \textcolor{comment}{//     Actually there are several special date that does not exist,}}
\DoxyCodeLine{742         \textcolor{comment}{// because of historical reasons, such as 1582/10/5-\/1582/10/14 (only in}}
\DoxyCodeLine{743         \textcolor{comment}{// several countries). But here, we do not care about such a complicated}}
\DoxyCodeLine{744         \textcolor{comment}{// rule. It makes the code complicated and there is only low probability}}
\DoxyCodeLine{745         \textcolor{comment}{// that such a specific date is needed in practice. If someone need to}}
\DoxyCodeLine{746         \textcolor{comment}{// validate date accurately, that means that the one need a specialized}}
\DoxyCodeLine{747         \textcolor{comment}{// library for their purpose in a different layer.}}
\DoxyCodeLine{748         \{}
\DoxyCodeLine{749             \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_leap = (year \% 4 == 0) \&\& ((year \% 100 != 0) || (year \% 400 == 0));}
\DoxyCodeLine{750             \textcolor{keyword}{const} \textcolor{keyword}{auto} max\_day = (month == 2) ? (is\_leap ? 29 : 28) :}
\DoxyCodeLine{751                 ((month == 4 || month == 6 || month == 9 || month == 11) ? 30 : 31);}
\DoxyCodeLine{752 }
\DoxyCodeLine{753             \textcolor{keywordflow}{if}((month < 1 || 12 < month) || (day < 1 || max\_day < day))}
\DoxyCodeLine{754             \{}
\DoxyCodeLine{755                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_date: "{}}}
\DoxyCodeLine{756                     \textcolor{stringliteral}{"{}invalid date: it does not conform RFC3339."{}}, \{\{}
\DoxyCodeLine{757                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}month should be 01-\/12, day should be"{}}}
\DoxyCodeLine{758                     \textcolor{stringliteral}{"{} 01-\/28,29,30,31, depending on month/year."{}}}
\DoxyCodeLine{759                     \}\}), \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{760             \}}
\DoxyCodeLine{761         \}}
\DoxyCodeLine{762         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(\mbox{\hyperlink{structtoml_1_1local__date}{local\_date}}(year, \textcolor{keyword}{static\_cast<}\mbox{\hyperlink{namespacetoml_a89509f5839cddbb6cc3205611e198ca5}{month\_t}}\textcolor{keyword}{>}(month -\/ 1), day),}
\DoxyCodeLine{763                                  token.unwrap()));}
\DoxyCodeLine{764     \}}
\DoxyCodeLine{765     \textcolor{keywordflow}{else}}
\DoxyCodeLine{766     \{}
\DoxyCodeLine{767         loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{768         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_local\_date: "{}},}
\DoxyCodeLine{769             \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}the next token is not a local\_date"{}}\}\}));}
\DoxyCodeLine{770     \}}
\DoxyCodeLine{771 \}}
\DoxyCodeLine{772 }
\DoxyCodeLine{773 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<local\_time, region>}}, std::string>}
\DoxyCodeLine{774 \mbox{\hyperlink{namespacetoml_1_1detail_aaf5f64afd505a0c69b3e28b6afbffb97}{parse\_local\_time}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{775 \{}
\DoxyCodeLine{776     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{777     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_local\_time::invoke(loc))}
\DoxyCodeLine{778     \{}
\DoxyCodeLine{779         \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}} inner\_loc(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad6a386a1bb61633d7dc51025ee4bd6be}{name}}(), token.unwrap().str());}
\DoxyCodeLine{780 }
\DoxyCodeLine{781         \textcolor{keyword}{const} \textcolor{keyword}{auto} h = lex\_time\_hour::invoke(inner\_loc);}
\DoxyCodeLine{782         \textcolor{keywordflow}{if}(!h || inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() || *inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != \textcolor{charliteral}{':'})}
\DoxyCodeLine{783         \{}
\DoxyCodeLine{784             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{785                 \textcolor{stringliteral}{"{}toml::parse\_local\_time: invalid year format"{}},}
\DoxyCodeLine{786                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be `:`"{}}\}\}),}
\DoxyCodeLine{787                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{788         \}}
\DoxyCodeLine{789         inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}();}
\DoxyCodeLine{790         \textcolor{keyword}{const} \textcolor{keyword}{auto} m = lex\_time\_minute::invoke(inner\_loc);}
\DoxyCodeLine{791         \textcolor{keywordflow}{if}(!m || inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() || *inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != \textcolor{charliteral}{':'})}
\DoxyCodeLine{792         \{}
\DoxyCodeLine{793             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{794                 \textcolor{stringliteral}{"{}toml::parse\_local\_time: invalid month format"{}},}
\DoxyCodeLine{795                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be `:`"{}}\}\}),}
\DoxyCodeLine{796                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{797         \}}
\DoxyCodeLine{798         inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}();}
\DoxyCodeLine{799         \textcolor{keyword}{const} \textcolor{keyword}{auto} s = lex\_time\_second::invoke(inner\_loc);}
\DoxyCodeLine{800         \textcolor{keywordflow}{if}(!s)}
\DoxyCodeLine{801         \{}
\DoxyCodeLine{802             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{803                 \textcolor{stringliteral}{"{}toml::parse\_local\_time: invalid second format"{}},}
\DoxyCodeLine{804                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}here"{}}\}\}),}
\DoxyCodeLine{805                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{806         \}}
\DoxyCodeLine{807 }
\DoxyCodeLine{808         \textcolor{keyword}{const} \textcolor{keywordtype}{int} hour   = from\_string<int>(h.unwrap().str(), 0);}
\DoxyCodeLine{809         \textcolor{keyword}{const} \textcolor{keywordtype}{int} minute = from\_string<int>(m.unwrap().str(), 0);}
\DoxyCodeLine{810         \textcolor{keyword}{const} \textcolor{keywordtype}{int} second = from\_string<int>(s.unwrap().str(), 0);}
\DoxyCodeLine{811 }
\DoxyCodeLine{812         \textcolor{keywordflow}{if}((hour   < 0 || 23 < hour) || (minute < 0 || 59 < minute) ||}
\DoxyCodeLine{813            (second < 0 || 60 < second)) \textcolor{comment}{// it may be leap second}}
\DoxyCodeLine{814         \{}
\DoxyCodeLine{815             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_time: "{}}}
\DoxyCodeLine{816                 \textcolor{stringliteral}{"{}invalid time: it does not conform RFC3339."{}}, \{\{}
\DoxyCodeLine{817                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}hour should be 00-\/23, minute should be"{}}}
\DoxyCodeLine{818                 \textcolor{stringliteral}{"{} 00-\/59, second should be 00-\/60 (depending on the leap"{}}}
\DoxyCodeLine{819                 \textcolor{stringliteral}{"{} second rules.)"{}}\}\}), \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{820         \}}
\DoxyCodeLine{821 }
\DoxyCodeLine{822         \mbox{\hyperlink{structtoml_1_1local__time}{local\_time}} time(hour, minute, second, 0, 0);}
\DoxyCodeLine{823 }
\DoxyCodeLine{824         \textcolor{keyword}{const} \textcolor{keyword}{auto} before\_secfrac = inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{825         \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} secfrac = lex\_time\_secfrac::invoke(inner\_loc))}
\DoxyCodeLine{826         \{}
\DoxyCodeLine{827             \textcolor{keyword}{auto} sf = secfrac.unwrap().str();}
\DoxyCodeLine{828             sf.erase(sf.begin()); \textcolor{comment}{// sf.front() == '.'}}
\DoxyCodeLine{829             \textcolor{keywordflow}{switch}(sf.size() \% 3)}
\DoxyCodeLine{830             \{}
\DoxyCodeLine{831                 \textcolor{keywordflow}{case} 2:  sf += \textcolor{charliteral}{'0'};  \textcolor{keywordflow}{break};}
\DoxyCodeLine{832                 \textcolor{keywordflow}{case} 1:  sf += \textcolor{stringliteral}{"{}00"{}}; \textcolor{keywordflow}{break};}
\DoxyCodeLine{833                 \textcolor{keywordflow}{case} 0:  \textcolor{keywordflow}{break};}
\DoxyCodeLine{834                 \textcolor{keywordflow}{default}: \textcolor{keywordflow}{break};}
\DoxyCodeLine{835             \}}
\DoxyCodeLine{836             \textcolor{keywordflow}{if}(sf.size() >= 9)}
\DoxyCodeLine{837             \{}
\DoxyCodeLine{838                 time.\mbox{\hyperlink{structtoml_1_1local__time_aa74932ceccf287bfaea3073e6f2b9291}{millisecond}} = from\_string<std::uint16\_t>(sf.substr(0, 3), 0u);}
\DoxyCodeLine{839                 time.\mbox{\hyperlink{structtoml_1_1local__time_a67662d3f6d54baea2fda9268e2b90845}{microsecond}} = from\_string<std::uint16\_t>(sf.substr(3, 3), 0u);}
\DoxyCodeLine{840                 time.\mbox{\hyperlink{structtoml_1_1local__time_a9bcf84d9eee020b6ce7d5c6fe335d0dc}{nanosecond}}  = from\_string<std::uint16\_t>(sf.substr(6, 3), 0u);}
\DoxyCodeLine{841             \}}
\DoxyCodeLine{842             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(sf.size() >= 6)}
\DoxyCodeLine{843             \{}
\DoxyCodeLine{844                 time.\mbox{\hyperlink{structtoml_1_1local__time_aa74932ceccf287bfaea3073e6f2b9291}{millisecond}} = from\_string<std::uint16\_t>(sf.substr(0, 3), 0u);}
\DoxyCodeLine{845                 time.\mbox{\hyperlink{structtoml_1_1local__time_a67662d3f6d54baea2fda9268e2b90845}{microsecond}} = from\_string<std::uint16\_t>(sf.substr(3, 3), 0u);}
\DoxyCodeLine{846             \}}
\DoxyCodeLine{847             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(sf.size() >= 3)}
\DoxyCodeLine{848             \{}
\DoxyCodeLine{849                 time.\mbox{\hyperlink{structtoml_1_1local__time_aa74932ceccf287bfaea3073e6f2b9291}{millisecond}} = from\_string<std::uint16\_t>(sf, 0u);}
\DoxyCodeLine{850                 time.\mbox{\hyperlink{structtoml_1_1local__time_a67662d3f6d54baea2fda9268e2b90845}{microsecond}} = 0u;}
\DoxyCodeLine{851             \}}
\DoxyCodeLine{852         \}}
\DoxyCodeLine{853         \textcolor{keywordflow}{else}}
\DoxyCodeLine{854         \{}
\DoxyCodeLine{855             \textcolor{keywordflow}{if}(before\_secfrac != inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}())}
\DoxyCodeLine{856             \{}
\DoxyCodeLine{857                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{858                     \textcolor{stringliteral}{"{}toml::parse\_local\_time: invalid subsecond format"{}},}
\DoxyCodeLine{859                     \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}here"{}}\}\}),}
\DoxyCodeLine{860                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{861             \}}
\DoxyCodeLine{862         \}}
\DoxyCodeLine{863         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(time, token.unwrap()));}
\DoxyCodeLine{864     \}}
\DoxyCodeLine{865     \textcolor{keywordflow}{else}}
\DoxyCodeLine{866     \{}
\DoxyCodeLine{867         loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{868         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_local\_time: "{}},}
\DoxyCodeLine{869             \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}the next token is not a local\_time"{}}\}\}));}
\DoxyCodeLine{870     \}}
\DoxyCodeLine{871 \}}
\DoxyCodeLine{872 }
\DoxyCodeLine{873 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<local\_datetime, region>}}, std::string>}
\DoxyCodeLine{874 \mbox{\hyperlink{namespacetoml_1_1detail_a5d307bd1493d2e305dc247f244da69b2}{parse\_local\_datetime}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{875 \{}
\DoxyCodeLine{876     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{877     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_local\_date\_time::invoke(loc))}
\DoxyCodeLine{878     \{}
\DoxyCodeLine{879         \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}} inner\_loc(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad6a386a1bb61633d7dc51025ee4bd6be}{name}}(), token.unwrap().str());}
\DoxyCodeLine{880         \textcolor{keyword}{const} \textcolor{keyword}{auto} date = \mbox{\hyperlink{namespacetoml_1_1detail_a086e87691ec78a9985f043905237335e}{parse\_local\_date}}(inner\_loc);}
\DoxyCodeLine{881         \textcolor{keywordflow}{if}(!date || inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{882         \{}
\DoxyCodeLine{883             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{884                 \textcolor{stringliteral}{"{}toml::parse\_local\_datetime: invalid datetime format"{}},}
\DoxyCodeLine{885                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}date, not datetime"{}}\}\}),}
\DoxyCodeLine{886                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{887         \}}
\DoxyCodeLine{888         \textcolor{keyword}{const} \textcolor{keywordtype}{char} delim = *(inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}());}
\DoxyCodeLine{889         \textcolor{keywordflow}{if}(delim != \textcolor{charliteral}{'T'} \&\& delim != \textcolor{charliteral}{'t'} \&\& delim != \textcolor{charliteral}{' '})}
\DoxyCodeLine{890         \{}
\DoxyCodeLine{891             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{892                 \textcolor{stringliteral}{"{}toml::parse\_local\_datetime: invalid datetime format"{}},}
\DoxyCodeLine{893                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be `T` or ` ` (space)"{}}\}\}),}
\DoxyCodeLine{894                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{895         \}}
\DoxyCodeLine{896         inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}();}
\DoxyCodeLine{897         \textcolor{keyword}{const} \textcolor{keyword}{auto} time = \mbox{\hyperlink{namespacetoml_1_1detail_aaf5f64afd505a0c69b3e28b6afbffb97}{parse\_local\_time}}(inner\_loc);}
\DoxyCodeLine{898         \textcolor{keywordflow}{if}(!time)}
\DoxyCodeLine{899         \{}
\DoxyCodeLine{900             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{901                 \textcolor{stringliteral}{"{}toml::parse\_local\_datetime: invalid datetime format"{}},}
\DoxyCodeLine{902                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}invalid time format"{}}\}\}),}
\DoxyCodeLine{903                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{904         \}}
\DoxyCodeLine{905         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(}
\DoxyCodeLine{906             \mbox{\hyperlink{structtoml_1_1local__datetime}{local\_datetime}}(date.unwrap().first, time.unwrap().first),}
\DoxyCodeLine{907             token.unwrap()));}
\DoxyCodeLine{908     \}}
\DoxyCodeLine{909     \textcolor{keywordflow}{else}}
\DoxyCodeLine{910     \{}
\DoxyCodeLine{911         loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{912         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_local\_datetime: "{}},}
\DoxyCodeLine{913             \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}the next token is not a local\_datetime"{}}\}\}));}
\DoxyCodeLine{914     \}}
\DoxyCodeLine{915 \}}
\DoxyCodeLine{916 }
\DoxyCodeLine{917 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<offset\_datetime, region>}}, std::string>}
\DoxyCodeLine{918 \mbox{\hyperlink{namespacetoml_1_1detail_ac710d6135936a580d7b3949744e488ca}{parse\_offset\_datetime}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{919 \{}
\DoxyCodeLine{920     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{921     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_offset\_date\_time::invoke(loc))}
\DoxyCodeLine{922     \{}
\DoxyCodeLine{923         \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}} inner\_loc(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad6a386a1bb61633d7dc51025ee4bd6be}{name}}(), token.unwrap().str());}
\DoxyCodeLine{924         \textcolor{keyword}{const} \textcolor{keyword}{auto} datetime = \mbox{\hyperlink{namespacetoml_1_1detail_a5d307bd1493d2e305dc247f244da69b2}{parse\_local\_datetime}}(inner\_loc);}
\DoxyCodeLine{925         \textcolor{keywordflow}{if}(!datetime || inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{926         \{}
\DoxyCodeLine{927             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{928                 \textcolor{stringliteral}{"{}toml::parse\_offset\_datetime: invalid datetime format"{}},}
\DoxyCodeLine{929                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}date, not datetime"{}}\}\}),}
\DoxyCodeLine{930                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{931         \}}
\DoxyCodeLine{932         \mbox{\hyperlink{structtoml_1_1time__offset}{time\_offset}} offset(0, 0);}
\DoxyCodeLine{933         \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} ofs = lex\_time\_numoffset::invoke(inner\_loc))}
\DoxyCodeLine{934         \{}
\DoxyCodeLine{935             \textcolor{keyword}{const} \textcolor{keyword}{auto} str = ofs.unwrap().str();}
\DoxyCodeLine{936 }
\DoxyCodeLine{937             \textcolor{keyword}{const} \textcolor{keyword}{auto} hour   = from\_string<int>(str.substr(1,2), 0);}
\DoxyCodeLine{938             \textcolor{keyword}{const} \textcolor{keyword}{auto} minute = from\_string<int>(str.substr(4,2), 0);}
\DoxyCodeLine{939 }
\DoxyCodeLine{940             \textcolor{keywordflow}{if}((hour < 0 || 23 < hour) || (minute < 0 || 59 < minute))}
\DoxyCodeLine{941             \{}
\DoxyCodeLine{942                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_offset\_datetime: "{}}}
\DoxyCodeLine{943                     \textcolor{stringliteral}{"{}invalid offset: it does not conform RFC3339."{}}, \{\{}
\DoxyCodeLine{944                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}month should be 01-\/12, day should be"{}}}
\DoxyCodeLine{945                     \textcolor{stringliteral}{"{} 01-\/28,29,30,31, depending on month/year."{}}}
\DoxyCodeLine{946                     \}\}), \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{947             \}}
\DoxyCodeLine{948 }
\DoxyCodeLine{949             \textcolor{keywordflow}{if}(str.front() == \textcolor{charliteral}{'+'})}
\DoxyCodeLine{950             \{}
\DoxyCodeLine{951                 offset = \mbox{\hyperlink{structtoml_1_1time__offset}{time\_offset}}(hour, minute);}
\DoxyCodeLine{952             \}}
\DoxyCodeLine{953             \textcolor{keywordflow}{else}}
\DoxyCodeLine{954             \{}
\DoxyCodeLine{955                 offset = \mbox{\hyperlink{structtoml_1_1time__offset}{time\_offset}}(-\/hour, -\/minute);}
\DoxyCodeLine{956             \}}
\DoxyCodeLine{957         \}}
\DoxyCodeLine{958         \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != \textcolor{charliteral}{'Z'} \&\& *inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != \textcolor{charliteral}{'z'})}
\DoxyCodeLine{959         \{}
\DoxyCodeLine{960             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{961                 \textcolor{stringliteral}{"{}toml::parse\_offset\_datetime: invalid datetime format"{}},}
\DoxyCodeLine{962                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be `Z` or `+HH:MM`"{}}\}\}),}
\DoxyCodeLine{963                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{964         \}}
\DoxyCodeLine{965         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(\mbox{\hyperlink{structtoml_1_1offset__datetime}{offset\_datetime}}(datetime.unwrap().first, offset),}
\DoxyCodeLine{966                                  token.unwrap()));}
\DoxyCodeLine{967     \}}
\DoxyCodeLine{968     \textcolor{keywordflow}{else}}
\DoxyCodeLine{969     \{}
\DoxyCodeLine{970         loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{971         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_offset\_datetime: "{}},}
\DoxyCodeLine{972             \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}the next token is not a offset\_datetime"{}}\}\}));}
\DoxyCodeLine{973     \}}
\DoxyCodeLine{974 \}}
\DoxyCodeLine{975 }
\DoxyCodeLine{976 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<key, region>}}, std::string>}
\DoxyCodeLine{977 \mbox{\hyperlink{namespacetoml_1_1detail_a868c59ae781e1aea376d827c8d7a841a}{parse\_simple\_key}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{978 \{}
\DoxyCodeLine{979     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} bstr = \mbox{\hyperlink{namespacetoml_1_1detail_a75c63a1eba5062b48bca39c3169b9246}{parse\_basic\_string}}(loc))}
\DoxyCodeLine{980     \{}
\DoxyCodeLine{981         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(bstr.unwrap().first.str, bstr.unwrap().second));}
\DoxyCodeLine{982     \}}
\DoxyCodeLine{983     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} lstr = \mbox{\hyperlink{namespacetoml_1_1detail_ae5a8856bc82b3291e074fe4a6ace1ac9}{parse\_literal\_string}}(loc))}
\DoxyCodeLine{984     \{}
\DoxyCodeLine{985         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(lstr.unwrap().first.str, lstr.unwrap().second));}
\DoxyCodeLine{986     \}}
\DoxyCodeLine{987     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} bare = lex\_unquoted\_key::invoke(loc))}
\DoxyCodeLine{988     \{}
\DoxyCodeLine{989         \textcolor{keyword}{const} \textcolor{keyword}{auto} reg = bare.unwrap();}
\DoxyCodeLine{990         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(reg.str(), reg));}
\DoxyCodeLine{991     \}}
\DoxyCodeLine{992     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_simple\_key: "{}},}
\DoxyCodeLine{993             \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}the next token is not a simple key"{}}\}\}));}
\DoxyCodeLine{994 \}}
\DoxyCodeLine{995 }
\DoxyCodeLine{996 \textcolor{comment}{// dotted key become vector of keys}}
\DoxyCodeLine{997 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<std::vector<key>}}, region>, std::string>}
\DoxyCodeLine{998 \mbox{\hyperlink{namespacetoml_1_1detail_ac3ca2e746db114f0747188013a7b9b62}{parse\_key}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{999 \{}
\DoxyCodeLine{1000     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{1001     \textcolor{comment}{// dotted key -\/> `foo.bar.baz` where several single keys are chained by}}
\DoxyCodeLine{1002     \textcolor{comment}{// dots. Whitespaces between keys and dots are allowed.}}
\DoxyCodeLine{1003     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_dotted\_key::invoke(loc))}
\DoxyCodeLine{1004     \{}
\DoxyCodeLine{1005         \textcolor{keyword}{const} \textcolor{keyword}{auto} reg = token.unwrap();}
\DoxyCodeLine{1006         \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}} inner\_loc(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad6a386a1bb61633d7dc51025ee4bd6be}{name}}(), reg.str());}
\DoxyCodeLine{1007         std::vector<key> keys;}
\DoxyCodeLine{1008 }
\DoxyCodeLine{1009         \textcolor{keywordflow}{while}(inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{1010         \{}
\DoxyCodeLine{1011             lex\_ws::invoke(inner\_loc);}
\DoxyCodeLine{1012             \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} k = \mbox{\hyperlink{namespacetoml_1_1detail_a868c59ae781e1aea376d827c8d7a841a}{parse\_simple\_key}}(inner\_loc))}
\DoxyCodeLine{1013             \{}
\DoxyCodeLine{1014                 keys.push\_back(k.unwrap().first);}
\DoxyCodeLine{1015             \}}
\DoxyCodeLine{1016             \textcolor{keywordflow}{else}}
\DoxyCodeLine{1017             \{}
\DoxyCodeLine{1018                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{1019                     \textcolor{stringliteral}{"{}toml::detail::parse\_key: dotted key contains invalid key"{}},}
\DoxyCodeLine{1020                     \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), k.unwrap\_err()\}\}),}
\DoxyCodeLine{1021                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{1022             \}}
\DoxyCodeLine{1023 }
\DoxyCodeLine{1024             lex\_ws::invoke(inner\_loc);}
\DoxyCodeLine{1025             \textcolor{keywordflow}{if}(inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{1026             \{}
\DoxyCodeLine{1027                 \textcolor{keywordflow}{break};}
\DoxyCodeLine{1028             \}}
\DoxyCodeLine{1029             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{'.'})}
\DoxyCodeLine{1030             \{}
\DoxyCodeLine{1031                 inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}(); \textcolor{comment}{// to skip `.`}}
\DoxyCodeLine{1032             \}}
\DoxyCodeLine{1033             \textcolor{keywordflow}{else}}
\DoxyCodeLine{1034             \{}
\DoxyCodeLine{1035                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_key: "{}}}
\DoxyCodeLine{1036                     \textcolor{stringliteral}{"{}dotted key contains invalid key "{}},}
\DoxyCodeLine{1037                     \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be `.`"{}}\}\}),}
\DoxyCodeLine{1038                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{1039             \}}
\DoxyCodeLine{1040         \}}
\DoxyCodeLine{1041         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(keys, reg));}
\DoxyCodeLine{1042     \}}
\DoxyCodeLine{1043     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{1044 }
\DoxyCodeLine{1045     \textcolor{comment}{// simple\_key: a single (basic\_string|literal\_string|bare key)}}
\DoxyCodeLine{1046     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} smpl = \mbox{\hyperlink{namespacetoml_1_1detail_a868c59ae781e1aea376d827c8d7a841a}{parse\_simple\_key}}(loc))}
\DoxyCodeLine{1047     \{}
\DoxyCodeLine{1048         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(std::vector<key>(1, smpl.unwrap().first),}
\DoxyCodeLine{1049                                  smpl.unwrap().second));}
\DoxyCodeLine{1050     \}}
\DoxyCodeLine{1051     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_key: an invalid key appeared."{}},}
\DoxyCodeLine{1052                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}is not a valid key"{}}\}\}, \{}
\DoxyCodeLine{1053                 \textcolor{stringliteral}{"{}bare keys  : non-\/empty strings composed only of [A-\/Za-\/z0-\/9\_-\/]."{}},}
\DoxyCodeLine{1054                 \textcolor{stringliteral}{"{}quoted keys: same as \(\backslash\)"{}basic strings\(\backslash\)"{} or 'literal strings'."{}},}
\DoxyCodeLine{1055                 \textcolor{stringliteral}{"{}dotted keys: sequence of bare or quoted keys joined with a dot."{}}}
\DoxyCodeLine{1056                 \}));}
\DoxyCodeLine{1057 \}}
\DoxyCodeLine{1058 }
\DoxyCodeLine{1059 \textcolor{comment}{// forward-\/decl to implement parse\_array and parse\_table}}
\DoxyCodeLine{1060 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{1061 \mbox{\hyperlink{structtoml_1_1result}{result<Value, std::string>}} \mbox{\hyperlink{namespacetoml_1_1detail_a1b4b4caf7f95ad4490c056a4b9394a2f}{parse\_value}}(location\&);}
\DoxyCodeLine{1062 }
\DoxyCodeLine{1063 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{1064 \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<typename Value::array\_type, region>}}, std::string>}
\DoxyCodeLine{1065 \mbox{\hyperlink{namespacetoml_1_1detail_af0db04876cc6292a9897aecc2ca0ea6c}{parse\_array}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{1066 \{}
\DoxyCodeLine{1067     \textcolor{keyword}{using }value\_type = Value;}
\DoxyCodeLine{1068     \textcolor{keyword}{using }array\_type = \textcolor{keyword}{typename} value\_type::array\_type;}
\DoxyCodeLine{1069 }
\DoxyCodeLine{1070     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{1071     \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{1072     \{}
\DoxyCodeLine{1073         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\textcolor{stringliteral}{"{}toml::parse\_array: input is empty"{}});}
\DoxyCodeLine{1074     \}}
\DoxyCodeLine{1075     \textcolor{keywordflow}{if}(*loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != \textcolor{charliteral}{'['})}
\DoxyCodeLine{1076     \{}
\DoxyCodeLine{1077         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\textcolor{stringliteral}{"{}toml::parse\_array: token is not an array"{}});}
\DoxyCodeLine{1078     \}}
\DoxyCodeLine{1079     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}();}
\DoxyCodeLine{1080 }
\DoxyCodeLine{1081     \textcolor{keyword}{using }lex\_ws\_comment\_newline = \mbox{\hyperlink{structtoml_1_1detail_1_1repeat}{repeat}}<}
\DoxyCodeLine{1082         \mbox{\hyperlink{structtoml_1_1detail_1_1either}{either<lex\_wschar, lex\_newline, lex\_comment>}}, \mbox{\hyperlink{structtoml_1_1detail_1_1unlimited}{unlimited}}>;}
\DoxyCodeLine{1083 }
\DoxyCodeLine{1084     array\_type retval;}
\DoxyCodeLine{1085     \textcolor{keywordflow}{while}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{1086     \{}
\DoxyCodeLine{1087         lex\_ws\_comment\_newline::invoke(loc); \textcolor{comment}{// skip}}
\DoxyCodeLine{1088 }
\DoxyCodeLine{1089         \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& *loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{']'})}
\DoxyCodeLine{1090         \{}
\DoxyCodeLine{1091             loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}(); \textcolor{comment}{// skip ']'}}
\DoxyCodeLine{1092             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(retval,}
\DoxyCodeLine{1093                       \mbox{\hyperlink{structtoml_1_1detail_1_1region}{region}}(loc, first, loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}())));}
\DoxyCodeLine{1094         \}}
\DoxyCodeLine{1095 }
\DoxyCodeLine{1096         \textcolor{keywordflow}{if}(\textcolor{keyword}{auto} val = parse\_value<value\_type>(loc))}
\DoxyCodeLine{1097         \{}
\DoxyCodeLine{1098             \textcolor{comment}{// After TOML v1.0.0-\/rc.1, array becomes to be able to have values}}
\DoxyCodeLine{1099             \textcolor{comment}{// with different types. So here we will omit this by default.}}
\DoxyCodeLine{1100             \textcolor{comment}{//}}
\DoxyCodeLine{1101             \textcolor{comment}{// But some of the test-\/suite checks if the parser accepts a hetero-\/}}
\DoxyCodeLine{1102             \textcolor{comment}{// geneous arrays, so we keep this for a while.}}
\DoxyCodeLine{1103 \textcolor{preprocessor}{\#ifdef TOML11\_DISALLOW\_HETEROGENEOUS\_ARRAYS}}
\DoxyCodeLine{1104             \textcolor{keywordflow}{if}(!retval.empty() \&\& retval.front().type() != val.as\_ok().type())}
\DoxyCodeLine{1105             \{}
\DoxyCodeLine{1106                 \textcolor{keyword}{auto} array\_start\_loc = loc;}
\DoxyCodeLine{1107                 array\_start\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{1108 }
\DoxyCodeLine{1109                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_array: "{}}}
\DoxyCodeLine{1110                     \textcolor{stringliteral}{"{}type of elements should be the same each other."{}}, \{}
\DoxyCodeLine{1111                         \{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(array\_start\_loc), \textcolor{stringliteral}{"{}array starts here"{}}\},}
\DoxyCodeLine{1112                         \{}
\DoxyCodeLine{1113                             retval.front().location(),}
\DoxyCodeLine{1114                             \textcolor{stringliteral}{"{}value has type "{}} + \mbox{\hyperlink{namespacetoml_aaf1e28f553918a844120bf20679de5c7}{stringize}}(retval.front().type())}
\DoxyCodeLine{1115                         \},}
\DoxyCodeLine{1116                         \{}
\DoxyCodeLine{1117                             val.unwrap().location(),}
\DoxyCodeLine{1118                             \textcolor{stringliteral}{"{}value has different type, "{}} + \mbox{\hyperlink{namespacetoml_aaf1e28f553918a844120bf20679de5c7}{stringize}}(val.unwrap().type())}
\DoxyCodeLine{1119                         \}}
\DoxyCodeLine{1120                     \}), \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{1121             \}}
\DoxyCodeLine{1122 \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{1123             retval.push\_back(std::move(val.unwrap()));}
\DoxyCodeLine{1124         \}}
\DoxyCodeLine{1125         \textcolor{keywordflow}{else}}
\DoxyCodeLine{1126         \{}
\DoxyCodeLine{1127             \textcolor{keyword}{auto} array\_start\_loc = loc;}
\DoxyCodeLine{1128             array\_start\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{1129 }
\DoxyCodeLine{1130             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_array: "{}}}
\DoxyCodeLine{1131                 \textcolor{stringliteral}{"{}value having invalid format appeared in an array"{}}, \{}
\DoxyCodeLine{1132                     \{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(array\_start\_loc), \textcolor{stringliteral}{"{}array starts here"{}}\},}
\DoxyCodeLine{1133                     \{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}it is not a valid value."{}}\}}
\DoxyCodeLine{1134                 \}), \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{1135         \}}
\DoxyCodeLine{1136 }
\DoxyCodeLine{1137         \textcolor{keyword}{using }lex\_array\_separator = \mbox{\hyperlink{structtoml_1_1detail_1_1sequence}{sequence<maybe<lex\_ws\_comment\_newline>}}, \mbox{\hyperlink{structtoml_1_1detail_1_1character}{character<','>}}>;}
\DoxyCodeLine{1138         \textcolor{keyword}{const} \textcolor{keyword}{auto} sp = lex\_array\_separator::invoke(loc);}
\DoxyCodeLine{1139         \textcolor{keywordflow}{if}(!sp)}
\DoxyCodeLine{1140         \{}
\DoxyCodeLine{1141             lex\_ws\_comment\_newline::invoke(loc);}
\DoxyCodeLine{1142             \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& *loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{']'})}
\DoxyCodeLine{1143             \{}
\DoxyCodeLine{1144                 loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}(); \textcolor{comment}{// skip ']'}}
\DoxyCodeLine{1145                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(retval,}
\DoxyCodeLine{1146                           \mbox{\hyperlink{structtoml_1_1detail_1_1region}{region}}(loc, first, loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}())));}
\DoxyCodeLine{1147             \}}
\DoxyCodeLine{1148             \textcolor{keywordflow}{else}}
\DoxyCodeLine{1149             \{}
\DoxyCodeLine{1150                 \textcolor{keyword}{auto} array\_start\_loc = loc;}
\DoxyCodeLine{1151                 array\_start\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{1152 }
\DoxyCodeLine{1153                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_array:"{}}}
\DoxyCodeLine{1154                     \textcolor{stringliteral}{"{} missing array separator `,` after a value"{}}, \{}
\DoxyCodeLine{1155                         \{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(array\_start\_loc), \textcolor{stringliteral}{"{}array starts here"{}}\},}
\DoxyCodeLine{1156                         \{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc),             \textcolor{stringliteral}{"{}should be `,`"{}}\}}
\DoxyCodeLine{1157                     \}), \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{1158             \}}
\DoxyCodeLine{1159         \}}
\DoxyCodeLine{1160     \}}
\DoxyCodeLine{1161     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{1162     \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_array: "{}}}
\DoxyCodeLine{1163             \textcolor{stringliteral}{"{}array did not closed by `]`"{}},}
\DoxyCodeLine{1164             \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}should be closed"{}}\}\}),}
\DoxyCodeLine{1165             \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{1166 \}}
\DoxyCodeLine{1167 }
\DoxyCodeLine{1168 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{1169 \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<std::pair<std::vector<key>}}, region>, Value>, std::string>}
\DoxyCodeLine{1170 \mbox{\hyperlink{namespacetoml_1_1detail_a56a849a04dc1414af6e04adb67411bdd}{parse\_key\_value\_pair}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{1171 \{}
\DoxyCodeLine{1172     \textcolor{keyword}{using }value\_type = Value;}
\DoxyCodeLine{1173 }
\DoxyCodeLine{1174     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{1175     \textcolor{keyword}{auto} key\_reg = \mbox{\hyperlink{namespacetoml_1_1detail_ac3ca2e746db114f0747188013a7b9b62}{parse\_key}}(loc);}
\DoxyCodeLine{1176     \textcolor{keywordflow}{if}(!key\_reg)}
\DoxyCodeLine{1177     \{}
\DoxyCodeLine{1178         std::string msg = std::move(key\_reg.unwrap\_err());}
\DoxyCodeLine{1179         \textcolor{comment}{// if the next token is keyvalue-\/separator, it means that there are no}}
\DoxyCodeLine{1180         \textcolor{comment}{// key. then we need to show error as "{}empty key is not allowed"{}.}}
\DoxyCodeLine{1181         \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} keyval\_sep = lex\_keyval\_sep::invoke(loc))}
\DoxyCodeLine{1182         \{}
\DoxyCodeLine{1183             loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{1184             msg = \mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_key\_value\_pair: "{}}}
\DoxyCodeLine{1185                 \textcolor{stringliteral}{"{}empty key is not allowed."{}},}
\DoxyCodeLine{1186                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}key expected before '='"{}}\}\});}
\DoxyCodeLine{1187         \}}
\DoxyCodeLine{1188         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(std::move(msg));}
\DoxyCodeLine{1189     \}}
\DoxyCodeLine{1190 }
\DoxyCodeLine{1191     \textcolor{keyword}{const} \textcolor{keyword}{auto} kvsp = lex\_keyval\_sep::invoke(loc);}
\DoxyCodeLine{1192     \textcolor{keywordflow}{if}(!kvsp)}
\DoxyCodeLine{1193     \{}
\DoxyCodeLine{1194         std::string msg;}
\DoxyCodeLine{1195         \textcolor{comment}{// if the line contains '=' after the invalid sequence, possibly the}}
\DoxyCodeLine{1196         \textcolor{comment}{// error is in the key (like, invalid character in bare key).}}
\DoxyCodeLine{1197         \textcolor{keyword}{const} \textcolor{keyword}{auto} line\_end = \mbox{\hyperlink{namespacetoml_a31abd17e078e497fb224d79260910b8d}{std::find}}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}(), loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}(), \textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{1198         \textcolor{keywordflow}{if}(\mbox{\hyperlink{namespacetoml_a31abd17e078e497fb224d79260910b8d}{std::find}}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}(), line\_end, \textcolor{charliteral}{'='}) != line\_end)}
\DoxyCodeLine{1199         \{}
\DoxyCodeLine{1200             msg = \mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_key\_value\_pair: "{}}}
\DoxyCodeLine{1201                 \textcolor{stringliteral}{"{}invalid format for key"{}},}
\DoxyCodeLine{1202                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}invalid character in key"{}}\}\},}
\DoxyCodeLine{1203                 \{\textcolor{stringliteral}{"{}Did you forget '.' to separate dotted-\/key?"{}},}
\DoxyCodeLine{1204                 \textcolor{stringliteral}{"{}Allowed characters for bare key are [0-\/9a-\/zA-\/Z\_-\/]."{}}\});}
\DoxyCodeLine{1205         \}}
\DoxyCodeLine{1206         \textcolor{keywordflow}{else} \textcolor{comment}{// if not, the error is lack of key-\/value separator.}}
\DoxyCodeLine{1207         \{}
\DoxyCodeLine{1208             msg = \mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_key\_value\_pair: "{}}}
\DoxyCodeLine{1209                 \textcolor{stringliteral}{"{}missing key-\/value separator `=`"{}},}
\DoxyCodeLine{1210                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}should be `=`"{}}\}\});}
\DoxyCodeLine{1211         \}}
\DoxyCodeLine{1212         loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{1213         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(std::move(msg));}
\DoxyCodeLine{1214     \}}
\DoxyCodeLine{1215 }
\DoxyCodeLine{1216     \textcolor{keyword}{const} \textcolor{keyword}{auto} after\_kvsp = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}(); \textcolor{comment}{// err msg}}
\DoxyCodeLine{1217     \textcolor{keyword}{auto} val = parse\_value<value\_type>(loc);}
\DoxyCodeLine{1218     \textcolor{keywordflow}{if}(!val)}
\DoxyCodeLine{1219     \{}
\DoxyCodeLine{1220         std::string msg;}
\DoxyCodeLine{1221         loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(after\_kvsp);}
\DoxyCodeLine{1222         \textcolor{comment}{// check there is something not a comment/whitespace after `=`}}
\DoxyCodeLine{1223         \textcolor{keywordflow}{if}(\mbox{\hyperlink{structtoml_1_1detail_1_1sequence}{sequence}}<\mbox{\hyperlink{structtoml_1_1detail_1_1maybe}{maybe<lex\_ws>}}, \mbox{\hyperlink{structtoml_1_1detail_1_1maybe}{maybe<lex\_comment>}}, \mbox{\hyperlink{structtoml_1_1detail_1_1either}{lex\_newline}}>::invoke(loc))}
\DoxyCodeLine{1224         \{}
\DoxyCodeLine{1225             loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(after\_kvsp);}
\DoxyCodeLine{1226             msg = \mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_key\_value\_pair: "{}}}
\DoxyCodeLine{1227                     \textcolor{stringliteral}{"{}missing value after key-\/value separator '='"{}},}
\DoxyCodeLine{1228                     \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}expected value, but got nothing"{}}\}\});}
\DoxyCodeLine{1229         \}}
\DoxyCodeLine{1230         \textcolor{keywordflow}{else} \textcolor{comment}{// there is something not a comment/whitespace, so invalid format.}}
\DoxyCodeLine{1231         \{}
\DoxyCodeLine{1232             msg = std::move(val.unwrap\_err());}
\DoxyCodeLine{1233         \}}
\DoxyCodeLine{1234         loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{1235         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(msg);}
\DoxyCodeLine{1236     \}}
\DoxyCodeLine{1237     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(std::move(key\_reg.unwrap()),}
\DoxyCodeLine{1238                              std::move(val.unwrap())));}
\DoxyCodeLine{1239 \}}
\DoxyCodeLine{1240 }
\DoxyCodeLine{1241 \textcolor{comment}{// for error messages.}}
\DoxyCodeLine{1242 \textcolor{keyword}{template}<\textcolor{keyword}{typename} InputIterator>}
\DoxyCodeLine{1243 std::string \mbox{\hyperlink{namespacetoml_1_1detail_a99e1ae9c891bbb8e62b0d729cf54ff68}{format\_dotted\_keys}}(InputIterator first, \textcolor{keyword}{const} InputIterator last)}
\DoxyCodeLine{1244 \{}
\DoxyCodeLine{1245     \textcolor{keyword}{static\_assert}(std::is\_same<\mbox{\hyperlink{namespacetoml_ab00c292fbb2e761ef69fdafd6b813348}{key}},}
\DoxyCodeLine{1246         \textcolor{keyword}{typename} std::iterator\_traits<InputIterator>::value\_type>\mbox{\hyperlink{namespacetoml_a34e466167cc683c477838accdebb2578}{::value}},\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{1247 }
\DoxyCodeLine{1248     std::string retval(*first++);}
\DoxyCodeLine{1249     \textcolor{keywordflow}{for}(; first != last; ++first)}
\DoxyCodeLine{1250     \{}
\DoxyCodeLine{1251         retval += \textcolor{charliteral}{'.'};}
\DoxyCodeLine{1252         retval += *first;}
\DoxyCodeLine{1253     \}}
\DoxyCodeLine{1254     \textcolor{keywordflow}{return} retval;}
\DoxyCodeLine{1255 \}}
\DoxyCodeLine{1256 }
\DoxyCodeLine{1257 \textcolor{comment}{// forward decl for is\_valid\_forward\_table\_definition}}
\DoxyCodeLine{1258 \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<std::vector<key>}}, region>, std::string>}
\DoxyCodeLine{1259 \mbox{\hyperlink{namespacetoml_1_1detail_aa2937fd996bb69876ef981959c05ef0f}{parse\_table\_key}}(location\& loc);}
\DoxyCodeLine{1260 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{1261 \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<typename Value::table\_type, region>}}, std::string>}
\DoxyCodeLine{1262 \mbox{\hyperlink{namespacetoml_1_1detail_a05d8b73335c77794f3a67b36cb9d67eb}{parse\_inline\_table}}(location\& loc);}
\DoxyCodeLine{1263 }
\DoxyCodeLine{1264 \textcolor{comment}{// The following toml file is allowed.}}
\DoxyCodeLine{1265 \textcolor{comment}{// ```toml}}
\DoxyCodeLine{1266 \textcolor{comment}{// [a.b.c]     \# here, table `a` has element `b`.}}
\DoxyCodeLine{1267 \textcolor{comment}{// foo = "{}bar"{}}}
\DoxyCodeLine{1268 \textcolor{comment}{// [a]         \# merge a = \{baz = "{}qux"{}\} to a = \{b = \{...\}\}}}
\DoxyCodeLine{1269 \textcolor{comment}{// baz = "{}qux"{}}}
\DoxyCodeLine{1270 \textcolor{comment}{// ```}}
\DoxyCodeLine{1271 \textcolor{comment}{// But the following is not allowed.}}
\DoxyCodeLine{1272 \textcolor{comment}{// ```toml}}
\DoxyCodeLine{1273 \textcolor{comment}{// [a]}}
\DoxyCodeLine{1274 \textcolor{comment}{// b.c.foo = "{}bar"{}}}
\DoxyCodeLine{1275 \textcolor{comment}{// [a]             \# error! the same table [a] defined!}}
\DoxyCodeLine{1276 \textcolor{comment}{// baz = "{}qux"{}}}
\DoxyCodeLine{1277 \textcolor{comment}{// ```}}
\DoxyCodeLine{1278 \textcolor{comment}{// The following is neither allowed.}}
\DoxyCodeLine{1279 \textcolor{comment}{// ```toml}}
\DoxyCodeLine{1280 \textcolor{comment}{// a = \{ b.c.foo = "{}bar"{}\}}}
\DoxyCodeLine{1281 \textcolor{comment}{// [a]             \# error! the same table [a] defined!}}
\DoxyCodeLine{1282 \textcolor{comment}{// baz = "{}qux"{}}}
\DoxyCodeLine{1283 \textcolor{comment}{// ```}}
\DoxyCodeLine{1284 \textcolor{comment}{// Here, it parses region of `tab-\/>at(k)` as a table key and check the depth}}
\DoxyCodeLine{1285 \textcolor{comment}{// of the key. If the key region points deeper node, it would be allowed.}}
\DoxyCodeLine{1286 \textcolor{comment}{// Otherwise, the key points the same node. It would be rejected.}}
\DoxyCodeLine{1287 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value, \textcolor{keyword}{typename} Iterator>}
\DoxyCodeLine{1288 \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacetoml_1_1detail_a76b45d2fab6622b5fcbdd3b9aebd5a1f}{is\_valid\_forward\_table\_definition}}(\textcolor{keyword}{const} Value\& fwd, \textcolor{keyword}{const} Value\& inserting,}
\DoxyCodeLine{1289         Iterator key\_first, Iterator key\_curr, Iterator key\_last)}
\DoxyCodeLine{1290 \{}
\DoxyCodeLine{1291     \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{1292     \textcolor{comment}{// check type of the value to be inserted/merged}}
\DoxyCodeLine{1293 }
\DoxyCodeLine{1294     std::string inserting\_reg = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{1295     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} ptr = \mbox{\hyperlink{namespacetoml_1_1detail_a18e4af33fa907452909c17e6cca24c09}{detail::get\_region}}(inserting))}
\DoxyCodeLine{1296     \{}
\DoxyCodeLine{1297         inserting\_reg = ptr-\/>str();}
\DoxyCodeLine{1298     \}}
\DoxyCodeLine{1299     \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}} inserting\_def(\textcolor{stringliteral}{"{}internal"{}}, std::move(inserting\_reg));}
\DoxyCodeLine{1300     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} inlinetable = parse\_inline\_table<Value>(inserting\_def))}
\DoxyCodeLine{1301     \{}
\DoxyCodeLine{1302         \textcolor{comment}{// check if we are overwriting existing table.}}
\DoxyCodeLine{1303         \textcolor{comment}{// ```toml}}
\DoxyCodeLine{1304         \textcolor{comment}{// \# NG}}
\DoxyCodeLine{1305         \textcolor{comment}{// a.b = 42}}
\DoxyCodeLine{1306         \textcolor{comment}{// a = \{d = 3.14\}}}
\DoxyCodeLine{1307         \textcolor{comment}{// ```}}
\DoxyCodeLine{1308         \textcolor{comment}{// Inserting an inline table to a existing super-\/table is not allowed in}}
\DoxyCodeLine{1309         \textcolor{comment}{// any case. If we found it, we can reject it without further checking.}}
\DoxyCodeLine{1310         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1311     \}}
\DoxyCodeLine{1312 }
\DoxyCodeLine{1313     \textcolor{comment}{// Valid and invalid cases when inserting to the [a.b] table:}}
\DoxyCodeLine{1314     \textcolor{comment}{//}}
\DoxyCodeLine{1315     \textcolor{comment}{// \#\# Invalid}}
\DoxyCodeLine{1316     \textcolor{comment}{//}}
\DoxyCodeLine{1317     \textcolor{comment}{// ```toml}}
\DoxyCodeLine{1318     \textcolor{comment}{// \# invalid}}
\DoxyCodeLine{1319     \textcolor{comment}{// [a]}}
\DoxyCodeLine{1320     \textcolor{comment}{// b.c.d = "{}foo"{}}}
\DoxyCodeLine{1321     \textcolor{comment}{// [a.b]       \# a.b is already defined and closed}}
\DoxyCodeLine{1322     \textcolor{comment}{// d = "{}bar"{}}}
\DoxyCodeLine{1323     \textcolor{comment}{// ```}}
\DoxyCodeLine{1324     \textcolor{comment}{// ```toml}}
\DoxyCodeLine{1325     \textcolor{comment}{// \# invalid}}
\DoxyCodeLine{1326     \textcolor{comment}{// a = \{b.c.d = "{}foo"{}\}}}
\DoxyCodeLine{1327     \textcolor{comment}{// [a.b] \# a is already defined and inline table is closed}}
\DoxyCodeLine{1328     \textcolor{comment}{// d = "{}bar"{}}}
\DoxyCodeLine{1329     \textcolor{comment}{// ```}}
\DoxyCodeLine{1330     \textcolor{comment}{// ```toml}}
\DoxyCodeLine{1331     \textcolor{comment}{// \# invalid}}
\DoxyCodeLine{1332     \textcolor{comment}{// a.b.c.d = "{}foo"{}}}
\DoxyCodeLine{1333     \textcolor{comment}{// [a.b] \# a.b is already defined and dotted-\/key table is closed}}
\DoxyCodeLine{1334     \textcolor{comment}{// d = "{}bar"{}}}
\DoxyCodeLine{1335     \textcolor{comment}{// ```}}
\DoxyCodeLine{1336     \textcolor{comment}{//}}
\DoxyCodeLine{1337     \textcolor{comment}{// \#\# Valid}}
\DoxyCodeLine{1338     \textcolor{comment}{//}}
\DoxyCodeLine{1339     \textcolor{comment}{// ```toml}}
\DoxyCodeLine{1340     \textcolor{comment}{// \# OK. a.b is defined, but is *overwritable*}}
\DoxyCodeLine{1341     \textcolor{comment}{// [a.b.c]}}
\DoxyCodeLine{1342     \textcolor{comment}{// d = "{}foo"{}}}
\DoxyCodeLine{1343     \textcolor{comment}{// [a.b]}}
\DoxyCodeLine{1344     \textcolor{comment}{// d = "{}bar"{}}}
\DoxyCodeLine{1345     \textcolor{comment}{// ```}}
\DoxyCodeLine{1346     \textcolor{comment}{// ```toml}}
\DoxyCodeLine{1347     \textcolor{comment}{// \# OK. a.b is defined, but is *overwritable*}}
\DoxyCodeLine{1348     \textcolor{comment}{// [a]}}
\DoxyCodeLine{1349     \textcolor{comment}{// b.c.d = "{}foo"{}}}
\DoxyCodeLine{1350     \textcolor{comment}{// b.e = "{}bar"{}}}
\DoxyCodeLine{1351     \textcolor{comment}{// ```}}
\DoxyCodeLine{1352 }
\DoxyCodeLine{1353     \textcolor{comment}{// -\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/}}
\DoxyCodeLine{1354     \textcolor{comment}{// check table defined before}}
\DoxyCodeLine{1355 }
\DoxyCodeLine{1356     std::string internal = \textcolor{stringliteral}{"{}"{}};}
\DoxyCodeLine{1357     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} ptr = \mbox{\hyperlink{namespacetoml_1_1detail_a18e4af33fa907452909c17e6cca24c09}{detail::get\_region}}(fwd))}
\DoxyCodeLine{1358     \{}
\DoxyCodeLine{1359         internal = ptr-\/>str();}
\DoxyCodeLine{1360     \}}
\DoxyCodeLine{1361     \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}} def(\textcolor{stringliteral}{"{}internal"{}}, std::move(internal));}
\DoxyCodeLine{1362     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} tabkeys = \mbox{\hyperlink{namespacetoml_1_1detail_aa2937fd996bb69876ef981959c05ef0f}{parse\_table\_key}}(def)) \textcolor{comment}{// [table.key]}}
\DoxyCodeLine{1363     \{}
\DoxyCodeLine{1364         \textcolor{comment}{// table keys always contains all the nodes from the root.}}
\DoxyCodeLine{1365         \textcolor{keyword}{const} \textcolor{keyword}{auto}\& tks = tabkeys.unwrap().first;}
\DoxyCodeLine{1366         \textcolor{keywordflow}{if}(std::size\_t(std::distance(key\_first, key\_last)) == tks.size() \&\&}
\DoxyCodeLine{1367            std::equal(tks.begin(), tks.end(), key\_first))}
\DoxyCodeLine{1368         \{}
\DoxyCodeLine{1369             \textcolor{comment}{// the keys are equivalent. it is not allowed.}}
\DoxyCodeLine{1370             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1371         \}}
\DoxyCodeLine{1372         \textcolor{comment}{// the keys are not equivalent. it is allowed.}}
\DoxyCodeLine{1373         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1374     \}}
\DoxyCodeLine{1375     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} dotkeys = \mbox{\hyperlink{namespacetoml_1_1detail_ac3ca2e746db114f0747188013a7b9b62}{parse\_key}}(def)) \textcolor{comment}{// a.b.c = "{}foo"{}}}
\DoxyCodeLine{1376     \{}
\DoxyCodeLine{1377         \textcolor{comment}{// consider the following case.}}
\DoxyCodeLine{1378         \textcolor{comment}{// [a]}}
\DoxyCodeLine{1379         \textcolor{comment}{// b.c = \{d = 42\}}}
\DoxyCodeLine{1380         \textcolor{comment}{// [a.b.c]}}
\DoxyCodeLine{1381         \textcolor{comment}{// e = 2.71}}
\DoxyCodeLine{1382         \textcolor{comment}{// this defines the table [a.b.c] twice. no?}}
\DoxyCodeLine{1383         \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} reopening\_dotkey\_by\_table = \mbox{\hyperlink{namespacetoml_1_1detail_aa2937fd996bb69876ef981959c05ef0f}{parse\_table\_key}}(inserting\_def))}
\DoxyCodeLine{1384         \{}
\DoxyCodeLine{1385             \textcolor{comment}{// re-\/opening a dotkey-\/defined table by a table is invalid.}}
\DoxyCodeLine{1386             \textcolor{comment}{// only dotkey can append a key-\/val. Like:}}
\DoxyCodeLine{1387             \textcolor{comment}{// ```toml}}
\DoxyCodeLine{1388             \textcolor{comment}{// a.b.c = "{}foo"{}}}
\DoxyCodeLine{1389             \textcolor{comment}{// a.b.d = "{}bar"{} \# OK. reopen `a.b` by dotkey}}
\DoxyCodeLine{1390             \textcolor{comment}{// [a.b]}}
\DoxyCodeLine{1391             \textcolor{comment}{// e = "{}bar"{} \# Invalid. re-\/opening `a.b` by [a.b] is not allowed.}}
\DoxyCodeLine{1392             \textcolor{comment}{// ```}}
\DoxyCodeLine{1393             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1394         \}}
\DoxyCodeLine{1395 }
\DoxyCodeLine{1396         \textcolor{comment}{// a dotted key starts from the node representing a table in which the}}
\DoxyCodeLine{1397         \textcolor{comment}{// dotted key belongs to.}}
\DoxyCodeLine{1398         \textcolor{keyword}{const} \textcolor{keyword}{auto}\& dks = dotkeys.unwrap().first;}
\DoxyCodeLine{1399         \textcolor{keywordflow}{if}(std::size\_t(std::distance(key\_curr, key\_last)) == dks.size() \&\&}
\DoxyCodeLine{1400            std::equal(dks.begin(), dks.end(), key\_curr))}
\DoxyCodeLine{1401         \{}
\DoxyCodeLine{1402             \textcolor{comment}{// the keys are equivalent. it is not allowed.}}
\DoxyCodeLine{1403             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1404         \}}
\DoxyCodeLine{1405         \textcolor{comment}{// the keys are not equivalent. it is allowed.}}
\DoxyCodeLine{1406         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{1407     \}}
\DoxyCodeLine{1408     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{1409 \}}
\DoxyCodeLine{1410 }
\DoxyCodeLine{1411 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value, \textcolor{keyword}{typename} InputIterator>}
\DoxyCodeLine{1412 \mbox{\hyperlink{structtoml_1_1result}{result<bool, std::string>}}}
\DoxyCodeLine{1413 \mbox{\hyperlink{namespacetoml_1_1detail_a0e42efd941fdedb92c70124d95b42dba}{insert\_nested\_key}}(\textcolor{keyword}{typename} Value::table\_type\& root, \textcolor{keyword}{const} Value\& v,}
\DoxyCodeLine{1414                   InputIterator iter, \textcolor{keyword}{const} InputIterator last,}
\DoxyCodeLine{1415                   \mbox{\hyperlink{structtoml_1_1detail_1_1region}{region}} key\_reg,}
\DoxyCodeLine{1416                   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} is\_array\_of\_table = \textcolor{keyword}{false})}
\DoxyCodeLine{1417 \{}
\DoxyCodeLine{1418     \textcolor{keyword}{static\_assert}(std::is\_same<\mbox{\hyperlink{namespacetoml_ab00c292fbb2e761ef69fdafd6b813348}{key}},}
\DoxyCodeLine{1419         \textcolor{keyword}{typename} std::iterator\_traits<InputIterator>::value\_type>\mbox{\hyperlink{namespacetoml_a34e466167cc683c477838accdebb2578}{::value}},\textcolor{stringliteral}{"{}"{}});}
\DoxyCodeLine{1420 }
\DoxyCodeLine{1421     \textcolor{keyword}{using }value\_type = Value;}
\DoxyCodeLine{1422     \textcolor{keyword}{using }table\_type = \textcolor{keyword}{typename} value\_type::table\_type;}
\DoxyCodeLine{1423     \textcolor{keyword}{using }array\_type = \textcolor{keyword}{typename} value\_type::array\_type;}
\DoxyCodeLine{1424 }
\DoxyCodeLine{1425     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = iter;}
\DoxyCodeLine{1426     assert(iter != last);}
\DoxyCodeLine{1427 }
\DoxyCodeLine{1428     table\_type* tab = std::addressof(root);}
\DoxyCodeLine{1429     \textcolor{keywordflow}{for}(; iter != last; ++iter) \textcolor{comment}{// search recursively}}
\DoxyCodeLine{1430     \{}
\DoxyCodeLine{1431         \textcolor{keyword}{const} \mbox{\hyperlink{namespacetoml_ab00c292fbb2e761ef69fdafd6b813348}{key}}\& k = *iter;}
\DoxyCodeLine{1432         \textcolor{keywordflow}{if}(std::next(iter) == last) \textcolor{comment}{// k is the last key}}
\DoxyCodeLine{1433         \{}
\DoxyCodeLine{1434             \textcolor{comment}{// XXX if the value is array-\/of-\/tables, there can be several}}
\DoxyCodeLine{1435             \textcolor{comment}{//     tables that are in the same array. in that case, we need to}}
\DoxyCodeLine{1436             \textcolor{comment}{//     find the last element and insert it to there.}}
\DoxyCodeLine{1437             \textcolor{keywordflow}{if}(is\_array\_of\_table)}
\DoxyCodeLine{1438             \{}
\DoxyCodeLine{1439                 \textcolor{keywordflow}{if}(tab-\/>count(k) == 1) \textcolor{comment}{// there is already an array of table}}
\DoxyCodeLine{1440                 \{}
\DoxyCodeLine{1441                     \textcolor{keywordflow}{if}(tab-\/>at(k).is\_table())}
\DoxyCodeLine{1442                     \{}
\DoxyCodeLine{1443                         \textcolor{comment}{// show special err msg for conflicting table}}
\DoxyCodeLine{1444                         \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(}
\DoxyCodeLine{1445                             \textcolor{stringliteral}{"{}toml::insert\_value: array of table (\(\backslash\)"{}"{}},}
\DoxyCodeLine{1446                             \mbox{\hyperlink{namespacetoml_1_1detail_a99e1ae9c891bbb8e62b0d729cf54ff68}{format\_dotted\_keys}}(first, last),}
\DoxyCodeLine{1447                             \textcolor{stringliteral}{"{}\(\backslash\)"{}) cannot be defined"{}}), \{}
\DoxyCodeLine{1448                                 \{tab-\/>at(k).\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}(), \textcolor{stringliteral}{"{}table already defined"{}}\},}
\DoxyCodeLine{1449                                 \{v.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a63170a96936ce5957e54e43a377a6118}{location}}(), \textcolor{stringliteral}{"{}this conflicts with the previous table"{}}\}}
\DoxyCodeLine{1450                             \}), v.location());}
\DoxyCodeLine{1451                     \}}
\DoxyCodeLine{1452                     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(!(tab-\/>at(k).is\_array()))}
\DoxyCodeLine{1453                     \{}
\DoxyCodeLine{1454                         \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(}
\DoxyCodeLine{1455                             \textcolor{stringliteral}{"{}toml::insert\_value: array of table (\(\backslash\)"{}"{}},}
\DoxyCodeLine{1456                             \mbox{\hyperlink{namespacetoml_1_1detail_a99e1ae9c891bbb8e62b0d729cf54ff68}{format\_dotted\_keys}}(first, last), \textcolor{stringliteral}{"{}\(\backslash\)"{}) collides with"{}}}
\DoxyCodeLine{1457                             \textcolor{stringliteral}{"{} existing value"{}}), \{}
\DoxyCodeLine{1458                                 \{tab-\/>at(k).\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}(),}
\DoxyCodeLine{1459                                  \mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(\textcolor{stringliteral}{"{}this "{}}, tab-\/>at(k).type(),}
\DoxyCodeLine{1460                                                   \textcolor{stringliteral}{"{} value already exists"{}})\},}
\DoxyCodeLine{1461                                 \{v.location(),}
\DoxyCodeLine{1462                                  \textcolor{stringliteral}{"{}while inserting this array-\/of-\/tables"{}}\}}
\DoxyCodeLine{1463                             \}), v.location());}
\DoxyCodeLine{1464                     \}}
\DoxyCodeLine{1465                     \textcolor{comment}{// the above if-\/else-\/if checks tab-\/>at(k) is an array}}
\DoxyCodeLine{1466                     \textcolor{keyword}{auto}\& a = tab-\/>at(k).as\_array();}
\DoxyCodeLine{1467                     \textcolor{comment}{// If table element is defined as [[array\_of\_tables]], it}}
\DoxyCodeLine{1468                     \textcolor{comment}{// cannot be an empty array. If an array of tables is}}
\DoxyCodeLine{1469                     \textcolor{comment}{// defined as `aot = []`, it cannot be appended.}}
\DoxyCodeLine{1470                     \textcolor{keywordflow}{if}(a.empty() || !(a.front().is\_table()))}
\DoxyCodeLine{1471                     \{}
\DoxyCodeLine{1472                         \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(}
\DoxyCodeLine{1473                             \textcolor{stringliteral}{"{}toml::insert\_value: array of table (\(\backslash\)"{}"{}},}
\DoxyCodeLine{1474                             \mbox{\hyperlink{namespacetoml_1_1detail_a99e1ae9c891bbb8e62b0d729cf54ff68}{format\_dotted\_keys}}(first, last), \textcolor{stringliteral}{"{}\(\backslash\)"{}) collides with"{}}}
\DoxyCodeLine{1475                             \textcolor{stringliteral}{"{} existing value"{}}), \{}
\DoxyCodeLine{1476                                 \{tab-\/>at(k).\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}(),}
\DoxyCodeLine{1477                                  \mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(\textcolor{stringliteral}{"{}this "{}}, tab-\/>at(k).type(),}
\DoxyCodeLine{1478                                                   \textcolor{stringliteral}{"{} value already exists"{}})\},}
\DoxyCodeLine{1479                                 \{v.location(),}
\DoxyCodeLine{1480                                  \textcolor{stringliteral}{"{}while inserting this array-\/of-\/tables"{}}\}}
\DoxyCodeLine{1481                             \}), v.location());}
\DoxyCodeLine{1482                     \}}
\DoxyCodeLine{1483                     \textcolor{comment}{// avoid conflicting array of table like the following.}}
\DoxyCodeLine{1484                     \textcolor{comment}{// ```toml}}
\DoxyCodeLine{1485                     \textcolor{comment}{// a = [\{b = 42\}] \# define a as an array of *inline* tables}}
\DoxyCodeLine{1486                     \textcolor{comment}{// [[a]]          \# a is an array of *multi-\/line* tables}}
\DoxyCodeLine{1487                     \textcolor{comment}{// b = 54}}
\DoxyCodeLine{1488                     \textcolor{comment}{// ```}}
\DoxyCodeLine{1489                     \textcolor{comment}{// Here, from the type information, these cannot be detected}}
\DoxyCodeLine{1490                     \textcolor{comment}{// because inline table is also a table.}}
\DoxyCodeLine{1491                     \textcolor{comment}{// But toml v0.5.0 explicitly says it is invalid. The above}}
\DoxyCodeLine{1492                     \textcolor{comment}{// array-\/of-\/tables has a static size and appending to the}}
\DoxyCodeLine{1493                     \textcolor{comment}{// array is invalid.}}
\DoxyCodeLine{1494                     \textcolor{comment}{// In this library, multi-\/line table value has a region}}
\DoxyCodeLine{1495                     \textcolor{comment}{// that points to the key of the table (e.g. [[a]]). By}}
\DoxyCodeLine{1496                     \textcolor{comment}{// comparing the first two letters in key, we can detect}}
\DoxyCodeLine{1497                     \textcolor{comment}{// the array-\/of-\/table is inline or multiline.}}
\DoxyCodeLine{1498                     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} ptr = \mbox{\hyperlink{namespacetoml_1_1detail_a18e4af33fa907452909c17e6cca24c09}{detail::get\_region}}(a.front()))}
\DoxyCodeLine{1499                     \{}
\DoxyCodeLine{1500                         \textcolor{keywordflow}{if}(ptr-\/>str().substr(0,2) != \textcolor{stringliteral}{"{}[["{}})}
\DoxyCodeLine{1501                         \{}
\DoxyCodeLine{1502                             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(}
\DoxyCodeLine{1503                                 \textcolor{stringliteral}{"{}toml::insert\_value: array of table (\(\backslash\)"{}"{}},}
\DoxyCodeLine{1504                                 \mbox{\hyperlink{namespacetoml_1_1detail_a99e1ae9c891bbb8e62b0d729cf54ff68}{format\_dotted\_keys}}(first, last), \textcolor{stringliteral}{"{}\(\backslash\)"{}) collides "{}}}
\DoxyCodeLine{1505                                 \textcolor{stringliteral}{"{}with existing array-\/of-\/tables"{}}), \{}
\DoxyCodeLine{1506                                     \{tab-\/>at(k).\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}(),}
\DoxyCodeLine{1507                                      \mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(\textcolor{stringliteral}{"{}this "{}}, tab-\/>at(k).type(),}
\DoxyCodeLine{1508                                                       \textcolor{stringliteral}{"{} value has static size"{}})\},}
\DoxyCodeLine{1509                                     \{v.location(),}
\DoxyCodeLine{1510                                      \textcolor{stringliteral}{"{}appending it to the statically sized array"{}}\}}
\DoxyCodeLine{1511                                 \}), v.location());}
\DoxyCodeLine{1512                         \}}
\DoxyCodeLine{1513                     \}}
\DoxyCodeLine{1514                     a.push\_back(v);}
\DoxyCodeLine{1515                     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\textcolor{keyword}{true});}
\DoxyCodeLine{1516                 \}}
\DoxyCodeLine{1517                 \textcolor{keywordflow}{else} \textcolor{comment}{// if not, we need to create the array of table}}
\DoxyCodeLine{1518                 \{}
\DoxyCodeLine{1519                     \textcolor{comment}{// XXX: Consider the following array of tables.}}
\DoxyCodeLine{1520                     \textcolor{comment}{// ```toml}}
\DoxyCodeLine{1521                     \textcolor{comment}{// \# This is a comment.}}
\DoxyCodeLine{1522                     \textcolor{comment}{// [[aot]]}}
\DoxyCodeLine{1523                     \textcolor{comment}{// foo = "{}bar"{}}}
\DoxyCodeLine{1524                     \textcolor{comment}{// ```}}
\DoxyCodeLine{1525                     \textcolor{comment}{// Here, the comment is for `aot`. But here, actually two}}
\DoxyCodeLine{1526                     \textcolor{comment}{// values are defined. An array that contains tables, named}}
\DoxyCodeLine{1527                     \textcolor{comment}{// `aot`, and the 0th element of the `aot`, `\{foo = "{}bar"{}\}`.}}
\DoxyCodeLine{1528                     \textcolor{comment}{// Those two are different from each other. But both of them}}
\DoxyCodeLine{1529                     \textcolor{comment}{// points to the same portion of the TOML file, `[[aot]]`,}}
\DoxyCodeLine{1530                     \textcolor{comment}{// so `key\_reg.comments()` returns `\# This is a comment`.}}
\DoxyCodeLine{1531                     \textcolor{comment}{// If it is assigned as a comment of `aot` defined here, the}}
\DoxyCodeLine{1532                     \textcolor{comment}{// comment will be duplicated. Both the `aot` itself and}}
\DoxyCodeLine{1533                     \textcolor{comment}{// the 0-\/th element will have the same comment. This causes}}
\DoxyCodeLine{1534                     \textcolor{comment}{// "{}duplication of the same comments"{} bug when the data is}}
\DoxyCodeLine{1535                     \textcolor{comment}{// serialized.}}
\DoxyCodeLine{1536                     \textcolor{comment}{//     Next, consider the following.}}
\DoxyCodeLine{1537                     \textcolor{comment}{// ```toml}}
\DoxyCodeLine{1538                     \textcolor{comment}{// \# comment 1}}
\DoxyCodeLine{1539                     \textcolor{comment}{// aot = [}}
\DoxyCodeLine{1540                     \textcolor{comment}{//     \# comment 2}}
\DoxyCodeLine{1541                     \textcolor{comment}{//     \{foo = "{}bar"{}\},}}
\DoxyCodeLine{1542                     \textcolor{comment}{// ]}}
\DoxyCodeLine{1543                     \textcolor{comment}{// ```}}
\DoxyCodeLine{1544                     \textcolor{comment}{// In this case, we can distinguish those two comments. So}}
\DoxyCodeLine{1545                     \textcolor{comment}{// here we need to add "{}comment 1"{} to the `aot` and}}
\DoxyCodeLine{1546                     \textcolor{comment}{// "{}comment 2"{} to the 0th element of that.}}
\DoxyCodeLine{1547                     \textcolor{comment}{//     To distinguish those two, we check the key region.}}
\DoxyCodeLine{1548                     std::vector<std::string> comments\{\textcolor{comment}{/* empty by default */}\};}
\DoxyCodeLine{1549                     \textcolor{keywordflow}{if}(key\_reg.\mbox{\hyperlink{structtoml_1_1detail_1_1region_ab29b9569c262fd0d1068501c05f49ea7}{str}}().substr(0, 2) != \textcolor{stringliteral}{"{}[["{}})}
\DoxyCodeLine{1550                     \{}
\DoxyCodeLine{1551                         comments = key\_reg.\mbox{\hyperlink{structtoml_1_1detail_1_1region_acf4d7a029b56c38ec3f1dcfa29f2968f}{comments}}();}
\DoxyCodeLine{1552                     \}}
\DoxyCodeLine{1553                     value\_type aot(array\_type(1, v), key\_reg, std::move(comments));}
\DoxyCodeLine{1554                     tab-\/>insert(std::make\_pair(k, aot));}
\DoxyCodeLine{1555                     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\textcolor{keyword}{true});}
\DoxyCodeLine{1556                 \}}
\DoxyCodeLine{1557             \} \textcolor{comment}{// end if(array of table)}}
\DoxyCodeLine{1558 }
\DoxyCodeLine{1559             \textcolor{keywordflow}{if}(tab-\/>count(k) == 1)}
\DoxyCodeLine{1560             \{}
\DoxyCodeLine{1561                 \textcolor{keywordflow}{if}(tab-\/>at(k).is\_table() \&\& v.is\_table())}
\DoxyCodeLine{1562                 \{}
\DoxyCodeLine{1563                     \textcolor{keywordflow}{if}(!\mbox{\hyperlink{namespacetoml_1_1detail_a76b45d2fab6622b5fcbdd3b9aebd5a1f}{is\_valid\_forward\_table\_definition}}(}
\DoxyCodeLine{1564                                 tab-\/>at(k), v, first, iter, last))}
\DoxyCodeLine{1565                     \{}
\DoxyCodeLine{1566                         \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(}
\DoxyCodeLine{1567                             \textcolor{stringliteral}{"{}toml::insert\_value: table (\(\backslash\)"{}"{}},}
\DoxyCodeLine{1568                             \mbox{\hyperlink{namespacetoml_1_1detail_a99e1ae9c891bbb8e62b0d729cf54ff68}{format\_dotted\_keys}}(first, last),}
\DoxyCodeLine{1569                             \textcolor{stringliteral}{"{}\(\backslash\)"{}) already exists."{}}), \{}
\DoxyCodeLine{1570                                 \{tab-\/>at(k).\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}(), \textcolor{stringliteral}{"{}table already exists here"{}}\},}
\DoxyCodeLine{1571                                 \{v.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a63170a96936ce5957e54e43a377a6118}{location}}(), \textcolor{stringliteral}{"{}table defined twice"{}}\}}
\DoxyCodeLine{1572                             \}), v.location());}
\DoxyCodeLine{1573                     \}}
\DoxyCodeLine{1574                     \textcolor{comment}{// to allow the following toml file.}}
\DoxyCodeLine{1575                     \textcolor{comment}{// [a.b.c]}}
\DoxyCodeLine{1576                     \textcolor{comment}{// d = 42}}
\DoxyCodeLine{1577                     \textcolor{comment}{// [a]}}
\DoxyCodeLine{1578                     \textcolor{comment}{// e = 2.71}}
\DoxyCodeLine{1579                     \textcolor{keyword}{auto}\& t = tab-\/>at(k).as\_table();}
\DoxyCodeLine{1580                     \textcolor{keywordflow}{for}(\textcolor{keyword}{const} \textcolor{keyword}{auto}\& kv : v.as\_table())}
\DoxyCodeLine{1581                     \{}
\DoxyCodeLine{1582                         \textcolor{keywordflow}{if}(tab-\/>at(k).contains(kv.first))}
\DoxyCodeLine{1583                         \{}
\DoxyCodeLine{1584                             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(}
\DoxyCodeLine{1585                                 \textcolor{stringliteral}{"{}toml::insert\_value: value (\(\backslash\)"{}"{}},}
\DoxyCodeLine{1586                                 \mbox{\hyperlink{namespacetoml_1_1detail_a99e1ae9c891bbb8e62b0d729cf54ff68}{format\_dotted\_keys}}(first, last),}
\DoxyCodeLine{1587                                 \textcolor{stringliteral}{"{}\(\backslash\)"{}) already exists."{}}), \{}
\DoxyCodeLine{1588                                     \{t.at(kv.first).location(), \textcolor{stringliteral}{"{}already exists here"{}}\},}
\DoxyCodeLine{1589                                     \{v.location(), \textcolor{stringliteral}{"{}this defined twice"{}}\}}
\DoxyCodeLine{1590                                 \}), v.location());}
\DoxyCodeLine{1591                         \}}
\DoxyCodeLine{1592                         t[kv.first] = kv.second;}
\DoxyCodeLine{1593                     \}}
\DoxyCodeLine{1594                     \mbox{\hyperlink{namespacetoml_1_1detail_adf0efc8a5f4d13eadb0dd29cbebecc7b}{detail::change\_region}}(tab-\/>at(k), key\_reg);}
\DoxyCodeLine{1595                     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\textcolor{keyword}{true});}
\DoxyCodeLine{1596                 \}}
\DoxyCodeLine{1597                 \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(v.is\_table()                     \&\&}
\DoxyCodeLine{1598                         tab-\/>at(k).is\_array()            \&\&}
\DoxyCodeLine{1599                         tab-\/>at(k).as\_array().size() > 0 \&\&}
\DoxyCodeLine{1600                         tab-\/>at(k).as\_array().front().is\_table())}
\DoxyCodeLine{1601                 \{}
\DoxyCodeLine{1602                     \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(}
\DoxyCodeLine{1603                         \textcolor{stringliteral}{"{}toml::insert\_value: array of tables (\(\backslash\)"{}"{}},}
\DoxyCodeLine{1604                         \mbox{\hyperlink{namespacetoml_1_1detail_a99e1ae9c891bbb8e62b0d729cf54ff68}{format\_dotted\_keys}}(first, last), \textcolor{stringliteral}{"{}\(\backslash\)"{}) already exists."{}}), \{}
\DoxyCodeLine{1605                             \{tab-\/>at(k).\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}(), \textcolor{stringliteral}{"{}array of tables defined here"{}}\},}
\DoxyCodeLine{1606                             \{v.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a63170a96936ce5957e54e43a377a6118}{location}}(), \textcolor{stringliteral}{"{}table conflicts with the previous array of table"{}}\}}
\DoxyCodeLine{1607                         \}), v.location());}
\DoxyCodeLine{1608                 \}}
\DoxyCodeLine{1609                 \textcolor{keywordflow}{else}}
\DoxyCodeLine{1610                 \{}
\DoxyCodeLine{1611                     \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(}
\DoxyCodeLine{1612                         \textcolor{stringliteral}{"{}toml::insert\_value: value (\(\backslash\)"{}"{}},}
\DoxyCodeLine{1613                         \mbox{\hyperlink{namespacetoml_1_1detail_a99e1ae9c891bbb8e62b0d729cf54ff68}{format\_dotted\_keys}}(first, last), \textcolor{stringliteral}{"{}\(\backslash\)"{}) already exists."{}}), \{}
\DoxyCodeLine{1614                             \{tab-\/>at(k).\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}(), \textcolor{stringliteral}{"{}value already exists here"{}}\},}
\DoxyCodeLine{1615                             \{v.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a63170a96936ce5957e54e43a377a6118}{location}}(), \textcolor{stringliteral}{"{}value defined twice"{}}\}}
\DoxyCodeLine{1616                         \}), v.location());}
\DoxyCodeLine{1617                 \}}
\DoxyCodeLine{1618             \}}
\DoxyCodeLine{1619             tab-\/>insert(std::make\_pair(k, v));}
\DoxyCodeLine{1620             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\textcolor{keyword}{true});}
\DoxyCodeLine{1621         \}}
\DoxyCodeLine{1622         \textcolor{keywordflow}{else} \textcolor{comment}{// k is not the last one, we should insert recursively}}
\DoxyCodeLine{1623         \{}
\DoxyCodeLine{1624             \textcolor{comment}{// if there is no corresponding value, insert it first.}}
\DoxyCodeLine{1625             \textcolor{comment}{// related: you don't need to write}}
\DoxyCodeLine{1626             \textcolor{comment}{// \# [x]}}
\DoxyCodeLine{1627             \textcolor{comment}{// \# [x.y]}}
\DoxyCodeLine{1628             \textcolor{comment}{// to write}}
\DoxyCodeLine{1629             \textcolor{comment}{// [x.y.z]}}
\DoxyCodeLine{1630             \textcolor{keywordflow}{if}(tab-\/>count(k) == 0)}
\DoxyCodeLine{1631             \{}
\DoxyCodeLine{1632                 \textcolor{comment}{// a table that is defined implicitly doesn't have any comments.}}
\DoxyCodeLine{1633                 (*tab)[k] = value\_type(table\_type\{\}, key\_reg, \{\textcolor{comment}{/*no comment*/}\});}
\DoxyCodeLine{1634             \}}
\DoxyCodeLine{1635 }
\DoxyCodeLine{1636             \textcolor{comment}{// type checking...}}
\DoxyCodeLine{1637             \textcolor{keywordflow}{if}(tab-\/>at(k).is\_table())}
\DoxyCodeLine{1638             \{}
\DoxyCodeLine{1639                 \textcolor{comment}{// According to toml-\/lang/toml:36d3091b3 "{}Clarify that inline}}
\DoxyCodeLine{1640                 \textcolor{comment}{// tables are immutable"{}, check if it adds key-\/value pair to an}}
\DoxyCodeLine{1641                 \textcolor{comment}{// inline table.}}
\DoxyCodeLine{1642                 \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto}* ptr = \mbox{\hyperlink{namespacetoml_1_1detail_a18e4af33fa907452909c17e6cca24c09}{get\_region}}(tab-\/>at(k)))}
\DoxyCodeLine{1643                 \{}
\DoxyCodeLine{1644                     \textcolor{comment}{// here, if the value is a (multi-\/line) table, the region}}
\DoxyCodeLine{1645                     \textcolor{comment}{// should be something like `[table-\/name]`.}}
\DoxyCodeLine{1646                     \textcolor{keywordflow}{if}(ptr-\/>front() == \textcolor{charliteral}{'\{'})}
\DoxyCodeLine{1647                     \{}
\DoxyCodeLine{1648                         \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(}
\DoxyCodeLine{1649                             \textcolor{stringliteral}{"{}toml::insert\_value: inserting to an inline table ("{}},}
\DoxyCodeLine{1650                             \mbox{\hyperlink{namespacetoml_1_1detail_a99e1ae9c891bbb8e62b0d729cf54ff68}{format\_dotted\_keys}}(first, std::next(iter)),}
\DoxyCodeLine{1651                             \textcolor{stringliteral}{"{}) but inline tables are immutable"{}}), \{}
\DoxyCodeLine{1652                                 \{tab-\/>at(k).\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}(), \textcolor{stringliteral}{"{}inline tables are immutable"{}}\},}
\DoxyCodeLine{1653                                 \{v.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a63170a96936ce5957e54e43a377a6118}{location}}(), \textcolor{stringliteral}{"{}inserting this"{}}\}}
\DoxyCodeLine{1654                             \}), v.location());}
\DoxyCodeLine{1655                     \}}
\DoxyCodeLine{1656                 \}}
\DoxyCodeLine{1657                 tab = std::addressof((*tab)[k].as\_table());}
\DoxyCodeLine{1658             \}}
\DoxyCodeLine{1659             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(tab-\/>at(k).is\_array()) \textcolor{comment}{// inserting to array-\/of-\/tables?}}
\DoxyCodeLine{1660             \{}
\DoxyCodeLine{1661                 \textcolor{keyword}{auto}\& a = (*tab)[k].as\_array();}
\DoxyCodeLine{1662                 \textcolor{keywordflow}{if}(!a.back().is\_table())}
\DoxyCodeLine{1663                 \{}
\DoxyCodeLine{1664                     \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(}
\DoxyCodeLine{1665                         \textcolor{stringliteral}{"{}toml::insert\_value: target ("{}},}
\DoxyCodeLine{1666                         \mbox{\hyperlink{namespacetoml_1_1detail_a99e1ae9c891bbb8e62b0d729cf54ff68}{format\_dotted\_keys}}(first, std::next(iter)),}
\DoxyCodeLine{1667                         \textcolor{stringliteral}{"{}) is neither table nor an array of tables"{}}), \{}
\DoxyCodeLine{1668                             \{a.back().\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}(), \mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(}
\DoxyCodeLine{1669                                     \textcolor{stringliteral}{"{}actual type is "{}}, a.back().type())\},}
\DoxyCodeLine{1670                             \{v.location(), \textcolor{stringliteral}{"{}inserting this"{}}\}}
\DoxyCodeLine{1671                         \}), v.location());}
\DoxyCodeLine{1672                 \}}
\DoxyCodeLine{1673                 tab = std::addressof(a.back().as\_table());}
\DoxyCodeLine{1674             \}}
\DoxyCodeLine{1675             \textcolor{keywordflow}{else}}
\DoxyCodeLine{1676             \{}
\DoxyCodeLine{1677                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(}
\DoxyCodeLine{1678                     \textcolor{stringliteral}{"{}toml::insert\_value: target ("{}},}
\DoxyCodeLine{1679                     \mbox{\hyperlink{namespacetoml_1_1detail_a99e1ae9c891bbb8e62b0d729cf54ff68}{format\_dotted\_keys}}(first, std::next(iter)),}
\DoxyCodeLine{1680                     \textcolor{stringliteral}{"{}) is neither table nor an array of tables"{}}), \{}
\DoxyCodeLine{1681                         \{tab-\/>at(k).\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}(), \mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(}
\DoxyCodeLine{1682                                 \textcolor{stringliteral}{"{}actual type is "{}}, tab-\/>at(k).type())\},}
\DoxyCodeLine{1683                         \{v.location(), \textcolor{stringliteral}{"{}inserting this"{}}\}}
\DoxyCodeLine{1684                     \}), v.location());}
\DoxyCodeLine{1685             \}}
\DoxyCodeLine{1686         \}}
\DoxyCodeLine{1687     \}}
\DoxyCodeLine{1688     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(std::string(\textcolor{stringliteral}{"{}toml::detail::insert\_nested\_key: never reach here"{}}));}
\DoxyCodeLine{1689 \}}
\DoxyCodeLine{1690 }
\DoxyCodeLine{1691 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{1692 \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<typename Value::table\_type, region>}}, std::string>}
\DoxyCodeLine{1693 \mbox{\hyperlink{namespacetoml_1_1detail_a05d8b73335c77794f3a67b36cb9d67eb}{parse\_inline\_table}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{1694 \{}
\DoxyCodeLine{1695     \textcolor{keyword}{using }value\_type = Value;}
\DoxyCodeLine{1696     \textcolor{keyword}{using }table\_type = \textcolor{keyword}{typename} value\_type::table\_type;}
\DoxyCodeLine{1697 }
\DoxyCodeLine{1698     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{1699     table\_type retval;}
\DoxyCodeLine{1700     \textcolor{keywordflow}{if}(!(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& *loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{'\{'}))}
\DoxyCodeLine{1701     \{}
\DoxyCodeLine{1702         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_inline\_table: "{}},}
\DoxyCodeLine{1703             \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}the next token is not an inline table"{}}\}\}));}
\DoxyCodeLine{1704     \}}
\DoxyCodeLine{1705     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}();}
\DoxyCodeLine{1706 }
\DoxyCodeLine{1707     \textcolor{comment}{// check if the inline table is an empty table = \{ \}}}
\DoxyCodeLine{1708     \mbox{\hyperlink{structtoml_1_1detail_1_1maybe_a85d0697d87e0079600f4eb2d47a50d76}{maybe<lex\_ws>::invoke}}(loc);}
\DoxyCodeLine{1709     \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& *loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{1710     \{}
\DoxyCodeLine{1711         loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}(); \textcolor{comment}{// skip `\}`}}
\DoxyCodeLine{1712         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(retval, \mbox{\hyperlink{structtoml_1_1detail_1_1region}{region}}(loc, first, loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}())));}
\DoxyCodeLine{1713     \}}
\DoxyCodeLine{1714 }
\DoxyCodeLine{1715     \textcolor{comment}{// it starts from "{}\{"{}. it should be formatted as inline-\/table}}
\DoxyCodeLine{1716     \textcolor{keywordflow}{while}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{1717     \{}
\DoxyCodeLine{1718         \textcolor{keyword}{const} \textcolor{keyword}{auto} kv\_r = parse\_key\_value\_pair<value\_type>(loc);}
\DoxyCodeLine{1719         \textcolor{keywordflow}{if}(!kv\_r)}
\DoxyCodeLine{1720         \{}
\DoxyCodeLine{1721             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(kv\_r.unwrap\_err());}
\DoxyCodeLine{1722         \}}
\DoxyCodeLine{1723 }
\DoxyCodeLine{1724         \textcolor{keyword}{const} \textcolor{keyword}{auto}\&              kvpair  = kv\_r.unwrap();}
\DoxyCodeLine{1725         \textcolor{keyword}{const} std::vector<key>\&  keys    = kvpair.first.first;}
\DoxyCodeLine{1726         \textcolor{keyword}{const} \textcolor{keyword}{auto}\&              key\_reg = kvpair.first.second;}
\DoxyCodeLine{1727         \textcolor{keyword}{const} value\_type\&        val     = kvpair.second;}
\DoxyCodeLine{1728 }
\DoxyCodeLine{1729         \textcolor{keyword}{const} \textcolor{keyword}{auto} inserted =}
\DoxyCodeLine{1730             \mbox{\hyperlink{namespacetoml_1_1detail_a0e42efd941fdedb92c70124d95b42dba}{insert\_nested\_key}}(retval, val, keys.begin(), keys.end(), key\_reg);}
\DoxyCodeLine{1731         \textcolor{keywordflow}{if}(!inserted)}
\DoxyCodeLine{1732         \{}
\DoxyCodeLine{1733             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\textcolor{stringliteral}{"{}toml::parse\_inline\_table: "{}}}
\DoxyCodeLine{1734                 \textcolor{stringliteral}{"{}failed to insert value into table: "{}} + inserted.unwrap\_err(),}
\DoxyCodeLine{1735                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{1736         \}}
\DoxyCodeLine{1737 }
\DoxyCodeLine{1738         \textcolor{keyword}{using }lex\_table\_separator = \mbox{\hyperlink{structtoml_1_1detail_1_1sequence}{sequence<maybe<lex\_ws>}}, \mbox{\hyperlink{structtoml_1_1detail_1_1character}{character<','>}}>;}
\DoxyCodeLine{1739         \textcolor{keyword}{const} \textcolor{keyword}{auto} sp = lex\_table\_separator::invoke(loc);}
\DoxyCodeLine{1740 }
\DoxyCodeLine{1741         \textcolor{keywordflow}{if}(!sp)}
\DoxyCodeLine{1742         \{}
\DoxyCodeLine{1743             \mbox{\hyperlink{structtoml_1_1detail_1_1maybe_a85d0697d87e0079600f4eb2d47a50d76}{maybe<lex\_ws>::invoke}}(loc);}
\DoxyCodeLine{1744 }
\DoxyCodeLine{1745             \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{1746             \{}
\DoxyCodeLine{1747                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{1748                     \textcolor{stringliteral}{"{}toml::parse\_inline\_table: missing table separator `\}` "{}},}
\DoxyCodeLine{1749                     \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}should be `\}`"{}}\}\}),}
\DoxyCodeLine{1750                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{1751             \}}
\DoxyCodeLine{1752             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{1753             \{}
\DoxyCodeLine{1754                 loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}(); \textcolor{comment}{// skip `\}`}}
\DoxyCodeLine{1755                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(}
\DoxyCodeLine{1756                             retval, \mbox{\hyperlink{structtoml_1_1detail_1_1region}{region}}(loc, first, loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}())));}
\DoxyCodeLine{1757             \}}
\DoxyCodeLine{1758             \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(*loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{'\#'} || *loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{'\(\backslash\)r'} || *loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{'\(\backslash\)n'})}
\DoxyCodeLine{1759             \{}
\DoxyCodeLine{1760                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{1761                     \textcolor{stringliteral}{"{}toml::parse\_inline\_table: missing curly brace `\}`"{}},}
\DoxyCodeLine{1762                     \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}should be `\}`"{}}\}\}),}
\DoxyCodeLine{1763                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{1764             \}}
\DoxyCodeLine{1765             \textcolor{keywordflow}{else}}
\DoxyCodeLine{1766             \{}
\DoxyCodeLine{1767                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{1768                     \textcolor{stringliteral}{"{}toml::parse\_inline\_table: missing table separator `,` "{}},}
\DoxyCodeLine{1769                     \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}should be `,`"{}}\}\}),}
\DoxyCodeLine{1770                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{1771             \}}
\DoxyCodeLine{1772         \}}
\DoxyCodeLine{1773         \textcolor{keywordflow}{else} \textcolor{comment}{// `,` is found}}
\DoxyCodeLine{1774         \{}
\DoxyCodeLine{1775             \mbox{\hyperlink{structtoml_1_1detail_1_1maybe_a85d0697d87e0079600f4eb2d47a50d76}{maybe<lex\_ws>::invoke}}(loc);}
\DoxyCodeLine{1776             \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& *loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{'\}'})}
\DoxyCodeLine{1777             \{}
\DoxyCodeLine{1778                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{1779                     \textcolor{stringliteral}{"{}toml::parse\_inline\_table: trailing comma is not allowed in"{}}}
\DoxyCodeLine{1780                     \textcolor{stringliteral}{"{} an inline table"{}},}
\DoxyCodeLine{1781                     \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}should be `\}`"{}}\}\}),}
\DoxyCodeLine{1782                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{1783             \}}
\DoxyCodeLine{1784         \}}
\DoxyCodeLine{1785     \}}
\DoxyCodeLine{1786     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{1787     \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_inline\_table: "{}}}
\DoxyCodeLine{1788             \textcolor{stringliteral}{"{}inline table did not closed by `\}`"{}},}
\DoxyCodeLine{1789             \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}should be closed"{}}\}\}),}
\DoxyCodeLine{1790             \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{1791 \}}
\DoxyCodeLine{1792 }
\DoxyCodeLine{1793 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<value\_t, std::string>}} \mbox{\hyperlink{namespacetoml_1_1detail_af4c6d5f0914d83402a2909b35f56faa3}{guess\_number\_type}}(\textcolor{keyword}{const} \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& l)}
\DoxyCodeLine{1794 \{}
\DoxyCodeLine{1795     \textcolor{comment}{// This function tries to find some (common) mistakes by checking characters}}
\DoxyCodeLine{1796     \textcolor{comment}{// that follows the last character of a value. But it is often difficult}}
\DoxyCodeLine{1797     \textcolor{comment}{// because some non-\/newline characters can appear after a value. E.g.}}
\DoxyCodeLine{1798     \textcolor{comment}{// spaces, tabs, commas (in an array or inline table), closing brackets}}
\DoxyCodeLine{1799     \textcolor{comment}{// (of an array or inline table), comment-\/sign (\#). Since this function}}
\DoxyCodeLine{1800     \textcolor{comment}{// does not parse further, those characters are always allowed to be there.}}
\DoxyCodeLine{1801     \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}} loc = l;}
\DoxyCodeLine{1802 }
\DoxyCodeLine{1803     \textcolor{keywordflow}{if}(lex\_offset\_date\_time::invoke(loc)) \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaa3453afefc0169f713370ff6bea1dc9a5}{value\_t::offset\_datetime}});\}}
\DoxyCodeLine{1804     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(l.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}());}
\DoxyCodeLine{1805 }
\DoxyCodeLine{1806     \textcolor{keywordflow}{if}(lex\_local\_date\_time::invoke(loc))}
\DoxyCodeLine{1807     \{}
\DoxyCodeLine{1808         \textcolor{comment}{// bad offset may appear after this.}}
\DoxyCodeLine{1809         \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& (*loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{'+'} || *loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{'-\/'}}
\DoxyCodeLine{1810                     || *loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{'Z'} || *loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{'z'}))}
\DoxyCodeLine{1811         \{}
\DoxyCodeLine{1812             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}bad offset: should be [+-\/]HH:MM or Z"{}},}
\DoxyCodeLine{1813                         \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}[+-\/]HH:MM or Z"{}}\}\},}
\DoxyCodeLine{1814                         \{\textcolor{stringliteral}{"{}pass: +09:00, -\/05:30"{}}, \textcolor{stringliteral}{"{}fail: +9:00, -\/5:30"{}}\}));}
\DoxyCodeLine{1815         \}}
\DoxyCodeLine{1816         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaa4786c634d28e7c1aa109efdd9e11ba32}{value\_t::local\_datetime}});}
\DoxyCodeLine{1817     \}}
\DoxyCodeLine{1818     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(l.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}());}
\DoxyCodeLine{1819 }
\DoxyCodeLine{1820     \textcolor{keywordflow}{if}(lex\_local\_date::invoke(loc))}
\DoxyCodeLine{1821     \{}
\DoxyCodeLine{1822         \textcolor{comment}{// bad time may appear after this.}}
\DoxyCodeLine{1823         \textcolor{comment}{// A space is allowed as a delimiter between local time. But there are}}
\DoxyCodeLine{1824         \textcolor{comment}{// both cases in which a space becomes valid or invalid.}}
\DoxyCodeLine{1825         \textcolor{comment}{// -\/ invalid: 2019-\/06-\/16 7:00:00}}
\DoxyCodeLine{1826         \textcolor{comment}{// -\/ valid  : 2019-\/06-\/16 07:00:00}}
\DoxyCodeLine{1827         \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{1828         \{}
\DoxyCodeLine{1829             \textcolor{keyword}{const} \textcolor{keyword}{auto} c = *loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{1830             \textcolor{keywordflow}{if}(c == \textcolor{charliteral}{'T'} || c == \textcolor{charliteral}{'t'})}
\DoxyCodeLine{1831             \{}
\DoxyCodeLine{1832                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}bad time: should be HH:MM:SS.subsec"{}},}
\DoxyCodeLine{1833                         \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}HH:MM:SS.subsec"{}}\}\},}
\DoxyCodeLine{1834                         \{\textcolor{stringliteral}{"{}pass: 1979-\/05-\/27T07:32:00, 1979-\/05-\/27 07:32:00.999999"{}},}
\DoxyCodeLine{1835                          \textcolor{stringliteral}{"{}fail: 1979-\/05-\/27T7:32:00, 1979-\/05-\/27 17:32"{}}\}));}
\DoxyCodeLine{1836             \}}
\DoxyCodeLine{1837             \textcolor{keywordflow}{if}(\textcolor{charliteral}{'0'} <= c \&\& c <= \textcolor{charliteral}{'9'})}
\DoxyCodeLine{1838             \{}
\DoxyCodeLine{1839                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}bad time: missing T"{}},}
\DoxyCodeLine{1840                         \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}T or space required here"{}}\}\},}
\DoxyCodeLine{1841                         \{\textcolor{stringliteral}{"{}pass: 1979-\/05-\/27T07:32:00, 1979-\/05-\/27 07:32:00.999999"{}},}
\DoxyCodeLine{1842                          \textcolor{stringliteral}{"{}fail: 1979-\/05-\/27T7:32:00, 1979-\/05-\/27 7:32"{}}\}));}
\DoxyCodeLine{1843             \}}
\DoxyCodeLine{1844             \textcolor{keywordflow}{if}(c == \textcolor{charliteral}{' '} \&\& std::next(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}()) != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\&}
\DoxyCodeLine{1845                 (\textcolor{charliteral}{'0'} <= *std::next(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}()) \&\& *std::next(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}())<= \textcolor{charliteral}{'9'}))}
\DoxyCodeLine{1846             \{}
\DoxyCodeLine{1847                 loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}();}
\DoxyCodeLine{1848                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}bad time: should be HH:MM:SS.subsec"{}},}
\DoxyCodeLine{1849                         \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}HH:MM:SS.subsec"{}}\}\},}
\DoxyCodeLine{1850                         \{\textcolor{stringliteral}{"{}pass: 1979-\/05-\/27T07:32:00, 1979-\/05-\/27 07:32:00.999999"{}},}
\DoxyCodeLine{1851                          \textcolor{stringliteral}{"{}fail: 1979-\/05-\/27T7:32:00, 1979-\/05-\/27 7:32"{}}\}));}
\DoxyCodeLine{1852             \}}
\DoxyCodeLine{1853         \}}
\DoxyCodeLine{1854         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaaa9647613bc34fa481cf7bfd71e46511f}{value\_t::local\_date}});}
\DoxyCodeLine{1855     \}}
\DoxyCodeLine{1856     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(l.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}());}
\DoxyCodeLine{1857 }
\DoxyCodeLine{1858     \textcolor{keywordflow}{if}(lex\_local\_time::invoke(loc)) \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaad118bc9b5fdddd0a0c91b99a41bb9501}{value\_t::local\_time}});\}}
\DoxyCodeLine{1859     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(l.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}());}
\DoxyCodeLine{1860 }
\DoxyCodeLine{1861     \textcolor{keywordflow}{if}(lex\_float::invoke(loc))}
\DoxyCodeLine{1862     \{}
\DoxyCodeLine{1863         \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& *loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{'\_'})}
\DoxyCodeLine{1864         \{}
\DoxyCodeLine{1865             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}bad float: `\_` should be surrounded by digits"{}},}
\DoxyCodeLine{1866                         \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}here"{}}\}\},}
\DoxyCodeLine{1867                         \{\textcolor{stringliteral}{"{}pass: +1.0, -\/2e-\/2, 3.141\_592\_653\_589, inf, nan"{}},}
\DoxyCodeLine{1868                          \textcolor{stringliteral}{"{}fail: .0, 1., \_1.0, 1.0\_, 1\_.0, 1.0\_\_0"{}}\}));}
\DoxyCodeLine{1869         \}}
\DoxyCodeLine{1870         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaa374515b23d6f106696387776a6077d17}{value\_t::floating}});}
\DoxyCodeLine{1871     \}}
\DoxyCodeLine{1872     loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(l.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}());}
\DoxyCodeLine{1873 }
\DoxyCodeLine{1874     \textcolor{keywordflow}{if}(lex\_integer::invoke(loc))}
\DoxyCodeLine{1875     \{}
\DoxyCodeLine{1876         \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{1877         \{}
\DoxyCodeLine{1878             \textcolor{keyword}{const} \textcolor{keyword}{auto} c = *loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{1879             \textcolor{keywordflow}{if}(c == \textcolor{charliteral}{'\_'})}
\DoxyCodeLine{1880             \{}
\DoxyCodeLine{1881                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}bad integer: `\_` should be surrounded by digits"{}},}
\DoxyCodeLine{1882                             \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}here"{}}\}\},}
\DoxyCodeLine{1883                             \{\textcolor{stringliteral}{"{}pass: -\/42, 1\_000, 1\_2\_3\_4\_5, 0xC0FFEE, 0b0010, 0o755"{}},}
\DoxyCodeLine{1884                              \textcolor{stringliteral}{"{}fail: 1\_\_000, 0123"{}}\}));}
\DoxyCodeLine{1885             \}}
\DoxyCodeLine{1886             \textcolor{keywordflow}{if}(\textcolor{charliteral}{'0'} <= c \&\& c <= \textcolor{charliteral}{'9'})}
\DoxyCodeLine{1887             \{}
\DoxyCodeLine{1888                 \textcolor{comment}{// leading zero. point '0'}}
\DoxyCodeLine{1889                 loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a6ac09c7dc5a66e4bf8f9888170766123}{retrace}}();}
\DoxyCodeLine{1890                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}bad integer: leading zero"{}},}
\DoxyCodeLine{1891                             \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}here"{}}\}\},}
\DoxyCodeLine{1892                             \{\textcolor{stringliteral}{"{}pass: -\/42, 1\_000, 1\_2\_3\_4\_5, 0xC0FFEE, 0b0010, 0o755"{}},}
\DoxyCodeLine{1893                              \textcolor{stringliteral}{"{}fail: 1\_\_000, 0123"{}}\}));}
\DoxyCodeLine{1894             \}}
\DoxyCodeLine{1895             \textcolor{keywordflow}{if}(c == \textcolor{charliteral}{':'} || c == \textcolor{charliteral}{'-\/'})}
\DoxyCodeLine{1896             \{}
\DoxyCodeLine{1897                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}bad datetime: invalid format"{}},}
\DoxyCodeLine{1898                             \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}here"{}}\}\},}
\DoxyCodeLine{1899                             \{\textcolor{stringliteral}{"{}pass: 1979-\/05-\/27T07:32:00-\/07:00, 1979-\/05-\/27 07:32:00.999999Z"{}},}
\DoxyCodeLine{1900                              \textcolor{stringliteral}{"{}fail: 1979-\/05-\/27T7:32:00-\/7:00, 1979-\/05-\/27 7:32-\/00:30"{}}\}));}
\DoxyCodeLine{1901             \}}
\DoxyCodeLine{1902             \textcolor{keywordflow}{if}(c == \textcolor{charliteral}{'.'} || c == \textcolor{charliteral}{'e'} || c == \textcolor{charliteral}{'E'})}
\DoxyCodeLine{1903             \{}
\DoxyCodeLine{1904                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}bad float: invalid format"{}},}
\DoxyCodeLine{1905                             \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}here"{}}\}\},}
\DoxyCodeLine{1906                             \{\textcolor{stringliteral}{"{}pass: +1.0, -\/2e-\/2, 3.141\_592\_653\_589, inf, nan"{}},}
\DoxyCodeLine{1907                              \textcolor{stringliteral}{"{}fail: .0, 1., \_1.0, 1.0\_, 1\_.0, 1.0\_\_0"{}}\}));}
\DoxyCodeLine{1908             \}}
\DoxyCodeLine{1909         \}}
\DoxyCodeLine{1910         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaa157db7df530023575515d366c9b672e8}{value\_t::integer}});}
\DoxyCodeLine{1911     \}}
\DoxyCodeLine{1912     \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& *loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{'.'})}
\DoxyCodeLine{1913     \{}
\DoxyCodeLine{1914         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}bad float: invalid format"{}},}
\DoxyCodeLine{1915                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}integer part required before this"{}}\}\},}
\DoxyCodeLine{1916                 \{\textcolor{stringliteral}{"{}pass: +1.0, -\/2e-\/2, 3.141\_592\_653\_589, inf, nan"{}},}
\DoxyCodeLine{1917                  \textcolor{stringliteral}{"{}fail: .0, 1., \_1.0, 1.0\_, 1\_.0, 1.0\_\_0"{}}\}));}
\DoxyCodeLine{1918     \}}
\DoxyCodeLine{1919     \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}() \&\& *loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == \textcolor{charliteral}{'\_'})}
\DoxyCodeLine{1920     \{}
\DoxyCodeLine{1921         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}bad number: `\_` should be surrounded by digits"{}},}
\DoxyCodeLine{1922                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}`\_` is not surrounded by digits"{}}\}\},}
\DoxyCodeLine{1923                 \{\textcolor{stringliteral}{"{}pass: -\/42, 1\_000, 1\_2\_3\_4\_5, 0xC0FFEE, 0b0010, 0o755"{}},}
\DoxyCodeLine{1924                  \textcolor{stringliteral}{"{}fail: 1\_\_000, 0123"{}}\}));}
\DoxyCodeLine{1925     \}}
\DoxyCodeLine{1926     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}bad format: unknown value appeared"{}},}
\DoxyCodeLine{1927                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}here"{}}\}\}));}
\DoxyCodeLine{1928 \}}
\DoxyCodeLine{1929 }
\DoxyCodeLine{1930 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<value\_t, std::string>}} \mbox{\hyperlink{namespacetoml_1_1detail_aa539305e166ebaaf247d3b552b6ad1b4}{guess\_value\_type}}(\textcolor{keyword}{const} \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{1931 \{}
\DoxyCodeLine{1932     \textcolor{keywordflow}{switch}(*loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}())}
\DoxyCodeLine{1933     \{}
\DoxyCodeLine{1934         \textcolor{keywordflow}{case} \textcolor{charliteral}{'"{}'} : \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaab45cffe084dd3d20d928bee85e7b0f21}{value\_t::string}});  \}}
\DoxyCodeLine{1935         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)''}: \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaab45cffe084dd3d20d928bee85e7b0f21}{value\_t::string}});  \}}
\DoxyCodeLine{1936         \textcolor{keywordflow}{case} \textcolor{charliteral}{'t'} : \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaa84e2c64f38f78ba3ea5c905ab5a2da27}{value\_t::boolean}}); \}}
\DoxyCodeLine{1937         \textcolor{keywordflow}{case} \textcolor{charliteral}{'f'} : \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaa84e2c64f38f78ba3ea5c905ab5a2da27}{value\_t::boolean}}); \}}
\DoxyCodeLine{1938         \textcolor{keywordflow}{case} \textcolor{charliteral}{'['} : \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaaf1f713c9e000f5d3f280adbd124df4f5}{value\_t::array}});   \}}
\DoxyCodeLine{1939         \textcolor{keywordflow}{case} \textcolor{charliteral}{'\{'} : \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaaaab9e1de16f38176f86d7a92ba337a8d}{value\_t::table}});   \}}
\DoxyCodeLine{1940         \textcolor{keywordflow}{case} \textcolor{charliteral}{'i'} : \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaa374515b23d6f106696387776a6077d17}{value\_t::floating}});\} \textcolor{comment}{// inf.}}
\DoxyCodeLine{1941         \textcolor{keywordflow}{case} \textcolor{charliteral}{'n'} : \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(\mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaa374515b23d6f106696387776a6077d17}{value\_t::floating}});\} \textcolor{comment}{// nan.}}
\DoxyCodeLine{1942         default  : \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_1_1detail_af4c6d5f0914d83402a2909b35f56faa3}{guess\_number\_type}}(loc);\}}
\DoxyCodeLine{1943     \}}
\DoxyCodeLine{1944 \}}
\DoxyCodeLine{1945 }
\DoxyCodeLine{1946 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value, \textcolor{keyword}{typename} T>}
\DoxyCodeLine{1947 \mbox{\hyperlink{structtoml_1_1result}{result<Value, std::string>}}}
\DoxyCodeLine{1948 \mbox{\hyperlink{namespacetoml_1_1detail_a1f20947f2ca256727e9319b02acf18fe}{parse\_value\_helper}}(\mbox{\hyperlink{structtoml_1_1result}{result}}<std::pair<T, region>, std::string> rslt)}
\DoxyCodeLine{1949 \{}
\DoxyCodeLine{1950     \textcolor{keywordflow}{if}(rslt.is\_ok())}
\DoxyCodeLine{1951     \{}
\DoxyCodeLine{1952         \textcolor{keyword}{auto} comments = rslt.as\_ok().second.comments();}
\DoxyCodeLine{1953         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(Value(std::move(rslt.as\_ok()), std::move(comments)));}
\DoxyCodeLine{1954     \}}
\DoxyCodeLine{1955     \textcolor{keywordflow}{else}}
\DoxyCodeLine{1956     \{}
\DoxyCodeLine{1957         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(std::move(rslt.as\_err()));}
\DoxyCodeLine{1958     \}}
\DoxyCodeLine{1959 \}}
\DoxyCodeLine{1960 }
\DoxyCodeLine{1961 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{1962 \mbox{\hyperlink{structtoml_1_1result}{result<Value, std::string>}} \mbox{\hyperlink{namespacetoml_1_1detail_a1b4b4caf7f95ad4490c056a4b9394a2f}{parse\_value}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{1963 \{}
\DoxyCodeLine{1964     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{1965     \textcolor{keywordflow}{if}(first == loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{1966     \{}
\DoxyCodeLine{1967         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_value: input is empty"{}},}
\DoxyCodeLine{1968                    \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}"{}}\}\}));}
\DoxyCodeLine{1969     \}}
\DoxyCodeLine{1970 }
\DoxyCodeLine{1971     \textcolor{keyword}{const} \textcolor{keyword}{auto} type = \mbox{\hyperlink{namespacetoml_1_1detail_aa539305e166ebaaf247d3b552b6ad1b4}{guess\_value\_type}}(loc);}
\DoxyCodeLine{1972     \textcolor{keywordflow}{if}(!type)}
\DoxyCodeLine{1973     \{}
\DoxyCodeLine{1974         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(type.unwrap\_err());}
\DoxyCodeLine{1975     \}}
\DoxyCodeLine{1976 }
\DoxyCodeLine{1977     \textcolor{keywordflow}{switch}(type.unwrap())}
\DoxyCodeLine{1978     \{}
\DoxyCodeLine{1979         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaa84e2c64f38f78ba3ea5c905ab5a2da27}{value\_t::boolean}}        : \{\textcolor{keywordflow}{return} parse\_value\_helper<Value>(\mbox{\hyperlink{namespacetoml_1_1detail_a79439bcaa95b2d9f009b131f4fe0503d}{parse\_boolean}}(loc)            );\}}
\DoxyCodeLine{1980         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaa157db7df530023575515d366c9b672e8}{value\_t::integer}}        : \{\textcolor{keywordflow}{return} parse\_value\_helper<Value>(\mbox{\hyperlink{namespacetoml_1_1detail_af3ce8ca50647de2d35f9e7fedf4e3c84}{parse\_integer}}(loc)            );\}}
\DoxyCodeLine{1981         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaa374515b23d6f106696387776a6077d17}{value\_t::floating}}       : \{\textcolor{keywordflow}{return} parse\_value\_helper<Value>(\mbox{\hyperlink{namespacetoml_1_1detail_a570077e5697415b2bc98a3a3c1d083a4}{parse\_floating}}(loc)           );\}}
\DoxyCodeLine{1982         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaab45cffe084dd3d20d928bee85e7b0f21}{value\_t::string}}         : \{\textcolor{keywordflow}{return} parse\_value\_helper<Value>(\mbox{\hyperlink{namespacetoml_1_1detail_acc4dcb02c7028634b40e03687ba238de}{parse\_string}}(loc)             );\}}
\DoxyCodeLine{1983         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaa3453afefc0169f713370ff6bea1dc9a5}{value\_t::offset\_datetime}}: \{\textcolor{keywordflow}{return} parse\_value\_helper<Value>(\mbox{\hyperlink{namespacetoml_1_1detail_ac710d6135936a580d7b3949744e488ca}{parse\_offset\_datetime}}(loc)    );\}}
\DoxyCodeLine{1984         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaa4786c634d28e7c1aa109efdd9e11ba32}{value\_t::local\_datetime}} : \{\textcolor{keywordflow}{return} parse\_value\_helper<Value>(\mbox{\hyperlink{namespacetoml_1_1detail_a5d307bd1493d2e305dc247f244da69b2}{parse\_local\_datetime}}(loc)     );\}}
\DoxyCodeLine{1985         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaaa9647613bc34fa481cf7bfd71e46511f}{value\_t::local\_date}}     : \{\textcolor{keywordflow}{return} parse\_value\_helper<Value>(\mbox{\hyperlink{namespacetoml_1_1detail_a086e87691ec78a9985f043905237335e}{parse\_local\_date}}(loc)         );\}}
\DoxyCodeLine{1986         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaad118bc9b5fdddd0a0c91b99a41bb9501}{value\_t::local\_time}}     : \{\textcolor{keywordflow}{return} parse\_value\_helper<Value>(\mbox{\hyperlink{namespacetoml_1_1detail_aaf5f64afd505a0c69b3e28b6afbffb97}{parse\_local\_time}}(loc)         );\}}
\DoxyCodeLine{1987         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaaf1f713c9e000f5d3f280adbd124df4f5}{value\_t::array}}          : \{\textcolor{keywordflow}{return} parse\_value\_helper<Value>(parse\_array<Value>(loc)       );\}}
\DoxyCodeLine{1988         \textcolor{keywordflow}{case} \mbox{\hyperlink{namespacetoml_a99b223fe1b911188b415ace2e80d9aaaaaab9e1de16f38176f86d7a92ba337a8d}{value\_t::table}}          : \{\textcolor{keywordflow}{return} parse\_value\_helper<Value>(parse\_inline\_table<Value>(loc));\}}
\DoxyCodeLine{1989         \textcolor{keywordflow}{default}:}
\DoxyCodeLine{1990         \{}
\DoxyCodeLine{1991             \textcolor{keyword}{const} \textcolor{keyword}{auto} msg = \mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_value: "{}}}
\DoxyCodeLine{1992                     \textcolor{stringliteral}{"{}unknown token appeared"{}}, \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}unknown"{}}\}\});}
\DoxyCodeLine{1993             loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(first);}
\DoxyCodeLine{1994             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(msg);}
\DoxyCodeLine{1995         \}}
\DoxyCodeLine{1996     \}}
\DoxyCodeLine{1997 \}}
\DoxyCodeLine{1998 }
\DoxyCodeLine{1999 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<std::vector<key>}}, region>, std::string>}
\DoxyCodeLine{2000 \mbox{\hyperlink{namespacetoml_1_1detail_aa2937fd996bb69876ef981959c05ef0f}{parse\_table\_key}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{2001 \{}
\DoxyCodeLine{2002     \textcolor{keywordflow}{if}(\textcolor{keyword}{auto} token = lex\_std\_table::invoke(loc))}
\DoxyCodeLine{2003     \{}
\DoxyCodeLine{2004         \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}} inner\_loc(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad6a386a1bb61633d7dc51025ee4bd6be}{name}}(), token.unwrap().str());}
\DoxyCodeLine{2005 }
\DoxyCodeLine{2006         \textcolor{keyword}{const} \textcolor{keyword}{auto} open = \mbox{\hyperlink{structtoml_1_1detail_1_1character_a324e051eb839e526a72e657478a65135}{lex\_std\_table\_open::invoke}}(inner\_loc);}
\DoxyCodeLine{2007         \textcolor{keywordflow}{if}(!open || inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{2008         \{}
\DoxyCodeLine{2009             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{2010                 \textcolor{stringliteral}{"{}toml::parse\_table\_key: no `[`"{}},}
\DoxyCodeLine{2011                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be `[`"{}}\}\}),}
\DoxyCodeLine{2012                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{2013         \}}
\DoxyCodeLine{2014         \textcolor{comment}{// to skip [ a . b . c ]}}
\DoxyCodeLine{2015         \textcolor{comment}{//          \string^-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/-\/ this whitespace}}
\DoxyCodeLine{2016         lex\_ws::invoke(inner\_loc);}
\DoxyCodeLine{2017         \textcolor{keyword}{const} \textcolor{keyword}{auto} keys = \mbox{\hyperlink{namespacetoml_1_1detail_ac3ca2e746db114f0747188013a7b9b62}{parse\_key}}(inner\_loc);}
\DoxyCodeLine{2018         \textcolor{keywordflow}{if}(!keys)}
\DoxyCodeLine{2019         \{}
\DoxyCodeLine{2020             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{2021                 \textcolor{stringliteral}{"{}toml::parse\_table\_key: invalid key"{}},}
\DoxyCodeLine{2022                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}not key"{}}\}\}),}
\DoxyCodeLine{2023                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{2024         \}}
\DoxyCodeLine{2025         \textcolor{comment}{// to skip [ a . b . c ]}}
\DoxyCodeLine{2026         \textcolor{comment}{//                    \string^-\/-\/ this whitespace}}
\DoxyCodeLine{2027         lex\_ws::invoke(inner\_loc);}
\DoxyCodeLine{2028         \textcolor{keyword}{const} \textcolor{keyword}{auto} close = \mbox{\hyperlink{structtoml_1_1detail_1_1character_a324e051eb839e526a72e657478a65135}{lex\_std\_table\_close::invoke}}(inner\_loc);}
\DoxyCodeLine{2029         \textcolor{keywordflow}{if}(!close)}
\DoxyCodeLine{2030         \{}
\DoxyCodeLine{2031             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{2032                 \textcolor{stringliteral}{"{}toml::parse\_table\_key: no `]`"{}},}
\DoxyCodeLine{2033                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be `]`"{}}\}\}),}
\DoxyCodeLine{2034                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{2035         \}}
\DoxyCodeLine{2036 }
\DoxyCodeLine{2037         \textcolor{comment}{// after [table.key], newline or EOF(empty table) required.}}
\DoxyCodeLine{2038         \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{2039         \{}
\DoxyCodeLine{2040             \textcolor{keyword}{using }lex\_newline\_after\_table\_key =}
\DoxyCodeLine{2041                 \mbox{\hyperlink{structtoml_1_1detail_1_1sequence}{sequence<maybe<lex\_ws>}}, \mbox{\hyperlink{structtoml_1_1detail_1_1maybe}{maybe<lex\_comment>}}, \mbox{\hyperlink{structtoml_1_1detail_1_1either}{lex\_newline}}>;}
\DoxyCodeLine{2042             \textcolor{keyword}{const} \textcolor{keyword}{auto} nl = lex\_newline\_after\_table\_key::invoke(loc);}
\DoxyCodeLine{2043             \textcolor{keywordflow}{if}(!nl)}
\DoxyCodeLine{2044             \{}
\DoxyCodeLine{2045                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{2046                     \textcolor{stringliteral}{"{}toml::parse\_table\_key: newline required after [table.key]"{}},}
\DoxyCodeLine{2047                     \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}expected newline"{}}\}\}),}
\DoxyCodeLine{2048                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{2049             \}}
\DoxyCodeLine{2050         \}}
\DoxyCodeLine{2051         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(keys.unwrap().first, token.unwrap()));}
\DoxyCodeLine{2052     \}}
\DoxyCodeLine{2053     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2054     \{}
\DoxyCodeLine{2055         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_table\_key: "{}}}
\DoxyCodeLine{2056             \textcolor{stringliteral}{"{}not a valid table key"{}}, \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}here"{}}\}\}));}
\DoxyCodeLine{2057     \}}
\DoxyCodeLine{2058 \}}
\DoxyCodeLine{2059 }
\DoxyCodeLine{2060 \textcolor{keyword}{inline} \mbox{\hyperlink{structtoml_1_1result}{result<std::pair<std::vector<key>}}, region>, std::string>}
\DoxyCodeLine{2061 \mbox{\hyperlink{namespacetoml_1_1detail_ac9c9a3d0c3d445410c904992154deb26}{parse\_array\_table\_key}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{2062 \{}
\DoxyCodeLine{2063     \textcolor{keywordflow}{if}(\textcolor{keyword}{auto} token = lex\_array\_table::invoke(loc))}
\DoxyCodeLine{2064     \{}
\DoxyCodeLine{2065         \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}} inner\_loc(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad6a386a1bb61633d7dc51025ee4bd6be}{name}}(), token.unwrap().str());}
\DoxyCodeLine{2066 }
\DoxyCodeLine{2067         \textcolor{keyword}{const} \textcolor{keyword}{auto} open = lex\_array\_table\_open::invoke(inner\_loc);}
\DoxyCodeLine{2068         \textcolor{keywordflow}{if}(!open || inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{2069         \{}
\DoxyCodeLine{2070             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{2071                 \textcolor{stringliteral}{"{}toml::parse\_array\_table\_key: no `[[`"{}},}
\DoxyCodeLine{2072                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be `[[`"{}}\}\}),}
\DoxyCodeLine{2073                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{2074         \}}
\DoxyCodeLine{2075         lex\_ws::invoke(inner\_loc);}
\DoxyCodeLine{2076         \textcolor{keyword}{const} \textcolor{keyword}{auto} keys = \mbox{\hyperlink{namespacetoml_1_1detail_ac3ca2e746db114f0747188013a7b9b62}{parse\_key}}(inner\_loc);}
\DoxyCodeLine{2077         \textcolor{keywordflow}{if}(!keys)}
\DoxyCodeLine{2078         \{}
\DoxyCodeLine{2079             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{2080                 \textcolor{stringliteral}{"{}toml::parse\_array\_table\_key: invalid key"{}},}
\DoxyCodeLine{2081                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}not a key"{}}\}\}),}
\DoxyCodeLine{2082                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{2083         \}}
\DoxyCodeLine{2084         lex\_ws::invoke(inner\_loc);}
\DoxyCodeLine{2085         \textcolor{keyword}{const} \textcolor{keyword}{auto} close = lex\_array\_table\_close::invoke(inner\_loc);}
\DoxyCodeLine{2086         \textcolor{keywordflow}{if}(!close)}
\DoxyCodeLine{2087         \{}
\DoxyCodeLine{2088             \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1internal__error}{internal\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(}
\DoxyCodeLine{2089                 \textcolor{stringliteral}{"{}toml::parse\_table\_key: no `]]`"{}},}
\DoxyCodeLine{2090                 \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc), \textcolor{stringliteral}{"{}should be `]]`"{}}\}\}),}
\DoxyCodeLine{2091                 \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(inner\_loc));}
\DoxyCodeLine{2092         \}}
\DoxyCodeLine{2093 }
\DoxyCodeLine{2094         \textcolor{comment}{// after [[table.key]], newline or EOF(empty table) required.}}
\DoxyCodeLine{2095         \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{2096         \{}
\DoxyCodeLine{2097             \textcolor{keyword}{using }lex\_newline\_after\_table\_key =}
\DoxyCodeLine{2098                 \mbox{\hyperlink{structtoml_1_1detail_1_1sequence}{sequence<maybe<lex\_ws>}}, \mbox{\hyperlink{structtoml_1_1detail_1_1maybe}{maybe<lex\_comment>}}, \mbox{\hyperlink{structtoml_1_1detail_1_1either}{lex\_newline}}>;}
\DoxyCodeLine{2099             \textcolor{keyword}{const} \textcolor{keyword}{auto} nl = lex\_newline\_after\_table\_key::invoke(loc);}
\DoxyCodeLine{2100             \textcolor{keywordflow}{if}(!nl)}
\DoxyCodeLine{2101             \{}
\DoxyCodeLine{2102                 \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::"{}}}
\DoxyCodeLine{2103                     \textcolor{stringliteral}{"{}parse\_array\_table\_key: newline required after [[table.key]]"{}},}
\DoxyCodeLine{2104                     \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}expected newline"{}}\}\}),}
\DoxyCodeLine{2105                     \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{2106             \}}
\DoxyCodeLine{2107         \}}
\DoxyCodeLine{2108         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(std::make\_pair(keys.unwrap().first, token.unwrap()));}
\DoxyCodeLine{2109     \}}
\DoxyCodeLine{2110     \textcolor{keywordflow}{else}}
\DoxyCodeLine{2111     \{}
\DoxyCodeLine{2112         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_array\_table\_key: "{}}}
\DoxyCodeLine{2113             \textcolor{stringliteral}{"{}not a valid table key"{}}, \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}here"{}}\}\}));}
\DoxyCodeLine{2114     \}}
\DoxyCodeLine{2115 \}}
\DoxyCodeLine{2116 }
\DoxyCodeLine{2117 \textcolor{comment}{// parse table body (key-\/value pairs until the iter hits the next [tablekey])}}
\DoxyCodeLine{2118 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{2119 \mbox{\hyperlink{structtoml_1_1result}{result<typename Value::table\_type, std::string>}}}
\DoxyCodeLine{2120 \mbox{\hyperlink{namespacetoml_1_1detail_a5f72df760411eb26f689fc2ee33d97ac}{parse\_ml\_table}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{2121 \{}
\DoxyCodeLine{2122     \textcolor{keyword}{using }value\_type = Value;}
\DoxyCodeLine{2123     \textcolor{keyword}{using }table\_type = \textcolor{keyword}{typename} value\_type::table\_type;}
\DoxyCodeLine{2124 }
\DoxyCodeLine{2125     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{2126     \textcolor{keywordflow}{if}(first == loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{2127     \{}
\DoxyCodeLine{2128         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(table\_type\{\});}
\DoxyCodeLine{2129     \}}
\DoxyCodeLine{2130 }
\DoxyCodeLine{2131     \textcolor{comment}{// XXX at lest one newline is needed.}}
\DoxyCodeLine{2132     \textcolor{keyword}{using }skip\_line = \mbox{\hyperlink{structtoml_1_1detail_1_1repeat}{repeat}}<}
\DoxyCodeLine{2133         \mbox{\hyperlink{structtoml_1_1detail_1_1sequence}{sequence<maybe<lex\_ws>}}, \mbox{\hyperlink{structtoml_1_1detail_1_1maybe}{maybe<lex\_comment>}}, \mbox{\hyperlink{structtoml_1_1detail_1_1either}{lex\_newline}}>, \mbox{\hyperlink{structtoml_1_1detail_1_1at__least}{at\_least<1>}}>;}
\DoxyCodeLine{2134     skip\_line::invoke(loc);}
\DoxyCodeLine{2135     lex\_ws::invoke(loc);}
\DoxyCodeLine{2136 }
\DoxyCodeLine{2137     table\_type tab;}
\DoxyCodeLine{2138     \textcolor{keywordflow}{while}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{2139     \{}
\DoxyCodeLine{2140         lex\_ws::invoke(loc);}
\DoxyCodeLine{2141         \textcolor{keyword}{const} \textcolor{keyword}{auto} before = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{2142         \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} tmp = \mbox{\hyperlink{namespacetoml_1_1detail_ac9c9a3d0c3d445410c904992154deb26}{parse\_array\_table\_key}}(loc)) \textcolor{comment}{// next table found}}
\DoxyCodeLine{2143         \{}
\DoxyCodeLine{2144             loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(before);}
\DoxyCodeLine{2145             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(tab);}
\DoxyCodeLine{2146         \}}
\DoxyCodeLine{2147         \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} tmp = \mbox{\hyperlink{namespacetoml_1_1detail_aa2937fd996bb69876ef981959c05ef0f}{parse\_table\_key}}(loc)) \textcolor{comment}{// next table found}}
\DoxyCodeLine{2148         \{}
\DoxyCodeLine{2149             loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(before);}
\DoxyCodeLine{2150             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(tab);}
\DoxyCodeLine{2151         \}}
\DoxyCodeLine{2152 }
\DoxyCodeLine{2153         \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} kv = parse\_key\_value\_pair<value\_type>(loc))}
\DoxyCodeLine{2154         \{}
\DoxyCodeLine{2155             \textcolor{keyword}{const} \textcolor{keyword}{auto}\&              kvpair  = kv.unwrap();}
\DoxyCodeLine{2156             \textcolor{keyword}{const} std::vector<key>\&  keys    = kvpair.first.first;}
\DoxyCodeLine{2157             \textcolor{keyword}{const} \textcolor{keyword}{auto}\&              key\_reg = kvpair.first.second;}
\DoxyCodeLine{2158             \textcolor{keyword}{const} value\_type\&        val     = kvpair.second;}
\DoxyCodeLine{2159             \textcolor{keyword}{const} \textcolor{keyword}{auto} inserted =}
\DoxyCodeLine{2160                 \mbox{\hyperlink{namespacetoml_1_1detail_a0e42efd941fdedb92c70124d95b42dba}{insert\_nested\_key}}(tab, val, keys.begin(), keys.end(), key\_reg);}
\DoxyCodeLine{2161             \textcolor{keywordflow}{if}(!inserted)}
\DoxyCodeLine{2162             \{}
\DoxyCodeLine{2163                 \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(inserted.unwrap\_err());}
\DoxyCodeLine{2164             \}}
\DoxyCodeLine{2165         \}}
\DoxyCodeLine{2166         \textcolor{keywordflow}{else}}
\DoxyCodeLine{2167         \{}
\DoxyCodeLine{2168             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(kv.unwrap\_err());}
\DoxyCodeLine{2169         \}}
\DoxyCodeLine{2170 }
\DoxyCodeLine{2171         \textcolor{comment}{// comment lines are skipped by the above function call.}}
\DoxyCodeLine{2172         \textcolor{comment}{// However, since the `skip\_line` requires at least 1 newline, it fails}}
\DoxyCodeLine{2173         \textcolor{comment}{// if the file ends with ws and/or comment without newline.}}
\DoxyCodeLine{2174         \textcolor{comment}{// `skip\_line` matches `ws? + comment? + newline`, not `ws` or `comment`}}
\DoxyCodeLine{2175         \textcolor{comment}{// itself. To skip the last ws and/or comment, call lexers.}}
\DoxyCodeLine{2176         \textcolor{comment}{// It does not matter if these fails, so the return value is discarded.}}
\DoxyCodeLine{2177         lex\_ws::invoke(loc);}
\DoxyCodeLine{2178         lex\_comment::invoke(loc);}
\DoxyCodeLine{2179 }
\DoxyCodeLine{2180         \textcolor{comment}{// skip\_line is (whitespace? comment? newline)\_\{1,\}. multiple empty lines}}
\DoxyCodeLine{2181         \textcolor{comment}{// and comments after the last key-\/value pairs are allowed.}}
\DoxyCodeLine{2182         \textcolor{keyword}{const} \textcolor{keyword}{auto} newline = skip\_line::invoke(loc);}
\DoxyCodeLine{2183         \textcolor{keywordflow}{if}(!newline \&\& loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{2184         \{}
\DoxyCodeLine{2185             \textcolor{keyword}{const} \textcolor{keyword}{auto} before2 = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{2186             lex\_ws::invoke(loc); \textcolor{comment}{// skip whitespace}}
\DoxyCodeLine{2187             \textcolor{keyword}{const} \textcolor{keyword}{auto} msg = \mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_table: "{}}}
\DoxyCodeLine{2188                 \textcolor{stringliteral}{"{}invalid line format"{}}, \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \mbox{\hyperlink{namespacetoml_adea2ccfef76e94dc32396c306a550c27}{concat\_to\_string}}(}
\DoxyCodeLine{2189                 \textcolor{stringliteral}{"{}expected newline, but got '"{}}, \mbox{\hyperlink{namespacetoml_1_1detail_a158ef9d09c21d75f226fd3cf8f2e8b1c}{show\_char}}(*loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}()), \textcolor{stringliteral}{"{}'."{}})\}\});}
\DoxyCodeLine{2190             loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ae7029e5f4aa2ab85280107391972cff0}{reset}}(before2);}
\DoxyCodeLine{2191             \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(msg);}
\DoxyCodeLine{2192         \}}
\DoxyCodeLine{2193 }
\DoxyCodeLine{2194         \textcolor{comment}{// the skip\_lines only matches with lines that includes newline.}}
\DoxyCodeLine{2195         \textcolor{comment}{// to skip the last line that includes comment and/or whitespace}}
\DoxyCodeLine{2196         \textcolor{comment}{// but no newline, call them one more time.}}
\DoxyCodeLine{2197         lex\_ws::invoke(loc);}
\DoxyCodeLine{2198         lex\_comment::invoke(loc);}
\DoxyCodeLine{2199     \}}
\DoxyCodeLine{2200     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(tab);}
\DoxyCodeLine{2201 \}}
\DoxyCodeLine{2202 }
\DoxyCodeLine{2203 \textcolor{keyword}{template}<\textcolor{keyword}{typename} Value>}
\DoxyCodeLine{2204 \mbox{\hyperlink{structtoml_1_1result}{result<Value, std::string>}} \mbox{\hyperlink{namespacetoml_1_1detail_a9e234b43031b5e23cb8ecb38c2c0484a}{parse\_toml\_file}}(\mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}}\& loc)}
\DoxyCodeLine{2205 \{}
\DoxyCodeLine{2206     \textcolor{keyword}{using }value\_type = Value;}
\DoxyCodeLine{2207     \textcolor{keyword}{using }table\_type = \textcolor{keyword}{typename} value\_type::table\_type;}
\DoxyCodeLine{2208 }
\DoxyCodeLine{2209     \textcolor{keyword}{const} \textcolor{keyword}{auto} first = loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}();}
\DoxyCodeLine{2210     \textcolor{keywordflow}{if}(first == loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{2211     \{}
\DoxyCodeLine{2212         \textcolor{comment}{// For empty files, return an empty table with an empty region (zero-\/length).}}
\DoxyCodeLine{2213         \textcolor{comment}{// Without the region, error messages would miss the filename.}}
\DoxyCodeLine{2214         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(value\_type(table\_type\{\}, \mbox{\hyperlink{structtoml_1_1detail_1_1region}{region}}(loc, first, first), \{\}));}
\DoxyCodeLine{2215     \}}
\DoxyCodeLine{2216 }
\DoxyCodeLine{2217     \textcolor{comment}{// put the first line as a region of a file}}
\DoxyCodeLine{2218     \textcolor{comment}{// Here first != loc.end(), so taking std::next is okay}}
\DoxyCodeLine{2219     \textcolor{keyword}{const} \mbox{\hyperlink{structtoml_1_1detail_1_1region}{region}} file(loc, first, std::next(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}()));}
\DoxyCodeLine{2220 }
\DoxyCodeLine{2221     \textcolor{comment}{// The first successive comments that are separated from the first value}}
\DoxyCodeLine{2222     \textcolor{comment}{// by an empty line are for a file itself.}}
\DoxyCodeLine{2223     \textcolor{comment}{// ```toml}}
\DoxyCodeLine{2224     \textcolor{comment}{// \# this is a comment for a file.}}
\DoxyCodeLine{2225     \textcolor{comment}{//}}
\DoxyCodeLine{2226     \textcolor{comment}{// key = "{}the first value"{}}}
\DoxyCodeLine{2227     \textcolor{comment}{// ```}}
\DoxyCodeLine{2228     \textcolor{comment}{// ```toml}}
\DoxyCodeLine{2229     \textcolor{comment}{// \# this is a comment for "{}the first value"{}.}}
\DoxyCodeLine{2230     \textcolor{comment}{// key = "{}the first value"{}}}
\DoxyCodeLine{2231     \textcolor{comment}{// ```}}
\DoxyCodeLine{2232     std::vector<std::string> comments;}
\DoxyCodeLine{2233     \textcolor{keyword}{using }lex\_first\_comments = \mbox{\hyperlink{structtoml_1_1detail_1_1sequence}{sequence}}<}
\DoxyCodeLine{2234         \mbox{\hyperlink{structtoml_1_1detail_1_1repeat}{repeat<sequence<maybe<lex\_ws>}}, \mbox{\hyperlink{namespacetoml_1_1detail_a912468f3d502bd2135ca6b61b947347a}{lex\_comment}}, \mbox{\hyperlink{structtoml_1_1detail_1_1either}{lex\_newline}}>, \mbox{\hyperlink{structtoml_1_1detail_1_1at__least}{at\_least<1>}}>,}
\DoxyCodeLine{2235         \mbox{\hyperlink{structtoml_1_1detail_1_1sequence}{sequence<maybe<lex\_ws>}}, \mbox{\hyperlink{structtoml_1_1detail_1_1either}{lex\_newline}}>}
\DoxyCodeLine{2236         >;}
\DoxyCodeLine{2237     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} token = lex\_first\_comments::invoke(loc))}
\DoxyCodeLine{2238     \{}
\DoxyCodeLine{2239         \mbox{\hyperlink{structtoml_1_1detail_1_1location}{location}} inner\_loc(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad6a386a1bb61633d7dc51025ee4bd6be}{name}}(), token.unwrap().str());}
\DoxyCodeLine{2240         \textcolor{keywordflow}{while}(inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{2241         \{}
\DoxyCodeLine{2242             \mbox{\hyperlink{structtoml_1_1detail_1_1maybe_a85d0697d87e0079600f4eb2d47a50d76}{maybe<lex\_ws>::invoke}}(inner\_loc); \textcolor{comment}{// remove ws if exists}}
\DoxyCodeLine{2243             \textcolor{keywordflow}{if}(lex\_newline::invoke(inner\_loc))}
\DoxyCodeLine{2244             \{}
\DoxyCodeLine{2245                 assert(inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() == inner\_loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}());}
\DoxyCodeLine{2246                 \textcolor{keywordflow}{break}; \textcolor{comment}{// empty line found.}}
\DoxyCodeLine{2247             \}}
\DoxyCodeLine{2248             \textcolor{keyword}{auto} com = lex\_comment::invoke(inner\_loc).unwrap().str();}
\DoxyCodeLine{2249             com.erase(com.begin()); \textcolor{comment}{// remove \# sign}}
\DoxyCodeLine{2250             comments.push\_back(std::move(com));}
\DoxyCodeLine{2251             lex\_newline::invoke(inner\_loc);}
\DoxyCodeLine{2252         \}}
\DoxyCodeLine{2253     \}}
\DoxyCodeLine{2254 }
\DoxyCodeLine{2255     table\_type data;}
\DoxyCodeLine{2256     \textcolor{comment}{// root object is also a table, but without [tablename]}}
\DoxyCodeLine{2257     \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} tab = parse\_ml\_table<value\_type>(loc))}
\DoxyCodeLine{2258     \{}
\DoxyCodeLine{2259         data = std::move(tab.unwrap());}
\DoxyCodeLine{2260     \}}
\DoxyCodeLine{2261     \textcolor{keywordflow}{else} \textcolor{comment}{// failed (empty table is regarded as success in parse\_ml\_table)}}
\DoxyCodeLine{2262     \{}
\DoxyCodeLine{2263         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(tab.unwrap\_err());}
\DoxyCodeLine{2264     \}}
\DoxyCodeLine{2265     \textcolor{keywordflow}{while}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a3fec075fe10382a901104613f84b37ee}{iter}}() != loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_ad2b13df42c4b6202d006830c3fa5eee6}{end}}())}
\DoxyCodeLine{2266     \{}
\DoxyCodeLine{2267         \textcolor{comment}{// here, the region of [table] is regarded as the table-\/key because}}
\DoxyCodeLine{2268         \textcolor{comment}{// the table body is normally too big and it is not so informative}}
\DoxyCodeLine{2269         \textcolor{comment}{// if the first key-\/value pair of the table is shown in the error}}
\DoxyCodeLine{2270         \textcolor{comment}{// message.}}
\DoxyCodeLine{2271         \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} tabkey = \mbox{\hyperlink{namespacetoml_1_1detail_ac9c9a3d0c3d445410c904992154deb26}{parse\_array\_table\_key}}(loc))}
\DoxyCodeLine{2272         \{}
\DoxyCodeLine{2273             \textcolor{keyword}{const} \textcolor{keyword}{auto} tab = parse\_ml\_table<value\_type>(loc);}
\DoxyCodeLine{2274             \textcolor{keywordflow}{if}(!tab)\{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(tab.unwrap\_err());\}}
\DoxyCodeLine{2275 }
\DoxyCodeLine{2276             \textcolor{keyword}{const} \textcolor{keyword}{auto}\& tk   = tabkey.unwrap();}
\DoxyCodeLine{2277             \textcolor{keyword}{const} \textcolor{keyword}{auto}\& keys = tk.first;}
\DoxyCodeLine{2278             \textcolor{keyword}{const} \textcolor{keyword}{auto}\& reg  = tk.second;}
\DoxyCodeLine{2279 }
\DoxyCodeLine{2280             \textcolor{keyword}{const} \textcolor{keyword}{auto} inserted = \mbox{\hyperlink{namespacetoml_1_1detail_a0e42efd941fdedb92c70124d95b42dba}{insert\_nested\_key}}(data,}
\DoxyCodeLine{2281                     value\_type(tab.unwrap(), reg, reg.comments()),}
\DoxyCodeLine{2282                     keys.begin(), keys.end(), reg,}
\DoxyCodeLine{2283                     \textcolor{comment}{/*is\_array\_of\_table=*/} \textcolor{keyword}{true});}
\DoxyCodeLine{2284             \textcolor{keywordflow}{if}(!inserted) \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(inserted.unwrap\_err());\}}
\DoxyCodeLine{2285 }
\DoxyCodeLine{2286             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{2287         \}}
\DoxyCodeLine{2288         \textcolor{keywordflow}{if}(\textcolor{keyword}{const} \textcolor{keyword}{auto} tabkey = \mbox{\hyperlink{namespacetoml_1_1detail_aa2937fd996bb69876ef981959c05ef0f}{parse\_table\_key}}(loc))}
\DoxyCodeLine{2289         \{}
\DoxyCodeLine{2290             \textcolor{keyword}{const} \textcolor{keyword}{auto} tab = parse\_ml\_table<value\_type>(loc);}
\DoxyCodeLine{2291             \textcolor{keywordflow}{if}(!tab)\{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(tab.unwrap\_err());\}}
\DoxyCodeLine{2292 }
\DoxyCodeLine{2293             \textcolor{keyword}{const} \textcolor{keyword}{auto}\& tk   = tabkey.unwrap();}
\DoxyCodeLine{2294             \textcolor{keyword}{const} \textcolor{keyword}{auto}\& keys = tk.first;}
\DoxyCodeLine{2295             \textcolor{keyword}{const} \textcolor{keyword}{auto}\& reg  = tk.second;}
\DoxyCodeLine{2296 }
\DoxyCodeLine{2297             \textcolor{keyword}{const} \textcolor{keyword}{auto} inserted = \mbox{\hyperlink{namespacetoml_1_1detail_a0e42efd941fdedb92c70124d95b42dba}{insert\_nested\_key}}(data,}
\DoxyCodeLine{2298                 value\_type(tab.unwrap(), reg, reg.comments()),}
\DoxyCodeLine{2299                 keys.begin(), keys.end(), reg);}
\DoxyCodeLine{2300             \textcolor{keywordflow}{if}(!inserted) \{\textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(inserted.unwrap\_err());\}}
\DoxyCodeLine{2301 }
\DoxyCodeLine{2302             \textcolor{keywordflow}{continue};}
\DoxyCodeLine{2303         \}}
\DoxyCodeLine{2304         \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_aaa49b96abbd03a5fd434e4098839efaf}{err}}(\mbox{\hyperlink{namespacetoml_1_1detail_ada573c450f0429aedaae47101e581ac8}{format\_underline}}(\textcolor{stringliteral}{"{}toml::parse\_toml\_file: "{}}}
\DoxyCodeLine{2305             \textcolor{stringliteral}{"{}unknown line appeared"{}}, \{\{\mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc), \textcolor{stringliteral}{"{}unknown format"{}}\}\}));}
\DoxyCodeLine{2306     \}}
\DoxyCodeLine{2307 }
\DoxyCodeLine{2308     \textcolor{keywordflow}{return} \mbox{\hyperlink{namespacetoml_a6e429ce41fe363c8d981d8c929fd26f6}{ok}}(Value(std::move(data), file, comments));}
\DoxyCodeLine{2309 \}}
\DoxyCodeLine{2310 }
\DoxyCodeLine{2311 \} \textcolor{comment}{// detail}}
\DoxyCodeLine{2312 }
\DoxyCodeLine{2313 \textcolor{keyword}{template}<\textcolor{keyword}{typename}                     Comment = \mbox{\hyperlink{comments_8hpp_ac5952aa66c2a24cfdbb3d82f70f22618}{TOML11\_DEFAULT\_COMMENT\_STRATEGY}},}
\DoxyCodeLine{2314          \textcolor{keyword}{template}<\textcolor{keyword}{typename} ...> \textcolor{keyword}{class }Table   = std::unordered\_map,}
\DoxyCodeLine{2315          \textcolor{keyword}{template}<\textcolor{keyword}{typename} ...> \textcolor{keyword}{class }Array   = std::vector>}
\DoxyCodeLine{2316 basic\_value<Comment, Table, Array>}
\DoxyCodeLine{2317 \mbox{\hyperlink{namespacetoml_aad36cfb12076c9628033eeaab7492942}{parse}}(std::istream\& is, \textcolor{keyword}{const} std::string\& fname = \textcolor{stringliteral}{"{}unknown file"{}})}
\DoxyCodeLine{2318 \{}
\DoxyCodeLine{2319     \textcolor{keyword}{using }value\_type = \mbox{\hyperlink{classtoml_1_1basic__value}{basic\_value<Comment, Table, Array>}};}
\DoxyCodeLine{2320 }
\DoxyCodeLine{2321     \textcolor{keyword}{const} \textcolor{keyword}{auto} beg = is.tellg();}
\DoxyCodeLine{2322     is.seekg(0, std::ios::end);}
\DoxyCodeLine{2323     \textcolor{keyword}{const} \textcolor{keyword}{auto} end = is.tellg();}
\DoxyCodeLine{2324     \textcolor{keyword}{const} \textcolor{keyword}{auto} fsize = end -\/ beg;}
\DoxyCodeLine{2325     is.seekg(beg);}
\DoxyCodeLine{2326 }
\DoxyCodeLine{2327     \textcolor{comment}{// read whole file as a sequence of char}}
\DoxyCodeLine{2328     assert(fsize >= 0);}
\DoxyCodeLine{2329     std::vector<char> letters(\textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(fsize));}
\DoxyCodeLine{2330     is.read(letters.data(), fsize);}
\DoxyCodeLine{2331 }
\DoxyCodeLine{2332     \textcolor{comment}{// append LF.}}
\DoxyCodeLine{2333     \textcolor{comment}{// Although TOML does not require LF at the EOF, to make parsing logic}}
\DoxyCodeLine{2334     \textcolor{comment}{// simpler, we "{}normalize"{} the content by adding LF if it does not exist.}}
\DoxyCodeLine{2335     \textcolor{comment}{// It also checks if the last char is CR, to avoid changing the meaning.}}
\DoxyCodeLine{2336     \textcolor{comment}{// This is not the *best* way to deal with the last character, but is a}}
\DoxyCodeLine{2337     \textcolor{comment}{// simple and quick fix.}}
\DoxyCodeLine{2338     \textcolor{keywordflow}{if}(!letters.empty() \&\& letters.back() != \textcolor{charliteral}{'\(\backslash\)n'} \&\& letters.back() != \textcolor{charliteral}{'\(\backslash\)r'})}
\DoxyCodeLine{2339     \{}
\DoxyCodeLine{2340         letters.push\_back(\textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{2341     \}}
\DoxyCodeLine{2342 }
\DoxyCodeLine{2343     \mbox{\hyperlink{structtoml_1_1detail_1_1location}{detail::location}} loc(std::move(fname), std::move(letters));}
\DoxyCodeLine{2344 }
\DoxyCodeLine{2345     \textcolor{comment}{// skip BOM if exists.}}
\DoxyCodeLine{2346     \textcolor{comment}{// XXX component of BOM (like 0xEF) exceeds the representable range of}}
\DoxyCodeLine{2347     \textcolor{comment}{// signed char, so on some (actually, most) of the environment, these cannot}}
\DoxyCodeLine{2348     \textcolor{comment}{// be compared to char. However, since we are always out of luck, we need to}}
\DoxyCodeLine{2349     \textcolor{comment}{// check our chars are equivalent to BOM. To do this, first we need to}}
\DoxyCodeLine{2350     \textcolor{comment}{// convert char to unsigned char to guarantee the comparability.}}
\DoxyCodeLine{2351     \textcolor{keywordflow}{if}(loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_abb56f59d170d61216cdf848c329b5c96}{source}}()-\/>size() >= 3)}
\DoxyCodeLine{2352     \{}
\DoxyCodeLine{2353         std::array<unsigned char, 3> BOM;}
\DoxyCodeLine{2354         std::memcpy(BOM.data(), loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_abb56f59d170d61216cdf848c329b5c96}{source}}()-\/>data(), 3);}
\DoxyCodeLine{2355         \textcolor{keywordflow}{if}(BOM[0] == 0xEF \&\& BOM[1] == 0xBB \&\& BOM[2] == 0xBF)}
\DoxyCodeLine{2356         \{}
\DoxyCodeLine{2357             loc.\mbox{\hyperlink{structtoml_1_1detail_1_1location_a97b2915707242c6ffe7452431ed09333}{advance}}(3); \textcolor{comment}{// BOM found. skip.}}
\DoxyCodeLine{2358         \}}
\DoxyCodeLine{2359     \}}
\DoxyCodeLine{2360 }
\DoxyCodeLine{2361     \textcolor{keyword}{const} \textcolor{keyword}{auto} data = detail::parse\_toml\_file<value\_type>(loc);}
\DoxyCodeLine{2362     \textcolor{keywordflow}{if}(!data)}
\DoxyCodeLine{2363     \{}
\DoxyCodeLine{2364         \textcolor{keywordflow}{throw} \mbox{\hyperlink{structtoml_1_1syntax__error}{syntax\_error}}(data.unwrap\_err(), \mbox{\hyperlink{structtoml_1_1source__location}{source\_location}}(loc));}
\DoxyCodeLine{2365     \}}
\DoxyCodeLine{2366     \textcolor{keywordflow}{return} data.unwrap();}
\DoxyCodeLine{2367 \}}
\DoxyCodeLine{2368 }
\DoxyCodeLine{2369 \textcolor{keyword}{template}<\textcolor{keyword}{typename}                     Comment = \mbox{\hyperlink{comments_8hpp_ac5952aa66c2a24cfdbb3d82f70f22618}{TOML11\_DEFAULT\_COMMENT\_STRATEGY}},}
\DoxyCodeLine{2370          \textcolor{keyword}{template}<\textcolor{keyword}{typename} ...> \textcolor{keyword}{class }Table   = std::unordered\_map,}
\DoxyCodeLine{2371          \textcolor{keyword}{template}<\textcolor{keyword}{typename} ...> \textcolor{keyword}{class }Array   = std::vector>}
\DoxyCodeLine{2372 \mbox{\hyperlink{classtoml_1_1basic__value}{basic\_value<Comment, Table, Array>}} \mbox{\hyperlink{namespacetoml_aad36cfb12076c9628033eeaab7492942}{parse}}(\textcolor{keyword}{const} std::string\& fname)}
\DoxyCodeLine{2373 \{}
\DoxyCodeLine{2374     std::ifstream ifs(fname.c\_str(), std::ios\_base::binary);}
\DoxyCodeLine{2375     \textcolor{keywordflow}{if}(!ifs.good())}
\DoxyCodeLine{2376     \{}
\DoxyCodeLine{2377         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}toml::parse: file open error -\/> "{}} + fname);}
\DoxyCodeLine{2378     \}}
\DoxyCodeLine{2379     \textcolor{keywordflow}{return} parse<Comment, Table, Array>(ifs, fname);}
\DoxyCodeLine{2380 \}}
\DoxyCodeLine{2381 }
\DoxyCodeLine{2382 \textcolor{preprocessor}{\#ifdef TOML11\_HAS\_STD\_FILESYSTEM}}
\DoxyCodeLine{2383 \textcolor{comment}{// This function just forwards `parse("{}filename.toml"{})` to std::string version}}
\DoxyCodeLine{2384 \textcolor{comment}{// to avoid the ambiguity in overload resolution.}}
\DoxyCodeLine{2385 \textcolor{comment}{//}}
\DoxyCodeLine{2386 \textcolor{comment}{// Both std::string and std::filesystem::path are convertible from const char*.}}
\DoxyCodeLine{2387 \textcolor{comment}{// Without this, both parse(std::string) and parse(std::filesystem::path)}}
\DoxyCodeLine{2388 \textcolor{comment}{// matches to parse("{}filename.toml"{}). This breaks the existing code.}}
\DoxyCodeLine{2389 \textcolor{comment}{//}}
\DoxyCodeLine{2390 \textcolor{comment}{// This function exactly matches to the invocation with c-\/string.}}
\DoxyCodeLine{2391 \textcolor{comment}{// So this function is preferred than others and the ambiguity disappears.}}
\DoxyCodeLine{2392 \textcolor{keyword}{template}<\textcolor{keyword}{typename}                     Comment = \mbox{\hyperlink{comments_8hpp_ac5952aa66c2a24cfdbb3d82f70f22618}{TOML11\_DEFAULT\_COMMENT\_STRATEGY}},}
\DoxyCodeLine{2393          \textcolor{keyword}{template}<\textcolor{keyword}{typename} ...> \textcolor{keyword}{class }Table   = std::unordered\_map,}
\DoxyCodeLine{2394          \textcolor{keyword}{template}<\textcolor{keyword}{typename} ...> \textcolor{keyword}{class }Array   = std::vector>}
\DoxyCodeLine{2395 basic\_value<Comment, Table, Array> \mbox{\hyperlink{namespacetoml_aad36cfb12076c9628033eeaab7492942}{parse}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* fname)}
\DoxyCodeLine{2396 \{}
\DoxyCodeLine{2397     \textcolor{keywordflow}{return} parse<Comment, Table, Array>(std::string(fname));}
\DoxyCodeLine{2398 \}}
\DoxyCodeLine{2399 }
\DoxyCodeLine{2400 \textcolor{keyword}{template}<\textcolor{keyword}{typename}                     Comment = \mbox{\hyperlink{comments_8hpp_ac5952aa66c2a24cfdbb3d82f70f22618}{TOML11\_DEFAULT\_COMMENT\_STRATEGY}},}
\DoxyCodeLine{2401          \textcolor{keyword}{template}<\textcolor{keyword}{typename} ...> \textcolor{keyword}{class }Table   = std::unordered\_map,}
\DoxyCodeLine{2402          \textcolor{keyword}{template}<\textcolor{keyword}{typename} ...> \textcolor{keyword}{class }Array   = std::vector>}
\DoxyCodeLine{2403 basic\_value<Comment, Table, Array> \mbox{\hyperlink{namespacetoml_aad36cfb12076c9628033eeaab7492942}{parse}}(\textcolor{keyword}{const} std::filesystem::path\& fpath)}
\DoxyCodeLine{2404 \{}
\DoxyCodeLine{2405     std::ifstream ifs(fpath, std::ios\_base::binary);}
\DoxyCodeLine{2406     \textcolor{keywordflow}{if}(!ifs.good())}
\DoxyCodeLine{2407     \{}
\DoxyCodeLine{2408         \textcolor{keywordflow}{throw} std::runtime\_error(\textcolor{stringliteral}{"{}toml::parse: file open error -\/> "{}} +}
\DoxyCodeLine{2409                                  fpath.string());}
\DoxyCodeLine{2410     \}}
\DoxyCodeLine{2411     \textcolor{keywordflow}{return} parse<Comment, Table, Array>(ifs, fpath.string());}
\DoxyCodeLine{2412 \}}
\DoxyCodeLine{2413 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// TOML11\_HAS\_STD\_FILESYSTEM}}
\DoxyCodeLine{2414 }
\DoxyCodeLine{2415 \} \textcolor{comment}{// toml}}
\DoxyCodeLine{2416 \textcolor{preprocessor}{\#endif}\textcolor{comment}{// TOML11\_PARSER\_HPP}}

\end{DoxyCode}
